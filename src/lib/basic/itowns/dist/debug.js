!(function (t, e) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = e())
    : 'function' == typeof define && define.amd
    ? define('debug', [], e)
    : 'object' == typeof exports
    ? (exports.debug = e())
    : (t.debug = e());
})(window, function () {
  return (window.webpackJsonp_name_ = window.webpackJsonp_name_ || []).push([
    [1],
    {
      0: function (t, e, n) {
        'use strict';
        n.r(e),
          n.d(e, 'ACESFilmicToneMapping', function () {
            return nt;
          }),
          n.d(e, 'AddEquation', function () {
            return S;
          }),
          n.d(e, 'AddOperation', function () {
            return Z;
          }),
          n.d(e, 'AdditiveAnimationBlendMode', function () {
            return We;
          }),
          n.d(e, 'AdditiveBlending', function () {
            return _;
          }),
          n.d(e, 'AlphaFormat', function () {
            return Ot;
          }),
          n.d(e, 'AlwaysDepth', function () {
            return j;
          }),
          n.d(e, 'AlwaysStencilFunc', function () {
            return qn;
          }),
          n.d(e, 'AmbientLight', function () {
            return _h;
          }),
          n.d(e, 'AmbientLightProbe', function () {
            return Gh;
          }),
          n.d(e, 'AnimationClip', function () {
            return wu;
          }),
          n.d(e, 'AnimationLoader', function () {
            return Ru;
          }),
          n.d(e, 'AnimationMixer', function () {
            return bd;
          }),
          n.d(e, 'AnimationObjectGroup', function () {
            return vd;
          }),
          n.d(e, 'AnimationUtils', function () {
            return cu;
          }),
          n.d(e, 'ArcCurve', function () {
            return zu;
          }),
          n.d(e, 'ArrayCamera', function () {
            return Ns;
          }),
          n.d(e, 'ArrowHelper', function () {
            return cp;
          }),
          n.d(e, 'Audio', function () {
            return td;
          }),
          n.d(e, 'AudioAnalyser', function () {
            return od;
          }),
          n.d(e, 'AudioContext', function () {
            return Bh;
          }),
          n.d(e, 'AudioListener', function () {
            return Qh;
          }),
          n.d(e, 'AudioLoader', function () {
            return Uh;
          }),
          n.d(e, 'AxesHelper', function () {
            return up;
          }),
          n.d(e, 'AxisHelper', function () {
            return uf;
          }),
          n.d(e, 'BackSide', function () {
            return m;
          }),
          n.d(e, 'BasicDepthPacking', function () {
            return an;
          }),
          n.d(e, 'BasicShadowMap', function () {
            return u;
          }),
          n.d(e, 'BinaryTextureLoader', function () {
            return mf;
          }),
          n.d(e, 'Bone', function () {
            return _l;
          }),
          n.d(e, 'BooleanKeyframeTrack', function () {
            return mu;
          }),
          n.d(e, 'BoundingBoxHelper', function () {
            return hf;
          }),
          n.d(e, 'Box2', function () {
            return Rd;
          }),
          n.d(e, 'Box3', function () {
            return ti;
          }),
          n.d(e, 'Box3Helper', function () {
            return rp;
          }),
          n.d(e, 'BoxBufferGeometry', function () {
            return fa;
          }),
          n.d(e, 'BoxGeometry', function () {
            return fa;
          }),
          n.d(e, 'BoxHelper', function () {
            return ip;
          }),
          n.d(e, 'BufferAttribute', function () {
            return Er;
          }),
          n.d(e, 'BufferGeometry', function () {
            return Yr;
          }),
          n.d(e, 'BufferGeometryLoader', function () {
            return Lh;
          }),
          n.d(e, 'ByteType', function () {
            return St;
          }),
          n.d(e, 'Cache', function () {
            return qu;
          }),
          n.d(e, 'Camera', function () {
            return xa;
          }),
          n.d(e, 'CameraHelper', function () {
            return tp;
          }),
          n.d(e, 'CanvasRenderer', function () {
            return yf;
          }),
          n.d(e, 'CanvasTexture', function () {
            return Jl;
          }),
          n.d(e, 'CatmullRomCurve3', function () {
            return Hu;
          }),
          n.d(e, 'CineonToneMapping', function () {
            return et;
          }),
          n.d(e, 'CircleBufferGeometry', function () {
            return Kl;
          }),
          n.d(e, 'CircleGeometry', function () {
            return Kl;
          }),
          n.d(e, 'ClampToEdgeWrapping', function () {
            return dt;
          }),
          n.d(e, 'Clock', function () {
            return Xh;
          }),
          n.d(e, 'Color', function () {
            return Mr;
          }),
          n.d(e, 'ColorKeyframeTrack', function () {
            return gu;
          }),
          n.d(e, 'CompressedTexture', function () {
            return $l;
          }),
          n.d(e, 'CompressedTextureLoader', function () {
            return Cu;
          }),
          n.d(e, 'ConeBufferGeometry', function () {
            return tc;
          }),
          n.d(e, 'ConeGeometry', function () {
            return tc;
          }),
          n.d(e, 'CubeCamera', function () {
            return _a;
          }),
          n.d(e, 'CubeReflectionMapping', function () {
            return at;
          }),
          n.d(e, 'CubeRefractionMapping', function () {
            return ot;
          }),
          n.d(e, 'CubeTexture', function () {
            return wa;
          }),
          n.d(e, 'CubeTextureLoader', function () {
            return ku;
          }),
          n.d(e, 'CubeUVReflectionMapping', function () {
            return ct;
          }),
          n.d(e, 'CubeUVRefractionMapping', function () {
            return ut;
          }),
          n.d(e, 'CubicBezierCurve', function () {
            return Yu;
          }),
          n.d(e, 'CubicBezierCurve3', function () {
            return $u;
          }),
          n.d(e, 'CubicInterpolant', function () {
            return hu;
          }),
          n.d(e, 'CullFaceBack', function () {
            return s;
          }),
          n.d(e, 'CullFaceFront', function () {
            return l;
          }),
          n.d(e, 'CullFaceFrontBack', function () {
            return c;
          }),
          n.d(e, 'CullFaceNone', function () {
            return o;
          }),
          n.d(e, 'Curve', function () {
            return Ou;
          }),
          n.d(e, 'CurvePath', function () {
            return nh;
          }),
          n.d(e, 'CustomBlending', function () {
            return q;
          }),
          n.d(e, 'CustomToneMapping', function () {
            return it;
          }),
          n.d(e, 'CylinderBufferGeometry', function () {
            return Ql;
          }),
          n.d(e, 'CylinderGeometry', function () {
            return Ql;
          }),
          n.d(e, 'Cylindrical', function () {
            return Ad;
          }),
          n.d(e, 'DataTexture', function () {
            return qa;
          }),
          n.d(e, 'DataTexture2DArray', function () {
            return Ya;
          }),
          n.d(e, 'DataTexture3D', function () {
            return $a;
          }),
          n.d(e, 'DataTextureLoader', function () {
            return Iu;
          }),
          n.d(e, 'DataUtils', function () {
            return pp;
          }),
          n.d(e, 'DecrementStencilOp', function () {
            return pn;
          }),
          n.d(e, 'DecrementWrapStencilOp', function () {
            return mn;
          }),
          n.d(e, 'DefaultLoadingManager', function () {
            return Tu;
          }),
          n.d(e, 'DepthFormat', function () {
            return jt;
          }),
          n.d(e, 'DepthStencilFormat', function () {
            return Gt;
          }),
          n.d(e, 'DepthTexture', function () {
            return Zl;
          }),
          n.d(e, 'DirectionalLight', function () {
            return bh;
          }),
          n.d(e, 'DirectionalLightHelper', function () {
            return Zd;
          }),
          n.d(e, 'DiscreteInterpolant', function () {
            return pu;
          }),
          n.d(e, 'DodecahedronBufferGeometry', function () {
            return nc;
          }),
          n.d(e, 'DodecahedronGeometry', function () {
            return nc;
          }),
          n.d(e, 'DoubleSide', function () {
            return g;
          }),
          n.d(e, 'DstAlphaFactor', function () {
            return O;
          }),
          n.d(e, 'DstColorFactor', function () {
            return z;
          }),
          n.d(e, 'DynamicBufferAttribute', function () {
            return Qp;
          }),
          n.d(e, 'DynamicCopyUsage', function () {
            return Pn;
          }),
          n.d(e, 'DynamicDrawUsage', function () {
            return Tn;
          }),
          n.d(e, 'DynamicReadUsage', function () {
            return Ln;
          }),
          n.d(e, 'EdgesGeometry', function () {
            return sc;
          }),
          n.d(e, 'EdgesHelper', function () {
            return df;
          }),
          n.d(e, 'EllipseCurve', function () {
            return Nu;
          }),
          n.d(e, 'EqualDepth', function () {
            return V;
          }),
          n.d(e, 'EqualStencilFunc', function () {
            return xn;
          }),
          n.d(e, 'EquirectangularReflectionMapping', function () {
            return st;
          }),
          n.d(e, 'EquirectangularRefractionMapping', function () {
            return lt;
          }),
          n.d(e, 'Euler', function () {
            return zi;
          }),
          n.d(e, 'EventDispatcher', function () {
            return On;
          }),
          n.d(e, 'ExtrudeBufferGeometry', function () {
            return Oc;
          }),
          n.d(e, 'ExtrudeGeometry', function () {
            return Oc;
          }),
          n.d(e, 'FaceColors', function () {
            return jp;
          }),
          n.d(e, 'FileLoader', function () {
            return Lu;
          }),
          n.d(e, 'FlatShading', function () {
            return y;
          }),
          n.d(e, 'Float16BufferAttribute', function () {
            return Dr;
          }),
          n.d(e, 'Float32Attribute', function () {
            return lf;
          }),
          n.d(e, 'Float32BufferAttribute', function () {
            return Or;
          }),
          n.d(e, 'Float64Attribute', function () {
            return cf;
          }),
          n.d(e, 'Float64BufferAttribute', function () {
            return Nr;
          }),
          n.d(e, 'FloatType', function () {
            return Rt;
          }),
          n.d(e, 'Fog', function () {
            return Vs;
          }),
          n.d(e, 'FogExp2', function () {
            return Hs;
          }),
          n.d(e, 'Font', function () {
            return Oh;
          }),
          n.d(e, 'FontLoader', function () {
            return zh;
          }),
          n.d(e, 'FrontSide', function () {
            return f;
          }),
          n.d(e, 'Frustum', function () {
            return Ea;
          }),
          n.d(e, 'GLBufferAttribute', function () {
            return Md;
          }),
          n.d(e, 'GLSL1', function () {
            return In;
          }),
          n.d(e, 'GLSL3', function () {
            return Dn;
          }),
          n.d(e, 'GammaEncoding', function () {
            return Ke;
          }),
          n.d(e, 'GreaterDepth', function () {
            return X;
          }),
          n.d(e, 'GreaterEqualDepth', function () {
            return W;
          }),
          n.d(e, 'GreaterEqualStencilFunc', function () {
            return Mn;
          }),
          n.d(e, 'GreaterStencilFunc', function () {
            return _n;
          }),
          n.d(e, 'GridHelper', function () {
            return Wd;
          }),
          n.d(e, 'Group', function () {
            return zs;
          }),
          n.d(e, 'HalfFloatType', function () {
            return Ct;
          }),
          n.d(e, 'HemisphereLight', function () {
            return oh;
          }),
          n.d(e, 'HemisphereLightHelper', function () {
            return Vd;
          }),
          n.d(e, 'HemisphereLightProbe', function () {
            return jh;
          }),
          n.d(e, 'IcosahedronBufferGeometry', function () {
            return zc;
          }),
          n.d(e, 'IcosahedronGeometry', function () {
            return zc;
          }),
          n.d(e, 'ImageBitmapLoader', function () {
            return Ih;
          }),
          n.d(e, 'ImageLoader', function () {
            return Pu;
          }),
          n.d(e, 'ImageUtils', function () {
            return Gn;
          }),
          n.d(e, 'ImmediateRenderObject', function () {
            return Id;
          }),
          n.d(e, 'IncrementStencilOp', function () {
            return dn;
          }),
          n.d(e, 'IncrementWrapStencilOp', function () {
            return fn;
          }),
          n.d(e, 'InstancedBufferAttribute', function () {
            return Ah;
          }),
          n.d(e, 'InstancedBufferGeometry', function () {
            return Eh;
          }),
          n.d(e, 'InstancedInterleavedBuffer', function () {
            return wd;
          }),
          n.d(e, 'InstancedMesh', function () {
            return Ll;
          }),
          n.d(e, 'Int16Attribute', function () {
            return rf;
          }),
          n.d(e, 'Int16BufferAttribute', function () {
            return Cr;
          }),
          n.d(e, 'Int32Attribute', function () {
            return of;
          }),
          n.d(e, 'Int32BufferAttribute', function () {
            return kr;
          }),
          n.d(e, 'Int8Attribute', function () {
            return tf;
          }),
          n.d(e, 'Int8BufferAttribute', function () {
            return Ar;
          }),
          n.d(e, 'IntType', function () {
            return At;
          }),
          n.d(e, 'InterleavedBuffer', function () {
            return Xs;
          }),
          n.d(e, 'InterleavedBufferAttribute', function () {
            return $s;
          }),
          n.d(e, 'Interpolant', function () {
            return uu;
          }),
          n.d(e, 'InterpolateDiscrete', function () {
            return Fe;
          }),
          n.d(e, 'InterpolateLinear', function () {
            return Be;
          }),
          n.d(e, 'InterpolateSmooth', function () {
            return Ue;
          }),
          n.d(e, 'InvertStencilOp', function () {
            return gn;
          }),
          n.d(e, 'JSONLoader', function () {
            return vf;
          }),
          n.d(e, 'KeepStencilOp', function () {
            return un;
          }),
          n.d(e, 'KeyframeTrack', function () {
            return fu;
          }),
          n.d(e, 'LOD', function () {
            return fl;
          }),
          n.d(e, 'LatheBufferGeometry', function () {
            return Fc;
          }),
          n.d(e, 'LatheGeometry', function () {
            return Fc;
          }),
          n.d(e, 'Layers', function () {
            return Fi;
          }),
          n.d(e, 'LensFlare', function () {
            return bf;
          }),
          n.d(e, 'LessDepth', function () {
            return G;
          }),
          n.d(e, 'LessEqualDepth', function () {
            return H;
          }),
          n.d(e, 'LessEqualStencilFunc', function () {
            return bn;
          }),
          n.d(e, 'LessStencilFunc', function () {
            return vn;
          }),
          n.d(e, 'Light', function () {
            return ah;
          }),
          n.d(e, 'LightProbe', function () {
            return qh;
          }),
          n.d(e, 'Line', function () {
            return Ol;
          }),
          n.d(e, 'Line3', function () {
            return kd;
          }),
          n.d(e, 'LineBasicMaterial', function () {
            return Rl;
          }),
          n.d(e, 'LineCurve', function () {
            return Ju;
          }),
          n.d(e, 'LineCurve3', function () {
            return Zu;
          }),
          n.d(e, 'LineDashedMaterial', function () {
            return su;
          }),
          n.d(e, 'LineLoop', function () {
            return Bl;
          }),
          n.d(e, 'LinePieces', function () {
            return Bp;
          }),
          n.d(e, 'LineSegments', function () {
            return Fl;
          }),
          n.d(e, 'LineStrip', function () {
            return Fp;
          }),
          n.d(e, 'LinearEncoding', function () {
            return Je;
          }),
          n.d(e, 'LinearFilter', function () {
            return xt;
          }),
          n.d(e, 'LinearInterpolant', function () {
            return du;
          }),
          n.d(e, 'LinearMipMapLinearFilter', function () {
            return Mt;
          }),
          n.d(e, 'LinearMipMapNearestFilter', function () {
            return _t;
          }),
          n.d(e, 'LinearMipmapLinearFilter', function () {
            return wt;
          }),
          n.d(e, 'LinearMipmapNearestFilter', function () {
            return bt;
          }),
          n.d(e, 'LinearToneMapping', function () {
            return Q;
          }),
          n.d(e, 'Loader', function () {
            return Eu;
          }),
          n.d(e, 'LoaderUtils', function () {
            return Th;
          }),
          n.d(e, 'LoadingManager', function () {
            return Su;
          }),
          n.d(e, 'LogLuvEncoding', function () {
            return tn;
          }),
          n.d(e, 'LoopOnce', function () {
            return Oe;
          }),
          n.d(e, 'LoopPingPong', function () {
            return ze;
          }),
          n.d(e, 'LoopRepeat', function () {
            return Ne;
          }),
          n.d(e, 'LuminanceAlphaFormat', function () {
            return Bt;
          }),
          n.d(e, 'LuminanceFormat', function () {
            return Ft;
          }),
          n.d(e, 'MOUSE', function () {
            return r;
          }),
          n.d(e, 'Material', function () {
            return gr;
          }),
          n.d(e, 'MaterialLoader', function () {
            return Sh;
          }),
          n.d(e, 'Math', function () {
            return Fn;
          }),
          n.d(e, 'MathUtils', function () {
            return Fn;
          }),
          n.d(e, 'Matrix3', function () {
            return Un;
          }),
          n.d(e, 'Matrix4', function () {
            return Ai;
          }),
          n.d(e, 'MaxEquation', function () {
            return L;
          }),
          n.d(e, 'Mesh', function () {
            return da;
          }),
          n.d(e, 'MeshBasicMaterial', function () {
            return qr;
          }),
          n.d(e, 'MeshDepthMaterial', function () {
            return Cs;
          }),
          n.d(e, 'MeshDistanceMaterial', function () {
            return Ps;
          }),
          n.d(e, 'MeshFaceMaterial', function () {
            return Hp;
          }),
          n.d(e, 'MeshLambertMaterial', function () {
            return au;
          }),
          n.d(e, 'MeshMatcapMaterial', function () {
            return ou;
          }),
          n.d(e, 'MeshNormalMaterial', function () {
            return ru;
          }),
          n.d(e, 'MeshPhongMaterial', function () {
            return nu;
          }),
          n.d(e, 'MeshPhysicalMaterial', function () {
            return eu;
          }),
          n.d(e, 'MeshStandardMaterial', function () {
            return tu;
          }),
          n.d(e, 'MeshToonMaterial', function () {
            return iu;
          }),
          n.d(e, 'MinEquation', function () {
            return A;
          }),
          n.d(e, 'MirroredRepeatWrapping', function () {
            return pt;
          }),
          n.d(e, 'MixOperation', function () {
            return J;
          }),
          n.d(e, 'MultiMaterial', function () {
            return Vp;
          }),
          n.d(e, 'MultiplyBlending', function () {
            return M;
          }),
          n.d(e, 'MultiplyOperation', function () {
            return $;
          }),
          n.d(e, 'NearestFilter', function () {
            return ft;
          }),
          n.d(e, 'NearestMipMapLinearFilter', function () {
            return vt;
          }),
          n.d(e, 'NearestMipMapNearestFilter', function () {
            return gt;
          }),
          n.d(e, 'NearestMipmapLinearFilter', function () {
            return yt;
          }),
          n.d(e, 'NearestMipmapNearestFilter', function () {
            return mt;
          }),
          n.d(e, 'NeverDepth', function () {
            return U;
          }),
          n.d(e, 'NeverStencilFunc', function () {
            return yn;
          }),
          n.d(e, 'NoBlending', function () {
            return x;
          }),
          n.d(e, 'NoColors', function () {
            return Up;
          }),
          n.d(e, 'NoToneMapping', function () {
            return K;
          }),
          n.d(e, 'NormalAnimationBlendMode', function () {
            return Ve;
          }),
          n.d(e, 'NormalBlending', function () {
            return b;
          }),
          n.d(e, 'NotEqualDepth', function () {
            return Y;
          }),
          n.d(e, 'NotEqualStencilFunc', function () {
            return wn;
          }),
          n.d(e, 'NumberKeyframeTrack', function () {
            return yu;
          }),
          n.d(e, 'Object3D', function () {
            return Qi;
          }),
          n.d(e, 'ObjectLoader', function () {
            return Rh;
          }),
          n.d(e, 'ObjectSpaceNormalMap', function () {
            return ln;
          }),
          n.d(e, 'OctahedronBufferGeometry', function () {
            return Bc;
          }),
          n.d(e, 'OctahedronGeometry', function () {
            return Bc;
          }),
          n.d(e, 'OneFactor', function () {
            return C;
          }),
          n.d(e, 'OneMinusDstAlphaFactor', function () {
            return N;
          }),
          n.d(e, 'OneMinusDstColorFactor', function () {
            return F;
          }),
          n.d(e, 'OneMinusSrcAlphaFactor', function () {
            return D;
          }),
          n.d(e, 'OneMinusSrcColorFactor', function () {
            return k;
          }),
          n.d(e, 'OrthographicCamera', function () {
            return vh;
          }),
          n.d(e, 'PCFShadowMap', function () {
            return h;
          }),
          n.d(e, 'PCFSoftShadowMap', function () {
            return d;
          }),
          n.d(e, 'PMREMGenerator', function () {
            return Rp;
          }),
          n.d(e, 'ParametricBufferGeometry', function () {
            return Uc;
          }),
          n.d(e, 'ParametricGeometry', function () {
            return Uc;
          }),
          n.d(e, 'Particle', function () {
            return Xp;
          }),
          n.d(e, 'ParticleBasicMaterial', function () {
            return Jp;
          }),
          n.d(e, 'ParticleSystem', function () {
            return Yp;
          }),
          n.d(e, 'ParticleSystemMaterial', function () {
            return Zp;
          }),
          n.d(e, 'Path', function () {
            return ih;
          }),
          n.d(e, 'PerspectiveCamera', function () {
            return ba;
          }),
          n.d(e, 'Plane', function () {
            return ir;
          }),
          n.d(e, 'PlaneBufferGeometry', function () {
            return Ra;
          }),
          n.d(e, 'PlaneGeometry', function () {
            return Ra;
          }),
          n.d(e, 'PlaneHelper', function () {
            return ap;
          }),
          n.d(e, 'PointCloud', function () {
            return Wp;
          }),
          n.d(e, 'PointCloudMaterial', function () {
            return $p;
          }),
          n.d(e, 'PointLight', function () {
            return yh;
          }),
          n.d(e, 'PointLightHelper', function () {
            return Ud;
          }),
          n.d(e, 'Points', function () {
            return Wl;
          }),
          n.d(e, 'PointsMaterial', function () {
            return Ul;
          }),
          n.d(e, 'PolarGridHelper', function () {
            return Xd;
          }),
          n.d(e, 'PolyhedronBufferGeometry', function () {
            return ec;
          }),
          n.d(e, 'PolyhedronGeometry', function () {
            return ec;
          }),
          n.d(e, 'PositionalAudio', function () {
            return ad;
          }),
          n.d(e, 'PropertyBinding', function () {
            return yd;
          }),
          n.d(e, 'PropertyMixer', function () {
            return sd;
          }),
          n.d(e, 'QuadraticBezierCurve', function () {
            return Ku;
          }),
          n.d(e, 'QuadraticBezierCurve3', function () {
            return Qu;
          }),
          n.d(e, 'Quaternion', function () {
            return Jn;
          }),
          n.d(e, 'QuaternionKeyframeTrack', function () {
            return xu;
          }),
          n.d(e, 'QuaternionLinearInterpolant', function () {
            return vu;
          }),
          n.d(e, 'REVISION', function () {
            return i;
          }),
          n.d(e, 'RGBADepthPacking', function () {
            return on;
          }),
          n.d(e, 'RGBAFormat', function () {
            return zt;
          }),
          n.d(e, 'RGBAIntegerFormat', function () {
            return $t;
          }),
          n.d(e, 'RGBA_ASTC_10x10_Format', function () {
            return ve;
          }),
          n.d(e, 'RGBA_ASTC_10x5_Format', function () {
            return me;
          }),
          n.d(e, 'RGBA_ASTC_10x6_Format', function () {
            return ge;
          }),
          n.d(e, 'RGBA_ASTC_10x8_Format', function () {
            return ye;
          }),
          n.d(e, 'RGBA_ASTC_12x10_Format', function () {
            return xe;
          }),
          n.d(e, 'RGBA_ASTC_12x12_Format', function () {
            return be;
          }),
          n.d(e, 'RGBA_ASTC_4x4_Format', function () {
            return se;
          }),
          n.d(e, 'RGBA_ASTC_5x4_Format', function () {
            return le;
          }),
          n.d(e, 'RGBA_ASTC_5x5_Format', function () {
            return ce;
          }),
          n.d(e, 'RGBA_ASTC_6x5_Format', function () {
            return ue;
          }),
          n.d(e, 'RGBA_ASTC_6x6_Format', function () {
            return he;
          }),
          n.d(e, 'RGBA_ASTC_8x5_Format', function () {
            return de;
          }),
          n.d(e, 'RGBA_ASTC_8x6_Format', function () {
            return pe;
          }),
          n.d(e, 'RGBA_ASTC_8x8_Format', function () {
            return fe;
          }),
          n.d(e, 'RGBA_BPTC_Format', function () {
            return _e;
          }),
          n.d(e, 'RGBA_ETC2_EAC_Format', function () {
            return oe;
          }),
          n.d(e, 'RGBA_PVRTC_2BPPV1_Format', function () {
            return ie;
          }),
          n.d(e, 'RGBA_PVRTC_4BPPV1_Format', function () {
            return ne;
          }),
          n.d(e, 'RGBA_S3TC_DXT1_Format', function () {
            return Zt;
          }),
          n.d(e, 'RGBA_S3TC_DXT3_Format', function () {
            return Kt;
          }),
          n.d(e, 'RGBA_S3TC_DXT5_Format', function () {
            return Qt;
          }),
          n.d(e, 'RGBDEncoding', function () {
            return rn;
          }),
          n.d(e, 'RGBEEncoding', function () {
            return Qe;
          }),
          n.d(e, 'RGBEFormat', function () {
            return Ut;
          }),
          n.d(e, 'RGBFormat', function () {
            return Nt;
          }),
          n.d(e, 'RGBIntegerFormat', function () {
            return Yt;
          }),
          n.d(e, 'RGBM16Encoding', function () {
            return nn;
          }),
          n.d(e, 'RGBM7Encoding', function () {
            return en;
          }),
          n.d(e, 'RGB_ETC1_Format', function () {
            return re;
          }),
          n.d(e, 'RGB_ETC2_Format', function () {
            return ae;
          }),
          n.d(e, 'RGB_PVRTC_2BPPV1_Format', function () {
            return ee;
          }),
          n.d(e, 'RGB_PVRTC_4BPPV1_Format', function () {
            return te;
          }),
          n.d(e, 'RGB_S3TC_DXT1_Format', function () {
            return Jt;
          }),
          n.d(e, 'RGFormat', function () {
            return Wt;
          }),
          n.d(e, 'RGIntegerFormat', function () {
            return Xt;
          }),
          n.d(e, 'RawShaderMaterial', function () {
            return Qc;
          }),
          n.d(e, 'Ray', function () {
            return Ei;
          }),
          n.d(e, 'Raycaster', function () {
            return qd;
          }),
          n.d(e, 'RectAreaLight', function () {
            return wh;
          }),
          n.d(e, 'RedFormat', function () {
            return Ht;
          }),
          n.d(e, 'RedIntegerFormat', function () {
            return Vt;
          }),
          n.d(e, 'ReinhardToneMapping', function () {
            return tt;
          }),
          n.d(e, 'RepeatWrapping', function () {
            return ht;
          }),
          n.d(e, 'ReplaceStencilOp', function () {
            return hn;
          }),
          n.d(e, 'ReverseSubtractEquation', function () {
            return E;
          }),
          n.d(e, 'RingBufferGeometry', function () {
            return jc;
          }),
          n.d(e, 'RingGeometry', function () {
            return jc;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_10x10_Format', function () {
            return ke;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_10x5_Format', function () {
            return Re;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_10x6_Format', function () {
            return Ce;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_10x8_Format', function () {
            return Pe;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_12x10_Format', function () {
            return Ie;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_12x12_Format', function () {
            return De;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_4x4_Format', function () {
            return we;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_5x4_Format', function () {
            return Me;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_5x5_Format', function () {
            return qe;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_6x5_Format', function () {
            return Se;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_6x6_Format', function () {
            return Te;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_8x5_Format', function () {
            return Ee;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_8x6_Format', function () {
            return Ae;
          }),
          n.d(e, 'SRGB8_ALPHA8_ASTC_8x8_Format', function () {
            return Le;
          }),
          n.d(e, 'Scene', function () {
            return Ws;
          }),
          n.d(e, 'SceneUtils', function () {
            return xf;
          }),
          n.d(e, 'ShaderChunk', function () {
            return Ca;
          }),
          n.d(e, 'ShaderLib', function () {
            return ka;
          }),
          n.d(e, 'ShaderMaterial', function () {
            return va;
          }),
          n.d(e, 'ShadowMaterial', function () {
            return Kc;
          }),
          n.d(e, 'Shape', function () {
            return rh;
          }),
          n.d(e, 'ShapeBufferGeometry', function () {
            return Gc;
          }),
          n.d(e, 'ShapeGeometry', function () {
            return Gc;
          }),
          n.d(e, 'ShapePath', function () {
            return Dh;
          }),
          n.d(e, 'ShapeUtils', function () {
            return kc;
          }),
          n.d(e, 'ShortType', function () {
            return Tt;
          }),
          n.d(e, 'Skeleton', function () {
            return ql;
          }),
          n.d(e, 'SkeletonHelper', function () {
            return Bd;
          }),
          n.d(e, 'SkinnedMesh', function () {
            return bl;
          }),
          n.d(e, 'SmoothShading', function () {
            return v;
          }),
          n.d(e, 'Sphere', function () {
            return xi;
          }),
          n.d(e, 'SphereBufferGeometry', function () {
            return Hc;
          }),
          n.d(e, 'SphereGeometry', function () {
            return Hc;
          }),
          n.d(e, 'Spherical', function () {
            return Ed;
          }),
          n.d(e, 'SphericalHarmonics3', function () {
            return Mh;
          }),
          n.d(e, 'SplineCurve', function () {
            return th;
          }),
          n.d(e, 'SpotLight', function () {
            return dh;
          }),
          n.d(e, 'SpotLightHelper', function () {
            return Od;
          }),
          n.d(e, 'Sprite', function () {
            return ul;
          }),
          n.d(e, 'SpriteMaterial', function () {
            return Js;
          }),
          n.d(e, 'SrcAlphaFactor', function () {
            return I;
          }),
          n.d(e, 'SrcAlphaSaturateFactor', function () {
            return B;
          }),
          n.d(e, 'SrcColorFactor', function () {
            return P;
          }),
          n.d(e, 'StaticCopyUsage', function () {
            return Cn;
          }),
          n.d(e, 'StaticDrawUsage', function () {
            return Sn;
          }),
          n.d(e, 'StaticReadUsage', function () {
            return An;
          }),
          n.d(e, 'StereoCamera', function () {
            return Wh;
          }),
          n.d(e, 'StreamCopyUsage', function () {
            return kn;
          }),
          n.d(e, 'StreamDrawUsage', function () {
            return En;
          }),
          n.d(e, 'StreamReadUsage', function () {
            return Rn;
          }),
          n.d(e, 'StringKeyframeTrack', function () {
            return bu;
          }),
          n.d(e, 'SubtractEquation', function () {
            return T;
          }),
          n.d(e, 'SubtractiveBlending', function () {
            return w;
          }),
          n.d(e, 'TOUCH', function () {
            return a;
          }),
          n.d(e, 'TangentSpaceNormalMap', function () {
            return sn;
          }),
          n.d(e, 'TetrahedronBufferGeometry', function () {
            return Vc;
          }),
          n.d(e, 'TetrahedronGeometry', function () {
            return Vc;
          }),
          n.d(e, 'TextBufferGeometry', function () {
            return Wc;
          }),
          n.d(e, 'TextGeometry', function () {
            return Wc;
          }),
          n.d(e, 'Texture', function () {
            return Vn;
          }),
          n.d(e, 'TextureLoader', function () {
            return Du;
          }),
          n.d(e, 'TorusBufferGeometry', function () {
            return Xc;
          }),
          n.d(e, 'TorusGeometry', function () {
            return Xc;
          }),
          n.d(e, 'TorusKnotBufferGeometry', function () {
            return Yc;
          }),
          n.d(e, 'TorusKnotGeometry', function () {
            return Yc;
          }),
          n.d(e, 'Triangle', function () {
            return fr;
          }),
          n.d(e, 'TriangleFanDrawMode', function () {
            return $e;
          }),
          n.d(e, 'TriangleStripDrawMode', function () {
            return Ye;
          }),
          n.d(e, 'TrianglesDrawMode', function () {
            return Xe;
          }),
          n.d(e, 'TubeBufferGeometry', function () {
            return $c;
          }),
          n.d(e, 'TubeGeometry', function () {
            return $c;
          }),
          n.d(e, 'UVMapping', function () {
            return rt;
          }),
          n.d(e, 'Uint16Attribute', function () {
            return af;
          }),
          n.d(e, 'Uint16BufferAttribute', function () {
            return Pr;
          }),
          n.d(e, 'Uint32Attribute', function () {
            return sf;
          }),
          n.d(e, 'Uint32BufferAttribute', function () {
            return Ir;
          }),
          n.d(e, 'Uint8Attribute', function () {
            return ef;
          }),
          n.d(e, 'Uint8BufferAttribute', function () {
            return Lr;
          }),
          n.d(e, 'Uint8ClampedAttribute', function () {
            return nf;
          }),
          n.d(e, 'Uint8ClampedBufferAttribute', function () {
            return Rr;
          }),
          n.d(e, 'Uniform', function () {
            return _d;
          }),
          n.d(e, 'UniformsLib', function () {
            return Pa;
          }),
          n.d(e, 'UniformsUtils', function () {
            return ya;
          }),
          n.d(e, 'UnsignedByteType', function () {
            return qt;
          }),
          n.d(e, 'UnsignedInt248Type', function () {
            return Dt;
          }),
          n.d(e, 'UnsignedIntType', function () {
            return Lt;
          }),
          n.d(e, 'UnsignedShort4444Type', function () {
            return Pt;
          }),
          n.d(e, 'UnsignedShort5551Type', function () {
            return kt;
          }),
          n.d(e, 'UnsignedShort565Type', function () {
            return It;
          }),
          n.d(e, 'UnsignedShortType', function () {
            return Et;
          }),
          n.d(e, 'VSMShadowMap', function () {
            return p;
          }),
          n.d(e, 'Vector2', function () {
            return Bn;
          }),
          n.d(e, 'Vector3', function () {
            return Zn;
          }),
          n.d(e, 'Vector4', function () {
            return Xn;
          }),
          n.d(e, 'VectorKeyframeTrack', function () {
            return _u;
          }),
          n.d(e, 'Vertex', function () {
            return Kp;
          }),
          n.d(e, 'VertexColors', function () {
            return Gp;
          }),
          n.d(e, 'VideoTexture', function () {
            return Yl;
          }),
          n.d(e, 'WebGL1Renderer', function () {
            return Gs;
          }),
          n.d(e, 'WebGLCubeRenderTarget', function () {
            return Ma;
          }),
          n.d(e, 'WebGLMultisampleRenderTarget', function () {
            return $n;
          }),
          n.d(e, 'WebGLRenderTarget', function () {
            return Yn;
          }),
          n.d(e, 'WebGLRenderTargetCube', function () {
            return gf;
          }),
          n.d(e, 'WebGLRenderer', function () {
            return js;
          }),
          n.d(e, 'WebGLUtils', function () {
            return Os;
          }),
          n.d(e, 'WireframeGeometry', function () {
            return Jc;
          }),
          n.d(e, 'WireframeHelper', function () {
            return pf;
          }),
          n.d(e, 'WrapAroundEnding', function () {
            return He;
          }),
          n.d(e, 'XHRLoader', function () {
            return ff;
          }),
          n.d(e, 'ZeroCurvatureEnding', function () {
            return je;
          }),
          n.d(e, 'ZeroFactor', function () {
            return R;
          }),
          n.d(e, 'ZeroSlopeEnding', function () {
            return Ge;
          }),
          n.d(e, 'ZeroStencilOp', function () {
            return cn;
          }),
          n.d(e, 'sRGBEncoding', function () {
            return Ze;
          });
        /**
         * @license
         * Copyright 2010-2021 Three.js Authors
         * SPDX-License-Identifier: MIT
         */
        const i = '127',
          r = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
          a = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
          o = 0,
          s = 1,
          l = 2,
          c = 3,
          u = 0,
          h = 1,
          d = 2,
          p = 3,
          f = 0,
          m = 1,
          g = 2,
          y = 1,
          v = 2,
          x = 0,
          b = 1,
          _ = 2,
          w = 3,
          M = 4,
          q = 5,
          S = 100,
          T = 101,
          E = 102,
          A = 103,
          L = 104,
          R = 200,
          C = 201,
          P = 202,
          k = 203,
          I = 204,
          D = 205,
          O = 206,
          N = 207,
          z = 208,
          F = 209,
          B = 210,
          U = 0,
          j = 1,
          G = 2,
          H = 3,
          V = 4,
          W = 5,
          X = 6,
          Y = 7,
          $ = 0,
          J = 1,
          Z = 2,
          K = 0,
          Q = 1,
          tt = 2,
          et = 3,
          nt = 4,
          it = 5,
          rt = 300,
          at = 301,
          ot = 302,
          st = 303,
          lt = 304,
          ct = 306,
          ut = 307,
          ht = 1e3,
          dt = 1001,
          pt = 1002,
          ft = 1003,
          mt = 1004,
          gt = 1004,
          yt = 1005,
          vt = 1005,
          xt = 1006,
          bt = 1007,
          _t = 1007,
          wt = 1008,
          Mt = 1008,
          qt = 1009,
          St = 1010,
          Tt = 1011,
          Et = 1012,
          At = 1013,
          Lt = 1014,
          Rt = 1015,
          Ct = 1016,
          Pt = 1017,
          kt = 1018,
          It = 1019,
          Dt = 1020,
          Ot = 1021,
          Nt = 1022,
          zt = 1023,
          Ft = 1024,
          Bt = 1025,
          Ut = zt,
          jt = 1026,
          Gt = 1027,
          Ht = 1028,
          Vt = 1029,
          Wt = 1030,
          Xt = 1031,
          Yt = 1032,
          $t = 1033,
          Jt = 33776,
          Zt = 33777,
          Kt = 33778,
          Qt = 33779,
          te = 35840,
          ee = 35841,
          ne = 35842,
          ie = 35843,
          re = 36196,
          ae = 37492,
          oe = 37496,
          se = 37808,
          le = 37809,
          ce = 37810,
          ue = 37811,
          he = 37812,
          de = 37813,
          pe = 37814,
          fe = 37815,
          me = 37816,
          ge = 37817,
          ye = 37818,
          ve = 37819,
          xe = 37820,
          be = 37821,
          _e = 36492,
          we = 37840,
          Me = 37841,
          qe = 37842,
          Se = 37843,
          Te = 37844,
          Ee = 37845,
          Ae = 37846,
          Le = 37847,
          Re = 37848,
          Ce = 37849,
          Pe = 37850,
          ke = 37851,
          Ie = 37852,
          De = 37853,
          Oe = 2200,
          Ne = 2201,
          ze = 2202,
          Fe = 2300,
          Be = 2301,
          Ue = 2302,
          je = 2400,
          Ge = 2401,
          He = 2402,
          Ve = 2500,
          We = 2501,
          Xe = 0,
          Ye = 1,
          $e = 2,
          Je = 3e3,
          Ze = 3001,
          Ke = 3007,
          Qe = 3002,
          tn = 3003,
          en = 3004,
          nn = 3005,
          rn = 3006,
          an = 3200,
          on = 3201,
          sn = 0,
          ln = 1,
          cn = 0,
          un = 7680,
          hn = 7681,
          dn = 7682,
          pn = 7683,
          fn = 34055,
          mn = 34056,
          gn = 5386,
          yn = 512,
          vn = 513,
          xn = 514,
          bn = 515,
          _n = 516,
          wn = 517,
          Mn = 518,
          qn = 519,
          Sn = 35044,
          Tn = 35048,
          En = 35040,
          An = 35045,
          Ln = 35049,
          Rn = 35041,
          Cn = 35046,
          Pn = 35050,
          kn = 35042,
          In = '100',
          Dn = '300 es';
        function On() {}
        Object.assign(On.prototype, {
          addEventListener: function (t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []),
              -1 === n[t].indexOf(e) && n[t].push(e);
          },
          hasEventListener: function (t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          },
          removeEventListener: function (t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
              const t = n.indexOf(e);
              -1 !== t && n.splice(t, 1);
            }
          },
          dispatchEvent: function (t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              const n = e.slice(0);
              for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
              t.target = null;
            }
          },
        });
        const Nn = [];
        for (let t = 0; t < 256; t++)
          Nn[t] = (t < 16 ? '0' : '') + t.toString(16);
        let zn = 1234567;
        const Fn = {
          DEG2RAD: Math.PI / 180,
          RAD2DEG: 180 / Math.PI,
          generateUUID: function () {
            const t = (4294967295 * Math.random()) | 0,
              e = (4294967295 * Math.random()) | 0,
              n = (4294967295 * Math.random()) | 0,
              i = (4294967295 * Math.random()) | 0;
            return (
              Nn[255 & t] +
              Nn[(t >> 8) & 255] +
              Nn[(t >> 16) & 255] +
              Nn[(t >> 24) & 255] +
              '-' +
              Nn[255 & e] +
              Nn[(e >> 8) & 255] +
              '-' +
              Nn[((e >> 16) & 15) | 64] +
              Nn[(e >> 24) & 255] +
              '-' +
              Nn[(63 & n) | 128] +
              Nn[(n >> 8) & 255] +
              '-' +
              Nn[(n >> 16) & 255] +
              Nn[(n >> 24) & 255] +
              Nn[255 & i] +
              Nn[(i >> 8) & 255] +
              Nn[(i >> 16) & 255] +
              Nn[(i >> 24) & 255]
            ).toUpperCase();
          },
          clamp: function (t, e, n) {
            return Math.max(e, Math.min(n, t));
          },
          euclideanModulo: function (t, e) {
            return ((t % e) + e) % e;
          },
          mapLinear: function (t, e, n, i, r) {
            return i + ((t - e) * (r - i)) / (n - e);
          },
          inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0;
          },
          lerp: function (t, e, n) {
            return (1 - n) * t + n * e;
          },
          damp: function (t, e, n, i) {
            return Fn.lerp(t, e, 1 - Math.exp(-n * i));
          },
          pingpong: function (t, e = 1) {
            return e - Math.abs(Fn.euclideanModulo(t, 2 * e) - e);
          },
          smoothstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
          },
          smootherstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1));
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t);
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random());
          },
          seededRandom: function (t) {
            return (
              void 0 !== t && (zn = t % 2147483647),
              (zn = (16807 * zn) % 2147483647),
              (zn - 1) / 2147483646
            );
          },
          degToRad: function (t) {
            return t * Fn.DEG2RAD;
          },
          radToDeg: function (t) {
            return t * Fn.RAD2DEG;
          },
          isPowerOfTwo: function (t) {
            return 0 == (t & (t - 1)) && 0 !== t;
          },
          ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
          },
          floorPowerOfTwo: function (t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
          },
          setQuaternionFromProperEuler: function (t, e, n, i, r) {
            const a = Math.cos,
              o = Math.sin,
              s = a(n / 2),
              l = o(n / 2),
              c = a((e + i) / 2),
              u = o((e + i) / 2),
              h = a((e - i) / 2),
              d = o((e - i) / 2),
              p = a((i - e) / 2),
              f = o((i - e) / 2);
            switch (r) {
              case 'XYX':
                t.set(s * u, l * h, l * d, s * c);
                break;
              case 'YZY':
                t.set(l * d, s * u, l * h, s * c);
                break;
              case 'ZXZ':
                t.set(l * h, l * d, s * u, s * c);
                break;
              case 'XZX':
                t.set(s * u, l * f, l * p, s * c);
                break;
              case 'YXY':
                t.set(l * p, s * u, l * f, s * c);
                break;
              case 'ZYZ':
                t.set(l * f, l * p, s * u, s * c);
                break;
              default:
                console.warn(
                  'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
                    r,
                );
            }
          },
        };
        class Bn {
          constructor(t = 0, e = 0) {
            (this.x = t), (this.y = e);
          }
          get width() {
            return this.x;
          }
          set width(t) {
            this.x = t;
          }
          get height() {
            return this.y;
          }
          set height(t) {
            this.y = t;
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error('index is out of range: ' + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error('index is out of range: ' + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this;
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6]),
              (this.y = i[1] * e + i[4] * n + i[7]),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n)),
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y;
          }
          cross(t) {
            return this.x * t.y - this.y * t.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              this
            );
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  'THREE.Vector2: offset has been removed from .fromBufferAttribute().',
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              this
            );
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = this.x - t.x,
              a = this.y - t.y;
            return (
              (this.x = r * n - a * i + t.x),
              (this.y = r * i + a * n + t.y),
              this
            );
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
        }
        Bn.prototype.isVector2 = !0;
        class Un {
          constructor() {
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error(
                  'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',
                );
          }
          set(t, e, n, i, r, a, o, s, l) {
            const c = this.elements;
            return (
              (c[0] = t),
              (c[1] = i),
              (c[2] = o),
              (c[3] = e),
              (c[4] = r),
              (c[5] = s),
              (c[6] = n),
              (c[7] = a),
              (c[8] = l),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0),
              e.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(t) {
            const e = t.elements;
            return (
              this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              a = n[0],
              o = n[3],
              s = n[6],
              l = n[1],
              c = n[4],
              u = n[7],
              h = n[2],
              d = n[5],
              p = n[8],
              f = i[0],
              m = i[3],
              g = i[6],
              y = i[1],
              v = i[4],
              x = i[7],
              b = i[2],
              _ = i[5],
              w = i[8];
            return (
              (r[0] = a * f + o * y + s * b),
              (r[3] = a * m + o * v + s * _),
              (r[6] = a * g + o * x + s * w),
              (r[1] = l * f + c * y + u * b),
              (r[4] = l * m + c * v + u * _),
              (r[7] = l * g + c * x + u * w),
              (r[2] = h * f + d * y + p * b),
              (r[5] = h * m + d * v + p * _),
              (r[8] = h * g + d * x + p * w),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              a = t[4],
              o = t[5],
              s = t[6],
              l = t[7],
              c = t[8];
            return (
              e * a * c -
              e * o * l -
              n * r * c +
              n * o * s +
              i * r * l -
              i * a * s
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              a = t[4],
              o = t[5],
              s = t[6],
              l = t[7],
              c = t[8],
              u = c * a - o * l,
              h = o * s - c * r,
              d = l * r - a * s,
              p = e * u + n * h + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return (
              (t[0] = u * f),
              (t[1] = (i * l - c * n) * f),
              (t[2] = (o * n - i * a) * f),
              (t[3] = h * f),
              (t[4] = (c * e - i * s) * f),
              (t[5] = (i * r - o * e) * f),
              (t[6] = d * f),
              (t[7] = (n * s - l * e) * f),
              (t[8] = (a * e - n * r) * f),
              this
            );
          }
          transpose() {
            let t;
            const e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
          }
          transposeIntoArray(t) {
            const e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          }
          setUvTransform(t, e, n, i, r, a, o) {
            const s = Math.cos(r),
              l = Math.sin(r);
            return (
              this.set(
                n * s,
                n * l,
                -n * (s * a + l * o) + a + t,
                -i * l,
                i * s,
                -i * (-l * a + s * o) + o + e,
                0,
                0,
                1,
              ),
              this
            );
          }
          scale(t, e) {
            const n = this.elements;
            return (
              (n[0] *= t),
              (n[3] *= t),
              (n[6] *= t),
              (n[1] *= e),
              (n[4] *= e),
              (n[7] *= e),
              this
            );
          }
          rotate(t) {
            const e = Math.cos(t),
              n = Math.sin(t),
              i = this.elements,
              r = i[0],
              a = i[3],
              o = i[6],
              s = i[1],
              l = i[4],
              c = i[7];
            return (
              (i[0] = e * r + n * s),
              (i[3] = e * a + n * l),
              (i[6] = e * o + n * c),
              (i[1] = -n * r + e * s),
              (i[4] = -n * a + e * l),
              (i[7] = -n * o + e * c),
              this
            );
          }
          translate(t, e) {
            const n = this.elements;
            return (
              (n[0] += t * n[2]),
              (n[3] += t * n[5]),
              (n[6] += t * n[8]),
              (n[1] += e * n[2]),
              (n[4] += e * n[5]),
              (n[7] += e * n[8]),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        }
        let jn;
        Un.prototype.isMatrix3 = !0;
        const Gn = {
          getDataURL: function (t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ('undefined' == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === jn &&
                (jn = document.createElementNS(
                  'http://www.w3.org/1999/xhtml',
                  'canvas',
                )),
                (jn.width = t.width),
                (jn.height = t.height);
              const n = jn.getContext('2d');
              t instanceof ImageData
                ? n.putImageData(t, 0, 0)
                : n.drawImage(t, 0, 0, t.width, t.height),
                (e = jn);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                  'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
                  t,
                ),
                e.toDataURL('image/jpeg', 0.6))
              : e.toDataURL('image/png');
          },
        };
        let Hn = 0;
        class Vn extends On {
          constructor(
            t = Vn.DEFAULT_IMAGE,
            e = Vn.DEFAULT_MAPPING,
            n = dt,
            i = dt,
            r = xt,
            a = wt,
            o = zt,
            s = qt,
            l = 1,
            c = Je,
          ) {
            super(),
              Object.defineProperty(this, 'id', { value: Hn++ }),
              (this.uuid = Fn.generateUUID()),
              (this.name = ''),
              (this.image = t),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.wrapS = n),
              (this.wrapT = i),
              (this.magFilter = r),
              (this.minFilter = a),
              (this.anisotropy = l),
              (this.format = o),
              (this.internalFormat = null),
              (this.type = s),
              (this.offset = new Bn(0, 0)),
              (this.repeat = new Bn(1, 1)),
              (this.center = new Bn(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new Un()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              (this.encoding = c),
              (this.version = 0),
              (this.onUpdate = null);
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y,
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.image = t.image),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.encoding = t.encoding),
              this
            );
          }
          toJSON(t) {
            const e = void 0 === t || 'string' == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
              return t.textures[this.uuid];
            const n = {
              metadata: {
                version: 4.5,
                type: 'Texture',
                generator: 'Texture.toJSON',
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            if (void 0 !== this.image) {
              const i = this.image;
              if (
                (void 0 === i.uuid && (i.uuid = Fn.generateUUID()),
                !e && void 0 === t.images[i.uuid])
              ) {
                let e;
                if (Array.isArray(i)) {
                  e = [];
                  for (let t = 0, n = i.length; t < n; t++)
                    i[t].isDataTexture
                      ? e.push(Wn(i[t].image))
                      : e.push(Wn(i[t]));
                } else e = Wn(i);
                t.images[i.uuid] = { uuid: i.uuid, url: e };
              }
              n.image = i.uuid;
            }
            return e || (t.textures[this.uuid] = n), n;
          }
          dispose() {
            this.dispatchEvent({ type: 'dispose' });
          }
          transformUv(t) {
            if (this.mapping !== rt) return t;
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case ht:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case dt:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case pt:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case ht:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case dt:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case pt:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            return this.flipY && (t.y = 1 - t.y), t;
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        function Wn(t) {
          return ('undefined' != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
            ('undefined' != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
            ? Gn.getDataURL(t)
            : t.data
            ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name,
              }
            : (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
        }
        (Vn.DEFAULT_IMAGE = void 0),
          (Vn.DEFAULT_MAPPING = rt),
          (Vn.prototype.isTexture = !0);
        class Xn {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (this.x = t), (this.y = e), (this.z = n), (this.w = i);
          }
          get width() {
            return this.z;
          }
          set width(t) {
            this.z = t;
          }
          get height() {
            return this.w;
          }
          set height(t) {
            this.w = t;
          }
          set(t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setW(t) {
            return (this.w = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error('index is out of range: ' + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error('index is out of range: ' + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                ),
                this.addVectors(t, e))
              : ((this.x += t.x),
                (this.y += t.y),
                (this.z += t.z),
                (this.w += t.w),
                this);
          }
          addScalar(t) {
            return (
              (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
            );
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x),
                (this.y -= t.y),
                (this.z -= t.z),
                (this.w -= t.w),
                this);
          }
          subScalar(t) {
            return (
              (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
            );
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          }
          multiply(t) {
            return (
              (this.x *= t.x),
              (this.y *= t.y),
              (this.z *= t.z),
              (this.w *= t.w),
              this
            );
          }
          multiplyScalar(t) {
            return (
              (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
            );
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = this.w,
              a = t.elements;
            return (
              (this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r),
              (this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r),
              (this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r),
              (this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r),
              this
            );
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const a = t.elements,
              o = a[0],
              s = a[4],
              l = a[8],
              c = a[1],
              u = a[5],
              h = a[9],
              d = a[2],
              p = a[6],
              f = a[10];
            if (
              Math.abs(s - c) < 0.01 &&
              Math.abs(l - d) < 0.01 &&
              Math.abs(h - p) < 0.01
            ) {
              if (
                Math.abs(s + c) < 0.1 &&
                Math.abs(l + d) < 0.1 &&
                Math.abs(h + p) < 0.1 &&
                Math.abs(o + u + f - 3) < 0.1
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              const t = (o + 1) / 2,
                a = (u + 1) / 2,
                m = (f + 1) / 2,
                g = (s + c) / 4,
                y = (l + d) / 4,
                v = (h + p) / 4;
              return (
                t > a && t > m
                  ? t < 0.01
                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                    : ((n = Math.sqrt(t)), (i = g / n), (r = y / n))
                  : a > m
                  ? a < 0.01
                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                    : ((i = Math.sqrt(a)), (n = g / i), (r = v / i))
                  : m < 0.01
                  ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                  : ((r = Math.sqrt(m)), (n = y / r), (i = v / r)),
                this.set(n, i, r, e),
                this
              );
            }
            let m = Math.sqrt(
              (p - h) * (p - h) + (l - d) * (l - d) + (c - s) * (c - s),
            );
            return (
              Math.abs(m) < 0.001 && (m = 1),
              (this.x = (p - h) / m),
              (this.y = (l - d) / m),
              (this.z = (c - s) / m),
              (this.w = Math.acos((o + u + f - 1) / 2)),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n)),
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          }
          lengthSq() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          length() {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w,
            );
          }
          manhattanLength() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            );
          }
          equals(t) {
            return (
              t.x === this.x &&
              t.y === this.y &&
              t.z === this.z &&
              t.w === this.w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]),
              (this.y = t[e + 1]),
              (this.z = t[e + 2]),
              (this.w = t[e + 3]),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this.x),
              (t[e + 1] = this.y),
              (t[e + 2] = this.z),
              (t[e + 3] = this.w),
              t
            );
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  'THREE.Vector4: offset has been removed from .fromBufferAttribute().',
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
        }
        Xn.prototype.isVector4 = !0;
        class Yn extends On {
          constructor(t, e, n) {
            super(),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new Xn(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new Xn(0, 0, t, e)),
              (n = n || {}),
              (this.texture = new Vn(
                void 0,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.encoding,
              )),
              (this.texture.image = {}),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = 1),
              (this.texture.generateMipmaps =
                void 0 !== n.generateMipmaps && n.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== n.minFilter ? n.minFilter : xt),
              (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
              (this.stencilBuffer =
                void 0 !== n.stencilBuffer && n.stencilBuffer),
              (this.depthTexture =
                void 0 !== n.depthTexture ? n.depthTexture : null);
          }
          setTexture(t) {
            (t.image = {
              width: this.width,
              height: this.height,
              depth: this.depth,
            }),
              (this.texture = t);
          }
          setSize(t, e, n = 1) {
            (this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
              (this.height = e),
              (this.depth = n),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = n),
              this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: 'dispose' });
          }
        }
        Yn.prototype.isWebGLRenderTarget = !0;
        class $n extends Yn {
          constructor(t, e, n) {
            super(t, e, n), (this.samples = 4);
          }
          copy(t) {
            return super.copy.call(this, t), (this.samples = t.samples), this;
          }
        }
        $n.prototype.isWebGLMultisampleRenderTarget = !0;
        class Jn {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (this._x = t), (this._y = e), (this._z = n), (this._w = i);
          }
          static slerp(t, e, n, i) {
            return (
              console.warn(
                'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.',
              ),
              n.slerpQuaternions(t, e, i)
            );
          }
          static slerpFlat(t, e, n, i, r, a, o) {
            let s = n[i + 0],
              l = n[i + 1],
              c = n[i + 2],
              u = n[i + 3];
            const h = r[a + 0],
              d = r[a + 1],
              p = r[a + 2],
              f = r[a + 3];
            if (0 === o)
              return (
                (t[e + 0] = s),
                (t[e + 1] = l),
                (t[e + 2] = c),
                void (t[e + 3] = u)
              );
            if (1 === o)
              return (
                (t[e + 0] = h),
                (t[e + 1] = d),
                (t[e + 2] = p),
                void (t[e + 3] = f)
              );
            if (u !== f || s !== h || l !== d || c !== p) {
              let t = 1 - o;
              const e = s * h + l * d + c * p + u * f,
                n = e >= 0 ? 1 : -1,
                i = 1 - e * e;
              if (i > Number.EPSILON) {
                const r = Math.sqrt(i),
                  a = Math.atan2(r, e * n);
                (t = Math.sin(t * a) / r), (o = Math.sin(o * a) / r);
              }
              const r = o * n;
              if (
                ((s = s * t + h * r),
                (l = l * t + d * r),
                (c = c * t + p * r),
                (u = u * t + f * r),
                t === 1 - o)
              ) {
                const t = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                (s *= t), (l *= t), (c *= t), (u *= t);
              }
            }
            (t[e] = s), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
          }
          static multiplyQuaternionsFlat(t, e, n, i, r, a) {
            const o = n[i],
              s = n[i + 1],
              l = n[i + 2],
              c = n[i + 3],
              u = r[a],
              h = r[a + 1],
              d = r[a + 2],
              p = r[a + 3];
            return (
              (t[e] = o * p + c * u + s * d - l * h),
              (t[e + 1] = s * p + c * h + l * u - o * d),
              (t[e + 2] = l * p + c * d + o * h - s * u),
              (t[e + 3] = c * p - o * u - s * h - l * d),
              t
            );
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(t) {
            (this._w = t), this._onChangeCallback();
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(t, e) {
            if (!t || !t.isEuler)
              throw new Error(
                'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
              );
            const n = t._x,
              i = t._y,
              r = t._z,
              a = t._order,
              o = Math.cos,
              s = Math.sin,
              l = o(n / 2),
              c = o(i / 2),
              u = o(r / 2),
              h = s(n / 2),
              d = s(i / 2),
              p = s(r / 2);
            switch (a) {
              case 'XYZ':
                (this._x = h * c * u + l * d * p),
                  (this._y = l * d * u - h * c * p),
                  (this._z = l * c * p + h * d * u),
                  (this._w = l * c * u - h * d * p);
                break;
              case 'YXZ':
                (this._x = h * c * u + l * d * p),
                  (this._y = l * d * u - h * c * p),
                  (this._z = l * c * p - h * d * u),
                  (this._w = l * c * u + h * d * p);
                break;
              case 'ZXY':
                (this._x = h * c * u - l * d * p),
                  (this._y = l * d * u + h * c * p),
                  (this._z = l * c * p + h * d * u),
                  (this._w = l * c * u - h * d * p);
                break;
              case 'ZYX':
                (this._x = h * c * u - l * d * p),
                  (this._y = l * d * u + h * c * p),
                  (this._z = l * c * p - h * d * u),
                  (this._w = l * c * u + h * d * p);
                break;
              case 'YZX':
                (this._x = h * c * u + l * d * p),
                  (this._y = l * d * u + h * c * p),
                  (this._z = l * c * p - h * d * u),
                  (this._w = l * c * u - h * d * p);
                break;
              case 'XZY':
                (this._x = h * c * u - l * d * p),
                  (this._y = l * d * u - h * c * p),
                  (this._z = l * c * p + h * d * u),
                  (this._w = l * c * u + h * d * p);
                break;
              default:
                console.warn(
                  'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
                    a,
                );
            }
            return !1 !== e && this._onChangeCallback(), this;
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              i = Math.sin(n);
            return (
              (this._x = t.x * i),
              (this._y = t.y * i),
              (this._z = t.z * i),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              i = e[4],
              r = e[8],
              a = e[1],
              o = e[5],
              s = e[9],
              l = e[2],
              c = e[6],
              u = e[10],
              h = n + o + u;
            if (h > 0) {
              const t = 0.5 / Math.sqrt(h + 1);
              (this._w = 0.25 / t),
                (this._x = (c - s) * t),
                (this._y = (r - l) * t),
                (this._z = (a - i) * t);
            } else if (n > o && n > u) {
              const t = 2 * Math.sqrt(1 + n - o - u);
              (this._w = (c - s) / t),
                (this._x = 0.25 * t),
                (this._y = (i + a) / t),
                (this._z = (r + l) / t);
            } else if (o > u) {
              const t = 2 * Math.sqrt(1 + o - n - u);
              (this._w = (r - l) / t),
                (this._x = (i + a) / t),
                (this._y = 0.25 * t),
                (this._z = (s + c) / t);
            } else {
              const t = 2 * Math.sqrt(1 + u - n - o);
              (this._w = (a - i) / t),
                (this._x = (r + l) / t),
                (this._y = (s + c) / t),
                (this._z = 0.25 * t);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y),
                      (this._y = t.x),
                      (this._z = 0),
                      (this._w = n))
                    : ((this._x = 0),
                      (this._y = -t.z),
                      (this._z = t.y),
                      (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            );
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(Fn.clamp(this.dot(t), -1, 1)));
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          }
          dot(t) {
            return (
              this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            );
          }
          lengthSq() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          length() {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w,
            );
          }
          normalize() {
            let t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',
                ),
                this.multiplyQuaternions(t, e))
              : this.multiplyQuaternions(this, t);
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this);
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              i = t._y,
              r = t._z,
              a = t._w,
              o = e._x,
              s = e._y,
              l = e._z,
              c = e._w;
            return (
              (this._x = n * c + a * o + i * l - r * s),
              (this._y = i * c + a * s + r * o - n * l),
              (this._z = r * c + a * l + n * s - i * o),
              (this._w = a * c - n * o - i * s - r * l),
              this._onChangeCallback(),
              this
            );
          }
          slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
              i = this._y,
              r = this._z,
              a = this._w;
            let o = a * t._w + n * t._x + i * t._y + r * t._z;
            if (
              (o < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (o = -o))
                : this.copy(t),
              o >= 1)
            )
              return (
                (this._w = a), (this._x = n), (this._y = i), (this._z = r), this
              );
            const s = 1 - o * o;
            if (s <= Number.EPSILON) {
              const t = 1 - e;
              return (
                (this._w = t * a + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * i + e * this._y),
                (this._z = t * r + e * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            const l = Math.sqrt(s),
              c = Math.atan2(l, o),
              u = Math.sin((1 - e) * c) / l,
              h = Math.sin(e * c) / l;
            return (
              (this._w = a * u + this._w * h),
              (this._x = n * u + this._x * h),
              (this._y = i * u + this._y * h),
              (this._z = r * u + this._z * h),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(t, e, n) {
            this.copy(t).slerp(e, n);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._w === this._w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._w),
              t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this._x = t.getX(e)),
              (this._y = t.getY(e)),
              (this._z = t.getZ(e)),
              (this._w = t.getW(e)),
              this
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
        }
        Jn.prototype.isQuaternion = !0;
        class Zn {
          constructor(t = 0, e = 0, n = 0) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          set(t, e, n) {
            return (
              void 0 === n && (n = this.z),
              (this.x = t),
              (this.y = e),
              (this.z = n),
              this
            );
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error('index is out of range: ' + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error('index is out of range: ' + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',
                ),
                this.multiplyVectors(t, e))
              : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          }
          multiplyVectors(t, e) {
            return (
              (this.x = t.x * e.x),
              (this.y = t.y * e.y),
              (this.z = t.z * e.z),
              this
            );
          }
          applyEuler(t) {
            return (
              (t && t.isEuler) ||
                console.error(
                  'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
                ),
              this.applyQuaternion(Qn.setFromEuler(t))
            );
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(Qn.setFromAxisAngle(t, e));
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[3] * n + r[6] * i),
              (this.y = r[1] * e + r[4] * n + r[7] * i),
              (this.z = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements,
              a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return (
              (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a),
              (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a),
              (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a),
              this
            );
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              a = t.y,
              o = t.z,
              s = t.w,
              l = s * e + a * i - o * n,
              c = s * n + o * e - r * i,
              u = s * i + r * n - a * e,
              h = -r * e - a * n - o * i;
            return (
              (this.x = l * s + h * -r + c * -o - u * -a),
              (this.y = c * s + h * -a + u * -r - l * -o),
              (this.z = u * s + h * -o + l * -a - c * -r),
              this
            );
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
              t.projectionMatrix,
            );
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
              t.matrixWorld,
            );
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * i),
              this.normalize()
            );
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n)),
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z,
            );
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              this
            );
          }
          cross(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',
                ),
                this.crossVectors(t, e))
              : this.crossVectors(this, t);
          }
          crossVectors(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              a = e.x,
              o = e.y,
              s = e.z;
            return (
              (this.x = i * s - r * o),
              (this.y = r * a - n * s),
              (this.z = n * o - i * a),
              this
            );
          }
          projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
          }
          projectOnPlane(t) {
            return Kn.copy(this).projectOnVector(t), this.sub(Kn);
          }
          reflect(t) {
            return this.sub(Kn.copy(t).multiplyScalar(2 * this.dot(t)));
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(Fn.clamp(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              i = this.z - t.z;
            return e * e + n * n + i * i;
          }
          manhattanDistanceTo(t) {
            return (
              Math.abs(this.x - t.x) +
              Math.abs(this.y - t.y) +
              Math.abs(this.z - t.z)
            );
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
          }
          setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return (
              (this.x = i * Math.sin(n)),
              (this.y = Math.cos(e) * t),
              (this.z = i * Math.cos(n)),
              this
            );
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
          }
          setFromCylindricalCoords(t, e, n) {
            return (
              (this.x = t * Math.sin(e)),
              (this.y = n),
              (this.z = t * Math.cos(e)),
              this
            );
          }
          setFromMatrixPosition(t) {
            const e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              i = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = i), this;
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e);
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e);
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  'THREE.Vector3: offset has been removed from .fromBufferAttribute().',
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              this
            );
          }
        }
        Zn.prototype.isVector3 = !0;
        const Kn = new Zn(),
          Qn = new Jn();
        class ti {
          constructor(
            t = new Zn(1 / 0, 1 / 0, 1 / 0),
            e = new Zn(-1 / 0, -1 / 0, -1 / 0),
          ) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromArray(t) {
            let e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              a = -1 / 0,
              o = -1 / 0;
            for (let s = 0, l = t.length; s < l; s += 3) {
              const l = t[s],
                c = t[s + 1],
                u = t[s + 2];
              l < e && (e = l),
                c < n && (n = c),
                u < i && (i = u),
                l > r && (r = l),
                c > a && (a = c),
                u > o && (o = u);
            }
            return this.min.set(e, n, i), this.max.set(r, a, o), this;
          }
          setFromBufferAttribute(t) {
            let e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              a = -1 / 0,
              o = -1 / 0;
            for (let s = 0, l = t.count; s < l; s++) {
              const l = t.getX(s),
                c = t.getY(s),
                u = t.getZ(s);
              l < e && (e = l),
                c < n && (n = c),
                u < i && (i = u),
                l > r && (r = l),
                c > a && (a = c),
                u > o && (o = u);
            }
            return this.min.set(e, n, i), this.max.set(r, a, o), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = ni.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          setFromObject(t) {
            return this.makeEmpty(), this.expandByObject(t);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          }
          getCenter(t) {
            return (
              void 0 === t &&
                (console.warn(
                  'THREE.Box3: .getCenter() target is now required',
                ),
                (t = new Zn())),
              this.isEmpty()
                ? t.set(0, 0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          }
          getSize(t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Box3: .getSize() target is now required'),
                (t = new Zn())),
              this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            );
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          expandByObject(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e &&
              (null === e.boundingBox && e.computeBoundingBox(),
              ii.copy(e.boundingBox),
              ii.applyMatrix4(t.matrixWorld),
              this.union(ii));
            const n = t.children;
            for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
            return this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          }
          getParameter(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  'THREE.Box3: .getParameter() target is now required',
                ),
                (e = new Zn())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y),
                (t.z - this.min.z) / (this.max.z - this.min.z),
              )
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          }
          intersectsSphere(t) {
            return (
              this.clampPoint(t.center, ni),
              ni.distanceToSquared(t.center) <= t.radius * t.radius
            );
          }
          intersectsPlane(t) {
            let e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x),
                  (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y),
                  (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y),
                  (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z),
                  (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z),
                  (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            );
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(ui),
              hi.subVectors(this.max, ui),
              ri.subVectors(t.a, ui),
              ai.subVectors(t.b, ui),
              oi.subVectors(t.c, ui),
              si.subVectors(ai, ri),
              li.subVectors(oi, ai),
              ci.subVectors(ri, oi);
            let e = [
              0,
              -si.z,
              si.y,
              0,
              -li.z,
              li.y,
              0,
              -ci.z,
              ci.y,
              si.z,
              0,
              -si.x,
              li.z,
              0,
              -li.x,
              ci.z,
              0,
              -ci.x,
              -si.y,
              si.x,
              0,
              -li.y,
              li.x,
              0,
              -ci.y,
              ci.x,
              0,
            ];
            return (
              !!fi(e, ri, ai, oi, hi) &&
              ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              !!fi(e, ri, ai, oi, hi) &&
                (di.crossVectors(si, li),
                (e = [di.x, di.y, di.z]),
                fi(e, ri, ai, oi, hi)))
            );
          }
          clampPoint(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  'THREE.Box3: .clampPoint() target is now required',
                ),
                (e = new Zn())),
              e.copy(t).clamp(this.min, this.max)
            );
          }
          distanceToPoint(t) {
            return ni.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          getBoundingSphere(t) {
            return (
              void 0 === t &&
                console.error(
                  'THREE.Box3: .getBoundingSphere() target is now required',
                ),
              this.getCenter(t.center),
              (t.radius = 0.5 * this.getSize(ni).length()),
              t
            );
          }
          intersect(t) {
            return (
              this.min.max(t.min),
              this.max.min(t.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          applyMatrix4(t) {
            return (
              this.isEmpty() ||
                (ei[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                ei[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                ei[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                ei[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                ei[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                ei[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                ei[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                ei[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(ei)),
              this
            );
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        ti.prototype.isBox3 = !0;
        const ei = [
            new Zn(),
            new Zn(),
            new Zn(),
            new Zn(),
            new Zn(),
            new Zn(),
            new Zn(),
            new Zn(),
          ],
          ni = new Zn(),
          ii = new ti(),
          ri = new Zn(),
          ai = new Zn(),
          oi = new Zn(),
          si = new Zn(),
          li = new Zn(),
          ci = new Zn(),
          ui = new Zn(),
          hi = new Zn(),
          di = new Zn(),
          pi = new Zn();
        function fi(t, e, n, i, r) {
          for (let a = 0, o = t.length - 3; a <= o; a += 3) {
            pi.fromArray(t, a);
            const o =
                r.x * Math.abs(pi.x) +
                r.y * Math.abs(pi.y) +
                r.z * Math.abs(pi.z),
              s = e.dot(pi),
              l = n.dot(pi),
              c = i.dot(pi);
            if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > o) return !1;
          }
          return !0;
        }
        const mi = new ti(),
          gi = new Zn(),
          yi = new Zn(),
          vi = new Zn();
        class xi {
          constructor(t = new Zn(), e = -1) {
            (this.center = t), (this.radius = e);
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this;
          }
          setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : mi.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++)
              i = Math.max(i, n.distanceToSquared(t[e]));
            return (this.radius = Math.sqrt(i)), this;
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(t) {
            return (
              t.distanceToSquared(this.center) <= this.radius * this.radius
            );
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          }
          intersectsBox(t) {
            return t.intersectsSphere(this);
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return (
              void 0 === e &&
                (console.warn(
                  'THREE.Sphere: .clampPoint() target is now required',
                ),
                (e = new Zn())),
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          }
          getBoundingBox(t) {
            return (
              void 0 === t &&
                (console.warn(
                  'THREE.Sphere: .getBoundingBox() target is now required',
                ),
                (t = new ti())),
              this.isEmpty()
                ? (t.makeEmpty(), t)
                : (t.set(this.center, this.center),
                  t.expandByScalar(this.radius),
                  t)
            );
          }
          applyMatrix4(t) {
            return (
              this.center.applyMatrix4(t),
              (this.radius = this.radius * t.getMaxScaleOnAxis()),
              this
            );
          }
          translate(t) {
            return this.center.add(t), this;
          }
          expandByPoint(t) {
            vi.subVectors(t, this.center);
            const e = vi.lengthSq();
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius);
              this.center.add(vi.multiplyScalar(n / t)), (this.radius += n);
            }
            return this;
          }
          union(t) {
            return (
              yi
                .subVectors(t.center, this.center)
                .normalize()
                .multiplyScalar(t.radius),
              this.expandByPoint(gi.copy(t.center).add(yi)),
              this.expandByPoint(gi.copy(t.center).sub(yi)),
              this
            );
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const bi = new Zn(),
          _i = new Zn(),
          wi = new Zn(),
          Mi = new Zn(),
          qi = new Zn(),
          Si = new Zn(),
          Ti = new Zn();
        class Ei {
          constructor(t = new Zn(), e = new Zn(0, 0, -1)) {
            (this.origin = t), (this.direction = e);
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          }
          copy(t) {
            return (
              this.origin.copy(t.origin), this.direction.copy(t.direction), this
            );
          }
          at(t, e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Ray: .at() target is now required'),
                (e = new Zn())),
              e.copy(this.direction).multiplyScalar(t).add(this.origin)
            );
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          }
          recast(t) {
            return this.origin.copy(this.at(t, bi)), this;
          }
          closestPointToPoint(t, e) {
            void 0 === e &&
              (console.warn(
                'THREE.Ray: .closestPointToPoint() target is now required',
              ),
              (e = new Zn())),
              e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.direction).multiplyScalar(n).add(this.origin);
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          }
          distanceSqToPoint(t) {
            const e = bi.subVectors(t, this.origin).dot(this.direction);
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (bi.copy(this.direction).multiplyScalar(e).add(this.origin),
                bi.distanceToSquared(t));
          }
          distanceSqToSegment(t, e, n, i) {
            _i.copy(t).add(e).multiplyScalar(0.5),
              wi.copy(e).sub(t).normalize(),
              Mi.copy(this.origin).sub(_i);
            const r = 0.5 * t.distanceTo(e),
              a = -this.direction.dot(wi),
              o = Mi.dot(this.direction),
              s = -Mi.dot(wi),
              l = Mi.lengthSq(),
              c = Math.abs(1 - a * a);
            let u, h, d, p;
            if (c > 0)
              if (((u = a * s - o), (h = a * o - s), (p = r * c), u >= 0))
                if (h >= -p)
                  if (h <= p) {
                    const t = 1 / c;
                    (u *= t),
                      (h *= t),
                      (d =
                        u * (u + a * h + 2 * o) + h * (a * u + h + 2 * s) + l);
                  } else
                    (h = r),
                      (u = Math.max(0, -(a * h + o))),
                      (d = -u * u + h * (h + 2 * s) + l);
                else
                  (h = -r),
                    (u = Math.max(0, -(a * h + o))),
                    (d = -u * u + h * (h + 2 * s) + l);
              else
                h <= -p
                  ? ((u = Math.max(0, -(-a * r + o))),
                    (h = u > 0 ? -r : Math.min(Math.max(-r, -s), r)),
                    (d = -u * u + h * (h + 2 * s) + l))
                  : h <= p
                  ? ((u = 0),
                    (h = Math.min(Math.max(-r, -s), r)),
                    (d = h * (h + 2 * s) + l))
                  : ((u = Math.max(0, -(a * r + o))),
                    (h = u > 0 ? r : Math.min(Math.max(-r, -s), r)),
                    (d = -u * u + h * (h + 2 * s) + l));
            else
              (h = a > 0 ? -r : r),
                (u = Math.max(0, -(a * h + o))),
                (d = -u * u + h * (h + 2 * s) + l);
            return (
              n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
              i && i.copy(wi).multiplyScalar(h).add(_i),
              d
            );
          }
          intersectSphere(t, e) {
            bi.subVectors(t.center, this.origin);
            const n = bi.dot(this.direction),
              i = bi.dot(bi) - n * n,
              r = t.radius * t.radius;
            if (i > r) return null;
            const a = Math.sqrt(r - i),
              o = n - a,
              s = n + a;
            return o < 0 && s < 0
              ? null
              : o < 0
              ? this.at(s, e)
              : this.at(o, e);
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            if (0 === e) return !0;
            return t.normal.dot(this.direction) * e < 0;
          }
          intersectBox(t, e) {
            let n, i, r, a, o, s;
            const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              u = 1 / this.direction.z,
              h = this.origin;
            return (
              l >= 0
                ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
                : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
              c >= 0
                ? ((r = (t.min.y - h.y) * c), (a = (t.max.y - h.y) * c))
                : ((r = (t.max.y - h.y) * c), (a = (t.min.y - h.y) * c)),
              n > a || r > i
                ? null
                : ((r > n || n != n) && (n = r),
                  (a < i || i != i) && (i = a),
                  u >= 0
                    ? ((o = (t.min.z - h.z) * u), (s = (t.max.z - h.z) * u))
                    : ((o = (t.max.z - h.z) * u), (s = (t.min.z - h.z) * u)),
                  n > s || o > i
                    ? null
                    : ((o > n || n != n) && (n = o),
                      (s < i || i != i) && (i = s),
                      i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            );
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, bi);
          }
          intersectTriangle(t, e, n, i, r) {
            qi.subVectors(e, t), Si.subVectors(n, t), Ti.crossVectors(qi, Si);
            let a,
              o = this.direction.dot(Ti);
            if (o > 0) {
              if (i) return null;
              a = 1;
            } else {
              if (!(o < 0)) return null;
              (a = -1), (o = -o);
            }
            Mi.subVectors(this.origin, t);
            const s = a * this.direction.dot(Si.crossVectors(Mi, Si));
            if (s < 0) return null;
            const l = a * this.direction.dot(qi.cross(Mi));
            if (l < 0) return null;
            if (s + l > o) return null;
            const c = -a * Mi.dot(Ti);
            return c < 0 ? null : this.at(c / o, r);
          }
          applyMatrix4(t) {
            return (
              this.origin.applyMatrix4(t),
              this.direction.transformDirection(t),
              this
            );
          }
          equals(t) {
            return (
              t.origin.equals(this.origin) && t.direction.equals(this.direction)
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class Ai {
          constructor() {
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error(
                  'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',
                );
          }
          set(t, e, n, i, r, a, o, s, l, c, u, h, d, p, f, m) {
            const g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = i),
              (g[1] = r),
              (g[5] = a),
              (g[9] = o),
              (g[13] = s),
              (g[2] = l),
              (g[6] = c),
              (g[10] = u),
              (g[14] = h),
              (g[3] = d),
              (g[7] = p),
              (g[11] = f),
              (g[15] = m),
              this
            );
          }
          identity() {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          clone() {
            return new Ai().fromArray(this.elements);
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          }
          setFromMatrix3(t) {
            const e = t.elements;
            return (
              this.set(
                e[0],
                e[3],
                e[6],
                0,
                e[1],
                e[4],
                e[7],
                0,
                e[2],
                e[5],
                e[8],
                0,
                0,
                0,
                0,
                1,
              ),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(t, e, n) {
            return (
              this.set(
                t.x,
                e.x,
                n.x,
                0,
                t.y,
                e.y,
                n.y,
                0,
                t.z,
                e.z,
                n.z,
                0,
                0,
                0,
                0,
                1,
              ),
              this
            );
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              i = 1 / Li.setFromMatrixColumn(t, 0).length(),
              r = 1 / Li.setFromMatrixColumn(t, 1).length(),
              a = 1 / Li.setFromMatrixColumn(t, 2).length();
            return (
              (e[0] = n[0] * i),
              (e[1] = n[1] * i),
              (e[2] = n[2] * i),
              (e[3] = 0),
              (e[4] = n[4] * r),
              (e[5] = n[5] * r),
              (e[6] = n[6] * r),
              (e[7] = 0),
              (e[8] = n[8] * a),
              (e[9] = n[9] * a),
              (e[10] = n[10] * a),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromEuler(t) {
            (t && t.isEuler) ||
              console.error(
                'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',
              );
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z,
              a = Math.cos(n),
              o = Math.sin(n),
              s = Math.cos(i),
              l = Math.sin(i),
              c = Math.cos(r),
              u = Math.sin(r);
            if ('XYZ' === t.order) {
              const t = a * c,
                n = a * u,
                i = o * c,
                r = o * u;
              (e[0] = s * c),
                (e[4] = -s * u),
                (e[8] = l),
                (e[1] = n + i * l),
                (e[5] = t - r * l),
                (e[9] = -o * s),
                (e[2] = r - t * l),
                (e[6] = i + n * l),
                (e[10] = a * s);
            } else if ('YXZ' === t.order) {
              const t = s * c,
                n = s * u,
                i = l * c,
                r = l * u;
              (e[0] = t + r * o),
                (e[4] = i * o - n),
                (e[8] = a * l),
                (e[1] = a * u),
                (e[5] = a * c),
                (e[9] = -o),
                (e[2] = n * o - i),
                (e[6] = r + t * o),
                (e[10] = a * s);
            } else if ('ZXY' === t.order) {
              const t = s * c,
                n = s * u,
                i = l * c,
                r = l * u;
              (e[0] = t - r * o),
                (e[4] = -a * u),
                (e[8] = i + n * o),
                (e[1] = n + i * o),
                (e[5] = a * c),
                (e[9] = r - t * o),
                (e[2] = -a * l),
                (e[6] = o),
                (e[10] = a * s);
            } else if ('ZYX' === t.order) {
              const t = a * c,
                n = a * u,
                i = o * c,
                r = o * u;
              (e[0] = s * c),
                (e[4] = i * l - n),
                (e[8] = t * l + r),
                (e[1] = s * u),
                (e[5] = r * l + t),
                (e[9] = n * l - i),
                (e[2] = -l),
                (e[6] = o * s),
                (e[10] = a * s);
            } else if ('YZX' === t.order) {
              const t = a * s,
                n = a * l,
                i = o * s,
                r = o * l;
              (e[0] = s * c),
                (e[4] = r - t * u),
                (e[8] = i * u + n),
                (e[1] = u),
                (e[5] = a * c),
                (e[9] = -o * c),
                (e[2] = -l * c),
                (e[6] = n * u + i),
                (e[10] = t - r * u);
            } else if ('XZY' === t.order) {
              const t = a * s,
                n = a * l,
                i = o * s,
                r = o * l;
              (e[0] = s * c),
                (e[4] = -u),
                (e[8] = l * c),
                (e[1] = t * u + r),
                (e[5] = a * c),
                (e[9] = n * u - i),
                (e[2] = i * u - n),
                (e[6] = o * c),
                (e[10] = r * u + t);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(t) {
            return this.compose(Ci, t, Pi);
          }
          lookAt(t, e, n) {
            const i = this.elements;
            return (
              Di.subVectors(t, e),
              0 === Di.lengthSq() && (Di.z = 1),
              Di.normalize(),
              ki.crossVectors(n, Di),
              0 === ki.lengthSq() &&
                (1 === Math.abs(n.z) ? (Di.x += 1e-4) : (Di.z += 1e-4),
                Di.normalize(),
                ki.crossVectors(n, Di)),
              ki.normalize(),
              Ii.crossVectors(Di, ki),
              (i[0] = ki.x),
              (i[4] = Ii.x),
              (i[8] = Di.x),
              (i[1] = ki.y),
              (i[5] = Ii.y),
              (i[9] = Di.y),
              (i[2] = ki.z),
              (i[6] = Ii.z),
              (i[10] = Di.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',
                ),
                this.multiplyMatrices(t, e))
              : this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              a = n[0],
              o = n[4],
              s = n[8],
              l = n[12],
              c = n[1],
              u = n[5],
              h = n[9],
              d = n[13],
              p = n[2],
              f = n[6],
              m = n[10],
              g = n[14],
              y = n[3],
              v = n[7],
              x = n[11],
              b = n[15],
              _ = i[0],
              w = i[4],
              M = i[8],
              q = i[12],
              S = i[1],
              T = i[5],
              E = i[9],
              A = i[13],
              L = i[2],
              R = i[6],
              C = i[10],
              P = i[14],
              k = i[3],
              I = i[7],
              D = i[11],
              O = i[15];
            return (
              (r[0] = a * _ + o * S + s * L + l * k),
              (r[4] = a * w + o * T + s * R + l * I),
              (r[8] = a * M + o * E + s * C + l * D),
              (r[12] = a * q + o * A + s * P + l * O),
              (r[1] = c * _ + u * S + h * L + d * k),
              (r[5] = c * w + u * T + h * R + d * I),
              (r[9] = c * M + u * E + h * C + d * D),
              (r[13] = c * q + u * A + h * P + d * O),
              (r[2] = p * _ + f * S + m * L + g * k),
              (r[6] = p * w + f * T + m * R + g * I),
              (r[10] = p * M + f * E + m * C + g * D),
              (r[14] = p * q + f * A + m * P + g * O),
              (r[3] = y * _ + v * S + x * L + b * k),
              (r[7] = y * w + v * T + x * R + b * I),
              (r[11] = y * M + v * E + x * C + b * D),
              (r[15] = y * q + v * A + x * P + b * O),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              i = t[8],
              r = t[12],
              a = t[1],
              o = t[5],
              s = t[9],
              l = t[13],
              c = t[2],
              u = t[6],
              h = t[10],
              d = t[14];
            return (
              t[3] *
                (+r * s * u -
                  i * l * u -
                  r * o * h +
                  n * l * h +
                  i * o * d -
                  n * s * d) +
              t[7] *
                (+e * s * d -
                  e * l * h +
                  r * a * h -
                  i * a * d +
                  i * l * c -
                  r * s * c) +
              t[11] *
                (+e * l * u -
                  e * o * d -
                  r * a * u +
                  n * a * d +
                  r * o * c -
                  n * l * c) +
              t[15] *
                (-i * o * c -
                  e * s * u +
                  e * o * h +
                  i * a * u -
                  n * a * h +
                  n * s * c)
            );
          }
          transpose() {
            const t = this.elements;
            let e;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          }
          setPosition(t, e, n) {
            const i = this.elements;
            return (
              t.isVector3
                ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                : ((i[12] = t), (i[13] = e), (i[14] = n)),
              this
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              a = t[4],
              o = t[5],
              s = t[6],
              l = t[7],
              c = t[8],
              u = t[9],
              h = t[10],
              d = t[11],
              p = t[12],
              f = t[13],
              m = t[14],
              g = t[15],
              y =
                u * m * l -
                f * h * l +
                f * s * d -
                o * m * d -
                u * s * g +
                o * h * g,
              v =
                p * h * l -
                c * m * l -
                p * s * d +
                a * m * d +
                c * s * g -
                a * h * g,
              x =
                c * f * l -
                p * u * l +
                p * o * d -
                a * f * d -
                c * o * g +
                a * u * g,
              b =
                p * u * s -
                c * f * s -
                p * o * h +
                a * f * h +
                c * o * m -
                a * u * m,
              _ = e * y + n * v + i * x + r * b;
            if (0 === _)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / _;
            return (
              (t[0] = y * w),
              (t[1] =
                (f * h * r -
                  u * m * r -
                  f * i * d +
                  n * m * d +
                  u * i * g -
                  n * h * g) *
                w),
              (t[2] =
                (o * m * r -
                  f * s * r +
                  f * i * l -
                  n * m * l -
                  o * i * g +
                  n * s * g) *
                w),
              (t[3] =
                (u * s * r -
                  o * h * r -
                  u * i * l +
                  n * h * l +
                  o * i * d -
                  n * s * d) *
                w),
              (t[4] = v * w),
              (t[5] =
                (c * m * r -
                  p * h * r +
                  p * i * d -
                  e * m * d -
                  c * i * g +
                  e * h * g) *
                w),
              (t[6] =
                (p * s * r -
                  a * m * r -
                  p * i * l +
                  e * m * l +
                  a * i * g -
                  e * s * g) *
                w),
              (t[7] =
                (a * h * r -
                  c * s * r +
                  c * i * l -
                  e * h * l -
                  a * i * d +
                  e * s * d) *
                w),
              (t[8] = x * w),
              (t[9] =
                (p * u * r -
                  c * f * r -
                  p * n * d +
                  e * f * d +
                  c * n * g -
                  e * u * g) *
                w),
              (t[10] =
                (a * f * r -
                  p * o * r +
                  p * n * l -
                  e * f * l -
                  a * n * g +
                  e * o * g) *
                w),
              (t[11] =
                (c * o * r -
                  a * u * r -
                  c * n * l +
                  e * u * l +
                  a * n * d -
                  e * o * d) *
                w),
              (t[12] = b * w),
              (t[13] =
                (c * f * i -
                  p * u * i +
                  p * n * h -
                  e * f * h -
                  c * n * m +
                  e * u * m) *
                w),
              (t[14] =
                (p * o * i -
                  a * f * i -
                  p * n * s +
                  e * f * s +
                  a * n * m -
                  e * o * m) *
                w),
              (t[15] =
                (a * u * i -
                  c * o * i +
                  c * n * s -
                  e * u * s -
                  a * n * h +
                  e * o * h) *
                w),
              this
            );
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z;
            return (
              (e[0] *= n),
              (e[4] *= i),
              (e[8] *= r),
              (e[1] *= n),
              (e[5] *= i),
              (e[9] *= r),
              (e[2] *= n),
              (e[6] *= i),
              (e[10] *= r),
              (e[3] *= n),
              (e[7] *= i),
              (e[11] *= r),
              this
            );
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i));
          }
          makeTranslation(t, e, n) {
            return (
              this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            );
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = 1 - n,
              a = t.x,
              o = t.y,
              s = t.z,
              l = r * a,
              c = r * o;
            return (
              this.set(
                l * a + n,
                l * o - i * s,
                l * s + i * o,
                0,
                l * o + i * s,
                c * o + n,
                c * s - i * a,
                0,
                l * s - i * o,
                c * s + i * a,
                r * s * s + n,
                0,
                0,
                0,
                0,
                1,
              ),
              this
            );
          }
          makeScale(t, e, n) {
            return (
              this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            );
          }
          makeShear(t, e, n) {
            return (
              this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
            );
          }
          compose(t, e, n) {
            const i = this.elements,
              r = e._x,
              a = e._y,
              o = e._z,
              s = e._w,
              l = r + r,
              c = a + a,
              u = o + o,
              h = r * l,
              d = r * c,
              p = r * u,
              f = a * c,
              m = a * u,
              g = o * u,
              y = s * l,
              v = s * c,
              x = s * u,
              b = n.x,
              _ = n.y,
              w = n.z;
            return (
              (i[0] = (1 - (f + g)) * b),
              (i[1] = (d + x) * b),
              (i[2] = (p - v) * b),
              (i[3] = 0),
              (i[4] = (d - x) * _),
              (i[5] = (1 - (h + g)) * _),
              (i[6] = (m + y) * _),
              (i[7] = 0),
              (i[8] = (p + v) * w),
              (i[9] = (m - y) * w),
              (i[10] = (1 - (h + f)) * w),
              (i[11] = 0),
              (i[12] = t.x),
              (i[13] = t.y),
              (i[14] = t.z),
              (i[15] = 1),
              this
            );
          }
          decompose(t, e, n) {
            const i = this.elements;
            let r = Li.set(i[0], i[1], i[2]).length();
            const a = Li.set(i[4], i[5], i[6]).length(),
              o = Li.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
              (t.x = i[12]),
              (t.y = i[13]),
              (t.z = i[14]),
              Ri.copy(this);
            const s = 1 / r,
              l = 1 / a,
              c = 1 / o;
            return (
              (Ri.elements[0] *= s),
              (Ri.elements[1] *= s),
              (Ri.elements[2] *= s),
              (Ri.elements[4] *= l),
              (Ri.elements[5] *= l),
              (Ri.elements[6] *= l),
              (Ri.elements[8] *= c),
              (Ri.elements[9] *= c),
              (Ri.elements[10] *= c),
              e.setFromRotationMatrix(Ri),
              (n.x = r),
              (n.y = a),
              (n.z = o),
              this
            );
          }
          makePerspective(t, e, n, i, r, a) {
            void 0 === a &&
              console.warn(
                'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',
              );
            const o = this.elements,
              s = (2 * r) / (e - t),
              l = (2 * r) / (n - i),
              c = (e + t) / (e - t),
              u = (n + i) / (n - i),
              h = -(a + r) / (a - r),
              d = (-2 * a * r) / (a - r);
            return (
              (o[0] = s),
              (o[4] = 0),
              (o[8] = c),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = l),
              (o[9] = u),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = h),
              (o[14] = d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            );
          }
          makeOrthographic(t, e, n, i, r, a) {
            const o = this.elements,
              s = 1 / (e - t),
              l = 1 / (n - i),
              c = 1 / (a - r),
              u = (e + t) * s,
              h = (n + i) * l,
              d = (a + r) * c;
            return (
              (o[0] = 2 * s),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -u),
              (o[1] = 0),
              (o[5] = 2 * l),
              (o[9] = 0),
              (o[13] = -h),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = -2 * c),
              (o[14] = -d),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          }
        }
        Ai.prototype.isMatrix4 = !0;
        const Li = new Zn(),
          Ri = new Ai(),
          Ci = new Zn(0, 0, 0),
          Pi = new Zn(1, 1, 1),
          ki = new Zn(),
          Ii = new Zn(),
          Di = new Zn(),
          Oi = new Ai(),
          Ni = new Jn();
        class zi {
          constructor(t = 0, e = 0, n = 0, i = zi.DefaultOrder) {
            (this._x = t), (this._y = e), (this._z = n), (this._order = i);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i || this._order),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, e, n) {
            const i = Fn.clamp,
              r = t.elements,
              a = r[0],
              o = r[4],
              s = r[8],
              l = r[1],
              c = r[5],
              u = r[9],
              h = r[2],
              d = r[6],
              p = r[10];
            switch ((e = e || this._order)) {
              case 'XYZ':
                (this._y = Math.asin(i(s, -1, 1))),
                  Math.abs(s) < 0.9999999
                    ? ((this._x = Math.atan2(-u, p)),
                      (this._z = Math.atan2(-o, a)))
                    : ((this._x = Math.atan2(d, c)), (this._z = 0));
                break;
              case 'YXZ':
                (this._x = Math.asin(-i(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._y = Math.atan2(s, p)),
                      (this._z = Math.atan2(l, c)))
                    : ((this._y = Math.atan2(-h, a)), (this._z = 0));
                break;
              case 'ZXY':
                (this._x = Math.asin(i(d, -1, 1))),
                  Math.abs(d) < 0.9999999
                    ? ((this._y = Math.atan2(-h, p)),
                      (this._z = Math.atan2(-o, c)))
                    : ((this._y = 0), (this._z = Math.atan2(l, a)));
                break;
              case 'ZYX':
                (this._y = Math.asin(-i(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(d, p)),
                      (this._z = Math.atan2(l, a)))
                    : ((this._x = 0), (this._z = Math.atan2(-o, c)));
                break;
              case 'YZX':
                (this._z = Math.asin(i(l, -1, 1))),
                  Math.abs(l) < 0.9999999
                    ? ((this._x = Math.atan2(-u, c)),
                      (this._y = Math.atan2(-h, a)))
                    : ((this._x = 0), (this._y = Math.atan2(s, p)));
                break;
              case 'XZY':
                (this._z = Math.asin(-i(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(d, c)),
                      (this._y = Math.atan2(s, a)))
                    : ((this._x = Math.atan2(-u, p)), (this._y = 0));
                break;
              default:
                console.warn(
                  'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
                    e,
                );
            }
            return (
              (this._order = e), !1 !== n && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(t, e, n) {
            return (
              Oi.makeRotationFromQuaternion(t),
              this.setFromRotationMatrix(Oi, e, n)
            );
          }
          setFromVector3(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order);
          }
          reorder(t) {
            return Ni.setFromEuler(this), this.setFromQuaternion(Ni, t);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          }
          toVector3(t) {
            return t
              ? t.set(this._x, this._y, this._z)
              : new Zn(this._x, this._y, this._z);
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
        }
        (zi.prototype.isEuler = !0),
          (zi.DefaultOrder = 'XYZ'),
          (zi.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']);
        class Fi {
          constructor() {
            this.mask = 1;
          }
          set(t) {
            this.mask = (1 << t) | 0;
          }
          enable(t) {
            this.mask |= (1 << t) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(t) {
            this.mask ^= (1 << t) | 0;
          }
          disable(t) {
            this.mask &= ~((1 << t) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(t) {
            return 0 != (this.mask & t.mask);
          }
        }
        let Bi = 0;
        const Ui = new Zn(),
          ji = new Jn(),
          Gi = new Ai(),
          Hi = new Zn(),
          Vi = new Zn(),
          Wi = new Zn(),
          Xi = new Jn(),
          Yi = new Zn(1, 0, 0),
          $i = new Zn(0, 1, 0),
          Ji = new Zn(0, 0, 1),
          Zi = { type: 'added' },
          Ki = { type: 'removed' };
        function Qi() {
          Object.defineProperty(this, 'id', { value: Bi++ }),
            (this.uuid = Fn.generateUUID()),
            (this.name = ''),
            (this.type = 'Object3D'),
            (this.parent = null),
            (this.children = []),
            (this.up = Qi.DefaultUp.clone());
          const t = new Zn(),
            e = new zi(),
            n = new Jn(),
            i = new Zn(1, 1, 1);
          e._onChange(function () {
            n.setFromEuler(e, !1);
          }),
            n._onChange(function () {
              e.setFromQuaternion(n, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: t },
              rotation: { configurable: !0, enumerable: !0, value: e },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new Ai() },
              normalMatrix: { value: new Un() },
            }),
            (this.matrix = new Ai()),
            (this.matrixWorld = new Ai()),
            (this.matrixAutoUpdate = Qi.DefaultMatrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Fi()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        (Qi.DefaultUp = new Zn(0, 1, 0)),
          (Qi.DefaultMatrixAutoUpdate = !0),
          (Qi.prototype = Object.assign(Object.create(On.prototype), {
            constructor: Qi,
            isObject3D: !0,
            onBeforeRender: function () {},
            onAfterRender: function () {},
            applyMatrix4: function (t) {
              this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(
                  this.position,
                  this.quaternion,
                  this.scale,
                );
            },
            applyQuaternion: function (t) {
              return this.quaternion.premultiply(t), this;
            },
            setRotationFromAxisAngle: function (t, e) {
              this.quaternion.setFromAxisAngle(t, e);
            },
            setRotationFromEuler: function (t) {
              this.quaternion.setFromEuler(t, !0);
            },
            setRotationFromMatrix: function (t) {
              this.quaternion.setFromRotationMatrix(t);
            },
            setRotationFromQuaternion: function (t) {
              this.quaternion.copy(t);
            },
            rotateOnAxis: function (t, e) {
              return (
                ji.setFromAxisAngle(t, e), this.quaternion.multiply(ji), this
              );
            },
            rotateOnWorldAxis: function (t, e) {
              return (
                ji.setFromAxisAngle(t, e), this.quaternion.premultiply(ji), this
              );
            },
            rotateX: function (t) {
              return this.rotateOnAxis(Yi, t);
            },
            rotateY: function (t) {
              return this.rotateOnAxis($i, t);
            },
            rotateZ: function (t) {
              return this.rotateOnAxis(Ji, t);
            },
            translateOnAxis: function (t, e) {
              return (
                Ui.copy(t).applyQuaternion(this.quaternion),
                this.position.add(Ui.multiplyScalar(e)),
                this
              );
            },
            translateX: function (t) {
              return this.translateOnAxis(Yi, t);
            },
            translateY: function (t) {
              return this.translateOnAxis($i, t);
            },
            translateZ: function (t) {
              return this.translateOnAxis(Ji, t);
            },
            localToWorld: function (t) {
              return t.applyMatrix4(this.matrixWorld);
            },
            worldToLocal: function (t) {
              return t.applyMatrix4(Gi.copy(this.matrixWorld).invert());
            },
            lookAt: function (t, e, n) {
              t.isVector3 ? Hi.copy(t) : Hi.set(t, e, n);
              const i = this.parent;
              this.updateWorldMatrix(!0, !1),
                Vi.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight
                  ? Gi.lookAt(Vi, Hi, this.up)
                  : Gi.lookAt(Hi, Vi, this.up),
                this.quaternion.setFromRotationMatrix(Gi),
                i &&
                  (Gi.extractRotation(i.matrixWorld),
                  ji.setFromRotationMatrix(Gi),
                  this.quaternion.premultiply(ji.invert()));
            },
            add: function (t) {
              if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                  this.add(arguments[t]);
                return this;
              }
              return t === this
                ? (console.error(
                    "THREE.Object3D.add: object can't be added as a child of itself.",
                    t,
                  ),
                  this)
                : (t && t.isObject3D
                    ? (null !== t.parent && t.parent.remove(t),
                      (t.parent = this),
                      this.children.push(t),
                      t.dispatchEvent(Zi))
                    : console.error(
                        'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                        t,
                      ),
                  this);
            },
            remove: function (t) {
              if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                  this.remove(arguments[t]);
                return this;
              }
              const e = this.children.indexOf(t);
              return (
                -1 !== e &&
                  ((t.parent = null),
                  this.children.splice(e, 1),
                  t.dispatchEvent(Ki)),
                this
              );
            },
            clear: function () {
              for (let t = 0; t < this.children.length; t++) {
                const e = this.children[t];
                (e.parent = null), e.dispatchEvent(Ki);
              }
              return (this.children.length = 0), this;
            },
            attach: function (t) {
              return (
                this.updateWorldMatrix(!0, !1),
                Gi.copy(this.matrixWorld).invert(),
                null !== t.parent &&
                  (t.parent.updateWorldMatrix(!0, !1),
                  Gi.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(Gi),
                this.add(t),
                t.updateWorldMatrix(!1, !0),
                this
              );
            },
            getObjectById: function (t) {
              return this.getObjectByProperty('id', t);
            },
            getObjectByName: function (t) {
              return this.getObjectByProperty('name', t);
            },
            getObjectByProperty: function (t, e) {
              if (this[t] === e) return this;
              for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i) return i;
              }
            },
            getWorldPosition: function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    'THREE.Object3D: .getWorldPosition() target is now required',
                  ),
                  (t = new Zn())),
                this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
              );
            },
            getWorldQuaternion: function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    'THREE.Object3D: .getWorldQuaternion() target is now required',
                  ),
                  (t = new Jn())),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Vi, t, Wi),
                t
              );
            },
            getWorldScale: function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    'THREE.Object3D: .getWorldScale() target is now required',
                  ),
                  (t = new Zn())),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Vi, Xi, t),
                t
              );
            },
            getWorldDirection: function (t) {
              void 0 === t &&
                (console.warn(
                  'THREE.Object3D: .getWorldDirection() target is now required',
                ),
                (t = new Zn())),
                this.updateWorldMatrix(!0, !1);
              const e = this.matrixWorld.elements;
              return t.set(e[8], e[9], e[10]).normalize();
            },
            raycast: function () {},
            traverse: function (t) {
              t(this);
              const e = this.children;
              for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
            },
            traverseVisible: function (t) {
              if (!1 === this.visible) return;
              t(this);
              const e = this.children;
              for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
            },
            traverseAncestors: function (t) {
              const e = this.parent;
              null !== e && (t(e), e.traverseAncestors(t));
            },
            updateMatrix: function () {
              this.matrix.compose(this.position, this.quaternion, this.scale),
                (this.matrixWorldNeedsUpdate = !0);
            },
            updateMatrixWorld: function (t) {
              this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) &&
                  (null === this.parent
                    ? this.matrixWorld.copy(this.matrix)
                    : this.matrixWorld.multiplyMatrices(
                        this.parent.matrixWorld,
                        this.matrix,
                      ),
                  (this.matrixWorldNeedsUpdate = !1),
                  (t = !0));
              const e = this.children;
              for (let n = 0, i = e.length; n < i; n++)
                e[n].updateMatrixWorld(t);
            },
            updateWorldMatrix: function (t, e) {
              const n = this.parent;
              if (
                (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix,
                    ),
                !0 === e)
              ) {
                const t = this.children;
                for (let e = 0, n = t.length; e < n; e++)
                  t[e].updateWorldMatrix(!1, !0);
              }
            },
            toJSON: function (t) {
              const e = void 0 === t || 'string' == typeof t,
                n = {};
              e &&
                ((t = {
                  geometries: {},
                  materials: {},
                  textures: {},
                  images: {},
                  shapes: {},
                  skeletons: {},
                  animations: {},
                }),
                (n.metadata = {
                  version: 4.5,
                  type: 'Object',
                  generator: 'Object3D.toJSON',
                }));
              const i = {};
              function r(e, n) {
                return (
                  void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                );
              }
              if (
                ((i.uuid = this.uuid),
                (i.type = this.type),
                '' !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                '{}' !== JSON.stringify(this.userData) &&
                  (i.userData = this.userData),
                (i.layers = this.layers.mask),
                (i.matrix = this.matrix.toArray()),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh &&
                  ((i.type = 'InstancedMesh'),
                  (i.count = this.count),
                  (i.instanceMatrix = this.instanceMatrix.toJSON()),
                  null !== this.instanceColor &&
                    (i.instanceColor = this.instanceColor.toJSON())),
                this.isMesh || this.isLine || this.isPoints)
              ) {
                i.geometry = r(t.geometries, this.geometry);
                const e = this.geometry.parameters;
                if (void 0 !== e && void 0 !== e.shapes) {
                  const n = e.shapes;
                  if (Array.isArray(n))
                    for (let e = 0, i = n.length; e < i; e++) {
                      const i = n[e];
                      r(t.shapes, i);
                    }
                  else r(t.shapes, n);
                }
              }
              if (
                (this.isSkinnedMesh &&
                  ((i.bindMode = this.bindMode),
                  (i.bindMatrix = this.bindMatrix.toArray()),
                  void 0 !== this.skeleton &&
                    (r(t.skeletons, this.skeleton),
                    (i.skeleton = this.skeleton.uuid))),
                void 0 !== this.material)
              )
                if (Array.isArray(this.material)) {
                  const e = [];
                  for (let n = 0, i = this.material.length; n < i; n++)
                    e.push(r(t.materials, this.material[n]));
                  i.material = e;
                } else i.material = r(t.materials, this.material);
              if (this.children.length > 0) {
                i.children = [];
                for (let e = 0; e < this.children.length; e++)
                  i.children.push(this.children[e].toJSON(t).object);
              }
              if (this.animations.length > 0) {
                i.animations = [];
                for (let e = 0; e < this.animations.length; e++) {
                  const n = this.animations[e];
                  i.animations.push(r(t.animations, n));
                }
              }
              if (e) {
                const e = a(t.geometries),
                  i = a(t.materials),
                  r = a(t.textures),
                  o = a(t.images),
                  s = a(t.shapes),
                  l = a(t.skeletons),
                  c = a(t.animations);
                e.length > 0 && (n.geometries = e),
                  i.length > 0 && (n.materials = i),
                  r.length > 0 && (n.textures = r),
                  o.length > 0 && (n.images = o),
                  s.length > 0 && (n.shapes = s),
                  l.length > 0 && (n.skeletons = l),
                  c.length > 0 && (n.animations = c);
              }
              return (n.object = i), n;
              function a(t) {
                const e = [];
                for (const n in t) {
                  const i = t[n];
                  delete i.metadata, e.push(i);
                }
                return e;
              }
            },
            clone: function (t) {
              return new this.constructor().copy(this, t);
            },
            copy: function (t, e = !0) {
              if (
                ((this.name = t.name),
                this.up.copy(t.up),
                this.position.copy(t.position),
                (this.rotation.order = t.rotation.order),
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                (this.matrixAutoUpdate = t.matrixAutoUpdate),
                (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
                (this.layers.mask = t.layers.mask),
                (this.visible = t.visible),
                (this.castShadow = t.castShadow),
                (this.receiveShadow = t.receiveShadow),
                (this.frustumCulled = t.frustumCulled),
                (this.renderOrder = t.renderOrder),
                (this.userData = JSON.parse(JSON.stringify(t.userData))),
                !0 === e)
              )
                for (let e = 0; e < t.children.length; e++) {
                  const n = t.children[e];
                  this.add(n.clone());
                }
              return this;
            },
          }));
        const tr = new Zn(),
          er = new Zn(),
          nr = new Un();
        class ir {
          constructor(t = new Zn(1, 0, 0), e = 0) {
            (this.normal = t), (this.constant = e);
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          }
          setComponents(t, e, n, i) {
            return this.normal.set(t, e, n), (this.constant = i), this;
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return (
              this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
            );
          }
          setFromCoplanarPoints(t, e, n) {
            const i = tr
              .subVectors(n, e)
              .cross(er.subVectors(t, e))
              .normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this;
          }
          copy(t) {
            return (
              this.normal.copy(t.normal), (this.constant = t.constant), this
            );
          }
          normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
          }
          projectPoint(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  'THREE.Plane: .projectPoint() target is now required',
                ),
                (e = new Zn())),
              e
                .copy(this.normal)
                .multiplyScalar(-this.distanceToPoint(t))
                .add(t)
            );
          }
          intersectLine(t, e) {
            void 0 === e &&
              (console.warn(
                'THREE.Plane: .intersectLine() target is now required',
              ),
              (e = new Zn()));
            const n = t.delta(tr),
              i = this.normal.dot(n);
            if (0 === i)
              return 0 === this.distanceToPoint(t.start)
                ? e.copy(t.start)
                : null;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1
              ? null
              : e.copy(n).multiplyScalar(r).add(t.start);
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          }
          intersectsBox(t) {
            return t.intersectsPlane(this);
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this);
          }
          coplanarPoint(t) {
            return (
              void 0 === t &&
                (console.warn(
                  'THREE.Plane: .coplanarPoint() target is now required',
                ),
                (t = new Zn())),
              t.copy(this.normal).multiplyScalar(-this.constant)
            );
          }
          applyMatrix4(t, e) {
            const n = e || nr.getNormalMatrix(t),
              i = this.coplanarPoint(tr).applyMatrix4(t),
              r = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -i.dot(r)), this;
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this;
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        ir.prototype.isPlane = !0;
        const rr = new Zn(),
          ar = new Zn(),
          or = new Zn(),
          sr = new Zn(),
          lr = new Zn(),
          cr = new Zn(),
          ur = new Zn(),
          hr = new Zn(),
          dr = new Zn(),
          pr = new Zn();
        class fr {
          constructor(t = new Zn(), e = new Zn(), n = new Zn()) {
            (this.a = t), (this.b = e), (this.c = n);
          }
          static getNormal(t, e, n, i) {
            void 0 === i &&
              (console.warn(
                'THREE.Triangle: .getNormal() target is now required',
              ),
              (i = new Zn())),
              i.subVectors(n, e),
              rr.subVectors(t, e),
              i.cross(rr);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
          }
          static getBarycoord(t, e, n, i, r) {
            rr.subVectors(i, e), ar.subVectors(n, e), or.subVectors(t, e);
            const a = rr.dot(rr),
              o = rr.dot(ar),
              s = rr.dot(or),
              l = ar.dot(ar),
              c = ar.dot(or),
              u = a * l - o * o;
            if (
              (void 0 === r &&
                (console.warn(
                  'THREE.Triangle: .getBarycoord() target is now required',
                ),
                (r = new Zn())),
              0 === u)
            )
              return r.set(-2, -1, -1);
            const h = 1 / u,
              d = (l * s - o * c) * h,
              p = (a * c - o * s) * h;
            return r.set(1 - d - p, p, d);
          }
          static containsPoint(t, e, n, i) {
            return (
              this.getBarycoord(t, e, n, i, sr),
              sr.x >= 0 && sr.y >= 0 && sr.x + sr.y <= 1
            );
          }
          static getUV(t, e, n, i, r, a, o, s) {
            return (
              this.getBarycoord(t, e, n, i, sr),
              s.set(0, 0),
              s.addScaledVector(r, sr.x),
              s.addScaledVector(a, sr.y),
              s.addScaledVector(o, sr.z),
              s
            );
          }
          static isFrontFacing(t, e, n, i) {
            return (
              rr.subVectors(n, e), ar.subVectors(t, e), rr.cross(ar).dot(i) < 0
            );
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          }
          setFromPointsAndIndices(t, e, n, i) {
            return (
              this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          }
          getArea() {
            return (
              rr.subVectors(this.c, this.b),
              ar.subVectors(this.a, this.b),
              0.5 * rr.cross(ar).length()
            );
          }
          getMidpoint(t) {
            return (
              void 0 === t &&
                (console.warn(
                  'THREE.Triangle: .getMidpoint() target is now required',
                ),
                (t = new Zn())),
              t
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3)
            );
          }
          getNormal(t) {
            return fr.getNormal(this.a, this.b, this.c, t);
          }
          getPlane(t) {
            return (
              void 0 === t &&
                (console.warn(
                  'THREE.Triangle: .getPlane() target is now required',
                ),
                (t = new ir())),
              t.setFromCoplanarPoints(this.a, this.b, this.c)
            );
          }
          getBarycoord(t, e) {
            return fr.getBarycoord(t, this.a, this.b, this.c, e);
          }
          getUV(t, e, n, i, r) {
            return fr.getUV(t, this.a, this.b, this.c, e, n, i, r);
          }
          containsPoint(t) {
            return fr.containsPoint(t, this.a, this.b, this.c);
          }
          isFrontFacing(t) {
            return fr.isFrontFacing(this.a, this.b, this.c, t);
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this);
          }
          closestPointToPoint(t, e) {
            void 0 === e &&
              (console.warn(
                'THREE.Triangle: .closestPointToPoint() target is now required',
              ),
              (e = new Zn()));
            const n = this.a,
              i = this.b,
              r = this.c;
            let a, o;
            lr.subVectors(i, n), cr.subVectors(r, n), hr.subVectors(t, n);
            const s = lr.dot(hr),
              l = cr.dot(hr);
            if (s <= 0 && l <= 0) return e.copy(n);
            dr.subVectors(t, i);
            const c = lr.dot(dr),
              u = cr.dot(dr);
            if (c >= 0 && u <= c) return e.copy(i);
            const h = s * u - c * l;
            if (h <= 0 && s >= 0 && c <= 0)
              return (a = s / (s - c)), e.copy(n).addScaledVector(lr, a);
            pr.subVectors(t, r);
            const d = lr.dot(pr),
              p = cr.dot(pr);
            if (p >= 0 && d <= p) return e.copy(r);
            const f = d * l - s * p;
            if (f <= 0 && l >= 0 && p <= 0)
              return (o = l / (l - p)), e.copy(n).addScaledVector(cr, o);
            const m = c * p - d * u;
            if (m <= 0 && u - c >= 0 && d - p >= 0)
              return (
                ur.subVectors(r, i),
                (o = (u - c) / (u - c + (d - p))),
                e.copy(i).addScaledVector(ur, o)
              );
            const g = 1 / (m + f + h);
            return (
              (a = f * g),
              (o = h * g),
              e.copy(n).addScaledVector(lr, a).addScaledVector(cr, o)
            );
          }
          equals(t) {
            return (
              t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            );
          }
        }
        let mr = 0;
        function gr() {
          Object.defineProperty(this, 'id', { value: mr++ }),
            (this.uuid = Fn.generateUUID()),
            (this.name = ''),
            (this.type = 'Material'),
            (this.fog = !0),
            (this.blending = b),
            (this.side = f),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = I),
            (this.blendDst = D),
            (this.blendEquation = S),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = H),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = qn),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = un),
            (this.stencilZFail = un),
            (this.stencilZPass = un),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0);
        }
        (gr.prototype = Object.assign(Object.create(On.prototype), {
          constructor: gr,
          isMaterial: !0,
          onBeforeCompile: function () {},
          customProgramCacheKey: function () {
            return this.onBeforeCompile.toString();
          },
          setValues: function (t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                  console.warn(
                    "THREE.Material: '" + e + "' parameter is undefined.",
                  );
                  continue;
                }
                if ('shading' === e) {
                  console.warn(
                    'THREE.' +
                      this.type +
                      ': .shading has been removed. Use the boolean .flatShading instead.',
                  ),
                    (this.flatShading = n === y);
                  continue;
                }
                const i = this[e];
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = n)
                  : console.warn(
                      'THREE.' +
                        this.type +
                        ": '" +
                        e +
                        "' is not a property of this material.",
                    );
              }
          },
          toJSON: function (t) {
            const e = void 0 === t || 'string' == typeof t;
            e && (t = { textures: {}, images: {} });
            const n = {
              metadata: {
                version: 4.5,
                type: 'Material',
                generator: 'Material.toJSON',
              },
            };
            function i(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              '' !== this.name && (n.name = this.name),
              this.color &&
                this.color.isColor &&
                (n.color = this.color.getHex()),
              void 0 !== this.roughness && (n.roughness = this.roughness),
              void 0 !== this.metalness && (n.metalness = this.metalness),
              this.sheen &&
                this.sheen.isColor &&
                (n.sheen = this.sheen.getHex()),
              this.emissive &&
                this.emissive.isColor &&
                (n.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (n.emissiveIntensity = this.emissiveIntensity),
              this.specular &&
                this.specular.isColor &&
                (n.specular = this.specular.getHex()),
              void 0 !== this.shininess && (n.shininess = this.shininess),
              void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap =
                  this.clearcoatRoughnessMap.toJSON(t).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap =
                  this.clearcoatNormalMap.toJSON(t).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              this.map &&
                this.map.isTexture &&
                (n.map = this.map.toJSON(t).uuid),
              this.matcap &&
                this.matcap.isTexture &&
                (n.matcap = this.matcap.toJSON(t).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                (n.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid),
                (n.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                (n.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(t).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                (n.reflectivity = this.reflectivity),
                (n.refractionRatio = this.refractionRatio),
                void 0 !== this.combine && (n.combine = this.combine),
                void 0 !== this.envMapIntensity &&
                  (n.envMapIntensity = this.envMapIntensity)),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(t).uuid),
              void 0 !== this.size && (n.size = this.size),
              null !== this.shadowSide && (n.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation &&
                (n.sizeAttenuation = this.sizeAttenuation),
              this.blending !== b && (n.blending = this.blending),
              this.side !== f && (n.side = this.side),
              this.vertexColors && (n.vertexColors = !0),
              this.opacity < 1 && (n.opacity = this.opacity),
              !0 === this.transparent && (n.transparent = this.transparent),
              (n.depthFunc = this.depthFunc),
              (n.depthTest = this.depthTest),
              (n.depthWrite = this.depthWrite),
              (n.colorWrite = this.colorWrite),
              (n.stencilWrite = this.stencilWrite),
              (n.stencilWriteMask = this.stencilWriteMask),
              (n.stencilFunc = this.stencilFunc),
              (n.stencilRef = this.stencilRef),
              (n.stencilFuncMask = this.stencilFuncMask),
              (n.stencilFail = this.stencilFail),
              (n.stencilZFail = this.stencilZFail),
              (n.stencilZPass = this.stencilZPass),
              this.rotation &&
                0 !== this.rotation &&
                (n.rotation = this.rotation),
              !0 === this.polygonOffset && (n.polygonOffset = !0),
              0 !== this.polygonOffsetFactor &&
                (n.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits &&
                (n.polygonOffsetUnits = this.polygonOffsetUnits),
              this.linewidth &&
                1 !== this.linewidth &&
                (n.linewidth = this.linewidth),
              void 0 !== this.dashSize && (n.dashSize = this.dashSize),
              void 0 !== this.gapSize && (n.gapSize = this.gapSize),
              void 0 !== this.scale && (n.scale = this.scale),
              !0 === this.dithering && (n.dithering = !0),
              this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
              !0 === this.alphaToCoverage &&
                (n.alphaToCoverage = this.alphaToCoverage),
              !0 === this.premultipliedAlpha &&
                (n.premultipliedAlpha = this.premultipliedAlpha),
              !0 === this.wireframe && (n.wireframe = this.wireframe),
              this.wireframeLinewidth > 1 &&
                (n.wireframeLinewidth = this.wireframeLinewidth),
              'round' !== this.wireframeLinecap &&
                (n.wireframeLinecap = this.wireframeLinecap),
              'round' !== this.wireframeLinejoin &&
                (n.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.morphTargets && (n.morphTargets = !0),
              !0 === this.morphNormals && (n.morphNormals = !0),
              !0 === this.skinning && (n.skinning = !0),
              !0 === this.flatShading && (n.flatShading = this.flatShading),
              !1 === this.visible && (n.visible = !1),
              !1 === this.toneMapped && (n.toneMapped = !1),
              '{}' !== JSON.stringify(this.userData) &&
                (n.userData = this.userData),
              e)
            ) {
              const e = i(t.textures),
                r = i(t.images);
              e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
            }
            return n;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            (this.name = t.name),
              (this.fog = t.fog),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite);
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
              const t = e.length;
              n = new Array(t);
              for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' });
          },
        })),
          Object.defineProperty(gr.prototype, 'needsUpdate', {
            set: function (t) {
              !0 === t && this.version++;
            },
          });
        const yr = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074,
          },
          vr = { h: 0, s: 0, l: 0 },
          xr = { h: 0, s: 0, l: 0 };
        function br(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
              ? e
              : n < 2 / 3
              ? t + 6 * (e - t) * (2 / 3 - n)
              : t
          );
        }
        function _r(t) {
          return t < 0.04045
            ? 0.0773993808 * t
            : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
        }
        function wr(t) {
          return t < 0.0031308
            ? 12.92 * t
            : 1.055 * Math.pow(t, 0.41666) - 0.055;
        }
        class Mr {
          constructor(t, e, n) {
            return void 0 === e && void 0 === n
              ? this.set(t)
              : this.setRGB(t, e, n);
          }
          set(t) {
            return (
              t && t.isColor
                ? this.copy(t)
                : 'number' == typeof t
                ? this.setHex(t)
                : 'string' == typeof t && this.setStyle(t),
              this
            );
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this;
          }
          setHex(t) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              this
            );
          }
          setRGB(t, e, n) {
            return (this.r = t), (this.g = e), (this.b = n), this;
          }
          setHSL(t, e, n) {
            if (
              ((t = Fn.euclideanModulo(t, 1)),
              (e = Fn.clamp(e, 0, 1)),
              (n = Fn.clamp(n, 0, 1)),
              0 === e)
            )
              this.r = this.g = this.b = n;
            else {
              const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                r = 2 * n - i;
              (this.r = br(r, i, t + 1 / 3)),
                (this.g = br(r, i, t)),
                (this.b = br(r, i, t - 1 / 3));
            }
            return this;
          }
          setStyle(t) {
            function e(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn(
                  'THREE.Color: Alpha component of ' + t + ' will be ignored.',
                );
            }
            let n;
            if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
              let t;
              const i = n[1],
                r = n[2];
              switch (i) {
                case 'rgb':
                case 'rgba':
                  if (
                    (t =
                      /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        r,
                      ))
                  )
                    return (
                      (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                      (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                      (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                      e(t[4]),
                      this
                    );
                  if (
                    (t =
                      /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        r,
                      ))
                  )
                    return (
                      (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                      (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                      (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                      e(t[4]),
                      this
                    );
                  break;
                case 'hsl':
                case 'hsla':
                  if (
                    (t =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        r,
                      ))
                  ) {
                    const n = parseFloat(t[1]) / 360,
                      i = parseInt(t[2], 10) / 100,
                      r = parseInt(t[3], 10) / 100;
                    return e(t[4]), this.setHSL(n, i, r);
                  }
              }
            } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const t = n[1],
                e = t.length;
              if (3 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                  (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                  (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                  this
                );
              if (6 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                  (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                  (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                  this
                );
            }
            return t && t.length > 0 ? this.setColorName(t) : this;
          }
          setColorName(t) {
            const e = yr[t];
            return (
              void 0 !== e
                ? this.setHex(e)
                : console.warn('THREE.Color: Unknown color ' + t),
              this
            );
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b);
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
          }
          copyGammaToLinear(t, e = 2) {
            return (
              (this.r = Math.pow(t.r, e)),
              (this.g = Math.pow(t.g, e)),
              (this.b = Math.pow(t.b, e)),
              this
            );
          }
          copyLinearToGamma(t, e = 2) {
            const n = e > 0 ? 1 / e : 1;
            return (
              (this.r = Math.pow(t.r, n)),
              (this.g = Math.pow(t.g, n)),
              (this.b = Math.pow(t.b, n)),
              this
            );
          }
          convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t), this;
          }
          convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t), this;
          }
          copySRGBToLinear(t) {
            return (
              (this.r = _r(t.r)), (this.g = _r(t.g)), (this.b = _r(t.b)), this
            );
          }
          copyLinearToSRGB(t) {
            return (
              (this.r = wr(t.r)), (this.g = wr(t.g)), (this.b = wr(t.b)), this
            );
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
          }
          getHex() {
            return (
              ((255 * this.r) << 16) ^
              ((255 * this.g) << 8) ^
              ((255 * this.b) << 0)
            );
          }
          getHexString() {
            return ('000000' + this.getHex().toString(16)).slice(-6);
          }
          getHSL(t) {
            void 0 === t &&
              (console.warn('THREE.Color: .getHSL() target is now required'),
              (t = { h: 0, s: 0, l: 0 }));
            const e = this.r,
              n = this.g,
              i = this.b,
              r = Math.max(e, n, i),
              a = Math.min(e, n, i);
            let o, s;
            const l = (a + r) / 2;
            if (a === r) (o = 0), (s = 0);
            else {
              const t = r - a;
              switch (((s = l <= 0.5 ? t / (r + a) : t / (2 - r - a)), r)) {
                case e:
                  o = (n - i) / t + (n < i ? 6 : 0);
                  break;
                case n:
                  o = (i - e) / t + 2;
                  break;
                case i:
                  o = (e - n) / t + 4;
              }
              o /= 6;
            }
            return (t.h = o), (t.s = s), (t.l = l), t;
          }
          getStyle() {
            return (
              'rgb(' +
              ((255 * this.r) | 0) +
              ',' +
              ((255 * this.g) | 0) +
              ',' +
              ((255 * this.b) | 0) +
              ')'
            );
          }
          offsetHSL(t, e, n) {
            return (
              this.getHSL(vr),
              (vr.h += t),
              (vr.s += e),
              (vr.l += n),
              this.setHSL(vr.h, vr.s, vr.l),
              this
            );
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
          }
          addColors(t, e) {
            return (
              (this.r = t.r + e.r),
              (this.g = t.g + e.g),
              (this.b = t.b + e.b),
              this
            );
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this;
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            );
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this;
          }
          lerp(t, e) {
            return (
              (this.r += (t.r - this.r) * e),
              (this.g += (t.g - this.g) * e),
              (this.b += (t.b - this.b) * e),
              this
            );
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n),
              (this.g = t.g + (e.g - t.g) * n),
              (this.b = t.b + (e.b - t.b) * n),
              this
            );
          }
          lerpHSL(t, e) {
            this.getHSL(vr), t.getHSL(xr);
            const n = Fn.lerp(vr.h, xr.h, e),
              i = Fn.lerp(vr.s, xr.s, e),
              r = Fn.lerp(vr.l, xr.l, e);
            return this.setHSL(n, i, r), this;
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
          }
          fromArray(t, e = 0) {
            return (
              (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
          }
          fromBufferAttribute(t, e) {
            return (
              (this.r = t.getX(e)),
              (this.g = t.getY(e)),
              (this.b = t.getZ(e)),
              !0 === t.normalized &&
                ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
              this
            );
          }
          toJSON() {
            return this.getHex();
          }
        }
        (Mr.NAMES = yr),
          (Mr.prototype.isColor = !0),
          (Mr.prototype.r = 1),
          (Mr.prototype.g = 1),
          (Mr.prototype.b = 1);
        class qr extends gr {
          constructor(t) {
            super(),
              (this.type = 'MeshBasicMaterial'),
              (this.color = new Mr(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = $),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        qr.prototype.isMeshBasicMaterial = !0;
        const Sr = new Zn(),
          Tr = new Bn();
        function Er(t, e, n) {
          if (Array.isArray(t))
            throw new TypeError(
              'THREE.BufferAttribute: array should be a Typed Array.',
            );
          (this.name = ''),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = !0 === n),
            (this.usage = Sn),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0);
        }
        function Ar(t, e, n) {
          Er.call(this, new Int8Array(t), e, n);
        }
        function Lr(t, e, n) {
          Er.call(this, new Uint8Array(t), e, n);
        }
        function Rr(t, e, n) {
          Er.call(this, new Uint8ClampedArray(t), e, n);
        }
        function Cr(t, e, n) {
          Er.call(this, new Int16Array(t), e, n);
        }
        function Pr(t, e, n) {
          Er.call(this, new Uint16Array(t), e, n);
        }
        function kr(t, e, n) {
          Er.call(this, new Int32Array(t), e, n);
        }
        function Ir(t, e, n) {
          Er.call(this, new Uint32Array(t), e, n);
        }
        function Dr(t, e, n) {
          Er.call(this, new Uint16Array(t), e, n);
        }
        function Or(t, e, n) {
          Er.call(this, new Float32Array(t), e, n);
        }
        function Nr(t, e, n) {
          Er.call(this, new Float64Array(t), e, n);
        }
        function zr(t) {
          if (0 === t.length) return -1 / 0;
          let e = t[0];
          for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
          return e;
        }
        Object.defineProperty(Er.prototype, 'needsUpdate', {
          set: function (t) {
            !0 === t && this.version++;
          },
        }),
          Object.assign(Er.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function () {},
            setUsage: function (t) {
              return (this.usage = t), this;
            },
            copy: function (t) {
              return (
                (this.name = t.name),
                (this.array = new t.array.constructor(t.array)),
                (this.itemSize = t.itemSize),
                (this.count = t.count),
                (this.normalized = t.normalized),
                (this.usage = t.usage),
                this
              );
            },
            copyAt: function (t, e, n) {
              (t *= this.itemSize), (n *= e.itemSize);
              for (let i = 0, r = this.itemSize; i < r; i++)
                this.array[t + i] = e.array[n + i];
              return this;
            },
            copyArray: function (t) {
              return this.array.set(t), this;
            },
            copyColorsArray: function (t) {
              const e = this.array;
              let n = 0;
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r &&
                  (console.warn(
                    'THREE.BufferAttribute.copyColorsArray(): color is undefined',
                    i,
                  ),
                  (r = new Mr())),
                  (e[n++] = r.r),
                  (e[n++] = r.g),
                  (e[n++] = r.b);
              }
              return this;
            },
            copyVector2sArray: function (t) {
              const e = this.array;
              let n = 0;
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r &&
                  (console.warn(
                    'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
                    i,
                  ),
                  (r = new Bn())),
                  (e[n++] = r.x),
                  (e[n++] = r.y);
              }
              return this;
            },
            copyVector3sArray: function (t) {
              const e = this.array;
              let n = 0;
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r &&
                  (console.warn(
                    'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
                    i,
                  ),
                  (r = new Zn())),
                  (e[n++] = r.x),
                  (e[n++] = r.y),
                  (e[n++] = r.z);
              }
              return this;
            },
            copyVector4sArray: function (t) {
              const e = this.array;
              let n = 0;
              for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r &&
                  (console.warn(
                    'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
                    i,
                  ),
                  (r = new Xn())),
                  (e[n++] = r.x),
                  (e[n++] = r.y),
                  (e[n++] = r.z),
                  (e[n++] = r.w);
              }
              return this;
            },
            applyMatrix3: function (t) {
              if (2 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                  Tr.fromBufferAttribute(this, e),
                    Tr.applyMatrix3(t),
                    this.setXY(e, Tr.x, Tr.y);
              else if (3 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                  Sr.fromBufferAttribute(this, e),
                    Sr.applyMatrix3(t),
                    this.setXYZ(e, Sr.x, Sr.y, Sr.z);
              return this;
            },
            applyMatrix4: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Sr.x = this.getX(e)),
                  (Sr.y = this.getY(e)),
                  (Sr.z = this.getZ(e)),
                  Sr.applyMatrix4(t),
                  this.setXYZ(e, Sr.x, Sr.y, Sr.z);
              return this;
            },
            applyNormalMatrix: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Sr.x = this.getX(e)),
                  (Sr.y = this.getY(e)),
                  (Sr.z = this.getZ(e)),
                  Sr.applyNormalMatrix(t),
                  this.setXYZ(e, Sr.x, Sr.y, Sr.z);
              return this;
            },
            transformDirection: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Sr.x = this.getX(e)),
                  (Sr.y = this.getY(e)),
                  (Sr.z = this.getZ(e)),
                  Sr.transformDirection(t),
                  this.setXYZ(e, Sr.x, Sr.y, Sr.z);
              return this;
            },
            set: function (t, e = 0) {
              return this.array.set(t, e), this;
            },
            getX: function (t) {
              return this.array[t * this.itemSize];
            },
            setX: function (t, e) {
              return (this.array[t * this.itemSize] = e), this;
            },
            getY: function (t) {
              return this.array[t * this.itemSize + 1];
            },
            setY: function (t, e) {
              return (this.array[t * this.itemSize + 1] = e), this;
            },
            getZ: function (t) {
              return this.array[t * this.itemSize + 2];
            },
            setZ: function (t, e) {
              return (this.array[t * this.itemSize + 2] = e), this;
            },
            getW: function (t) {
              return this.array[t * this.itemSize + 3];
            },
            setW: function (t, e) {
              return (this.array[t * this.itemSize + 3] = e), this;
            },
            setXY: function (t, e, n) {
              return (
                (t *= this.itemSize),
                (this.array[t + 0] = e),
                (this.array[t + 1] = n),
                this
              );
            },
            setXYZ: function (t, e, n, i) {
              return (
                (t *= this.itemSize),
                (this.array[t + 0] = e),
                (this.array[t + 1] = n),
                (this.array[t + 2] = i),
                this
              );
            },
            setXYZW: function (t, e, n, i, r) {
              return (
                (t *= this.itemSize),
                (this.array[t + 0] = e),
                (this.array[t + 1] = n),
                (this.array[t + 2] = i),
                (this.array[t + 3] = r),
                this
              );
            },
            onUpload: function (t) {
              return (this.onUploadCallback = t), this;
            },
            clone: function () {
              return new this.constructor(this.array, this.itemSize).copy(this);
            },
            toJSON: function () {
              const t = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized,
              };
              return (
                '' !== this.name && (t.name = this.name),
                this.usage !== Sn && (t.usage = this.usage),
                (0 === this.updateRange.offset &&
                  -1 === this.updateRange.count) ||
                  (t.updateRange = this.updateRange),
                t
              );
            },
          }),
          (Ar.prototype = Object.create(Er.prototype)),
          (Ar.prototype.constructor = Ar),
          (Lr.prototype = Object.create(Er.prototype)),
          (Lr.prototype.constructor = Lr),
          (Rr.prototype = Object.create(Er.prototype)),
          (Rr.prototype.constructor = Rr),
          (Cr.prototype = Object.create(Er.prototype)),
          (Cr.prototype.constructor = Cr),
          (Pr.prototype = Object.create(Er.prototype)),
          (Pr.prototype.constructor = Pr),
          (kr.prototype = Object.create(Er.prototype)),
          (kr.prototype.constructor = kr),
          (Ir.prototype = Object.create(Er.prototype)),
          (Ir.prototype.constructor = Ir),
          (Dr.prototype = Object.create(Er.prototype)),
          (Dr.prototype.constructor = Dr),
          (Dr.prototype.isFloat16BufferAttribute = !0),
          (Or.prototype = Object.create(Er.prototype)),
          (Or.prototype.constructor = Or),
          (Nr.prototype = Object.create(Er.prototype)),
          (Nr.prototype.constructor = Nr);
        const Fr = {
          Int8Array: Int8Array,
          Uint8Array: Uint8Array,
          Uint8ClampedArray: Uint8ClampedArray,
          Int16Array: Int16Array,
          Uint16Array: Uint16Array,
          Int32Array: Int32Array,
          Uint32Array: Uint32Array,
          Float32Array: Float32Array,
          Float64Array: Float64Array,
        };
        function Br(t, e) {
          return new Fr[t](e);
        }
        let Ur = 0;
        const jr = new Ai(),
          Gr = new Qi(),
          Hr = new Zn(),
          Vr = new ti(),
          Wr = new ti(),
          Xr = new Zn();
        function Yr() {
          Object.defineProperty(this, 'id', { value: Ur++ }),
            (this.uuid = Fn.generateUUID()),
            (this.name = ''),
            (this.type = 'BufferGeometry'),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        Yr.prototype = Object.assign(Object.create(On.prototype), {
          constructor: Yr,
          isBufferGeometry: !0,
          getIndex: function () {
            return this.index;
          },
          setIndex: function (t) {
            return (
              Array.isArray(t)
                ? (this.index = new (zr(t) > 65535 ? Ir : Pr)(t, 1))
                : (this.index = t),
              this
            );
          },
          getAttribute: function (t) {
            return this.attributes[t];
          },
          setAttribute: function (t, e) {
            return (this.attributes[t] = e), this;
          },
          deleteAttribute: function (t) {
            return delete this.attributes[t], this;
          },
          hasAttribute: function (t) {
            return void 0 !== this.attributes[t];
          },
          addGroup: function (t, e, n = 0) {
            this.groups.push({ start: t, count: e, materialIndex: n });
          },
          clearGroups: function () {
            this.groups = [];
          },
          setDrawRange: function (t, e) {
            (this.drawRange.start = t), (this.drawRange.count = e);
          },
          applyMatrix4: function (t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
            const n = this.attributes.normal;
            if (void 0 !== n) {
              const e = new Un().getNormalMatrix(t);
              n.applyNormalMatrix(e), (n.needsUpdate = !0);
            }
            const i = this.attributes.tangent;
            return (
              void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          },
          rotateX: function (t) {
            return jr.makeRotationX(t), this.applyMatrix4(jr), this;
          },
          rotateY: function (t) {
            return jr.makeRotationY(t), this.applyMatrix4(jr), this;
          },
          rotateZ: function (t) {
            return jr.makeRotationZ(t), this.applyMatrix4(jr), this;
          },
          translate: function (t, e, n) {
            return jr.makeTranslation(t, e, n), this.applyMatrix4(jr), this;
          },
          scale: function (t, e, n) {
            return jr.makeScale(t, e, n), this.applyMatrix4(jr), this;
          },
          lookAt: function (t) {
            return (
              Gr.lookAt(t),
              Gr.updateMatrix(),
              this.applyMatrix4(Gr.matrix),
              this
            );
          },
          center: function () {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(Hr).negate(),
              this.translate(Hr.x, Hr.y, Hr.z),
              this
            );
          },
          setFromPoints: function (t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n];
              e.push(i.x, i.y, i.z || 0);
            }
            return this.setAttribute('position', new Or(e, 3)), this;
          },
          computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new ti());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this,
                ),
                void this.boundingBox.set(
                  new Zn(-1 / 0, -1 / 0, -1 / 0),
                  new Zn(1 / 0, 1 / 0, 1 / 0),
                )
              );
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Vr.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Xr.addVectors(this.boundingBox.min, Vr.min),
                        this.boundingBox.expandByPoint(Xr),
                        Xr.addVectors(this.boundingBox.max, Vr.max),
                        this.boundingBox.expandByPoint(Xr))
                      : (this.boundingBox.expandByPoint(Vr.min),
                        this.boundingBox.expandByPoint(Vr.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this,
              );
          },
          computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new xi());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this,
                ),
                void this.boundingSphere.set(new Zn(), 1 / 0)
              );
            if (t) {
              const n = this.boundingSphere.center;
              if ((Vr.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Wr.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Xr.addVectors(Vr.min, Wr.min),
                        Vr.expandByPoint(Xr),
                        Xr.addVectors(Vr.max, Wr.max),
                        Vr.expandByPoint(Xr))
                      : (Vr.expandByPoint(Wr.min), Vr.expandByPoint(Wr.max));
                }
              Vr.getCenter(n);
              let i = 0;
              for (let e = 0, r = t.count; e < r; e++)
                Xr.fromBufferAttribute(t, e),
                  (i = Math.max(i, n.distanceToSquared(Xr)));
              if (e)
                for (let r = 0, a = e.length; r < a; r++) {
                  const a = e[r],
                    o = this.morphTargetsRelative;
                  for (let e = 0, r = a.count; e < r; e++)
                    Xr.fromBufferAttribute(a, e),
                      o && (Hr.fromBufferAttribute(t, e), Xr.add(Hr)),
                      (i = Math.max(i, n.distanceToSquared(Xr)));
                }
              (this.boundingSphere.radius = Math.sqrt(i)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this,
                  );
            }
          },
          computeFaceNormals: function () {},
          computeTangents: function () {
            const t = this.index,
              e = this.attributes;
            if (
              null === t ||
              void 0 === e.position ||
              void 0 === e.normal ||
              void 0 === e.uv
            )
              return void console.error(
                'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
              );
            const n = t.array,
              i = e.position.array,
              r = e.normal.array,
              a = e.uv.array,
              o = i.length / 3;
            void 0 === e.tangent &&
              this.setAttribute('tangent', new Er(new Float32Array(4 * o), 4));
            const s = e.tangent.array,
              l = [],
              c = [];
            for (let t = 0; t < o; t++) (l[t] = new Zn()), (c[t] = new Zn());
            const u = new Zn(),
              h = new Zn(),
              d = new Zn(),
              p = new Bn(),
              f = new Bn(),
              m = new Bn(),
              g = new Zn(),
              y = new Zn();
            function v(t, e, n) {
              u.fromArray(i, 3 * t),
                h.fromArray(i, 3 * e),
                d.fromArray(i, 3 * n),
                p.fromArray(a, 2 * t),
                f.fromArray(a, 2 * e),
                m.fromArray(a, 2 * n),
                h.sub(u),
                d.sub(u),
                f.sub(p),
                m.sub(p);
              const r = 1 / (f.x * m.y - m.x * f.y);
              isFinite(r) &&
                (g
                  .copy(h)
                  .multiplyScalar(m.y)
                  .addScaledVector(d, -f.y)
                  .multiplyScalar(r),
                y
                  .copy(d)
                  .multiplyScalar(f.x)
                  .addScaledVector(h, -m.x)
                  .multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[n].add(g),
                c[t].add(y),
                c[e].add(y),
                c[n].add(y));
            }
            let x = this.groups;
            0 === x.length && (x = [{ start: 0, count: n.length }]);
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3)
                v(n[t + 0], n[t + 1], n[t + 2]);
            }
            const b = new Zn(),
              _ = new Zn(),
              w = new Zn(),
              M = new Zn();
            function q(t) {
              w.fromArray(r, 3 * t), M.copy(w);
              const e = l[t];
              b.copy(e),
                b.sub(w.multiplyScalar(w.dot(e))).normalize(),
                _.crossVectors(M, e);
              const n = _.dot(c[t]) < 0 ? -1 : 1;
              (s[4 * t] = b.x),
                (s[4 * t + 1] = b.y),
                (s[4 * t + 2] = b.z),
                (s[4 * t + 3] = n);
            }
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3)
                q(n[t + 0]), q(n[t + 1]), q(n[t + 2]);
            }
          },
          computeVertexNormals: function () {
            const t = this.index,
              e = this.getAttribute('position');
            if (void 0 !== e) {
              let n = this.getAttribute('normal');
              if (void 0 === n)
                (n = new Er(new Float32Array(3 * e.count), 3)),
                  this.setAttribute('normal', n);
              else
                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
              const i = new Zn(),
                r = new Zn(),
                a = new Zn(),
                o = new Zn(),
                s = new Zn(),
                l = new Zn(),
                c = new Zn(),
                u = new Zn();
              if (t)
                for (let h = 0, d = t.count; h < d; h += 3) {
                  const d = t.getX(h + 0),
                    p = t.getX(h + 1),
                    f = t.getX(h + 2);
                  i.fromBufferAttribute(e, d),
                    r.fromBufferAttribute(e, p),
                    a.fromBufferAttribute(e, f),
                    c.subVectors(a, r),
                    u.subVectors(i, r),
                    c.cross(u),
                    o.fromBufferAttribute(n, d),
                    s.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, f),
                    o.add(c),
                    s.add(c),
                    l.add(c),
                    n.setXYZ(d, o.x, o.y, o.z),
                    n.setXYZ(p, s.x, s.y, s.z),
                    n.setXYZ(f, l.x, l.y, l.z);
                }
              else
                for (let t = 0, o = e.count; t < o; t += 3)
                  i.fromBufferAttribute(e, t + 0),
                    r.fromBufferAttribute(e, t + 1),
                    a.fromBufferAttribute(e, t + 2),
                    c.subVectors(a, r),
                    u.subVectors(i, r),
                    c.cross(u),
                    n.setXYZ(t + 0, c.x, c.y, c.z),
                    n.setXYZ(t + 1, c.x, c.y, c.z),
                    n.setXYZ(t + 2, c.x, c.y, c.z);
              this.normalizeNormals(), (n.needsUpdate = !0);
            }
          },
          merge: function (t, e) {
            if (!t || !t.isBufferGeometry)
              return void console.error(
                'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
                t,
              );
            void 0 === e &&
              ((e = 0),
              console.warn(
                'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
              ));
            const n = this.attributes;
            for (const i in n) {
              if (void 0 === t.attributes[i]) continue;
              const r = n[i].array,
                a = t.attributes[i],
                o = a.array,
                s = a.itemSize * e,
                l = Math.min(o.length, r.length - s);
              for (let t = 0, e = s; t < l; t++, e++) r[e] = o[t];
            }
            return this;
          },
          normalizeNormals: function () {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
              Xr.fromBufferAttribute(t, e),
                Xr.normalize(),
                t.setXYZ(e, Xr.x, Xr.y, Xr.z);
          },
          toNonIndexed: function () {
            function t(t, e) {
              const n = t.array,
                i = t.itemSize,
                r = t.normalized,
                a = new n.constructor(e.length * i);
              let o = 0,
                s = 0;
              for (let t = 0, r = e.length; t < r; t++) {
                o = e[t] * i;
                for (let t = 0; t < i; t++) a[s++] = n[o++];
              }
              return new Er(a, i, r);
            }
            if (null === this.index)
              return (
                console.warn(
                  'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.',
                ),
                this
              );
            const e = new Yr(),
              n = this.index.array,
              i = this.attributes;
            for (const r in i) {
              const a = t(i[r], n);
              e.setAttribute(r, a);
            }
            const r = this.morphAttributes;
            for (const i in r) {
              const a = [],
                o = r[i];
              for (let e = 0, i = o.length; e < i; e++) {
                const i = t(o[e], n);
                a.push(i);
              }
              e.morphAttributes[i] = a;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const a = this.groups;
            for (let t = 0, n = a.length; t < n; t++) {
              const n = a[t];
              e.addGroup(n.start, n.count, n.materialIndex);
            }
            return e;
          },
          toJSON: function () {
            const t = {
              metadata: {
                version: 4.5,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON',
              },
            };
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              '' !== this.name && (t.name = this.name),
              Object.keys(this.userData).length > 0 &&
                (t.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters;
              for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
              return t;
            }
            t.data = { attributes: {} };
            const e = this.index;
            null !== e &&
              (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array),
              });
            const n = this.attributes;
            for (const e in n) {
              const i = n[e];
              t.data.attributes[e] = i.toJSON(t.data);
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
              const n = this.morphAttributes[e],
                a = [];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                a.push(i.toJSON(t.data));
              }
              a.length > 0 && ((i[e] = a), (r = !0));
            }
            r &&
              ((t.data.morphAttributes = i),
              (t.data.morphTargetsRelative = this.morphTargetsRelative));
            const a = this.groups;
            a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
            const o = this.boundingSphere;
            return (
              null !== o &&
                (t.data.boundingSphere = {
                  center: o.center.toArray(),
                  radius: o.radius,
                }),
              t
            );
          },
          clone: function () {
            return new Yr().copy(this);
          },
          copy: function (t) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
              const n = i[t];
              this.setAttribute(t, n.clone(e));
            }
            const r = t.morphAttributes;
            for (const t in r) {
              const n = [],
                i = r[t];
              for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
              this.morphAttributes[t] = n;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const a = t.groups;
            for (let t = 0, e = a.length; t < e; t++) {
              const e = a[t];
              this.addGroup(e.start, e.count, e.materialIndex);
            }
            const o = t.boundingBox;
            null !== o && (this.boundingBox = o.clone());
            const s = t.boundingSphere;
            return (
              null !== s && (this.boundingSphere = s.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              this
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' });
          },
        });
        const $r = new Ai(),
          Jr = new Ei(),
          Zr = new xi(),
          Kr = new Zn(),
          Qr = new Zn(),
          ta = new Zn(),
          ea = new Zn(),
          na = new Zn(),
          ia = new Zn(),
          ra = new Zn(),
          aa = new Zn(),
          oa = new Zn(),
          sa = new Bn(),
          la = new Bn(),
          ca = new Bn(),
          ua = new Zn(),
          ha = new Zn();
        function da(t = new Yr(), e = new qr()) {
          Qi.call(this),
            (this.type = 'Mesh'),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        function pa(t, e, n, i, r, a, o, s, l, c, u, h) {
          Kr.fromBufferAttribute(r, c),
            Qr.fromBufferAttribute(r, u),
            ta.fromBufferAttribute(r, h);
          const d = t.morphTargetInfluences;
          if (e.morphTargets && a && d) {
            ra.set(0, 0, 0), aa.set(0, 0, 0), oa.set(0, 0, 0);
            for (let t = 0, e = a.length; t < e; t++) {
              const e = d[t],
                n = a[t];
              0 !== e &&
                (ea.fromBufferAttribute(n, c),
                na.fromBufferAttribute(n, u),
                ia.fromBufferAttribute(n, h),
                o
                  ? (ra.addScaledVector(ea, e),
                    aa.addScaledVector(na, e),
                    oa.addScaledVector(ia, e))
                  : (ra.addScaledVector(ea.sub(Kr), e),
                    aa.addScaledVector(na.sub(Qr), e),
                    oa.addScaledVector(ia.sub(ta), e)));
            }
            Kr.add(ra), Qr.add(aa), ta.add(oa);
          }
          t.isSkinnedMesh &&
            e.skinning &&
            (t.boneTransform(c, Kr),
            t.boneTransform(u, Qr),
            t.boneTransform(h, ta));
          const p = (function (t, e, n, i, r, a, o, s) {
            let l;
            if (
              ((l =
                e.side === m
                  ? i.intersectTriangle(o, a, r, !0, s)
                  : i.intersectTriangle(r, a, o, e.side !== g, s)),
              null === l)
            )
              return null;
            ha.copy(s), ha.applyMatrix4(t.matrixWorld);
            const c = n.ray.origin.distanceTo(ha);
            return c < n.near || c > n.far
              ? null
              : { distance: c, point: ha.clone(), object: t };
          })(t, e, n, i, Kr, Qr, ta, ua);
          if (p) {
            s &&
              (sa.fromBufferAttribute(s, c),
              la.fromBufferAttribute(s, u),
              ca.fromBufferAttribute(s, h),
              (p.uv = fr.getUV(ua, Kr, Qr, ta, sa, la, ca, new Bn()))),
              l &&
                (sa.fromBufferAttribute(l, c),
                la.fromBufferAttribute(l, u),
                ca.fromBufferAttribute(l, h),
                (p.uv2 = fr.getUV(ua, Kr, Qr, ta, sa, la, ca, new Bn())));
            const t = { a: c, b: u, c: h, normal: new Zn(), materialIndex: 0 };
            fr.getNormal(Kr, Qr, ta, t.normal), (p.face = t);
          }
          return p;
        }
        da.prototype = Object.assign(Object.create(Qi.prototype), {
          constructor: da,
          isMesh: !0,
          copy: function (t) {
            return (
              Qi.prototype.copy.call(this, t),
              void 0 !== t.morphTargetInfluences &&
                (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign(
                  {},
                  t.morphTargetDictionary,
                )),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          },
          updateMorphTargets: function () {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
            }
          },
          raycast: function (t, e) {
            const n = this.geometry,
              i = this.material,
              r = this.matrixWorld;
            if (void 0 === i) return;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Zr.copy(n.boundingSphere),
              Zr.applyMatrix4(r),
              !1 === t.ray.intersectsSphere(Zr))
            )
              return;
            if (
              ($r.copy(r).invert(),
              Jr.copy(t.ray).applyMatrix4($r),
              null !== n.boundingBox && !1 === Jr.intersectsBox(n.boundingBox))
            )
              return;
            let a;
            if (n.isBufferGeometry) {
              const r = n.index,
                o = n.attributes.position,
                s = n.morphAttributes.position,
                l = n.morphTargetsRelative,
                c = n.attributes.uv,
                u = n.attributes.uv2,
                h = n.groups,
                d = n.drawRange;
              if (null !== r)
                if (Array.isArray(i))
                  for (let n = 0, p = h.length; n < p; n++) {
                    const p = h[n],
                      f = i[p.materialIndex];
                    for (
                      let n = Math.max(p.start, d.start),
                        i = Math.min(p.start + p.count, d.start + d.count);
                      n < i;
                      n += 3
                    ) {
                      const i = r.getX(n),
                        h = r.getX(n + 1),
                        d = r.getX(n + 2);
                      (a = pa(this, f, t, Jr, o, s, l, c, u, i, h, d)),
                        a &&
                          ((a.faceIndex = Math.floor(n / 3)),
                          (a.face.materialIndex = p.materialIndex),
                          e.push(a));
                    }
                  }
                else {
                  for (
                    let n = Math.max(0, d.start),
                      h = Math.min(r.count, d.start + d.count);
                    n < h;
                    n += 3
                  ) {
                    const h = r.getX(n),
                      d = r.getX(n + 1),
                      p = r.getX(n + 2);
                    (a = pa(this, i, t, Jr, o, s, l, c, u, h, d, p)),
                      a && ((a.faceIndex = Math.floor(n / 3)), e.push(a));
                  }
                }
              else if (void 0 !== o)
                if (Array.isArray(i))
                  for (let n = 0, r = h.length; n < r; n++) {
                    const r = h[n],
                      p = i[r.materialIndex];
                    for (
                      let n = Math.max(r.start, d.start),
                        i = Math.min(r.start + r.count, d.start + d.count);
                      n < i;
                      n += 3
                    ) {
                      (a = pa(this, p, t, Jr, o, s, l, c, u, n, n + 1, n + 2)),
                        a &&
                          ((a.faceIndex = Math.floor(n / 3)),
                          (a.face.materialIndex = r.materialIndex),
                          e.push(a));
                    }
                  }
                else {
                  for (
                    let n = Math.max(0, d.start),
                      r = Math.min(o.count, d.start + d.count);
                    n < r;
                    n += 3
                  ) {
                    (a = pa(this, i, t, Jr, o, s, l, c, u, n, n + 1, n + 2)),
                      a && ((a.faceIndex = Math.floor(n / 3)), e.push(a));
                  }
                }
            } else
              n.isGeometry &&
                console.error(
                  'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
          },
        });
        class fa extends Yr {
          constructor(t = 1, e = 1, n = 1, i = 1, r = 1, a = 1) {
            super(),
              (this.type = 'BoxGeometry'),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: a,
              });
            const o = this;
            (i = Math.floor(i)), (r = Math.floor(r)), (a = Math.floor(a));
            const s = [],
              l = [],
              c = [],
              u = [];
            let h = 0,
              d = 0;
            function p(t, e, n, i, r, a, p, f, m, g, y) {
              const v = a / m,
                x = p / g,
                b = a / 2,
                _ = p / 2,
                w = f / 2,
                M = m + 1,
                q = g + 1;
              let S = 0,
                T = 0;
              const E = new Zn();
              for (let a = 0; a < q; a++) {
                const o = a * x - _;
                for (let s = 0; s < M; s++) {
                  const h = s * v - b;
                  (E[t] = h * i),
                    (E[e] = o * r),
                    (E[n] = w),
                    l.push(E.x, E.y, E.z),
                    (E[t] = 0),
                    (E[e] = 0),
                    (E[n] = f > 0 ? 1 : -1),
                    c.push(E.x, E.y, E.z),
                    u.push(s / m),
                    u.push(1 - a / g),
                    (S += 1);
                }
              }
              for (let t = 0; t < g; t++)
                for (let e = 0; e < m; e++) {
                  const n = h + e + M * t,
                    i = h + e + M * (t + 1),
                    r = h + (e + 1) + M * (t + 1),
                    a = h + (e + 1) + M * t;
                  s.push(n, i, a), s.push(i, r, a), (T += 6);
                }
              o.addGroup(d, T, y), (d += T), (h += S);
            }
            p('z', 'y', 'x', -1, -1, n, e, t, a, r, 0),
              p('z', 'y', 'x', 1, -1, n, e, -t, a, r, 1),
              p('x', 'z', 'y', 1, 1, t, n, e, i, a, 2),
              p('x', 'z', 'y', 1, -1, t, n, -e, i, a, 3),
              p('x', 'y', 'z', 1, -1, t, e, n, i, r, 4),
              p('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5),
              this.setIndex(s),
              this.setAttribute('position', new Or(l, 3)),
              this.setAttribute('normal', new Or(c, 3)),
              this.setAttribute('uv', new Or(u, 2));
          }
        }
        function ma(t) {
          const e = {};
          for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
              const r = t[n][i];
              r &&
              (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? (e[n][i] = r.clone())
                : Array.isArray(r)
                ? (e[n][i] = r.slice())
                : (e[n][i] = r);
            }
          }
          return e;
        }
        function ga(t) {
          const e = {};
          for (let n = 0; n < t.length; n++) {
            const i = ma(t[n]);
            for (const t in i) e[t] = i[t];
          }
          return e;
        }
        const ya = { clone: ma, merge: ga };
        function va(t) {
          gr.call(this),
            (this.type = 'ShaderMaterial'),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.vertexShader =
              'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
            (this.fragmentShader =
              'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.skinning = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv2: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t &&
              (void 0 !== t.attributes &&
                console.error(
                  'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',
                ),
              this.setValues(t));
        }
        function xa() {
          Qi.call(this),
            (this.type = 'Camera'),
            (this.matrixWorldInverse = new Ai()),
            (this.projectionMatrix = new Ai()),
            (this.projectionMatrixInverse = new Ai());
        }
        function ba(t = 50, e = 1, n = 0.1, i = 2e3) {
          xa.call(this),
            (this.type = 'PerspectiveCamera'),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        (va.prototype = Object.create(gr.prototype)),
          (va.prototype.constructor = va),
          (va.prototype.isShaderMaterial = !0),
          (va.prototype.copy = function (t) {
            return (
              gr.prototype.copy.call(this, t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = ma(t.uniforms)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            );
          }),
          (va.prototype.toJSON = function (t) {
            const e = gr.prototype.toJSON.call(this, t);
            (e.glslVersion = this.glslVersion), (e.uniforms = {});
            for (const n in this.uniforms) {
              const i = this.uniforms[n].value;
              i && i.isTexture
                ? (e.uniforms[n] = { type: 't', value: i.toJSON(t).uuid })
                : i && i.isColor
                ? (e.uniforms[n] = { type: 'c', value: i.getHex() })
                : i && i.isVector2
                ? (e.uniforms[n] = { type: 'v2', value: i.toArray() })
                : i && i.isVector3
                ? (e.uniforms[n] = { type: 'v3', value: i.toArray() })
                : i && i.isVector4
                ? (e.uniforms[n] = { type: 'v4', value: i.toArray() })
                : i && i.isMatrix3
                ? (e.uniforms[n] = { type: 'm3', value: i.toArray() })
                : i && i.isMatrix4
                ? (e.uniforms[n] = { type: 'm4', value: i.toArray() })
                : (e.uniforms[n] = { value: i });
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader);
            const n = {};
            for (const t in this.extensions)
              !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
          }),
          (xa.prototype = Object.assign(Object.create(Qi.prototype), {
            constructor: xa,
            isCamera: !0,
            copy: function (t, e) {
              return (
                Qi.prototype.copy.call(this, t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this
              );
            },
            getWorldDirection: function (t) {
              void 0 === t &&
                (console.warn(
                  'THREE.Camera: .getWorldDirection() target is now required',
                ),
                (t = new Zn())),
                this.updateWorldMatrix(!0, !1);
              const e = this.matrixWorld.elements;
              return t.set(-e[8], -e[9], -e[10]).normalize();
            },
            updateMatrixWorld: function (t) {
              Qi.prototype.updateMatrixWorld.call(this, t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert();
            },
            updateWorldMatrix: function (t, e) {
              Qi.prototype.updateWorldMatrix.call(this, t, e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert();
            },
            clone: function () {
              return new this.constructor().copy(this);
            },
          })),
          (ba.prototype = Object.assign(Object.create(xa.prototype), {
            constructor: ba,
            isPerspectiveCamera: !0,
            copy: function (t, e) {
              return (
                xa.prototype.copy.call(this, t, e),
                (this.fov = t.fov),
                (this.zoom = t.zoom),
                (this.near = t.near),
                (this.far = t.far),
                (this.focus = t.focus),
                (this.aspect = t.aspect),
                (this.view =
                  null === t.view ? null : Object.assign({}, t.view)),
                (this.filmGauge = t.filmGauge),
                (this.filmOffset = t.filmOffset),
                this
              );
            },
            setFocalLength: function (t) {
              const e = (0.5 * this.getFilmHeight()) / t;
              (this.fov = 2 * Fn.RAD2DEG * Math.atan(e)),
                this.updateProjectionMatrix();
            },
            getFocalLength: function () {
              const t = Math.tan(0.5 * Fn.DEG2RAD * this.fov);
              return (0.5 * this.getFilmHeight()) / t;
            },
            getEffectiveFOV: function () {
              return (
                2 *
                Fn.RAD2DEG *
                Math.atan(Math.tan(0.5 * Fn.DEG2RAD * this.fov) / this.zoom)
              );
            },
            getFilmWidth: function () {
              return this.filmGauge * Math.min(this.aspect, 1);
            },
            getFilmHeight: function () {
              return this.filmGauge / Math.max(this.aspect, 1);
            },
            setViewOffset: function (t, e, n, i, r, a) {
              (this.aspect = t / e),
                null === this.view &&
                  (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1,
                  }),
                (this.view.enabled = !0),
                (this.view.fullWidth = t),
                (this.view.fullHeight = e),
                (this.view.offsetX = n),
                (this.view.offsetY = i),
                (this.view.width = r),
                (this.view.height = a),
                this.updateProjectionMatrix();
            },
            clearViewOffset: function () {
              null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix();
            },
            updateProjectionMatrix: function () {
              const t = this.near;
              let e = (t * Math.tan(0.5 * Fn.DEG2RAD * this.fov)) / this.zoom,
                n = 2 * e,
                i = this.aspect * n,
                r = -0.5 * i;
              const a = this.view;
              if (null !== this.view && this.view.enabled) {
                const t = a.fullWidth,
                  o = a.fullHeight;
                (r += (a.offsetX * i) / t),
                  (e -= (a.offsetY * n) / o),
                  (i *= a.width / t),
                  (n *= a.height / o);
              }
              const o = this.filmOffset;
              0 !== o && (r += (t * o) / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(
                  r,
                  r + i,
                  e,
                  e - n,
                  t,
                  this.far,
                ),
                this.projectionMatrixInverse
                  .copy(this.projectionMatrix)
                  .invert();
            },
            toJSON: function (t) {
              const e = Qi.prototype.toJSON.call(this, t);
              return (
                (e.object.fov = this.fov),
                (e.object.zoom = this.zoom),
                (e.object.near = this.near),
                (e.object.far = this.far),
                (e.object.focus = this.focus),
                (e.object.aspect = this.aspect),
                null !== this.view &&
                  (e.object.view = Object.assign({}, this.view)),
                (e.object.filmGauge = this.filmGauge),
                (e.object.filmOffset = this.filmOffset),
                e
              );
            },
          }));
        class _a extends Qi {
          constructor(t, e, n) {
            if (
              (super(),
              (this.type = 'CubeCamera'),
              !0 !== n.isWebGLCubeRenderTarget)
            )
              return void console.error(
                'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.',
              );
            this.renderTarget = n;
            const i = new ba(90, 1, t, e);
            (i.layers = this.layers),
              i.up.set(0, -1, 0),
              i.lookAt(new Zn(1, 0, 0)),
              this.add(i);
            const r = new ba(90, 1, t, e);
            (r.layers = this.layers),
              r.up.set(0, -1, 0),
              r.lookAt(new Zn(-1, 0, 0)),
              this.add(r);
            const a = new ba(90, 1, t, e);
            (a.layers = this.layers),
              a.up.set(0, 0, 1),
              a.lookAt(new Zn(0, 1, 0)),
              this.add(a);
            const o = new ba(90, 1, t, e);
            (o.layers = this.layers),
              o.up.set(0, 0, -1),
              o.lookAt(new Zn(0, -1, 0)),
              this.add(o);
            const s = new ba(90, 1, t, e);
            (s.layers = this.layers),
              s.up.set(0, -1, 0),
              s.lookAt(new Zn(0, 0, 1)),
              this.add(s);
            const l = new ba(90, 1, t, e);
            (l.layers = this.layers),
              l.up.set(0, -1, 0),
              l.lookAt(new Zn(0, 0, -1)),
              this.add(l);
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget,
              [i, r, a, o, s, l] = this.children,
              c = t.xr.enabled,
              u = t.getRenderTarget();
            t.xr.enabled = !1;
            const h = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0),
              t.render(e, i),
              t.setRenderTarget(n, 1),
              t.render(e, r),
              t.setRenderTarget(n, 2),
              t.render(e, a),
              t.setRenderTarget(n, 3),
              t.render(e, o),
              t.setRenderTarget(n, 4),
              t.render(e, s),
              (n.texture.generateMipmaps = h),
              t.setRenderTarget(n, 5),
              t.render(e, l),
              t.setRenderTarget(u),
              (t.xr.enabled = c);
          }
        }
        class wa extends Vn {
          constructor(t, e, n, i, r, a, o, s, l, c) {
            super(
              (t = void 0 !== t ? t : []),
              (e = void 0 !== e ? e : at),
              n,
              i,
              r,
              a,
              (o = void 0 !== o ? o : Nt),
              s,
              l,
              c,
            ),
              (this._needsFlipEnvMap = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(t) {
            this.image = t;
          }
        }
        wa.prototype.isCubeTexture = !0;
        class Ma extends Yn {
          constructor(t, e, n) {
            Number.isInteger(e) &&
              (console.warn(
                'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )',
              ),
              (e = n)),
              super(t, t, e),
              (e = e || {}),
              (this.texture = new wa(
                void 0,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.encoding,
              )),
              (this.texture.generateMipmaps =
                void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== e.minFilter ? e.minFilter : xt),
              (this.texture._needsFlipEnvMap = !1);
          }
          fromEquirectangularTexture(t, e) {
            (this.texture.type = e.type),
              (this.texture.format = zt),
              (this.texture.encoding = e.encoding),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter);
            const n = {
                uniforms: { tEquirect: { value: null } },
                vertexShader:
                  '\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t',
                fragmentShader:
                  '\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t',
              },
              i = new fa(5, 5, 5),
              r = new va({
                name: 'CubemapFromEquirect',
                uniforms: ma(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: m,
                blending: x,
              });
            r.uniforms.tEquirect.value = e;
            const a = new da(i, r),
              o = e.minFilter;
            e.minFilter === wt && (e.minFilter = xt);
            return (
              new _a(1, 10, this).update(t, a),
              (e.minFilter = o),
              a.geometry.dispose(),
              a.material.dispose(),
              this
            );
          }
          clear(t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++)
              t.setRenderTarget(this, r), t.clear(e, n, i);
            t.setRenderTarget(r);
          }
        }
        Ma.prototype.isWebGLCubeRenderTarget = !0;
        class qa extends Vn {
          constructor(t, e, n, i, r, a, o, s, l, c, u, h) {
            super(null, a, o, s, l, c, i, r, u, h),
              (this.image = { data: t || null, width: e || 1, height: n || 1 }),
              (this.magFilter = void 0 !== l ? l : ft),
              (this.minFilter = void 0 !== c ? c : ft),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        qa.prototype.isDataTexture = !0;
        const Sa = new xi(),
          Ta = new Zn();
        class Ea {
          constructor(
            t = new ir(),
            e = new ir(),
            n = new ir(),
            i = new ir(),
            r = new ir(),
            a = new ir(),
          ) {
            this.planes = [t, e, n, i, r, a];
          }
          set(t, e, n, i, r, a) {
            const o = this.planes;
            return (
              o[0].copy(t),
              o[1].copy(e),
              o[2].copy(n),
              o[3].copy(i),
              o[4].copy(r),
              o[5].copy(a),
              this
            );
          }
          copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          }
          setFromProjectionMatrix(t) {
            const e = this.planes,
              n = t.elements,
              i = n[0],
              r = n[1],
              a = n[2],
              o = n[3],
              s = n[4],
              l = n[5],
              c = n[6],
              u = n[7],
              h = n[8],
              d = n[9],
              p = n[10],
              f = n[11],
              m = n[12],
              g = n[13],
              y = n[14],
              v = n[15];
            return (
              e[0].setComponents(o - i, u - s, f - h, v - m).normalize(),
              e[1].setComponents(o + i, u + s, f + h, v + m).normalize(),
              e[2].setComponents(o + r, u + l, f + d, v + g).normalize(),
              e[3].setComponents(o - r, u - l, f - d, v - g).normalize(),
              e[4].setComponents(o - a, u - c, f - p, v - y).normalize(),
              e[5].setComponents(o + a, u + c, f + p, v + y).normalize(),
              this
            );
          }
          intersectsObject(t) {
            const e = t.geometry;
            return (
              null === e.boundingSphere && e.computeBoundingSphere(),
              Sa.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
              this.intersectsSphere(Sa)
            );
          }
          intersectsSprite(t) {
            return (
              Sa.center.set(0, 0, 0),
              (Sa.radius = 0.7071067811865476),
              Sa.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(Sa)
            );
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              i = -t.radius;
            for (let t = 0; t < 6; t++) {
              if (e[t].distanceToPoint(n) < i) return !1;
            }
            return !0;
          }
          intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
              const i = e[n];
              if (
                ((Ta.x = i.normal.x > 0 ? t.max.x : t.min.x),
                (Ta.y = i.normal.y > 0 ? t.max.y : t.min.y),
                (Ta.z = i.normal.z > 0 ? t.max.z : t.min.z),
                i.distanceToPoint(Ta) < 0)
              )
                return !1;
            }
            return !0;
          }
          containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
              if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function Aa() {
          let t = null,
            e = !1,
            n = null,
            i = null;
          function r(e, a) {
            n(e, a), (i = t.requestAnimationFrame(r));
          }
          return {
            start: function () {
              !0 !== e &&
                null !== n &&
                ((i = t.requestAnimationFrame(r)), (e = !0));
            },
            stop: function () {
              t.cancelAnimationFrame(i), (e = !1);
            },
            setAnimationLoop: function (t) {
              n = t;
            },
            setContext: function (e) {
              t = e;
            },
          };
        }
        function La(t, e) {
          const n = e.isWebGL2,
            i = new WeakMap();
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data);
              const n = i.get(e);
              n && (t.deleteBuffer(n.buffer), i.delete(e));
            },
            update: function (e, r) {
              if (e.isGLBufferAttribute) {
                const t = i.get(e);
                return void (
                  (!t || t.version < e.version) &&
                  i.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version,
                  })
                );
              }
              e.isInterleavedBufferAttribute && (e = e.data);
              const a = i.get(e);
              void 0 === a
                ? i.set(
                    e,
                    (function (e, i) {
                      const r = e.array,
                        a = e.usage,
                        o = t.createBuffer();
                      t.bindBuffer(i, o),
                        t.bufferData(i, r, a),
                        e.onUploadCallback();
                      let s = 5126;
                      return (
                        r instanceof Float32Array
                          ? (s = 5126)
                          : r instanceof Float64Array
                          ? console.warn(
                              'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.',
                            )
                          : r instanceof Uint16Array
                          ? e.isFloat16BufferAttribute
                            ? n
                              ? (s = 5131)
                              : console.warn(
                                  'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.',
                                )
                            : (s = 5123)
                          : r instanceof Int16Array
                          ? (s = 5122)
                          : r instanceof Uint32Array
                          ? (s = 5125)
                          : r instanceof Int32Array
                          ? (s = 5124)
                          : r instanceof Int8Array
                          ? (s = 5120)
                          : r instanceof Uint8Array && (s = 5121),
                        {
                          buffer: o,
                          type: s,
                          bytesPerElement: r.BYTES_PER_ELEMENT,
                          version: e.version,
                        }
                      );
                    })(e, r),
                  )
                : a.version < e.version &&
                  (!(function (e, i, r) {
                    const a = i.array,
                      o = i.updateRange;
                    t.bindBuffer(r, e),
                      -1 === o.count
                        ? t.bufferSubData(r, 0, a)
                        : (n
                            ? t.bufferSubData(
                                r,
                                o.offset * a.BYTES_PER_ELEMENT,
                                a,
                                o.offset,
                                o.count,
                              )
                            : t.bufferSubData(
                                r,
                                o.offset * a.BYTES_PER_ELEMENT,
                                a.subarray(o.offset, o.offset + o.count),
                              ),
                          (o.count = -1));
                  })(a.buffer, e, r),
                  (a.version = e.version));
            },
          };
        }
        class Ra extends Yr {
          constructor(t = 1, e = 1, n = 1, i = 1) {
            super(),
              (this.type = 'PlaneGeometry'),
              (this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i,
              });
            const r = t / 2,
              a = e / 2,
              o = Math.floor(n),
              s = Math.floor(i),
              l = o + 1,
              c = s + 1,
              u = t / o,
              h = e / s,
              d = [],
              p = [],
              f = [],
              m = [];
            for (let t = 0; t < c; t++) {
              const e = t * h - a;
              for (let n = 0; n < l; n++) {
                const i = n * u - r;
                p.push(i, -e, 0),
                  f.push(0, 0, 1),
                  m.push(n / o),
                  m.push(1 - t / s);
              }
            }
            for (let t = 0; t < s; t++)
              for (let e = 0; e < o; e++) {
                const n = e + l * t,
                  i = e + l * (t + 1),
                  r = e + 1 + l * (t + 1),
                  a = e + 1 + l * t;
                d.push(n, i, a), d.push(i, r, a);
              }
            this.setIndex(d),
              this.setAttribute('position', new Or(p, 3)),
              this.setAttribute('normal', new Or(f, 3)),
              this.setAttribute('uv', new Or(m, 2));
          }
        }
        const Ca = {
            alphamap_fragment:
              '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
            alphamap_pars_fragment:
              '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
            alphatest_fragment:
              '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif',
            aomap_fragment:
              '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif',
            aomap_pars_fragment:
              '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
            begin_vertex: 'vec3 transformed = vec3( position );',
            beginnormal_vertex:
              'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
            bsdfs:
              'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif',
            bumpmap_pars_fragment:
              '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
            clipping_planes_fragment:
              '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
            clipping_planes_pars_fragment:
              '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
            clipping_planes_pars_vertex:
              '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
            clipping_planes_vertex:
              '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
            color_fragment:
              '#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif',
            color_pars_fragment:
              '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif',
            color_pars_vertex:
              '#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif',
            color_vertex:
              '#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif',
            common:
              '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
            cube_uv_reflection_fragment:
              '#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif',
            defaultnormal_vertex:
              'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
            displacementmap_pars_vertex:
              '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
            displacementmap_vertex:
              '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
            emissivemap_fragment:
              '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
            emissivemap_pars_fragment:
              '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
            encodings_fragment:
              'gl_FragColor = linearToOutputTexel( gl_FragColor );',
            encodings_pars_fragment:
              '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
            envmap_fragment:
              '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
            envmap_common_pars_fragment:
              '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
            envmap_pars_fragment:
              '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
            envmap_pars_vertex:
              '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
            envmap_physical_pars_fragment:
              '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif',
            envmap_vertex:
              '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
            fog_vertex: '#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif',
            fog_pars_vertex:
              '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif',
            fog_fragment:
              '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
            fog_pars_fragment:
              '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
            gradientmap_pars_fragment:
              '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
            lightmap_fragment:
              '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif',
            lightmap_pars_fragment:
              '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
            lights_lambert_vertex:
              'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
            lights_pars_begin:
              'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif',
            lights_toon_fragment:
              'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
            lights_toon_pars_fragment:
              'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
            lights_phong_fragment:
              'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
            lights_phong_pars_fragment:
              'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
            lights_physical_fragment:
              'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif',
            lights_physical_pars_fragment:
              'struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
            lights_fragment_begin:
              '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
            lights_fragment_maps:
              '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif',
            lights_fragment_end:
              '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
            logdepthbuf_fragment:
              '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
            logdepthbuf_pars_fragment:
              '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
            logdepthbuf_pars_vertex:
              '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
            logdepthbuf_vertex:
              '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
            map_fragment:
              '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
            map_pars_fragment:
              '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
            map_particle_fragment:
              '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
            map_particle_pars_fragment:
              '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
            metalnessmap_fragment:
              'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
            metalnessmap_pars_fragment:
              '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
            morphnormal_vertex:
              '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif',
            morphtarget_pars_vertex:
              '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
            morphtarget_vertex:
              '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif',
            normal_fragment_begin:
              'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
            normal_fragment_maps:
              '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
            normalmap_pars_fragment:
              '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif',
            clearcoat_normal_fragment_begin:
              '#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
            clearcoat_normal_fragment_maps:
              '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif',
            clearcoat_pars_fragment:
              '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
            packing:
              'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
            premultiplied_alpha_fragment:
              '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
            project_vertex:
              'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
            dithering_fragment:
              '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
            dithering_pars_fragment:
              '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
            roughnessmap_fragment:
              'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
            roughnessmap_pars_fragment:
              '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
            shadowmap_pars_fragment:
              '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
            shadowmap_pars_vertex:
              '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
            shadowmap_vertex:
              '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
            shadowmask_pars_fragment:
              'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
            skinbase_vertex:
              '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
            skinning_pars_vertex:
              '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
            skinning_vertex:
              '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
            skinnormal_vertex:
              '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
            specularmap_fragment:
              'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
            specularmap_pars_fragment:
              '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
            tonemapping_fragment:
              '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
            tonemapping_pars_fragment:
              '#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
            transmissionmap_fragment:
              '#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif',
            transmissionmap_pars_fragment:
              '#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif',
            uv_pars_fragment:
              '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
            uv_pars_vertex:
              '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
            uv_vertex:
              '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
            uv2_pars_fragment:
              '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
            uv2_pars_vertex:
              '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
            uv2_vertex:
              '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
            worldpos_vertex:
              '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
            background_frag:
              'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
            background_vert:
              'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
            cube_frag:
              '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
            cube_vert:
              'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
            depth_frag:
              '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
            depth_vert:
              '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
            distanceRGBA_frag:
              '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
            distanceRGBA_vert:
              '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
            equirect_frag:
              'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
            equirect_vert:
              'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
            linedashed_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
            linedashed_vert:
              'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
            meshbasic_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshbasic_vert:
              '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
            meshlambert_frag:
              'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshlambert_vert:
              '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            meshmatcap_frag:
              '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshmatcap_vert:
              '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
            meshtoon_frag:
              '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshtoon_vert:
              '#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            meshphong_frag:
              '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshphong_vert:
              '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            meshphysical_frag:
              '#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
            meshphysical_vert:
              '#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            normal_frag:
              '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
            normal_vert:
              '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
            points_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
            points_vert:
              'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
            shadow_frag:
              'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
            shadow_vert:
              '#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
            sprite_frag:
              'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
            sprite_vert:
              'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
          },
          Pa = {
            common: {
              diffuse: { value: new Mr(15658734) },
              opacity: { value: 1 },
              map: { value: null },
              uvTransform: { value: new Un() },
              uv2Transform: { value: new Un() },
              alphaMap: { value: null },
            },
            specularmap: { specularMap: { value: null } },
            envmap: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              refractionRatio: { value: 0.98 },
              maxMipLevel: { value: 0 },
            },
            aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
            lightmap: {
              lightMap: { value: null },
              lightMapIntensity: { value: 1 },
            },
            emissivemap: { emissiveMap: { value: null } },
            bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
            normalmap: {
              normalMap: { value: null },
              normalScale: { value: new Bn(1, 1) },
            },
            displacementmap: {
              displacementMap: { value: null },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 },
            },
            roughnessmap: { roughnessMap: { value: null } },
            metalnessmap: { metalnessMap: { value: null } },
            gradientmap: { gradientMap: { value: null } },
            fog: {
              fogDensity: { value: 25e-5 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new Mr(16777215) },
            },
            lights: {
              ambientLightColor: { value: [] },
              lightProbe: { value: [] },
              directionalLights: {
                value: [],
                properties: { direction: {}, color: {} },
              },
              directionalLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {},
                },
              },
              spotLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              spotShadowMap: { value: [] },
              spotShadowMatrix: { value: [] },
              pointLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {},
                },
              },
              pointLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {},
                },
              },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
              },
              rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
              },
              ltc_1: { value: null },
              ltc_2: { value: null },
            },
            points: {
              diffuse: { value: new Mr(15658734) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              alphaMap: { value: null },
              uvTransform: { value: new Un() },
            },
            sprite: {
              diffuse: { value: new Mr(15658734) },
              opacity: { value: 1 },
              center: { value: new Bn(0.5, 0.5) },
              rotation: { value: 0 },
              map: { value: null },
              alphaMap: { value: null },
              uvTransform: { value: new Un() },
            },
          },
          ka = {
            basic: {
              uniforms: ga([
                Pa.common,
                Pa.specularmap,
                Pa.envmap,
                Pa.aomap,
                Pa.lightmap,
                Pa.fog,
              ]),
              vertexShader: Ca.meshbasic_vert,
              fragmentShader: Ca.meshbasic_frag,
            },
            lambert: {
              uniforms: ga([
                Pa.common,
                Pa.specularmap,
                Pa.envmap,
                Pa.aomap,
                Pa.lightmap,
                Pa.emissivemap,
                Pa.fog,
                Pa.lights,
                { emissive: { value: new Mr(0) } },
              ]),
              vertexShader: Ca.meshlambert_vert,
              fragmentShader: Ca.meshlambert_frag,
            },
            phong: {
              uniforms: ga([
                Pa.common,
                Pa.specularmap,
                Pa.envmap,
                Pa.aomap,
                Pa.lightmap,
                Pa.emissivemap,
                Pa.bumpmap,
                Pa.normalmap,
                Pa.displacementmap,
                Pa.fog,
                Pa.lights,
                {
                  emissive: { value: new Mr(0) },
                  specular: { value: new Mr(1118481) },
                  shininess: { value: 30 },
                },
              ]),
              vertexShader: Ca.meshphong_vert,
              fragmentShader: Ca.meshphong_frag,
            },
            standard: {
              uniforms: ga([
                Pa.common,
                Pa.envmap,
                Pa.aomap,
                Pa.lightmap,
                Pa.emissivemap,
                Pa.bumpmap,
                Pa.normalmap,
                Pa.displacementmap,
                Pa.roughnessmap,
                Pa.metalnessmap,
                Pa.fog,
                Pa.lights,
                {
                  emissive: { value: new Mr(0) },
                  roughness: { value: 1 },
                  metalness: { value: 0 },
                  envMapIntensity: { value: 1 },
                },
              ]),
              vertexShader: Ca.meshphysical_vert,
              fragmentShader: Ca.meshphysical_frag,
            },
            toon: {
              uniforms: ga([
                Pa.common,
                Pa.aomap,
                Pa.lightmap,
                Pa.emissivemap,
                Pa.bumpmap,
                Pa.normalmap,
                Pa.displacementmap,
                Pa.gradientmap,
                Pa.fog,
                Pa.lights,
                { emissive: { value: new Mr(0) } },
              ]),
              vertexShader: Ca.meshtoon_vert,
              fragmentShader: Ca.meshtoon_frag,
            },
            matcap: {
              uniforms: ga([
                Pa.common,
                Pa.bumpmap,
                Pa.normalmap,
                Pa.displacementmap,
                Pa.fog,
                { matcap: { value: null } },
              ]),
              vertexShader: Ca.meshmatcap_vert,
              fragmentShader: Ca.meshmatcap_frag,
            },
            points: {
              uniforms: ga([Pa.points, Pa.fog]),
              vertexShader: Ca.points_vert,
              fragmentShader: Ca.points_frag,
            },
            dashed: {
              uniforms: ga([
                Pa.common,
                Pa.fog,
                {
                  scale: { value: 1 },
                  dashSize: { value: 1 },
                  totalSize: { value: 2 },
                },
              ]),
              vertexShader: Ca.linedashed_vert,
              fragmentShader: Ca.linedashed_frag,
            },
            depth: {
              uniforms: ga([Pa.common, Pa.displacementmap]),
              vertexShader: Ca.depth_vert,
              fragmentShader: Ca.depth_frag,
            },
            normal: {
              uniforms: ga([
                Pa.common,
                Pa.bumpmap,
                Pa.normalmap,
                Pa.displacementmap,
                { opacity: { value: 1 } },
              ]),
              vertexShader: Ca.normal_vert,
              fragmentShader: Ca.normal_frag,
            },
            sprite: {
              uniforms: ga([Pa.sprite, Pa.fog]),
              vertexShader: Ca.sprite_vert,
              fragmentShader: Ca.sprite_frag,
            },
            background: {
              uniforms: {
                uvTransform: { value: new Un() },
                t2D: { value: null },
              },
              vertexShader: Ca.background_vert,
              fragmentShader: Ca.background_frag,
            },
            cube: {
              uniforms: ga([Pa.envmap, { opacity: { value: 1 } }]),
              vertexShader: Ca.cube_vert,
              fragmentShader: Ca.cube_frag,
            },
            equirect: {
              uniforms: { tEquirect: { value: null } },
              vertexShader: Ca.equirect_vert,
              fragmentShader: Ca.equirect_frag,
            },
            distanceRGBA: {
              uniforms: ga([
                Pa.common,
                Pa.displacementmap,
                {
                  referencePosition: { value: new Zn() },
                  nearDistance: { value: 1 },
                  farDistance: { value: 1e3 },
                },
              ]),
              vertexShader: Ca.distanceRGBA_vert,
              fragmentShader: Ca.distanceRGBA_frag,
            },
            shadow: {
              uniforms: ga([
                Pa.lights,
                Pa.fog,
                { color: { value: new Mr(0) }, opacity: { value: 1 } },
              ]),
              vertexShader: Ca.shadow_vert,
              fragmentShader: Ca.shadow_frag,
            },
          };
        function Ia(t, e, n, i, r) {
          const a = new Mr(0);
          let o,
            s,
            l = 0,
            c = null,
            u = 0,
            h = null;
          function d(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, r);
          }
          return {
            getClearColor: function () {
              return a;
            },
            setClearColor: function (t, e = 1) {
              a.set(t), (l = e), d(a, l);
            },
            getClearAlpha: function () {
              return l;
            },
            setClearAlpha: function (t) {
              (l = t), d(a, l);
            },
            render: function (n, r, p, g) {
              let y = !0 === r.isScene ? r.background : null;
              y && y.isTexture && (y = e.get(y));
              const v = t.xr,
                x = v.getSession && v.getSession();
              x && 'additive' === x.environmentBlendMode && (y = null),
                null === y ? d(a, l) : y && y.isColor && (d(y, 1), (g = !0)),
                (t.autoClear || g) &&
                  t.clear(
                    t.autoClearColor,
                    t.autoClearDepth,
                    t.autoClearStencil,
                  ),
                y && (y.isCubeTexture || y.mapping === ct)
                  ? (void 0 === s &&
                      ((s = new da(
                        new fa(1, 1, 1),
                        new va({
                          name: 'BackgroundCubeMaterial',
                          uniforms: ma(ka.cube.uniforms),
                          vertexShader: ka.cube.vertexShader,
                          fragmentShader: ka.cube.fragmentShader,
                          side: m,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        }),
                      )),
                      s.geometry.deleteAttribute('normal'),
                      s.geometry.deleteAttribute('uv'),
                      (s.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                      }),
                      Object.defineProperty(s.material, 'envMap', {
                        get: function () {
                          return this.uniforms.envMap.value;
                        },
                      }),
                      i.update(s)),
                    (s.material.uniforms.envMap.value = y),
                    (s.material.uniforms.flipEnvMap.value =
                      y.isCubeTexture && y._needsFlipEnvMap ? -1 : 1),
                    (c === y && u === y.version && h === t.toneMapping) ||
                      ((s.material.needsUpdate = !0),
                      (c = y),
                      (u = y.version),
                      (h = t.toneMapping)),
                    n.unshift(s, s.geometry, s.material, 0, 0, null))
                  : y &&
                    y.isTexture &&
                    (void 0 === o &&
                      ((o = new da(
                        new Ra(2, 2),
                        new va({
                          name: 'BackgroundMaterial',
                          uniforms: ma(ka.background.uniforms),
                          vertexShader: ka.background.vertexShader,
                          fragmentShader: ka.background.fragmentShader,
                          side: f,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        }),
                      )),
                      o.geometry.deleteAttribute('normal'),
                      Object.defineProperty(o.material, 'map', {
                        get: function () {
                          return this.uniforms.t2D.value;
                        },
                      }),
                      i.update(o)),
                    (o.material.uniforms.t2D.value = y),
                    !0 === y.matrixAutoUpdate && y.updateMatrix(),
                    o.material.uniforms.uvTransform.value.copy(y.matrix),
                    (c === y && u === y.version && h === t.toneMapping) ||
                      ((o.material.needsUpdate = !0),
                      (c = y),
                      (u = y.version),
                      (h = t.toneMapping)),
                    n.unshift(o, o.geometry, o.material, 0, 0, null));
            },
          };
        }
        function Da(t, e, n, i) {
          const r = t.getParameter(34921),
            a = i.isWebGL2 ? null : e.get('OES_vertex_array_object'),
            o = i.isWebGL2 || null !== a,
            s = {},
            l = d(null);
          let c = l;
          function u(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : a.bindVertexArrayOES(e);
          }
          function h(e) {
            return i.isWebGL2
              ? t.deleteVertexArray(e)
              : a.deleteVertexArrayOES(e);
          }
          function d(t) {
            const e = [],
              n = [],
              i = [];
            for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: i,
              object: t,
              attributes: {},
              index: null,
            };
          }
          function p() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
          }
          function f(t) {
            m(t, 0);
          }
          function m(n, r) {
            const a = c.newAttributes,
              o = c.enabledAttributes,
              s = c.attributeDivisors;
            if (
              ((a[n] = 1),
              0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
              s[n] !== r)
            ) {
              (i.isWebGL2 ? t : e.get('ANGLE_instanced_arrays'))[
                i.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
              ](n, r),
                (s[n] = r);
            }
          }
          function g() {
            const e = c.newAttributes,
              n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++)
              n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
          }
          function y(e, n, r, a, o, s) {
            !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
              ? t.vertexAttribPointer(e, n, r, a, o, s)
              : t.vertexAttribIPointer(e, n, r, o, s);
          }
          function v() {
            x(), c !== l && ((c = l), u(c.object));
          }
          function x() {
            (l.geometry = null), (l.program = null), (l.wireframe = !1);
          }
          return {
            setup: function (r, l, h, v, x) {
              let b = !1;
              if (o) {
                const e = (function (e, n, r) {
                  const o = !0 === r.wireframe;
                  let l = s[e.id];
                  void 0 === l && ((l = {}), (s[e.id] = l));
                  let c = l[n.id];
                  void 0 === c && ((c = {}), (l[n.id] = c));
                  let u = c[o];
                  void 0 === u &&
                    ((u = d(
                      i.isWebGL2
                        ? t.createVertexArray()
                        : a.createVertexArrayOES(),
                    )),
                    (c[o] = u));
                  return u;
                })(v, h, l);
                c !== e && ((c = e), u(c.object)),
                  (b = (function (t, e) {
                    const n = c.attributes,
                      i = t.attributes;
                    let r = 0;
                    for (const t in i) {
                      const e = n[t],
                        a = i[t];
                      if (void 0 === e) return !0;
                      if (e.attribute !== a) return !0;
                      if (e.data !== a.data) return !0;
                      r++;
                    }
                    return c.attributesNum !== r || c.index !== e;
                  })(v, x)),
                  b &&
                    (function (t, e) {
                      const n = {},
                        i = t.attributes;
                      let r = 0;
                      for (const t in i) {
                        const e = i[t],
                          a = {};
                        (a.attribute = e),
                          e.data && (a.data = e.data),
                          (n[t] = a),
                          r++;
                      }
                      (c.attributes = n), (c.attributesNum = r), (c.index = e);
                    })(v, x);
              } else {
                const t = !0 === l.wireframe;
                (c.geometry === v.id &&
                  c.program === h.id &&
                  c.wireframe === t) ||
                  ((c.geometry = v.id),
                  (c.program = h.id),
                  (c.wireframe = t),
                  (b = !0));
              }
              !0 === r.isInstancedMesh && (b = !0),
                null !== x && n.update(x, 34963),
                b &&
                  (!(function (r, a, o, s) {
                    if (
                      !1 === i.isWebGL2 &&
                      (r.isInstancedMesh || s.isInstancedBufferGeometry) &&
                      null === e.get('ANGLE_instanced_arrays')
                    )
                      return;
                    p();
                    const l = s.attributes,
                      c = o.getAttributes(),
                      u = a.defaultAttributeValues;
                    for (const e in c) {
                      const i = c[e];
                      if (i >= 0) {
                        const a = l[e];
                        if (void 0 !== a) {
                          const e = a.normalized,
                            r = a.itemSize,
                            o = n.get(a);
                          if (void 0 === o) continue;
                          const l = o.buffer,
                            c = o.type,
                            u = o.bytesPerElement;
                          if (a.isInterleavedBufferAttribute) {
                            const n = a.data,
                              o = n.stride,
                              h = a.offset;
                            n && n.isInstancedInterleavedBuffer
                              ? (m(i, n.meshPerAttribute),
                                void 0 === s._maxInstanceCount &&
                                  (s._maxInstanceCount =
                                    n.meshPerAttribute * n.count))
                              : f(i),
                              t.bindBuffer(34962, l),
                              y(i, r, c, e, o * u, h * u);
                          } else
                            a.isInstancedBufferAttribute
                              ? (m(i, a.meshPerAttribute),
                                void 0 === s._maxInstanceCount &&
                                  (s._maxInstanceCount =
                                    a.meshPerAttribute * a.count))
                              : f(i),
                              t.bindBuffer(34962, l),
                              y(i, r, c, e, 0, 0);
                        } else if ('instanceMatrix' === e) {
                          const e = n.get(r.instanceMatrix);
                          if (void 0 === e) continue;
                          const a = e.buffer,
                            o = e.type;
                          m(i + 0, 1),
                            m(i + 1, 1),
                            m(i + 2, 1),
                            m(i + 3, 1),
                            t.bindBuffer(34962, a),
                            t.vertexAttribPointer(i + 0, 4, o, !1, 64, 0),
                            t.vertexAttribPointer(i + 1, 4, o, !1, 64, 16),
                            t.vertexAttribPointer(i + 2, 4, o, !1, 64, 32),
                            t.vertexAttribPointer(i + 3, 4, o, !1, 64, 48);
                        } else if ('instanceColor' === e) {
                          const e = n.get(r.instanceColor);
                          if (void 0 === e) continue;
                          const a = e.buffer,
                            o = e.type;
                          m(i, 1),
                            t.bindBuffer(34962, a),
                            t.vertexAttribPointer(i, 3, o, !1, 12, 0);
                        } else if (void 0 !== u) {
                          const n = u[e];
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(i, n);
                                break;
                              case 3:
                                t.vertexAttrib3fv(i, n);
                                break;
                              case 4:
                                t.vertexAttrib4fv(i, n);
                                break;
                              default:
                                t.vertexAttrib1fv(i, n);
                            }
                        }
                      }
                    }
                    g();
                  })(r, l, h, v),
                  null !== x && t.bindBuffer(34963, n.get(x).buffer));
            },
            reset: v,
            resetDefaultState: x,
            dispose: function () {
              v();
              for (const t in s) {
                const e = s[t];
                for (const t in e) {
                  const n = e[t];
                  for (const t in n) h(n[t].object), delete n[t];
                  delete e[t];
                }
                delete s[t];
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === s[t.id]) return;
              const e = s[t.id];
              for (const t in e) {
                const n = e[t];
                for (const t in n) h(n[t].object), delete n[t];
                delete e[t];
              }
              delete s[t.id];
            },
            releaseStatesOfProgram: function (t) {
              for (const e in s) {
                const n = s[e];
                if (void 0 === n[t.id]) continue;
                const i = n[t.id];
                for (const t in i) h(i[t].object), delete i[t];
                delete n[t.id];
              }
            },
            initAttributes: p,
            enableAttribute: f,
            disableUnusedAttributes: g,
          };
        }
        function Oa(t, e, n, i) {
          const r = i.isWebGL2;
          let a;
          (this.setMode = function (t) {
            a = t;
          }),
            (this.render = function (e, i) {
              t.drawArrays(a, e, i), n.update(i, a, 1);
            }),
            (this.renderInstances = function (i, o, s) {
              if (0 === s) return;
              let l, c;
              if (r) (l = t), (c = 'drawArraysInstanced');
              else if (
                ((l = e.get('ANGLE_instanced_arrays')),
                (c = 'drawArraysInstancedANGLE'),
                null === l)
              )
                return void console.error(
                  'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
                );
              l[c](a, i, o, s), n.update(o, a, s);
            });
        }
        function Na(t, e, n) {
          let i;
          function r(e) {
            if ('highp' === e) {
              if (
                t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                t.getShaderPrecisionFormat(35632, 36338).precision > 0
              )
                return 'highp';
              e = 'mediump';
            }
            return 'mediump' === e &&
              t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36337).precision > 0
              ? 'mediump'
              : 'lowp';
          }
          const a =
            ('undefined' != typeof WebGL2RenderingContext &&
              t instanceof WebGL2RenderingContext) ||
            ('undefined' != typeof WebGL2ComputeRenderingContext &&
              t instanceof WebGL2ComputeRenderingContext);
          let o = void 0 !== n.precision ? n.precision : 'highp';
          const s = r(o);
          s !== o &&
            (console.warn(
              'THREE.WebGLRenderer:',
              o,
              'not supported, using',
              s,
              'instead.',
            ),
            (o = s));
          const l = !0 === n.logarithmicDepthBuffer,
            c = t.getParameter(34930),
            u = t.getParameter(35660),
            h = t.getParameter(3379),
            d = t.getParameter(34076),
            p = t.getParameter(34921),
            f = t.getParameter(36347),
            m = t.getParameter(36348),
            g = t.getParameter(36349),
            y = u > 0,
            v = a || e.has('OES_texture_float');
          return {
            isWebGL2: a,
            getMaxAnisotropy: function () {
              if (void 0 !== i) return i;
              if (!0 === e.has('EXT_texture_filter_anisotropic')) {
                const n = e.get('EXT_texture_filter_anisotropic');
                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else i = 0;
              return i;
            },
            getMaxPrecision: r,
            precision: o,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: u,
            maxTextureSize: h,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: y,
            floatFragmentTextures: v,
            floatVertexTextures: y && v,
            maxSamples: a ? t.getParameter(36183) : 0,
          };
        }
        function za(t) {
          const e = this;
          let n = null,
            i = 0,
            r = !1,
            a = !1;
          const o = new ir(),
            s = new Un(),
            l = { value: null, needsUpdate: !1 };
          function c() {
            l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
              (e.numPlanes = i),
              (e.numIntersection = 0);
          }
          function u(t, n, i, r) {
            const a = null !== t ? t.length : 0;
            let c = null;
            if (0 !== a) {
              if (((c = l.value), !0 !== r || null === c)) {
                const e = i + 4 * a,
                  r = n.matrixWorldInverse;
                s.getNormalMatrix(r),
                  (null === c || c.length < e) && (c = new Float32Array(e));
                for (let e = 0, n = i; e !== a; ++e, n += 4)
                  o.copy(t[e]).applyMatrix4(r, s),
                    o.normal.toArray(c, n),
                    (c[n + 3] = o.constant);
              }
              (l.value = c), (l.needsUpdate = !0);
            }
            return (e.numPlanes = a), (e.numIntersection = 0), c;
          }
          (this.uniform = l),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e, a) {
              const o = 0 !== t.length || e || 0 !== i || r;
              return (r = e), (n = u(t, a, 0)), (i = t.length), o;
            }),
            (this.beginShadows = function () {
              (a = !0), u(null);
            }),
            (this.endShadows = function () {
              (a = !1), c();
            }),
            (this.setState = function (e, o, s) {
              const h = e.clippingPlanes,
                d = e.clipIntersection,
                p = e.clipShadows,
                f = t.get(e);
              if (!r || null === h || 0 === h.length || (a && !p))
                a ? u(null) : c();
              else {
                const t = a ? 0 : i,
                  e = 4 * t;
                let r = f.clippingState || null;
                (l.value = r), (r = u(h, o, e, s));
                for (let t = 0; t !== e; ++t) r[t] = n[t];
                (f.clippingState = r),
                  (this.numIntersection = d ? this.numPlanes : 0),
                  (this.numPlanes += t);
              }
            });
        }
        function Fa(t) {
          let e = new WeakMap();
          function n(t, e) {
            return (
              e === st ? (t.mapping = at) : e === lt && (t.mapping = ot), t
            );
          }
          function i(t) {
            const n = t.target;
            n.removeEventListener('dispose', i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const a = r.mapping;
                if (a === st || a === lt) {
                  if (e.has(r)) {
                    return n(e.get(r).texture, r.mapping);
                  }
                  {
                    const a = r.image;
                    if (a && a.height > 0) {
                      const o = t.getRenderTarget(),
                        s = new Ma(a.height / 2);
                      return (
                        s.fromEquirectangularTexture(t, r),
                        e.set(r, s),
                        t.setRenderTarget(o),
                        r.addEventListener('dispose', i),
                        n(s.texture, r.mapping)
                      );
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        function Ba(t) {
          const e = {};
          function n(n) {
            if (void 0 !== e[n]) return e[n];
            let i;
            switch (n) {
              case 'WEBGL_depth_texture':
                i =
                  t.getExtension('WEBGL_depth_texture') ||
                  t.getExtension('MOZ_WEBGL_depth_texture') ||
                  t.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
              case 'EXT_texture_filter_anisotropic':
                i =
                  t.getExtension('EXT_texture_filter_anisotropic') ||
                  t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                  t.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
              case 'WEBGL_compressed_texture_s3tc':
                i =
                  t.getExtension('WEBGL_compressed_texture_s3tc') ||
                  t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                  t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
              case 'WEBGL_compressed_texture_pvrtc':
                i =
                  t.getExtension('WEBGL_compressed_texture_pvrtc') ||
                  t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
              default:
                i = t.getExtension(n);
            }
            return (e[n] = i), i;
          }
          return {
            has: function (t) {
              return null !== n(t);
            },
            init: function (t) {
              t.isWebGL2
                ? n('EXT_color_buffer_float')
                : (n('WEBGL_depth_texture'),
                  n('OES_texture_float'),
                  n('OES_texture_half_float'),
                  n('OES_texture_half_float_linear'),
                  n('OES_standard_derivatives'),
                  n('OES_element_index_uint'),
                  n('OES_vertex_array_object'),
                  n('ANGLE_instanced_arrays')),
                n('OES_texture_float_linear'),
                n('EXT_color_buffer_half_float');
            },
            get: function (t) {
              const e = n(t);
              return (
                null === e &&
                  console.warn(
                    'THREE.WebGLRenderer: ' + t + ' extension not supported.',
                  ),
                e
              );
            },
          };
        }
        function Ua(t, e, n, i) {
          const r = {},
            a = new WeakMap();
          function o(t) {
            const s = t.target;
            null !== s.index && e.remove(s.index);
            for (const t in s.attributes) e.remove(s.attributes[t]);
            s.removeEventListener('dispose', o), delete r[s.id];
            const l = a.get(s);
            l && (e.remove(l), a.delete(s)),
              i.releaseStatesOfGeometry(s),
              !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
              n.memory.geometries--;
          }
          function s(t) {
            const n = [],
              i = t.index,
              r = t.attributes.position;
            let o = 0;
            if (null !== i) {
              const t = i.array;
              o = i.version;
              for (let e = 0, i = t.length; e < i; e += 3) {
                const i = t[e + 0],
                  r = t[e + 1],
                  a = t[e + 2];
                n.push(i, r, r, a, a, i);
              }
            } else {
              const t = r.array;
              o = r.version;
              for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                const t = e + 0,
                  i = e + 1,
                  r = e + 2;
                n.push(t, i, i, r, r, t);
              }
            }
            const s = new (zr(n) > 65535 ? Ir : Pr)(n, 1);
            s.version = o;
            const l = a.get(t);
            l && e.remove(l), a.set(t, s);
          }
          return {
            get: function (t, e) {
              return (
                !0 === r[e.id] ||
                  (e.addEventListener('dispose', o),
                  (r[e.id] = !0),
                  n.memory.geometries++),
                e
              );
            },
            update: function (t) {
              const n = t.attributes;
              for (const t in n) e.update(n[t], 34962);
              const i = t.morphAttributes;
              for (const t in i) {
                const n = i[t];
                for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
              }
            },
            getWireframeAttribute: function (t) {
              const e = a.get(t);
              if (e) {
                const n = t.index;
                null !== n && e.version < n.version && s(t);
              } else s(t);
              return a.get(t);
            },
          };
        }
        function ja(t, e, n, i) {
          const r = i.isWebGL2;
          let a, o, s;
          (this.setMode = function (t) {
            a = t;
          }),
            (this.setIndex = function (t) {
              (o = t.type), (s = t.bytesPerElement);
            }),
            (this.render = function (e, i) {
              t.drawElements(a, i, o, e * s), n.update(i, a, 1);
            }),
            (this.renderInstances = function (i, l, c) {
              if (0 === c) return;
              let u, h;
              if (r) (u = t), (h = 'drawElementsInstanced');
              else if (
                ((u = e.get('ANGLE_instanced_arrays')),
                (h = 'drawElementsInstancedANGLE'),
                null === u)
              )
                return void console.error(
                  'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
                );
              u[h](a, l, o, i * s, c), n.update(l, a, c);
            });
        }
        function Ga(t) {
          const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return {
            memory: { geometries: 0, textures: 0 },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              e.frame++,
                (e.calls = 0),
                (e.triangles = 0),
                (e.points = 0),
                (e.lines = 0);
            },
            update: function (t, n, i) {
              switch ((e.calls++, n)) {
                case 4:
                  e.triangles += i * (t / 3);
                  break;
                case 1:
                  e.lines += i * (t / 2);
                  break;
                case 3:
                  e.lines += i * (t - 1);
                  break;
                case 2:
                  e.lines += i * t;
                  break;
                case 0:
                  e.points += i * t;
                  break;
                default:
                  console.error('THREE.WebGLInfo: Unknown draw mode:', n);
              }
            },
          };
        }
        function Ha(t, e) {
          return t[0] - e[0];
        }
        function Va(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1]);
        }
        function Wa(t) {
          const e = {},
            n = new Float32Array(8),
            i = [];
          for (let t = 0; t < 8; t++) i[t] = [t, 0];
          return {
            update: function (r, a, o, s) {
              const l = r.morphTargetInfluences,
                c = void 0 === l ? 0 : l.length;
              let u = e[a.id];
              if (void 0 === u) {
                u = [];
                for (let t = 0; t < c; t++) u[t] = [t, 0];
                e[a.id] = u;
              }
              for (let t = 0; t < c; t++) {
                const e = u[t];
                (e[0] = t), (e[1] = l[t]);
              }
              u.sort(Va);
              for (let t = 0; t < 8; t++)
                t < c && u[t][1]
                  ? ((i[t][0] = u[t][0]), (i[t][1] = u[t][1]))
                  : ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0));
              i.sort(Ha);
              const h = o.morphTargets && a.morphAttributes.position,
                d = o.morphNormals && a.morphAttributes.normal;
              let p = 0;
              for (let t = 0; t < 8; t++) {
                const e = i[t],
                  r = e[0],
                  o = e[1];
                r !== Number.MAX_SAFE_INTEGER && o
                  ? (h &&
                      a.getAttribute('morphTarget' + t) !== h[r] &&
                      a.setAttribute('morphTarget' + t, h[r]),
                    d &&
                      a.getAttribute('morphNormal' + t) !== d[r] &&
                      a.setAttribute('morphNormal' + t, d[r]),
                    (n[t] = o),
                    (p += o))
                  : (h &&
                      !0 === a.hasAttribute('morphTarget' + t) &&
                      a.deleteAttribute('morphTarget' + t),
                    d &&
                      !0 === a.hasAttribute('morphNormal' + t) &&
                      a.deleteAttribute('morphNormal' + t),
                    (n[t] = 0));
              }
              const f = a.morphTargetsRelative ? 1 : 1 - p;
              s.getUniforms().setValue(t, 'morphTargetBaseInfluence', f),
                s.getUniforms().setValue(t, 'morphTargetInfluences', n);
            },
          };
        }
        function Xa(t, e, n, i) {
          let r = new WeakMap();
          function a(t) {
            const e = t.target;
            e.removeEventListener('dispose', a),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor);
          }
          return {
            update: function (t) {
              const o = i.render.frame,
                s = t.geometry,
                l = e.get(t, s);
              return (
                r.get(l) !== o && (e.update(l), r.set(l, o)),
                t.isInstancedMesh &&
                  (!1 === t.hasEventListener('dispose', a) &&
                    t.addEventListener('dispose', a),
                  n.update(t.instanceMatrix, 34962),
                  null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                l
              );
            },
            dispose: function () {
              r = new WeakMap();
            },
          };
        }
        ka.physical = {
          uniforms: ga([
            ka.standard.uniforms,
            {
              clearcoat: { value: 0 },
              clearcoatMap: { value: null },
              clearcoatRoughness: { value: 0 },
              clearcoatRoughnessMap: { value: null },
              clearcoatNormalScale: { value: new Bn(1, 1) },
              clearcoatNormalMap: { value: null },
              sheen: { value: new Mr(0) },
              transmission: { value: 0 },
              transmissionMap: { value: null },
            },
          ]),
          vertexShader: Ca.meshphysical_vert,
          fragmentShader: Ca.meshphysical_frag,
        };
        class Ya extends Vn {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = ft),
              (this.minFilter = ft),
              (this.wrapR = dt),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.needsUpdate = !0);
          }
        }
        Ya.prototype.isDataTexture2DArray = !0;
        class $a extends Vn {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = ft),
              (this.minFilter = ft),
              (this.wrapR = dt),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.needsUpdate = !0);
          }
        }
        $a.prototype.isDataTexture3D = !0;
        const Ja = new Vn(),
          Za = new Ya(),
          Ka = new $a(),
          Qa = new wa(),
          to = [],
          eo = [],
          no = new Float32Array(16),
          io = new Float32Array(9),
          ro = new Float32Array(4);
        function ao(t, e, n) {
          const i = t[0];
          if (i <= 0 || i > 0) return t;
          const r = e * n;
          let a = to[r];
          if (
            (void 0 === a && ((a = new Float32Array(r)), (to[r] = a)), 0 !== e)
          ) {
            i.toArray(a, 0);
            for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(a, r);
          }
          return a;
        }
        function oo(t, e) {
          if (t.length !== e.length) return !1;
          for (let n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n]) return !1;
          return !0;
        }
        function so(t, e) {
          for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
        }
        function lo(t, e) {
          let n = eo[e];
          void 0 === n && ((n = new Int32Array(e)), (eo[e] = n));
          for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
          return n;
        }
        function co(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
        }
        function uo(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (oo(n, e)) return;
            t.uniform2fv(this.addr, e), so(n, e);
          }
        }
        function ho(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z));
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b),
              (n[0] = e.r),
              (n[1] = e.g),
              (n[2] = e.b));
          else {
            if (oo(n, e)) return;
            t.uniform3fv(this.addr, e), so(n, e);
          }
        }
        function po(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (oo(n, e)) return;
            t.uniform4fv(this.addr, e), so(n, e);
          }
        }
        function fo(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (oo(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), so(n, e);
          } else {
            if (oo(n, i)) return;
            ro.set(i), t.uniformMatrix2fv(this.addr, !1, ro), so(n, i);
          }
        }
        function mo(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (oo(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), so(n, e);
          } else {
            if (oo(n, i)) return;
            io.set(i), t.uniformMatrix3fv(this.addr, !1, io), so(n, i);
          }
        }
        function go(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (oo(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), so(n, e);
          } else {
            if (oo(n, i)) return;
            no.set(i), t.uniformMatrix4fv(this.addr, !1, no), so(n, i);
          }
        }
        function yo(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
        }
        function vo(t, e) {
          const n = this.cache;
          oo(n, e) || (t.uniform2iv(this.addr, e), so(n, e));
        }
        function xo(t, e) {
          const n = this.cache;
          oo(n, e) || (t.uniform3iv(this.addr, e), so(n, e));
        }
        function bo(t, e) {
          const n = this.cache;
          oo(n, e) || (t.uniform4iv(this.addr, e), so(n, e));
        }
        function _o(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
        }
        function wo(t, e) {
          const n = this.cache;
          oo(n, e) || (t.uniform2uiv(this.addr, e), so(n, e));
        }
        function Mo(t, e) {
          const n = this.cache;
          oo(n, e) || (t.uniform3uiv(this.addr, e), so(n, e));
        }
        function qo(t, e) {
          const n = this.cache;
          oo(n, e) || (t.uniform4uiv(this.addr, e), so(n, e));
        }
        function So(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.safeSetTexture2D(e || Ja, r);
        }
        function To(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTexture3D(e || Ka, r);
        }
        function Eo(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.safeSetTextureCube(e || Qa, r);
        }
        function Ao(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTexture2DArray(e || Za, r);
        }
        function Lo(t, e) {
          t.uniform1fv(this.addr, e);
        }
        function Ro(t, e) {
          const n = ao(e, this.size, 2);
          t.uniform2fv(this.addr, n);
        }
        function Co(t, e) {
          const n = ao(e, this.size, 3);
          t.uniform3fv(this.addr, n);
        }
        function Po(t, e) {
          const n = ao(e, this.size, 4);
          t.uniform4fv(this.addr, n);
        }
        function ko(t, e) {
          const n = ao(e, this.size, 4);
          t.uniformMatrix2fv(this.addr, !1, n);
        }
        function Io(t, e) {
          const n = ao(e, this.size, 9);
          t.uniformMatrix3fv(this.addr, !1, n);
        }
        function Do(t, e) {
          const n = ao(e, this.size, 16);
          t.uniformMatrix4fv(this.addr, !1, n);
        }
        function Oo(t, e) {
          t.uniform1iv(this.addr, e);
        }
        function No(t, e) {
          t.uniform2iv(this.addr, e);
        }
        function zo(t, e) {
          t.uniform3iv(this.addr, e);
        }
        function Fo(t, e) {
          t.uniform4iv(this.addr, e);
        }
        function Bo(t, e) {
          t.uniform1uiv(this.addr, e);
        }
        function Uo(t, e) {
          t.uniform2uiv(this.addr, e);
        }
        function jo(t, e) {
          t.uniform3uiv(this.addr, e);
        }
        function Go(t, e) {
          t.uniform4uiv(this.addr, e);
        }
        function Ho(t, e, n) {
          const i = e.length,
            r = lo(n, i);
          t.uniform1iv(this.addr, r);
          for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || Ja, r[t]);
        }
        function Vo(t, e, n) {
          const i = e.length,
            r = lo(n, i);
          t.uniform1iv(this.addr, r);
          for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Qa, r[t]);
        }
        function Wo(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return co;
                case 35664:
                  return uo;
                case 35665:
                  return ho;
                case 35666:
                  return po;
                case 35674:
                  return fo;
                case 35675:
                  return mo;
                case 35676:
                  return go;
                case 5124:
                case 35670:
                  return yo;
                case 35667:
                case 35671:
                  return vo;
                case 35668:
                case 35672:
                  return xo;
                case 35669:
                case 35673:
                  return bo;
                case 5125:
                  return _o;
                case 36294:
                  return wo;
                case 36295:
                  return Mo;
                case 36296:
                  return qo;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return So;
                case 35679:
                case 36299:
                case 36307:
                  return To;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return Eo;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return Ao;
              }
            })(e.type));
        }
        function Xo(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.size = e.size),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return Lo;
                case 35664:
                  return Ro;
                case 35665:
                  return Co;
                case 35666:
                  return Po;
                case 35674:
                  return ko;
                case 35675:
                  return Io;
                case 35676:
                  return Do;
                case 5124:
                case 35670:
                  return Oo;
                case 35667:
                case 35671:
                  return No;
                case 35668:
                case 35672:
                  return zo;
                case 35669:
                case 35673:
                  return Fo;
                case 5125:
                  return Bo;
                case 36294:
                  return Uo;
                case 36295:
                  return jo;
                case 36296:
                  return Go;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return Ho;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return Vo;
              }
            })(e.type));
        }
        function Yo(t) {
          (this.id = t), (this.seq = []), (this.map = {});
        }
        (Xo.prototype.updateCache = function (t) {
          const e = this.cache;
          t instanceof Float32Array &&
            e.length !== t.length &&
            (this.cache = new Float32Array(t.length)),
            so(e, t);
        }),
          (Yo.prototype.setValue = function (t, e, n) {
            const i = this.seq;
            for (let r = 0, a = i.length; r !== a; ++r) {
              const a = i[r];
              a.setValue(t, e[a.id], n);
            }
          });
        const $o = /(\w+)(\])?(\[|\.)?/g;
        function Jo(t, e) {
          t.seq.push(e), (t.map[e.id] = e);
        }
        function Zo(t, e, n) {
          const i = t.name,
            r = i.length;
          for ($o.lastIndex = 0; ; ) {
            const a = $o.exec(i),
              o = $o.lastIndex;
            let s = a[1];
            const l = ']' === a[2],
              c = a[3];
            if ((l && (s |= 0), void 0 === c || ('[' === c && o + 2 === r))) {
              Jo(n, void 0 === c ? new Wo(s, t, e) : new Xo(s, t, e));
              break;
            }
            {
              let t = n.map[s];
              void 0 === t && ((t = new Yo(s)), Jo(n, t)), (n = t);
            }
          }
        }
        function Ko(t, e) {
          (this.seq = []), (this.map = {});
          const n = t.getProgramParameter(e, 35718);
          for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i);
            Zo(n, t.getUniformLocation(e, n.name), this);
          }
        }
        function Qo(t, e, n) {
          const i = t.createShader(e);
          return t.shaderSource(i, n), t.compileShader(i), i;
        }
        (Ko.prototype.setValue = function (t, e, n, i) {
          const r = this.map[e];
          void 0 !== r && r.setValue(t, n, i);
        }),
          (Ko.prototype.setOptional = function (t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i);
          }),
          (Ko.upload = function (t, e, n, i) {
            for (let r = 0, a = e.length; r !== a; ++r) {
              const a = e[r],
                o = n[a.id];
              !1 !== o.needsUpdate && a.setValue(t, o.value, i);
            }
          }),
          (Ko.seqWithValue = function (t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
              const r = t[i];
              r.id in e && n.push(r);
            }
            return n;
          });
        let ts = 0;
        function es(t) {
          switch (t) {
            case Je:
              return ['Linear', '( value )'];
            case Ze:
              return ['sRGB', '( value )'];
            case Qe:
              return ['RGBE', '( value )'];
            case en:
              return ['RGBM', '( value, 7.0 )'];
            case nn:
              return ['RGBM', '( value, 16.0 )'];
            case rn:
              return ['RGBD', '( value, 256.0 )'];
            case Ke:
              return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
            case tn:
              return ['LogLuv', '( value )'];
            default:
              return (
                console.warn('THREE.WebGLProgram: Unsupported encoding:', t),
                ['Linear', '( value )']
              );
          }
        }
        function ns(t, e, n) {
          const i = t.getShaderParameter(e, 35713),
            r = t.getShaderInfoLog(e).trim();
          if (i && '' === r) return '';
          return (
            'THREE.WebGLShader: gl.getShaderInfoLog() ' +
            n +
            '\n' +
            r +
            (function (t) {
              const e = t.split('\n');
              for (let t = 0; t < e.length; t++) e[t] = t + 1 + ': ' + e[t];
              return e.join('\n');
            })(t.getShaderSource(e))
          );
        }
        function is(t, e) {
          const n = es(e);
          return (
            'vec4 ' +
            t +
            '( vec4 value ) { return ' +
            n[0] +
            'ToLinear' +
            n[1] +
            '; }'
          );
        }
        function rs(t, e) {
          const n = es(e);
          return (
            'vec4 ' +
            t +
            '( vec4 value ) { return LinearTo' +
            n[0] +
            n[1] +
            '; }'
          );
        }
        function as(t, e) {
          let n;
          switch (e) {
            case Q:
              n = 'Linear';
              break;
            case tt:
              n = 'Reinhard';
              break;
            case et:
              n = 'OptimizedCineon';
              break;
            case nt:
              n = 'ACESFilmic';
              break;
            case it:
              n = 'Custom';
              break;
            default:
              console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e),
                (n = 'Linear');
          }
          return (
            'vec3 ' +
            t +
            '( vec3 color ) { return ' +
            n +
            'ToneMapping( color ); }'
          );
        }
        function os(t) {
          return '' !== t;
        }
        function ss(t, e) {
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
        }
        function ls(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(
              /UNION_CLIPPING_PLANES/g,
              e.numClippingPlanes - e.numClipIntersection,
            );
        }
        const cs = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function us(t) {
          return t.replace(cs, hs);
        }
        function hs(t, e) {
          const n = Ca[e];
          if (void 0 === n)
            throw new Error('Can not resolve #include <' + e + '>');
          return us(n);
        }
        const ds =
            /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          ps =
            /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function fs(t) {
          return t.replace(ps, gs).replace(ds, ms);
        }
        function ms(t, e, n, i) {
          return (
            console.warn(
              'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.',
            ),
            gs(t, e, n, i)
          );
        }
        function gs(t, e, n, i) {
          let r = '';
          for (let t = parseInt(e); t < parseInt(n); t++)
            r += i
              .replace(/\[\s*i\s*\]/g, '[ ' + t + ' ]')
              .replace(/UNROLLED_LOOP_INDEX/g, t);
          return r;
        }
        function ys(t) {
          let e =
            'precision ' +
            t.precision +
            ' float;\nprecision ' +
            t.precision +
            ' int;';
          return (
            'highp' === t.precision
              ? (e += '\n#define HIGH_PRECISION')
              : 'mediump' === t.precision
              ? (e += '\n#define MEDIUM_PRECISION')
              : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
            e
          );
        }
        function vs(t, e, n, i) {
          const r = t.getContext(),
            a = n.defines;
          let o = n.vertexShader,
            s = n.fragmentShader;
          const l = (function (t) {
              let e = 'SHADOWMAP_TYPE_BASIC';
              return (
                t.shadowMapType === h
                  ? (e = 'SHADOWMAP_TYPE_PCF')
                  : t.shadowMapType === d
                  ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
                  : t.shadowMapType === p && (e = 'SHADOWMAP_TYPE_VSM'),
                e
              );
            })(n),
            c = (function (t) {
              let e = 'ENVMAP_TYPE_CUBE';
              if (t.envMap)
                switch (t.envMapMode) {
                  case at:
                  case ot:
                    e = 'ENVMAP_TYPE_CUBE';
                    break;
                  case ct:
                  case ut:
                    e = 'ENVMAP_TYPE_CUBE_UV';
                }
              return e;
            })(n),
            u = (function (t) {
              let e = 'ENVMAP_MODE_REFLECTION';
              if (t.envMap)
                switch (t.envMapMode) {
                  case ot:
                  case ut:
                    e = 'ENVMAP_MODE_REFRACTION';
                }
              return e;
            })(n),
            f = (function (t) {
              let e = 'ENVMAP_BLENDING_NONE';
              if (t.envMap)
                switch (t.combine) {
                  case $:
                    e = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
                  case J:
                    e = 'ENVMAP_BLENDING_MIX';
                    break;
                  case Z:
                    e = 'ENVMAP_BLENDING_ADD';
                }
              return e;
            })(n),
            m = t.gammaFactor > 0 ? t.gammaFactor : 1,
            g = n.isWebGL2
              ? ''
              : (function (t) {
                  return [
                    t.extensionDerivatives ||
                    t.envMapCubeUV ||
                    t.bumpMap ||
                    t.tangentSpaceNormalMap ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    'physical' === t.shaderID
                      ? '#extension GL_OES_standard_derivatives : enable'
                      : '',
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                    t.rendererExtensionFragDepth
                      ? '#extension GL_EXT_frag_depth : enable'
                      : '',
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? '#extension GL_EXT_draw_buffers : require'
                      : '',
                    (t.extensionShaderTextureLOD || t.envMap) &&
                    t.rendererExtensionShaderTextureLod
                      ? '#extension GL_EXT_shader_texture_lod : enable'
                      : '',
                  ]
                    .filter(os)
                    .join('\n');
                })(n),
            y = (function (t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                !1 !== i && e.push('#define ' + n + ' ' + i);
              }
              return e.join('\n');
            })(a),
            v = r.createProgram();
          let x,
            b,
            _ = n.glslVersion ? '#version ' + n.glslVersion + '\n' : '';
          n.isRawShaderMaterial
            ? ((x = [y].filter(os).join('\n')),
              x.length > 0 && (x += '\n'),
              (b = [g, y].filter(os).join('\n')),
              b.length > 0 && (b += '\n'))
            : ((x = [
                ys(n),
                '#define SHADER_NAME ' + n.shaderName,
                y,
                n.instancing ? '#define USE_INSTANCING' : '',
                n.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
                n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                '#define GAMMA_FACTOR ' + m,
                '#define MAX_BONES ' + n.maxBones,
                n.useFog && n.fog ? '#define USE_FOG' : '',
                n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                n.map ? '#define USE_MAP' : '',
                n.envMap ? '#define USE_ENVMAP' : '',
                n.envMap ? '#define ' + u : '',
                n.lightMap ? '#define USE_LIGHTMAP' : '',
                n.aoMap ? '#define USE_AOMAP' : '',
                n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                n.bumpMap ? '#define USE_BUMPMAP' : '',
                n.normalMap ? '#define USE_NORMALMAP' : '',
                n.normalMap && n.objectSpaceNormalMap
                  ? '#define OBJECTSPACE_NORMALMAP'
                  : '',
                n.normalMap && n.tangentSpaceNormalMap
                  ? '#define TANGENTSPACE_NORMALMAP'
                  : '',
                n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                n.clearcoatRoughnessMap
                  ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                  : '',
                n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                n.displacementMap && n.supportsVertexTextures
                  ? '#define USE_DISPLACEMENTMAP'
                  : '',
                n.specularMap ? '#define USE_SPECULARMAP' : '',
                n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                n.alphaMap ? '#define USE_ALPHAMAP' : '',
                n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                n.vertexTangents ? '#define USE_TANGENT' : '',
                n.vertexColors ? '#define USE_COLOR' : '',
                n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                n.vertexUvs ? '#define USE_UV' : '',
                n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                n.flatShading ? '#define FLAT_SHADED' : '',
                n.skinning ? '#define USE_SKINNING' : '',
                n.useVertexTexture ? '#define BONE_TEXTURE' : '',
                n.morphTargets ? '#define USE_MORPHTARGETS' : '',
                n.morphNormals && !1 === n.flatShading
                  ? '#define USE_MORPHNORMALS'
                  : '',
                n.doubleSided ? '#define DOUBLE_SIDED' : '',
                n.flipSided ? '#define FLIP_SIDED' : '',
                n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                n.shadowMapEnabled ? '#define ' + l : '',
                n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? '#define USE_LOGDEPTHBUF_EXT'
                  : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                '#ifdef USE_INSTANCING',
                '\tattribute mat4 instanceMatrix;',
                '#endif',
                '#ifdef USE_INSTANCING_COLOR',
                '\tattribute vec3 instanceColor;',
                '#endif',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_TANGENT',
                '\tattribute vec4 tangent;',
                '#endif',
                '#if defined( USE_COLOR_ALPHA )',
                '\tattribute vec4 color;',
                '#elif defined( USE_COLOR )',
                '\tattribute vec3 color;',
                '#endif',
                '#ifdef USE_MORPHTARGETS',
                '\tattribute vec3 morphTarget0;',
                '\tattribute vec3 morphTarget1;',
                '\tattribute vec3 morphTarget2;',
                '\tattribute vec3 morphTarget3;',
                '\t#ifdef USE_MORPHNORMALS',
                '\t\tattribute vec3 morphNormal0;',
                '\t\tattribute vec3 morphNormal1;',
                '\t\tattribute vec3 morphNormal2;',
                '\t\tattribute vec3 morphNormal3;',
                '\t#else',
                '\t\tattribute vec3 morphTarget4;',
                '\t\tattribute vec3 morphTarget5;',
                '\t\tattribute vec3 morphTarget6;',
                '\t\tattribute vec3 morphTarget7;',
                '\t#endif',
                '#endif',
                '#ifdef USE_SKINNING',
                '\tattribute vec4 skinIndex;',
                '\tattribute vec4 skinWeight;',
                '#endif',
                '\n',
              ]
                .filter(os)
                .join('\n')),
              (b = [
                g,
                ys(n),
                '#define SHADER_NAME ' + n.shaderName,
                y,
                n.alphaTest
                  ? '#define ALPHATEST ' +
                    n.alphaTest +
                    (n.alphaTest % 1 ? '' : '.0')
                  : '',
                '#define GAMMA_FACTOR ' + m,
                n.useFog && n.fog ? '#define USE_FOG' : '',
                n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                n.map ? '#define USE_MAP' : '',
                n.matcap ? '#define USE_MATCAP' : '',
                n.envMap ? '#define USE_ENVMAP' : '',
                n.envMap ? '#define ' + c : '',
                n.envMap ? '#define ' + u : '',
                n.envMap ? '#define ' + f : '',
                n.lightMap ? '#define USE_LIGHTMAP' : '',
                n.aoMap ? '#define USE_AOMAP' : '',
                n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                n.bumpMap ? '#define USE_BUMPMAP' : '',
                n.normalMap ? '#define USE_NORMALMAP' : '',
                n.normalMap && n.objectSpaceNormalMap
                  ? '#define OBJECTSPACE_NORMALMAP'
                  : '',
                n.normalMap && n.tangentSpaceNormalMap
                  ? '#define TANGENTSPACE_NORMALMAP'
                  : '',
                n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                n.clearcoatRoughnessMap
                  ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                  : '',
                n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                n.specularMap ? '#define USE_SPECULARMAP' : '',
                n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                n.alphaMap ? '#define USE_ALPHAMAP' : '',
                n.sheen ? '#define USE_SHEEN' : '',
                n.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                n.vertexTangents ? '#define USE_TANGENT' : '',
                n.vertexColors || n.instancingColor ? '#define USE_COLOR' : '',
                n.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                n.vertexUvs ? '#define USE_UV' : '',
                n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                n.gradientMap ? '#define USE_GRADIENTMAP' : '',
                n.flatShading ? '#define FLAT_SHADED' : '',
                n.doubleSided ? '#define DOUBLE_SIDED' : '',
                n.flipSided ? '#define FLIP_SIDED' : '',
                n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                n.shadowMapEnabled ? '#define ' + l : '',
                n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                n.physicallyCorrectLights
                  ? '#define PHYSICALLY_CORRECT_LIGHTS'
                  : '',
                n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? '#define USE_LOGDEPTHBUF_EXT'
                  : '',
                (n.extensionShaderTextureLOD || n.envMap) &&
                n.rendererExtensionShaderTextureLod
                  ? '#define TEXTURE_LOD_EXT'
                  : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                n.toneMapping !== K ? '#define TONE_MAPPING' : '',
                n.toneMapping !== K ? Ca.tonemapping_pars_fragment : '',
                n.toneMapping !== K ? as('toneMapping', n.toneMapping) : '',
                n.dithering ? '#define DITHERING' : '',
                Ca.encodings_pars_fragment,
                n.map ? is('mapTexelToLinear', n.mapEncoding) : '',
                n.matcap ? is('matcapTexelToLinear', n.matcapEncoding) : '',
                n.envMap ? is('envMapTexelToLinear', n.envMapEncoding) : '',
                n.emissiveMap
                  ? is('emissiveMapTexelToLinear', n.emissiveMapEncoding)
                  : '',
                n.lightMap
                  ? is('lightMapTexelToLinear', n.lightMapEncoding)
                  : '',
                rs('linearToOutputTexel', n.outputEncoding),
                n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
                '\n',
              ]
                .filter(os)
                .join('\n'))),
            (o = us(o)),
            (o = ss(o, n)),
            (o = ls(o, n)),
            (s = us(s)),
            (s = ss(s, n)),
            (s = ls(s, n)),
            (o = fs(o)),
            (s = fs(s)),
            n.isWebGL2 &&
              !0 !== n.isRawShaderMaterial &&
              ((_ = '#version 300 es\n'),
              (x =
                [
                  '#define attribute in',
                  '#define varying out',
                  '#define texture2D texture',
                ].join('\n') +
                '\n' +
                x),
              (b =
                [
                  '#define varying in',
                  n.glslVersion === Dn ? '' : 'out highp vec4 pc_fragColor;',
                  n.glslVersion === Dn
                    ? ''
                    : '#define gl_FragColor pc_fragColor',
                  '#define gl_FragDepthEXT gl_FragDepth',
                  '#define texture2D texture',
                  '#define textureCube texture',
                  '#define texture2DProj textureProj',
                  '#define texture2DLodEXT textureLod',
                  '#define texture2DProjLodEXT textureProjLod',
                  '#define textureCubeLodEXT textureLod',
                  '#define texture2DGradEXT textureGrad',
                  '#define texture2DProjGradEXT textureProjGrad',
                  '#define textureCubeGradEXT textureGrad',
                ].join('\n') +
                '\n' +
                b));
          const w = _ + b + s,
            M = Qo(r, 35633, _ + x + o),
            q = Qo(r, 35632, w);
          if (
            (r.attachShader(v, M),
            r.attachShader(v, q),
            void 0 !== n.index0AttributeName
              ? r.bindAttribLocation(v, 0, n.index0AttributeName)
              : !0 === n.morphTargets && r.bindAttribLocation(v, 0, 'position'),
            r.linkProgram(v),
            t.debug.checkShaderErrors)
          ) {
            const t = r.getProgramInfoLog(v).trim(),
              e = r.getShaderInfoLog(M).trim(),
              n = r.getShaderInfoLog(q).trim();
            let i = !0,
              a = !0;
            if (!1 === r.getProgramParameter(v, 35714)) {
              i = !1;
              const e = ns(r, M, 'vertex'),
                n = ns(r, q, 'fragment');
              console.error(
                'THREE.WebGLProgram: shader error: ',
                r.getError(),
                '35715',
                r.getProgramParameter(v, 35715),
                'gl.getProgramInfoLog',
                t,
                e,
                n,
              );
            } else
              '' !== t
                ? console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', t)
                : ('' !== e && '' !== n) || (a = !1);
            a &&
              (this.diagnostics = {
                runnable: i,
                programLog: t,
                vertexShader: { log: e, prefix: x },
                fragmentShader: { log: n, prefix: b },
              });
          }
          let S, T;
          return (
            r.deleteShader(M),
            r.deleteShader(q),
            (this.getUniforms = function () {
              return void 0 === S && (S = new Ko(r, v)), S;
            }),
            (this.getAttributes = function () {
              return (
                void 0 === T &&
                  (T = (function (t, e) {
                    const n = {},
                      i = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < i; r++) {
                      const i = t.getActiveAttrib(e, r).name;
                      n[i] = t.getAttribLocation(e, i);
                    }
                    return n;
                  })(r, v)),
                T
              );
            }),
            (this.destroy = function () {
              i.releaseStatesOfProgram(this),
                r.deleteProgram(v),
                (this.program = void 0);
            }),
            (this.name = n.shaderName),
            (this.id = ts++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = v),
            (this.vertexShader = M),
            (this.fragmentShader = q),
            this
          );
        }
        function xs(t, e, n, i, r, a) {
          const o = [],
            s = i.isWebGL2,
            l = i.logarithmicDepthBuffer,
            c = i.floatVertexTextures,
            u = i.maxVertexUniforms,
            h = i.vertexTextures;
          let d = i.precision;
          const p = {
              MeshDepthMaterial: 'depth',
              MeshDistanceMaterial: 'distanceRGBA',
              MeshNormalMaterial: 'normal',
              MeshBasicMaterial: 'basic',
              MeshLambertMaterial: 'lambert',
              MeshPhongMaterial: 'phong',
              MeshToonMaterial: 'toon',
              MeshStandardMaterial: 'physical',
              MeshPhysicalMaterial: 'physical',
              MeshMatcapMaterial: 'matcap',
              LineBasicMaterial: 'basic',
              LineDashedMaterial: 'dashed',
              PointsMaterial: 'points',
              ShadowMaterial: 'shadow',
              SpriteMaterial: 'sprite',
            },
            f = [
              'precision',
              'isWebGL2',
              'supportsVertexTextures',
              'outputEncoding',
              'instancing',
              'instancingColor',
              'map',
              'mapEncoding',
              'matcap',
              'matcapEncoding',
              'envMap',
              'envMapMode',
              'envMapEncoding',
              'envMapCubeUV',
              'lightMap',
              'lightMapEncoding',
              'aoMap',
              'emissiveMap',
              'emissiveMapEncoding',
              'bumpMap',
              'normalMap',
              'objectSpaceNormalMap',
              'tangentSpaceNormalMap',
              'clearcoatMap',
              'clearcoatRoughnessMap',
              'clearcoatNormalMap',
              'displacementMap',
              'specularMap',
              'roughnessMap',
              'metalnessMap',
              'gradientMap',
              'alphaMap',
              'combine',
              'vertexColors',
              'vertexAlphas',
              'vertexTangents',
              'vertexUvs',
              'uvsVertexOnly',
              'fog',
              'useFog',
              'fogExp2',
              'flatShading',
              'sizeAttenuation',
              'logarithmicDepthBuffer',
              'skinning',
              'maxBones',
              'useVertexTexture',
              'morphTargets',
              'morphNormals',
              'premultipliedAlpha',
              'numDirLights',
              'numPointLights',
              'numSpotLights',
              'numHemiLights',
              'numRectAreaLights',
              'numDirLightShadows',
              'numPointLightShadows',
              'numSpotLightShadows',
              'shadowMapEnabled',
              'shadowMapType',
              'toneMapping',
              'physicallyCorrectLights',
              'alphaTest',
              'doubleSided',
              'flipSided',
              'numClippingPlanes',
              'numClipIntersection',
              'depthPacking',
              'dithering',
              'sheen',
              'transmissionMap',
            ];
          function y(t) {
            let e;
            return (
              t && t.isTexture
                ? (e = t.encoding)
                : t && t.isWebGLRenderTarget
                ? (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
                  ),
                  (e = t.texture.encoding))
                : (e = Je),
              e
            );
          }
          return {
            getParameters: function (r, o, f, v, x) {
              const b = v.fog,
                _ = r.isMeshStandardMaterial ? v.environment : null,
                w = e.get(r.envMap || _),
                M = p[r.type],
                q = x.isSkinnedMesh
                  ? (function (t) {
                      const e = t.skeleton.bones;
                      if (c) return 1024;
                      {
                        const t = u,
                          n = Math.floor((t - 20) / 4),
                          i = Math.min(n, e.length);
                        return i < e.length
                          ? (console.warn(
                              'THREE.WebGLRenderer: Skeleton has ' +
                                e.length +
                                ' bones. This GPU supports ' +
                                i +
                                '.',
                            ),
                            0)
                          : i;
                      }
                    })(x)
                  : 0;
              let S, T;
              if (
                (null !== r.precision &&
                  ((d = i.getMaxPrecision(r.precision)),
                  d !== r.precision &&
                    console.warn(
                      'THREE.WebGLProgram.getParameters:',
                      r.precision,
                      'not supported, using',
                      d,
                      'instead.',
                    )),
                M)
              ) {
                const t = ka[M];
                (S = t.vertexShader), (T = t.fragmentShader);
              } else (S = r.vertexShader), (T = r.fragmentShader);
              const E = t.getRenderTarget();
              return {
                isWebGL2: s,
                shaderID: M,
                shaderName: r.type,
                vertexShader: S,
                fragmentShader: T,
                defines: r.defines,
                isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                glslVersion: r.glslVersion,
                precision: d,
                instancing: !0 === x.isInstancedMesh,
                instancingColor:
                  !0 === x.isInstancedMesh && null !== x.instanceColor,
                supportsVertexTextures: h,
                outputEncoding: null !== E ? y(E.texture) : t.outputEncoding,
                map: !!r.map,
                mapEncoding: y(r.map),
                matcap: !!r.matcap,
                matcapEncoding: y(r.matcap),
                envMap: !!w,
                envMapMode: w && w.mapping,
                envMapEncoding: y(w),
                envMapCubeUV: !!w && (w.mapping === ct || w.mapping === ut),
                lightMap: !!r.lightMap,
                lightMapEncoding: y(r.lightMap),
                aoMap: !!r.aoMap,
                emissiveMap: !!r.emissiveMap,
                emissiveMapEncoding: y(r.emissiveMap),
                bumpMap: !!r.bumpMap,
                normalMap: !!r.normalMap,
                objectSpaceNormalMap: r.normalMapType === ln,
                tangentSpaceNormalMap: r.normalMapType === sn,
                clearcoatMap: !!r.clearcoatMap,
                clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                clearcoatNormalMap: !!r.clearcoatNormalMap,
                displacementMap: !!r.displacementMap,
                roughnessMap: !!r.roughnessMap,
                metalnessMap: !!r.metalnessMap,
                specularMap: !!r.specularMap,
                alphaMap: !!r.alphaMap,
                gradientMap: !!r.gradientMap,
                sheen: !!r.sheen,
                transmissionMap: !!r.transmissionMap,
                combine: r.combine,
                vertexTangents: r.normalMap && r.vertexTangents,
                vertexColors: r.vertexColors,
                vertexAlphas:
                  !0 === r.vertexColors &&
                  x.geometry.attributes.color &&
                  4 === x.geometry.attributes.color.itemSize,
                vertexUvs: !!(
                  r.map ||
                  r.bumpMap ||
                  r.normalMap ||
                  r.specularMap ||
                  r.alphaMap ||
                  r.emissiveMap ||
                  r.roughnessMap ||
                  r.metalnessMap ||
                  r.clearcoatMap ||
                  r.clearcoatRoughnessMap ||
                  r.clearcoatNormalMap ||
                  r.displacementMap ||
                  r.transmissionMap
                ),
                uvsVertexOnly: !(
                  r.map ||
                  r.bumpMap ||
                  r.normalMap ||
                  r.specularMap ||
                  r.alphaMap ||
                  r.emissiveMap ||
                  r.roughnessMap ||
                  r.metalnessMap ||
                  r.clearcoatNormalMap ||
                  r.transmissionMap ||
                  !r.displacementMap
                ),
                fog: !!b,
                useFog: r.fog,
                fogExp2: b && b.isFogExp2,
                flatShading: !!r.flatShading,
                sizeAttenuation: r.sizeAttenuation,
                logarithmicDepthBuffer: l,
                skinning: r.skinning && q > 0,
                maxBones: q,
                useVertexTexture: c,
                morphTargets: r.morphTargets,
                morphNormals: r.morphNormals,
                numDirLights: o.directional.length,
                numPointLights: o.point.length,
                numSpotLights: o.spot.length,
                numRectAreaLights: o.rectArea.length,
                numHemiLights: o.hemi.length,
                numDirLightShadows: o.directionalShadowMap.length,
                numPointLightShadows: o.pointShadowMap.length,
                numSpotLightShadows: o.spotShadowMap.length,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: r.dithering,
                shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: r.toneMapped ? t.toneMapping : K,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: r.premultipliedAlpha,
                alphaTest: r.alphaTest,
                doubleSided: r.side === g,
                flipSided: r.side === m,
                depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                index0AttributeName: r.index0AttributeName,
                extensionDerivatives: r.extensions && r.extensions.derivatives,
                extensionFragDepth: r.extensions && r.extensions.fragDepth,
                extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                extensionShaderTextureLOD:
                  r.extensions && r.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: s || n.has('EXT_frag_depth'),
                rendererExtensionDrawBuffers: s || n.has('WEBGL_draw_buffers'),
                rendererExtensionShaderTextureLod:
                  s || n.has('EXT_shader_texture_lod'),
                customProgramCacheKey: r.customProgramCacheKey(),
              };
            },
            getProgramCacheKey: function (e) {
              const n = [];
              if (
                (e.shaderID
                  ? n.push(e.shaderID)
                  : (n.push(e.fragmentShader), n.push(e.vertexShader)),
                void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
              if (!1 === e.isRawShaderMaterial) {
                for (let t = 0; t < f.length; t++) n.push(e[f[t]]);
                n.push(t.outputEncoding), n.push(t.gammaFactor);
              }
              return n.push(e.customProgramCacheKey), n.join();
            },
            getUniforms: function (t) {
              const e = p[t.type];
              let n;
              if (e) {
                const t = ka[e];
                n = ya.clone(t.uniforms);
              } else n = t.uniforms;
              return n;
            },
            acquireProgram: function (e, n) {
              let i;
              for (let t = 0, e = o.length; t < e; t++) {
                const e = o[t];
                if (e.cacheKey === n) {
                  (i = e), ++i.usedTimes;
                  break;
                }
              }
              return void 0 === i && ((i = new vs(t, n, e, r)), o.push(i)), i;
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = o.indexOf(t);
                (o[e] = o[o.length - 1]), o.pop(), t.destroy();
              }
            },
            programs: o,
          };
        }
        function bs() {
          let t = new WeakMap();
          return {
            get: function (e) {
              let n = t.get(e);
              return void 0 === n && ((n = {}), t.set(e, n)), n;
            },
            remove: function (e) {
              t.delete(e);
            },
            update: function (e, n, i) {
              t.get(e)[n] = i;
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function _s(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.program !== e.program
            ? t.program.id - e.program.id
            : t.material.id !== e.material.id
            ? t.material.id - e.material.id
            : t.z !== e.z
            ? t.z - e.z
            : t.id - e.id;
        }
        function ws(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : t.id - e.id;
        }
        function Ms(t) {
          const e = [];
          let n = 0;
          const i = [],
            r = [],
            a = { id: -1 };
          function o(i, r, o, s, l, c) {
            let u = e[n];
            const h = t.get(o);
            return (
              void 0 === u
                ? ((u = {
                    id: i.id,
                    object: i,
                    geometry: r,
                    material: o,
                    program: h.program || a,
                    groupOrder: s,
                    renderOrder: i.renderOrder,
                    z: l,
                    group: c,
                  }),
                  (e[n] = u))
                : ((u.id = i.id),
                  (u.object = i),
                  (u.geometry = r),
                  (u.material = o),
                  (u.program = h.program || a),
                  (u.groupOrder = s),
                  (u.renderOrder = i.renderOrder),
                  (u.z = l),
                  (u.group = c)),
              n++,
              u
            );
          }
          return {
            opaque: i,
            transparent: r,
            init: function () {
              (n = 0), (i.length = 0), (r.length = 0);
            },
            push: function (t, e, n, a, s, l) {
              const c = o(t, e, n, a, s, l);
              (!0 === n.transparent ? r : i).push(c);
            },
            unshift: function (t, e, n, a, s, l) {
              const c = o(t, e, n, a, s, l);
              (!0 === n.transparent ? r : i).unshift(c);
            },
            finish: function () {
              for (let t = n, i = e.length; t < i; t++) {
                const n = e[t];
                if (null === n.id) break;
                (n.id = null),
                  (n.object = null),
                  (n.geometry = null),
                  (n.material = null),
                  (n.program = null),
                  (n.group = null);
              }
            },
            sort: function (t, e) {
              i.length > 1 && i.sort(t || _s), r.length > 1 && r.sort(e || ws);
            },
          };
        }
        function qs(t) {
          let e = new WeakMap();
          return {
            get: function (n, i) {
              let r;
              return (
                !1 === e.has(n)
                  ? ((r = new Ms(t)), e.set(n, [r]))
                  : i >= e.get(n).length
                  ? ((r = new Ms(t)), e.get(n).push(r))
                  : (r = e.get(n)[i]),
                r
              );
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        function Ss() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case 'DirectionalLight':
                  n = { direction: new Zn(), color: new Mr() };
                  break;
                case 'SpotLight':
                  n = {
                    position: new Zn(),
                    direction: new Zn(),
                    color: new Mr(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                  };
                  break;
                case 'PointLight':
                  n = {
                    position: new Zn(),
                    color: new Mr(),
                    distance: 0,
                    decay: 0,
                  };
                  break;
                case 'HemisphereLight':
                  n = {
                    direction: new Zn(),
                    skyColor: new Mr(),
                    groundColor: new Mr(),
                  };
                  break;
                case 'RectAreaLight':
                  n = {
                    color: new Mr(),
                    position: new Zn(),
                    halfWidth: new Zn(),
                    halfHeight: new Zn(),
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        let Ts = 0;
        function Es(t, e) {
          return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
        }
        function As(t, e) {
          const n = new Ss(),
            i = (function () {
              const t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  let n;
                  switch (e.type) {
                    case 'DirectionalLight':
                    case 'SpotLight':
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Bn(),
                      };
                      break;
                    case 'PointLight':
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Bn(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (t[e.id] = n), n;
                },
              };
            })(),
            r = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadow: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
            };
          for (let t = 0; t < 9; t++) r.probe.push(new Zn());
          const a = new Zn(),
            o = new Ai(),
            s = new Ai();
          return {
            setup: function (a) {
              let o = 0,
                s = 0,
                l = 0;
              for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
              let c = 0,
                u = 0,
                h = 0,
                d = 0,
                p = 0,
                f = 0,
                m = 0,
                g = 0;
              a.sort(Es);
              for (let t = 0, e = a.length; t < e; t++) {
                const e = a[t],
                  y = e.color,
                  v = e.intensity,
                  x = e.distance,
                  b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight)
                  (o += y.r * v), (s += y.g * v), (l += y.b * v);
                else if (e.isLightProbe)
                  for (let t = 0; t < 9; t++)
                    r.probe[t].addScaledVector(e.sh.coefficients[t], v);
                else if (e.isDirectionalLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.directionalShadow[c] = n),
                      (r.directionalShadowMap[c] = b),
                      (r.directionalShadowMatrix[c] = e.shadow.matrix),
                      f++;
                  }
                  (r.directional[c] = t), c++;
                } else if (e.isSpotLight) {
                  const t = n.get(e);
                  if (
                    (t.position.setFromMatrixPosition(e.matrixWorld),
                    t.color.copy(y).multiplyScalar(v),
                    (t.distance = x),
                    (t.coneCos = Math.cos(e.angle)),
                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.spotShadow[h] = n),
                      (r.spotShadowMap[h] = b),
                      (r.spotShadowMatrix[h] = e.shadow.matrix),
                      g++;
                  }
                  (r.spot[h] = t), h++;
                } else if (e.isRectAreaLight) {
                  const t = n.get(e);
                  t.color.copy(y).multiplyScalar(v),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (r.rectArea[d] = t),
                    d++;
                } else if (e.isPointLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity),
                    (t.distance = e.distance),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (r.pointShadow[u] = n),
                      (r.pointShadowMap[u] = b),
                      (r.pointShadowMatrix[u] = e.shadow.matrix),
                      m++;
                  }
                  (r.point[u] = t), u++;
                } else if (e.isHemisphereLight) {
                  const t = n.get(e);
                  t.skyColor.copy(e.color).multiplyScalar(v),
                    t.groundColor.copy(e.groundColor).multiplyScalar(v),
                    (r.hemi[p] = t),
                    p++;
                }
              }
              d > 0 &&
                (e.isWebGL2 || !0 === t.has('OES_texture_float_linear')
                  ? ((r.rectAreaLTC1 = Pa.LTC_FLOAT_1),
                    (r.rectAreaLTC2 = Pa.LTC_FLOAT_2))
                  : !0 === t.has('OES_texture_half_float_linear')
                  ? ((r.rectAreaLTC1 = Pa.LTC_HALF_1),
                    (r.rectAreaLTC2 = Pa.LTC_HALF_2))
                  : console.error(
                      'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.',
                    )),
                (r.ambient[0] = o),
                (r.ambient[1] = s),
                (r.ambient[2] = l);
              const y = r.hash;
              (y.directionalLength === c &&
                y.pointLength === u &&
                y.spotLength === h &&
                y.rectAreaLength === d &&
                y.hemiLength === p &&
                y.numDirectionalShadows === f &&
                y.numPointShadows === m &&
                y.numSpotShadows === g) ||
                ((r.directional.length = c),
                (r.spot.length = h),
                (r.rectArea.length = d),
                (r.point.length = u),
                (r.hemi.length = p),
                (r.directionalShadow.length = f),
                (r.directionalShadowMap.length = f),
                (r.pointShadow.length = m),
                (r.pointShadowMap.length = m),
                (r.spotShadow.length = g),
                (r.spotShadowMap.length = g),
                (r.directionalShadowMatrix.length = f),
                (r.pointShadowMatrix.length = m),
                (r.spotShadowMatrix.length = g),
                (y.directionalLength = c),
                (y.pointLength = u),
                (y.spotLength = h),
                (y.rectAreaLength = d),
                (y.hemiLength = p),
                (y.numDirectionalShadows = f),
                (y.numPointShadows = m),
                (y.numSpotShadows = g),
                (r.version = Ts++));
            },
            setupView: function (t, e) {
              let n = 0,
                i = 0,
                l = 0,
                c = 0,
                u = 0;
              const h = e.matrixWorldInverse;
              for (let e = 0, d = t.length; e < d; e++) {
                const d = t[e];
                if (d.isDirectionalLight) {
                  const t = r.directional[n];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    a.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(a),
                    t.direction.transformDirection(h),
                    n++;
                } else if (d.isSpotLight) {
                  const t = r.spot[l];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(h),
                    t.direction.setFromMatrixPosition(d.matrixWorld),
                    a.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(a),
                    t.direction.transformDirection(h),
                    l++;
                } else if (d.isRectAreaLight) {
                  const t = r.rectArea[c];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(h),
                    s.identity(),
                    o.copy(d.matrixWorld),
                    o.premultiply(h),
                    s.extractRotation(o),
                    t.halfWidth.set(0.5 * d.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * d.height, 0),
                    t.halfWidth.applyMatrix4(s),
                    t.halfHeight.applyMatrix4(s),
                    c++;
                } else if (d.isPointLight) {
                  const t = r.point[i];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(h),
                    i++;
                } else if (d.isHemisphereLight) {
                  const t = r.hemi[u];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    t.direction.transformDirection(h),
                    t.direction.normalize(),
                    u++;
                }
              }
            },
            state: r,
          };
        }
        function Ls(t, e) {
          const n = new As(t, e),
            i = [],
            r = [];
          return {
            init: function () {
              (i.length = 0), (r.length = 0);
            },
            state: { lightsArray: i, shadowsArray: r, lights: n },
            setupLights: function () {
              n.setup(i);
            },
            setupLightsView: function (t) {
              n.setupView(i, t);
            },
            pushLight: function (t) {
              i.push(t);
            },
            pushShadow: function (t) {
              r.push(t);
            },
          };
        }
        function Rs(t, e) {
          let n = new WeakMap();
          return {
            get: function (i, r = 0) {
              let a;
              return (
                !1 === n.has(i)
                  ? ((a = new Ls(t, e)), n.set(i, [a]))
                  : r >= n.get(i).length
                  ? ((a = new Ls(t, e)), n.get(i).push(a))
                  : (a = n.get(i)[r]),
                a
              );
            },
            dispose: function () {
              n = new WeakMap();
            },
          };
        }
        class Cs extends gr {
          constructor(t) {
            super(),
              (this.type = 'MeshDepthMaterial'),
              (this.depthPacking = an),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            );
          }
        }
        Cs.prototype.isMeshDepthMaterial = !0;
        class Ps extends gr {
          constructor(t) {
            super(),
              (this.type = 'MeshDistanceMaterial'),
              (this.referencePosition = new Zn()),
              (this.nearDistance = 1),
              (this.farDistance = 1e3),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.referencePosition.copy(t.referencePosition),
              (this.nearDistance = t.nearDistance),
              (this.farDistance = t.farDistance),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            );
          }
        }
        Ps.prototype.isMeshDistanceMaterial = !0;
        function ks(t, e, n) {
          let i = new Ea();
          const r = new Bn(),
            a = new Bn(),
            o = new Xn(),
            s = [],
            l = [],
            c = {},
            u = n.maxTextureSize,
            d = { 0: m, 1: f, 2: g },
            y = new va({
              defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
              uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new Bn() },
                radius: { value: 4 },
              },
              vertexShader:
                'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}',
              fragmentShader:
                'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
            }),
            v = y.clone();
          v.defines.HORIZONTAL_PASS = 1;
          const b = new Yr();
          b.setAttribute(
            'position',
            new Er(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
          );
          const _ = new da(b, y),
            w = this;
          function M(n, i) {
            const r = e.update(_);
            (y.uniforms.shadow_pass.value = n.map.texture),
              (y.uniforms.resolution.value = n.mapSize),
              (y.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(i, null, r, y, _, null),
              (v.uniforms.shadow_pass.value = n.mapPass.texture),
              (v.uniforms.resolution.value = n.mapSize),
              (v.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(i, null, r, v, _, null);
          }
          function q(t, e, n) {
            const i = (t << 0) | (e << 1) | (n << 2);
            let r = s[i];
            return (
              void 0 === r &&
                ((r = new Cs({
                  depthPacking: on,
                  morphTargets: t,
                  skinning: e,
                })),
                (s[i] = r)),
              r
            );
          }
          function S(t, e, n) {
            const i = (t << 0) | (e << 1) | (n << 2);
            let r = l[i];
            return (
              void 0 === r &&
                ((r = new Ps({ morphTargets: t, skinning: e })), (l[i] = r)),
              r
            );
          }
          function T(e, n, i, r, a, o, s) {
            let l = null,
              u = q,
              h = e.customDepthMaterial;
            if (
              (!0 === r.isPointLight &&
                ((u = S), (h = e.customDistanceMaterial)),
              void 0 === h)
            ) {
              let t = !1;
              !0 === i.morphTargets &&
                (t =
                  n.morphAttributes &&
                  n.morphAttributes.position &&
                  n.morphAttributes.position.length > 0);
              let r = !1;
              !0 === e.isSkinnedMesh &&
                (!0 === i.skinning
                  ? (r = !0)
                  : console.warn(
                      'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',
                      e,
                    ));
              l = u(t, r, !0 === e.isInstancedMesh);
            } else l = h;
            if (
              t.localClippingEnabled &&
              !0 === i.clipShadows &&
              0 !== i.clippingPlanes.length
            ) {
              const t = l.uuid,
                e = i.uuid;
              let n = c[t];
              void 0 === n && ((n = {}), (c[t] = n));
              let r = n[e];
              void 0 === r && ((r = l.clone()), (n[e] = r)), (l = r);
            }
            return (
              (l.visible = i.visible),
              (l.wireframe = i.wireframe),
              (l.side =
                s === p
                  ? null !== i.shadowSide
                    ? i.shadowSide
                    : i.side
                  : null !== i.shadowSide
                  ? i.shadowSide
                  : d[i.side]),
              (l.clipShadows = i.clipShadows),
              (l.clippingPlanes = i.clippingPlanes),
              (l.clipIntersection = i.clipIntersection),
              (l.wireframeLinewidth = i.wireframeLinewidth),
              (l.linewidth = i.linewidth),
              !0 === r.isPointLight &&
                !0 === l.isMeshDistanceMaterial &&
                (l.referencePosition.setFromMatrixPosition(r.matrixWorld),
                (l.nearDistance = a),
                (l.farDistance = o)),
              l
            );
          }
          function E(n, r, a, o, s) {
            if (!1 === n.visible) return;
            if (
              n.layers.test(r.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && s === p)) &&
              (!n.frustumCulled || i.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                a.matrixWorldInverse,
                n.matrixWorld,
              );
              const i = e.update(n),
                r = n.material;
              if (Array.isArray(r)) {
                const e = i.groups;
                for (let l = 0, c = e.length; l < c; l++) {
                  const c = e[l],
                    u = r[c.materialIndex];
                  if (u && u.visible) {
                    const e = T(n, i, u, o, a.near, a.far, s);
                    t.renderBufferDirect(a, null, i, e, n, c);
                  }
                }
              } else if (r.visible) {
                const e = T(n, i, r, o, a.near, a.far, s);
                t.renderBufferDirect(a, null, i, e, n, null);
              }
            }
            const l = n.children;
            for (let t = 0, e = l.length; t < e; t++) E(l[t], r, a, o, s);
          }
          (this.enabled = !1),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this.type = h),
            (this.render = function (e, n, s) {
              if (!1 === w.enabled) return;
              if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
              if (0 === e.length) return;
              const l = t.getRenderTarget(),
                c = t.getActiveCubeFace(),
                h = t.getActiveMipmapLevel(),
                d = t.state;
              d.setBlending(x),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
              for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l],
                  h = c.shadow;
                if (void 0 === h) {
                  console.warn('THREE.WebGLShadowMap:', c, 'has no shadow.');
                  continue;
                }
                if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                r.copy(h.mapSize);
                const f = h.getFrameExtents();
                if (
                  (r.multiply(f),
                  a.copy(h.mapSize),
                  (r.x > u || r.y > u) &&
                    (r.x > u &&
                      ((a.x = Math.floor(u / f.x)),
                      (r.x = a.x * f.x),
                      (h.mapSize.x = a.x)),
                    r.y > u &&
                      ((a.y = Math.floor(u / f.y)),
                      (r.y = a.y * f.y),
                      (h.mapSize.y = a.y))),
                  null === h.map && !h.isPointLightShadow && this.type === p)
                ) {
                  const t = { minFilter: xt, magFilter: xt, format: zt };
                  (h.map = new Yn(r.x, r.y, t)),
                    (h.map.texture.name = c.name + '.shadowMap'),
                    (h.mapPass = new Yn(r.x, r.y, t)),
                    h.camera.updateProjectionMatrix();
                }
                if (null === h.map) {
                  const t = { minFilter: ft, magFilter: ft, format: zt };
                  (h.map = new Yn(r.x, r.y, t)),
                    (h.map.texture.name = c.name + '.shadowMap'),
                    h.camera.updateProjectionMatrix();
                }
                t.setRenderTarget(h.map), t.clear();
                const m = h.getViewportCount();
                for (let t = 0; t < m; t++) {
                  const e = h.getViewport(t);
                  o.set(a.x * e.x, a.y * e.y, a.x * e.z, a.y * e.w),
                    d.viewport(o),
                    h.updateMatrices(c, t),
                    (i = h.getFrustum()),
                    E(n, s, h.camera, c, this.type);
                }
                h.isPointLightShadow || this.type !== p || M(h, s),
                  (h.needsUpdate = !1);
              }
              (w.needsUpdate = !1), t.setRenderTarget(l, c, h);
            });
        }
        function Is(t, e, n) {
          const i = n.isWebGL2;
          const r = new (function () {
              let e = !1;
              const n = new Xn();
              let i = null;
              const r = new Xn(0, 0, 0, 0);
              return {
                setMask: function (n) {
                  i === n || e || (t.colorMask(n, n, n, n), (i = n));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e, i, a, o, s) {
                  !0 === s && ((e *= o), (i *= o), (a *= o)),
                    n.set(e, i, a, o),
                    !1 === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n));
                },
                reset: function () {
                  (e = !1), (i = null), r.set(-1, 0, 0, 0);
                },
              };
            })(),
            a = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null;
              return {
                setTest: function (t) {
                  t ? gt(2929) : yt(2929);
                },
                setMask: function (i) {
                  n === i || e || (t.depthMask(i), (n = i));
                },
                setFunc: function (e) {
                  if (i !== e) {
                    if (e)
                      switch (e) {
                        case U:
                          t.depthFunc(512);
                          break;
                        case j:
                          t.depthFunc(519);
                          break;
                        case G:
                          t.depthFunc(513);
                          break;
                        case H:
                          t.depthFunc(515);
                          break;
                        case V:
                          t.depthFunc(514);
                          break;
                        case W:
                          t.depthFunc(518);
                          break;
                        case X:
                          t.depthFunc(516);
                          break;
                        case Y:
                          t.depthFunc(517);
                          break;
                        default:
                          t.depthFunc(515);
                      }
                    else t.depthFunc(515);
                    i = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  r !== e && (t.clearDepth(e), (r = e));
                },
                reset: function () {
                  (e = !1), (n = null), (i = null), (r = null);
                },
              };
            })(),
            c = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null,
                a = null,
                o = null,
                s = null,
                l = null,
                c = null;
              return {
                setTest: function (t) {
                  e || (t ? gt(2960) : yt(2960));
                },
                setMask: function (i) {
                  n === i || e || (t.stencilMask(i), (n = i));
                },
                setFunc: function (e, n, o) {
                  (i === e && r === n && a === o) ||
                    (t.stencilFunc(e, n, o), (i = e), (r = n), (a = o));
                },
                setOp: function (e, n, i) {
                  (o === e && s === n && l === i) ||
                    (t.stencilOp(e, n, i), (o = e), (s = n), (l = i));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  c !== e && (t.clearStencil(e), (c = e));
                },
                reset: function () {
                  (e = !1),
                    (n = null),
                    (i = null),
                    (r = null),
                    (a = null),
                    (o = null),
                    (s = null),
                    (l = null),
                    (c = null);
                },
              };
            })();
          let u = {},
            h = null,
            d = {},
            p = null,
            f = !1,
            y = null,
            v = null,
            $ = null,
            J = null,
            Z = null,
            K = null,
            Q = null,
            tt = !1,
            et = null,
            nt = null,
            it = null,
            rt = null,
            at = null;
          const ot = t.getParameter(35661);
          let st = !1,
            lt = 0;
          const ct = t.getParameter(7938);
          -1 !== ct.indexOf('WebGL')
            ? ((lt = parseFloat(/^WebGL (\d)/.exec(ct)[1])), (st = lt >= 1))
            : -1 !== ct.indexOf('OpenGL ES') &&
              ((lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1])),
              (st = lt >= 2));
          let ut = null,
            ht = {};
          const dt = new Xn(0, 0, t.canvas.width, t.canvas.height),
            pt = new Xn(0, 0, t.canvas.width, t.canvas.height);
          function ft(e, n, i) {
            const r = new Uint8Array(4),
              a = t.createTexture();
            t.bindTexture(e, a),
              t.texParameteri(e, 10241, 9728),
              t.texParameteri(e, 10240, 9728);
            for (let e = 0; e < i; e++)
              t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return a;
          }
          const mt = {};
          function gt(e) {
            !0 !== u[e] && (t.enable(e), (u[e] = !0));
          }
          function yt(e) {
            !1 !== u[e] && (t.disable(e), (u[e] = !1));
          }
          (mt[3553] = ft(3553, 3553, 1)),
            (mt[34067] = ft(34067, 34069, 6)),
            r.setClear(0, 0, 0, 1),
            a.setClear(1),
            c.setClear(0),
            gt(2929),
            a.setFunc(H),
            _t(!1),
            wt(s),
            gt(2884),
            bt(x);
          const vt = { [S]: 32774, [T]: 32778, [E]: 32779 };
          if (i) (vt[A] = 32775), (vt[L] = 32776);
          else {
            const t = e.get('EXT_blend_minmax');
            null !== t && ((vt[A] = t.MIN_EXT), (vt[L] = t.MAX_EXT));
          }
          const xt = {
            [R]: 0,
            [C]: 1,
            [P]: 768,
            [I]: 770,
            [B]: 776,
            [z]: 774,
            [O]: 772,
            [k]: 769,
            [D]: 771,
            [F]: 775,
            [N]: 773,
          };
          function bt(e, n, i, r, a, o, s, l) {
            if (e !== x) {
              if ((!1 === f && (gt(3042), (f = !0)), e === q))
                (a = a || n),
                  (o = o || i),
                  (s = s || r),
                  (n === v && a === Z) ||
                    (t.blendEquationSeparate(vt[n], vt[a]), (v = n), (Z = a)),
                  (i === $ && r === J && o === K && s === Q) ||
                    (t.blendFuncSeparate(xt[i], xt[r], xt[o], xt[s]),
                    ($ = i),
                    (J = r),
                    (K = o),
                    (Q = s)),
                  (y = e),
                  (tt = null);
              else if (e !== y || l !== tt) {
                if (
                  ((v === S && Z === S) ||
                    (t.blendEquation(32774), (v = S), (Z = S)),
                  l)
                )
                  switch (e) {
                    case b:
                      t.blendFuncSeparate(1, 771, 1, 771);
                      break;
                    case _:
                      t.blendFunc(1, 1);
                      break;
                    case w:
                      t.blendFuncSeparate(0, 0, 769, 771);
                      break;
                    case M:
                      t.blendFuncSeparate(0, 768, 0, 770);
                      break;
                    default:
                      console.error('THREE.WebGLState: Invalid blending: ', e);
                  }
                else
                  switch (e) {
                    case b:
                      t.blendFuncSeparate(770, 771, 1, 771);
                      break;
                    case _:
                      t.blendFunc(770, 1);
                      break;
                    case w:
                      t.blendFunc(0, 769);
                      break;
                    case M:
                      t.blendFunc(0, 768);
                      break;
                    default:
                      console.error('THREE.WebGLState: Invalid blending: ', e);
                  }
                ($ = null),
                  (J = null),
                  (K = null),
                  (Q = null),
                  (y = e),
                  (tt = l);
              }
            } else !0 === f && (yt(3042), (f = !1));
          }
          function _t(e) {
            et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (et = e));
          }
          function wt(e) {
            e !== o
              ? (gt(2884),
                e !== nt &&
                  (e === s
                    ? t.cullFace(1029)
                    : e === l
                    ? t.cullFace(1028)
                    : t.cullFace(1032)))
              : yt(2884),
              (nt = e);
          }
          function Mt(e, n, i) {
            e
              ? (gt(32823),
                (rt === n && at === i) ||
                  (t.polygonOffset(n, i), (rt = n), (at = i)))
              : yt(32823);
          }
          function qt(e) {
            void 0 === e && (e = 33984 + ot - 1),
              ut !== e && (t.activeTexture(e), (ut = e));
          }
          return {
            buffers: { color: r, depth: a, stencil: c },
            enable: gt,
            disable: yt,
            bindFramebuffer: function (e, n) {
              null === n && null !== h && (n = h),
                d[e] !== n && (t.bindFramebuffer(e, n), (d[e] = n));
            },
            bindXRFramebuffer: function (e) {
              e !== h && (t.bindFramebuffer(36160, e), (h = e));
            },
            useProgram: function (e) {
              return p !== e && (t.useProgram(e), (p = e), !0);
            },
            setBlending: bt,
            setMaterial: function (t, e) {
              t.side === g ? yt(2884) : gt(2884);
              let n = t.side === m;
              e && (n = !n),
                _t(n),
                t.blending === b && !1 === t.transparent
                  ? bt(x)
                  : bt(
                      t.blending,
                      t.blendEquation,
                      t.blendSrc,
                      t.blendDst,
                      t.blendEquationAlpha,
                      t.blendSrcAlpha,
                      t.blendDstAlpha,
                      t.premultipliedAlpha,
                    ),
                a.setFunc(t.depthFunc),
                a.setTest(t.depthTest),
                a.setMask(t.depthWrite),
                r.setMask(t.colorWrite);
              const i = t.stencilWrite;
              c.setTest(i),
                i &&
                  (c.setMask(t.stencilWriteMask),
                  c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                  c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                Mt(
                  t.polygonOffset,
                  t.polygonOffsetFactor,
                  t.polygonOffsetUnits,
                ),
                !0 === t.alphaToCoverage ? gt(32926) : yt(32926);
            },
            setFlipSided: _t,
            setCullFace: wt,
            setLineWidth: function (e) {
              e !== it && (st && t.lineWidth(e), (it = e));
            },
            setPolygonOffset: Mt,
            setScissorTest: function (t) {
              t ? gt(3089) : yt(3089);
            },
            activeTexture: qt,
            bindTexture: function (e, n) {
              null === ut && qt();
              let i = ht[ut];
              void 0 === i &&
                ((i = { type: void 0, texture: void 0 }), (ht[ut] = i)),
                (i.type === e && i.texture === n) ||
                  (t.bindTexture(e, n || mt[e]), (i.type = e), (i.texture = n));
            },
            unbindTexture: function () {
              const e = ht[ut];
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null),
                (e.type = void 0),
                (e.texture = void 0));
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments);
              } catch (t) {
                console.error('THREE.WebGLState:', t);
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments);
              } catch (t) {
                console.error('THREE.WebGLState:', t);
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments);
              } catch (t) {
                console.error('THREE.WebGLState:', t);
              }
            },
            scissor: function (e) {
              !1 === dt.equals(e) &&
                (t.scissor(e.x, e.y, e.z, e.w), dt.copy(e));
            },
            viewport: function (e) {
              !1 === pt.equals(e) &&
                (t.viewport(e.x, e.y, e.z, e.w), pt.copy(e));
            },
            reset: function () {
              t.disable(3042),
                t.disable(2884),
                t.disable(2929),
                t.disable(32823),
                t.disable(3089),
                t.disable(2960),
                t.disable(32926),
                t.blendEquation(32774),
                t.blendFunc(1, 0),
                t.blendFuncSeparate(1, 0, 1, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(513),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(519, 0, 4294967295),
                t.stencilOp(7680, 7680, 7680),
                t.clearStencil(0),
                t.cullFace(1029),
                t.frontFace(2305),
                t.polygonOffset(0, 0),
                t.activeTexture(33984),
                t.bindFramebuffer(36160, null),
                !0 === i &&
                  (t.bindFramebuffer(36009, null),
                  t.bindFramebuffer(36008, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (u = {}),
                (ut = null),
                (ht = {}),
                (h = null),
                (d = {}),
                (p = null),
                (f = !1),
                (y = null),
                (v = null),
                ($ = null),
                (J = null),
                (Z = null),
                (K = null),
                (Q = null),
                (tt = !1),
                (et = null),
                (nt = null),
                (it = null),
                (rt = null),
                (at = null),
                dt.set(0, 0, t.canvas.width, t.canvas.height),
                pt.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                a.reset(),
                c.reset();
            },
          };
        }
        function Ds(t, e, n, i, r, a, o) {
          const s = r.isWebGL2,
            l = r.maxTextures,
            c = r.maxCubemapSize,
            u = r.maxTextureSize,
            h = r.maxSamples,
            d = new WeakMap();
          let p,
            f = !1;
          try {
            f =
              'undefined' != typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext('2d');
          } catch (t) {}
          function m(t, e) {
            return f
              ? new OffscreenCanvas(t, e)
              : document.createElementNS(
                  'http://www.w3.org/1999/xhtml',
                  'canvas',
                );
          }
          function g(t, e, n, i) {
            let r = 1;
            if (
              ((t.width > i || t.height > i) &&
                (r = i / Math.max(t.width, t.height)),
              r < 1 || !0 === e)
            ) {
              if (
                ('undefined' != typeof HTMLImageElement &&
                  t instanceof HTMLImageElement) ||
                ('undefined' != typeof HTMLCanvasElement &&
                  t instanceof HTMLCanvasElement) ||
                ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const i = e ? Fn.floorPowerOfTwo : Math.floor,
                  a = i(r * t.width),
                  o = i(r * t.height);
                void 0 === p && (p = m(a, o));
                const s = n ? m(a, o) : p;
                (s.width = a), (s.height = o);
                return (
                  s.getContext('2d').drawImage(t, 0, 0, a, o),
                  console.warn(
                    'THREE.WebGLRenderer: Texture has been resized from (' +
                      t.width +
                      'x' +
                      t.height +
                      ') to (' +
                      a +
                      'x' +
                      o +
                      ').',
                  ),
                  s
                );
              }
              return (
                'data' in t &&
                  console.warn(
                    'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                      t.width +
                      'x' +
                      t.height +
                      ').',
                  ),
                t
              );
            }
            return t;
          }
          function y(t) {
            return Fn.isPowerOfTwo(t.width) && Fn.isPowerOfTwo(t.height);
          }
          function v(t, e) {
            return (
              t.generateMipmaps && e && t.minFilter !== ft && t.minFilter !== xt
            );
          }
          function x(e, n, r, a) {
            t.generateMipmap(e);
            i.get(n).__maxMipLevel = Math.log2(Math.max(r, a));
          }
          function b(n, i, r) {
            if (!1 === s) return i;
            if (null !== n) {
              if (void 0 !== t[n]) return t[n];
              console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                  n +
                  "'",
              );
            }
            let a = i;
            return (
              6403 === i &&
                (5126 === r && (a = 33326),
                5131 === r && (a = 33325),
                5121 === r && (a = 33321)),
              6407 === i &&
                (5126 === r && (a = 34837),
                5131 === r && (a = 34843),
                5121 === r && (a = 32849)),
              6408 === i &&
                (5126 === r && (a = 34836),
                5131 === r && (a = 34842),
                5121 === r && (a = 32856)),
              (33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a) ||
                e.get('EXT_color_buffer_float'),
              a
            );
          }
          function _(t) {
            return t === ft || t === mt || t === yt ? 9728 : 9729;
          }
          function w(e) {
            const n = e.target;
            n.removeEventListener('dispose', w),
              (function (e) {
                const n = i.get(e);
                if (void 0 === n.__webglInit) return;
                t.deleteTexture(n.__webglTexture), i.remove(e);
              })(n),
              n.isVideoTexture && d.delete(n),
              o.memory.textures--;
          }
          function M(e) {
            const n = e.target;
            n.removeEventListener('dispose', M),
              (function (e) {
                const n = e.texture,
                  r = i.get(e),
                  a = i.get(n);
                if (!e) return;
                void 0 !== a.__webglTexture &&
                  t.deleteTexture(a.__webglTexture);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLCubeRenderTarget)
                  for (let e = 0; e < 6; e++)
                    t.deleteFramebuffer(r.__webglFramebuffer[e]),
                      r.__webglDepthbuffer &&
                        t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                else
                  t.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                    r.__webglDepthRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                i.remove(n), i.remove(e);
              })(n),
              o.memory.textures--;
          }
          let q = 0;
          function S(t, e) {
            const r = i.get(t);
            if (
              (t.isVideoTexture &&
                (function (t) {
                  const e = o.render.frame;
                  d.get(t) !== e && (d.set(t, e), t.update());
                })(t),
              t.version > 0 && r.__version !== t.version)
            ) {
              const n = t.image;
              if (void 0 === n)
                console.warn(
                  'THREE.WebGLRenderer: Texture marked for update but image is undefined',
                );
              else {
                if (!1 !== n.complete) return void C(r, t, e);
                console.warn(
                  'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
                );
              }
            }
            n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
          }
          function T(e, r) {
            const o = i.get(e);
            e.version > 0 && o.__version !== e.version
              ? (function (e, i, r) {
                  if (6 !== i.image.length) return;
                  R(e, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, i.flipY),
                    t.pixelStorei(37441, i.premultiplyAlpha),
                    t.pixelStorei(3317, i.unpackAlignment),
                    t.pixelStorei(37443, 0);
                  const o =
                      i &&
                      (i.isCompressedTexture || i.image[0].isCompressedTexture),
                    l = i.image[0] && i.image[0].isDataTexture,
                    u = [];
                  for (let t = 0; t < 6; t++)
                    u[t] =
                      o || l
                        ? l
                          ? i.image[t].image
                          : i.image[t]
                        : g(i.image[t], !1, !0, c);
                  const h = u[0],
                    d = y(h) || s,
                    p = a.convert(i.format),
                    f = a.convert(i.type),
                    m = b(i.internalFormat, p, f);
                  let _;
                  if ((L(34067, i, d), o)) {
                    for (let t = 0; t < 6; t++) {
                      _ = u[t].mipmaps;
                      for (let e = 0; e < _.length; e++) {
                        const r = _[e];
                        i.format !== zt && i.format !== Nt
                          ? null !== p
                            ? n.compressedTexImage2D(
                                34069 + t,
                                e,
                                m,
                                r.width,
                                r.height,
                                0,
                                r.data,
                              )
                            : console.warn(
                                'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                              )
                          : n.texImage2D(
                              34069 + t,
                              e,
                              m,
                              r.width,
                              r.height,
                              0,
                              p,
                              f,
                              r.data,
                            );
                      }
                    }
                    e.__maxMipLevel = _.length - 1;
                  } else {
                    _ = i.mipmaps;
                    for (let t = 0; t < 6; t++)
                      if (l) {
                        n.texImage2D(
                          34069 + t,
                          0,
                          m,
                          u[t].width,
                          u[t].height,
                          0,
                          p,
                          f,
                          u[t].data,
                        );
                        for (let e = 0; e < _.length; e++) {
                          const i = _[e].image[t].image;
                          n.texImage2D(
                            34069 + t,
                            e + 1,
                            m,
                            i.width,
                            i.height,
                            0,
                            p,
                            f,
                            i.data,
                          );
                        }
                      } else {
                        n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                        for (let e = 0; e < _.length; e++) {
                          const i = _[e];
                          n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
                        }
                      }
                    e.__maxMipLevel = _.length;
                  }
                  v(i, d) && x(34067, i, h.width, h.height);
                  (e.__version = i.version), i.onUpdate && i.onUpdate(i);
                })(o, e, r)
              : (n.activeTexture(33984 + r),
                n.bindTexture(34067, o.__webglTexture));
          }
          const E = { [ht]: 10497, [dt]: 33071, [pt]: 33648 },
            A = {
              [ft]: 9728,
              [mt]: 9984,
              [yt]: 9986,
              [xt]: 9729,
              [bt]: 9985,
              [wt]: 9987,
            };
          function L(n, a, o) {
            if (
              (o
                ? (t.texParameteri(n, 10242, E[a.wrapS]),
                  t.texParameteri(n, 10243, E[a.wrapT]),
                  (32879 !== n && 35866 !== n) ||
                    t.texParameteri(n, 32882, E[a.wrapR]),
                  t.texParameteri(n, 10240, A[a.magFilter]),
                  t.texParameteri(n, 10241, A[a.minFilter]))
                : (t.texParameteri(n, 10242, 33071),
                  t.texParameteri(n, 10243, 33071),
                  (32879 !== n && 35866 !== n) ||
                    t.texParameteri(n, 32882, 33071),
                  (a.wrapS === dt && a.wrapT === dt) ||
                    console.warn(
                      'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
                    ),
                  t.texParameteri(n, 10240, _(a.magFilter)),
                  t.texParameteri(n, 10241, _(a.minFilter)),
                  a.minFilter !== ft &&
                    a.minFilter !== xt &&
                    console.warn(
                      'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
                    )),
              !0 === e.has('EXT_texture_filter_anisotropic'))
            ) {
              const o = e.get('EXT_texture_filter_anisotropic');
              if (a.type === Rt && !1 === e.has('OES_texture_float_linear'))
                return;
              if (
                !1 === s &&
                a.type === Ct &&
                !1 === e.has('OES_texture_half_float_linear')
              )
                return;
              (a.anisotropy > 1 || i.get(a).__currentAnisotropy) &&
                (t.texParameterf(
                  n,
                  o.TEXTURE_MAX_ANISOTROPY_EXT,
                  Math.min(a.anisotropy, r.getMaxAnisotropy()),
                ),
                (i.get(a).__currentAnisotropy = a.anisotropy));
            }
          }
          function R(e, n) {
            void 0 === e.__webglInit &&
              ((e.__webglInit = !0),
              n.addEventListener('dispose', w),
              (e.__webglTexture = t.createTexture()),
              o.memory.textures++);
          }
          function C(e, i, r) {
            let o = 3553;
            i.isDataTexture2DArray && (o = 35866),
              i.isDataTexture3D && (o = 32879),
              R(e, i),
              n.activeTexture(33984 + r),
              n.bindTexture(o, e.__webglTexture),
              t.pixelStorei(37440, i.flipY),
              t.pixelStorei(37441, i.premultiplyAlpha),
              t.pixelStorei(3317, i.unpackAlignment),
              t.pixelStorei(37443, 0);
            const l =
                (function (t) {
                  return (
                    !s &&
                    (t.wrapS !== dt ||
                      t.wrapT !== dt ||
                      (t.minFilter !== ft && t.minFilter !== xt))
                  );
                })(i) && !1 === y(i.image),
              c = g(i.image, l, !1, u),
              h = y(c) || s,
              d = a.convert(i.format);
            let p,
              f = a.convert(i.type),
              m = b(i.internalFormat, d, f);
            L(o, i, h);
            const _ = i.mipmaps;
            if (i.isDepthTexture)
              (m = 6402),
                s
                  ? (m =
                      i.type === Rt
                        ? 36012
                        : i.type === Lt
                        ? 33190
                        : i.type === Dt
                        ? 35056
                        : 33189)
                  : i.type === Rt &&
                    console.error(
                      'WebGLRenderer: Floating point depth texture requires WebGL2.',
                    ),
                i.format === jt &&
                  6402 === m &&
                  i.type !== Et &&
                  i.type !== Lt &&
                  (console.warn(
                    'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',
                  ),
                  (i.type = Et),
                  (f = a.convert(i.type))),
                i.format === Gt &&
                  6402 === m &&
                  ((m = 34041),
                  i.type !== Dt &&
                    (console.warn(
                      'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',
                    ),
                    (i.type = Dt),
                    (f = a.convert(i.type)))),
                n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
            else if (i.isDataTexture)
              if (_.length > 0 && h) {
                for (let t = 0, e = _.length; t < e; t++)
                  (p = _[t]),
                    n.texImage2D(
                      3553,
                      t,
                      m,
                      p.width,
                      p.height,
                      0,
                      d,
                      f,
                      p.data,
                    );
                (i.generateMipmaps = !1), (e.__maxMipLevel = _.length - 1);
              } else
                n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                  (e.__maxMipLevel = 0);
            else if (i.isCompressedTexture) {
              for (let t = 0, e = _.length; t < e; t++)
                (p = _[t]),
                  i.format !== zt && i.format !== Nt
                    ? null !== d
                      ? n.compressedTexImage2D(
                          3553,
                          t,
                          m,
                          p.width,
                          p.height,
                          0,
                          p.data,
                        )
                      : console.warn(
                          'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                        )
                    : n.texImage2D(
                        3553,
                        t,
                        m,
                        p.width,
                        p.height,
                        0,
                        d,
                        f,
                        p.data,
                      );
              e.__maxMipLevel = _.length - 1;
            } else if (i.isDataTexture2DArray)
              n.texImage3D(
                35866,
                0,
                m,
                c.width,
                c.height,
                c.depth,
                0,
                d,
                f,
                c.data,
              ),
                (e.__maxMipLevel = 0);
            else if (i.isDataTexture3D)
              n.texImage3D(
                32879,
                0,
                m,
                c.width,
                c.height,
                c.depth,
                0,
                d,
                f,
                c.data,
              ),
                (e.__maxMipLevel = 0);
            else if (_.length > 0 && h) {
              for (let t = 0, e = _.length; t < e; t++)
                (p = _[t]), n.texImage2D(3553, t, m, d, f, p);
              (i.generateMipmaps = !1), (e.__maxMipLevel = _.length - 1);
            } else n.texImage2D(3553, 0, m, d, f, c), (e.__maxMipLevel = 0);
            v(i, h) && x(o, i, c.width, c.height),
              (e.__version = i.version),
              i.onUpdate && i.onUpdate(i);
          }
          function P(e, r, o, s) {
            const l = r.texture,
              c = a.convert(l.format),
              u = a.convert(l.type),
              h = b(l.internalFormat, c, u);
            32879 === s || 35866 === s
              ? n.texImage3D(s, 0, h, r.width, r.height, r.depth, 0, c, u, null)
              : n.texImage2D(s, 0, h, r.width, r.height, 0, c, u, null),
              n.bindFramebuffer(36160, e),
              t.framebufferTexture2D(36160, o, s, i.get(l).__webglTexture, 0),
              n.bindFramebuffer(36160, null);
          }
          function k(e, n, i) {
            if (
              (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)
            ) {
              let r = 33189;
              if (i) {
                const e = n.depthTexture;
                e &&
                  e.isDepthTexture &&
                  (e.type === Rt ? (r = 36012) : e.type === Lt && (r = 33190));
                const i = D(n);
                t.renderbufferStorageMultisample(
                  36161,
                  i,
                  r,
                  n.width,
                  n.height,
                );
              } else t.renderbufferStorage(36161, r, n.width, n.height);
              t.framebufferRenderbuffer(36160, 36096, 36161, e);
            } else if (n.depthBuffer && n.stencilBuffer) {
              if (i) {
                const e = D(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  35056,
                  n.width,
                  n.height,
                );
              } else t.renderbufferStorage(36161, 34041, n.width, n.height);
              t.framebufferRenderbuffer(36160, 33306, 36161, e);
            } else {
              const e = n.texture,
                r = a.convert(e.format),
                o = a.convert(e.type),
                s = b(e.internalFormat, r, o);
              if (i) {
                const e = D(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  s,
                  n.width,
                  n.height,
                );
              } else t.renderbufferStorage(36161, s, n.width, n.height);
            }
            t.bindRenderbuffer(36161, null);
          }
          function I(e) {
            const r = i.get(e),
              a = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
              if (a)
                throw new Error(
                  'target.depthTexture not supported in Cube render targets',
                );
              !(function (e, r) {
                if (r && r.isWebGLCubeRenderTarget)
                  throw new Error(
                    'Depth Texture with cube render targets is not supported',
                  );
                if (
                  (n.bindFramebuffer(36160, e),
                  !r.depthTexture || !r.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
                  );
                (i.get(r.depthTexture).__webglTexture &&
                  r.depthTexture.image.width === r.width &&
                  r.depthTexture.image.height === r.height) ||
                  ((r.depthTexture.image.width = r.width),
                  (r.depthTexture.image.height = r.height),
                  (r.depthTexture.needsUpdate = !0)),
                  S(r.depthTexture, 0);
                const a = i.get(r.depthTexture).__webglTexture;
                if (r.depthTexture.format === jt)
                  t.framebufferTexture2D(36160, 36096, 3553, a, 0);
                else {
                  if (r.depthTexture.format !== Gt)
                    throw new Error('Unknown depthTexture format');
                  t.framebufferTexture2D(36160, 33306, 3553, a, 0);
                }
              })(r.__webglFramebuffer, e);
            } else if (a) {
              r.__webglDepthbuffer = [];
              for (let i = 0; i < 6; i++)
                n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                  (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                  k(r.__webglDepthbuffer[i], e, !1);
            } else
              n.bindFramebuffer(36160, r.__webglFramebuffer),
                (r.__webglDepthbuffer = t.createRenderbuffer()),
                k(r.__webglDepthbuffer, e, !1);
            n.bindFramebuffer(36160, null);
          }
          function D(t) {
            return s && t.isWebGLMultisampleRenderTarget
              ? Math.min(h, t.samples)
              : 0;
          }
          let O = !1,
            N = !1;
          (this.allocateTextureUnit = function () {
            const t = q;
            return (
              t >= l &&
                console.warn(
                  'THREE.WebGLTextures: Trying to use ' +
                    t +
                    ' texture units while this GPU supports only ' +
                    l,
                ),
              (q += 1),
              t
            );
          }),
            (this.resetTextureUnits = function () {
              q = 0;
            }),
            (this.setTexture2D = S),
            (this.setTexture2DArray = function (t, e) {
              const r = i.get(t);
              t.version > 0 && r.__version !== t.version
                ? C(r, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(35866, r.__webglTexture));
            }),
            (this.setTexture3D = function (t, e) {
              const r = i.get(t);
              t.version > 0 && r.__version !== t.version
                ? C(r, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(32879, r.__webglTexture));
            }),
            (this.setTextureCube = T),
            (this.setupRenderTarget = function (e) {
              const r = e.texture,
                l = i.get(e),
                c = i.get(r);
              e.addEventListener('dispose', M),
                (c.__webglTexture = t.createTexture()),
                (c.__version = r.version),
                o.memory.textures++;
              const u = !0 === e.isWebGLCubeRenderTarget,
                h = !0 === e.isWebGLMultisampleRenderTarget,
                d = r.isDataTexture3D || r.isDataTexture2DArray,
                p = y(e) || s;
              if (
                (!s ||
                  r.format !== Nt ||
                  (r.type !== Rt && r.type !== Ct) ||
                  ((r.format = zt),
                  console.warn(
                    'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.',
                  )),
                u)
              ) {
                l.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                  l.__webglFramebuffer[e] = t.createFramebuffer();
              } else if (((l.__webglFramebuffer = t.createFramebuffer()), h))
                if (s) {
                  (l.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (l.__webglColorRenderbuffer = t.createRenderbuffer()),
                    t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
                  const i = a.convert(r.format),
                    o = a.convert(r.type),
                    s = b(r.internalFormat, i, o),
                    c = D(e);
                  t.renderbufferStorageMultisample(
                    36161,
                    c,
                    s,
                    e.width,
                    e.height,
                  ),
                    n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(
                      36160,
                      36064,
                      36161,
                      l.__webglColorRenderbuffer,
                    ),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer &&
                      ((l.__webglDepthRenderbuffer = t.createRenderbuffer()),
                      k(l.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(36160, null);
                } else
                  console.warn(
                    'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                  );
              if (u) {
                n.bindTexture(34067, c.__webglTexture), L(34067, r, p);
                for (let t = 0; t < 6; t++)
                  P(l.__webglFramebuffer[t], e, 36064, 34069 + t);
                v(r, p) && x(34067, r, e.width, e.height),
                  n.bindTexture(34067, null);
              } else {
                let t = 3553;
                if (d)
                  if (s) {
                    t = r.isDataTexture3D ? 32879 : 35866;
                  } else
                    console.warn(
                      'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.',
                    );
                n.bindTexture(t, c.__webglTexture),
                  L(t, r, p),
                  P(l.__webglFramebuffer, e, 36064, t),
                  v(r, p) && x(3553, r, e.width, e.height),
                  n.bindTexture(3553, null);
              }
              e.depthBuffer && I(e);
            }),
            (this.updateRenderTargetMipmap = function (t) {
              const e = t.texture;
              if (v(e, y(t) || s)) {
                const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                  a = i.get(e).__webglTexture;
                n.bindTexture(r, a),
                  x(r, e, t.width, t.height),
                  n.bindTexture(r, null);
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (e.isWebGLMultisampleRenderTarget)
                if (s) {
                  const r = i.get(e);
                  n.bindFramebuffer(36008, r.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(36009, r.__webglFramebuffer);
                  const a = e.width,
                    o = e.height;
                  let s = 16384;
                  e.depthBuffer && (s |= 256),
                    e.stencilBuffer && (s |= 1024),
                    t.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, 9728),
                    n.bindFramebuffer(36160, r.__webglMultisampledFramebuffer);
                } else
                  console.warn(
                    'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                  );
            }),
            (this.safeSetTexture2D = function (t, e) {
              t &&
                t.isWebGLRenderTarget &&
                (!1 === O &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.",
                  ),
                  (O = !0)),
                (t = t.texture)),
                S(t, e);
            }),
            (this.safeSetTextureCube = function (t, e) {
              t &&
                t.isWebGLCubeRenderTarget &&
                (!1 === N &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
                  ),
                  (N = !0)),
                (t = t.texture)),
                T(t, e);
            });
        }
        function Os(t, e, n) {
          const i = n.isWebGL2;
          return {
            convert: function (t) {
              let n;
              if (t === qt) return 5121;
              if (t === Pt) return 32819;
              if (t === kt) return 32820;
              if (t === It) return 33635;
              if (t === St) return 5120;
              if (t === Tt) return 5122;
              if (t === Et) return 5123;
              if (t === At) return 5124;
              if (t === Lt) return 5125;
              if (t === Rt) return 5126;
              if (t === Ct)
                return i
                  ? 5131
                  : ((n = e.get('OES_texture_half_float')),
                    null !== n ? n.HALF_FLOAT_OES : null);
              if (t === Ot) return 6406;
              if (t === Nt) return 6407;
              if (t === zt) return 6408;
              if (t === Ft) return 6409;
              if (t === Bt) return 6410;
              if (t === jt) return 6402;
              if (t === Gt) return 34041;
              if (t === Ht) return 6403;
              if (t === Vt) return 36244;
              if (t === Wt) return 33319;
              if (t === Xt) return 33320;
              if (t === Yt) return 36248;
              if (t === $t) return 36249;
              if (t === Jt || t === Zt || t === Kt || t === Qt) {
                if (((n = e.get('WEBGL_compressed_texture_s3tc')), null === n))
                  return null;
                if (t === Jt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (t === Zt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (t === Kt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (t === Qt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
              if (t === te || t === ee || t === ne || t === ie) {
                if (((n = e.get('WEBGL_compressed_texture_pvrtc')), null === n))
                  return null;
                if (t === te) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (t === ee) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (t === ne) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (t === ie) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
              if (t === re)
                return (
                  (n = e.get('WEBGL_compressed_texture_etc1')),
                  null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
                );
              if (
                (t === ae || t === oe) &&
                ((n = e.get('WEBGL_compressed_texture_etc')), null !== n)
              ) {
                if (t === ae) return n.COMPRESSED_RGB8_ETC2;
                if (t === oe) return n.COMPRESSED_RGBA8_ETC2_EAC;
              }
              return t === se ||
                t === le ||
                t === ce ||
                t === ue ||
                t === he ||
                t === de ||
                t === pe ||
                t === fe ||
                t === me ||
                t === ge ||
                t === ye ||
                t === ve ||
                t === xe ||
                t === be ||
                t === we ||
                t === Me ||
                t === qe ||
                t === Se ||
                t === Te ||
                t === Ee ||
                t === Ae ||
                t === Le ||
                t === Re ||
                t === Ce ||
                t === Pe ||
                t === ke ||
                t === Ie ||
                t === De
                ? ((n = e.get('WEBGL_compressed_texture_astc')),
                  null !== n ? t : null)
                : t === _e
                ? ((n = e.get('EXT_texture_compression_bptc')),
                  null !== n ? t : null)
                : t === Dt
                ? i
                  ? 34042
                  : ((n = e.get('WEBGL_depth_texture')),
                    null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
                : void 0;
            },
          };
        }
        class Ns extends ba {
          constructor(t = []) {
            super(), (this.cameras = t);
          }
        }
        Ns.prototype.isArrayCamera = !0;
        class zs extends Qi {
          constructor() {
            super(), (this.type = 'Group');
          }
        }
        function Fs() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        function Bs(t, e) {
          const n = this,
            i = t.state;
          let r = null,
            a = 1,
            o = null,
            s = 'local-floor',
            l = null;
          const c = [],
            u = new Map(),
            h = new ba();
          h.layers.enable(1), (h.viewport = new Xn());
          const d = new ba();
          d.layers.enable(2), (d.viewport = new Xn());
          const p = [h, d],
            f = new Ns();
          f.layers.enable(1), f.layers.enable(2);
          let m = null,
            g = null;
          function y(t) {
            const e = u.get(t.inputSource);
            e && e.dispatchEvent({ type: t.type, data: t.inputSource });
          }
          function v() {
            u.forEach(function (t, e) {
              t.disconnect(e);
            }),
              u.clear(),
              (m = null),
              (g = null),
              i.bindXRFramebuffer(null),
              t.setRenderTarget(t.getRenderTarget()),
              q.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({ type: 'sessionend' });
          }
          function x(t) {
            const e = r.inputSources;
            for (let t = 0; t < c.length; t++) u.set(e[t], c[t]);
            for (let e = 0; e < t.removed.length; e++) {
              const n = t.removed[e],
                i = u.get(n);
              i &&
                (i.dispatchEvent({ type: 'disconnected', data: n }),
                u.delete(n));
            }
            for (let e = 0; e < t.added.length; e++) {
              const n = t.added[e],
                i = u.get(n);
              i && i.dispatchEvent({ type: 'connected', data: n });
            }
          }
          (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = c[t];
              return (
                void 0 === e && ((e = new Fs()), (c[t] = e)),
                e.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (t) {
              let e = c[t];
              return (
                void 0 === e && ((e = new Fs()), (c[t] = e)), e.getGripSpace()
              );
            }),
            (this.getHand = function (t) {
              let e = c[t];
              return (
                void 0 === e && ((e = new Fs()), (c[t] = e)), e.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (t) {
              (a = t),
                !0 === n.isPresenting &&
                  console.warn(
                    'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',
                  );
            }),
            (this.setReferenceSpaceType = function (t) {
              (s = t),
                !0 === n.isPresenting &&
                  console.warn(
                    'THREE.WebXRManager: Cannot change reference space type while presenting.',
                  );
            }),
            (this.getReferenceSpace = function () {
              return o;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = async function (t) {
              if (((r = t), null !== r)) {
                r.addEventListener('select', y),
                  r.addEventListener('selectstart', y),
                  r.addEventListener('selectend', y),
                  r.addEventListener('squeeze', y),
                  r.addEventListener('squeezestart', y),
                  r.addEventListener('squeezeend', y),
                  r.addEventListener('end', v),
                  r.addEventListener('inputsourceschange', x);
                const t = e.getContextAttributes();
                !0 !== t.xrCompatible && (await e.makeXRCompatible());
                const i = {
                    antialias: t.antialias,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: a,
                  },
                  l = new XRWebGLLayer(r, e, i);
                r.updateRenderState({ baseLayer: l }),
                  (o = await r.requestReferenceSpace(s)),
                  q.setContext(r),
                  q.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: 'sessionstart' });
              }
            });
          const b = new Zn(),
            _ = new Zn();
          function w(t, e) {
            null === e
              ? t.matrixWorld.copy(t.matrix)
              : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert();
          }
          this.getCamera = function (t) {
            (f.near = d.near = h.near = t.near),
              (f.far = d.far = h.far = t.far),
              (m === f.near && g === f.far) ||
                (r.updateRenderState({ depthNear: f.near, depthFar: f.far }),
                (m = f.near),
                (g = f.far));
            const e = t.parent,
              n = f.cameras;
            w(f, e);
            for (let t = 0; t < n.length; t++) w(n[t], e);
            t.matrixWorld.copy(f.matrixWorld),
              t.matrix.copy(f.matrix),
              t.matrix.decompose(t.position, t.quaternion, t.scale);
            const i = t.children;
            for (let t = 0, e = i.length; t < e; t++)
              i[t].updateMatrixWorld(!0);
            return (
              2 === n.length
                ? (function (t, e, n) {
                    b.setFromMatrixPosition(e.matrixWorld),
                      _.setFromMatrixPosition(n.matrixWorld);
                    const i = b.distanceTo(_),
                      r = e.projectionMatrix.elements,
                      a = n.projectionMatrix.elements,
                      o = r[14] / (r[10] - 1),
                      s = r[14] / (r[10] + 1),
                      l = (r[9] + 1) / r[5],
                      c = (r[9] - 1) / r[5],
                      u = (r[8] - 1) / r[0],
                      h = (a[8] + 1) / a[0],
                      d = o * u,
                      p = o * h,
                      f = i / (-u + h),
                      m = f * -u;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                      t.translateX(m),
                      t.translateZ(f),
                      t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                      t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = o + f,
                      y = s + f,
                      v = d - m,
                      x = p + (i - m),
                      w = ((l * s) / y) * g,
                      M = ((c * s) / y) * g;
                    t.projectionMatrix.makePerspective(v, x, w, M, g, y);
                  })(f, h, d)
                : f.projectionMatrix.copy(h.projectionMatrix),
              f
            );
          };
          let M = null;
          const q = new Aa();
          q.setAnimationLoop(function (t, e) {
            if (((l = e.getViewerPose(o)), null !== l)) {
              const t = l.views,
                e = r.renderState.baseLayer;
              i.bindXRFramebuffer(e.framebuffer);
              let n = !1;
              t.length !== f.cameras.length &&
                ((f.cameras.length = 0), (n = !0));
              for (let i = 0; i < t.length; i++) {
                const r = t[i],
                  a = e.getViewport(r),
                  o = p[i];
                o.matrix.fromArray(r.transform.matrix),
                  o.projectionMatrix.fromArray(r.projectionMatrix),
                  o.viewport.set(a.x, a.y, a.width, a.height),
                  0 === i && f.matrix.copy(o.matrix),
                  !0 === n && f.cameras.push(o);
              }
            }
            const n = r.inputSources;
            for (let t = 0; t < c.length; t++) {
              const i = c[t],
                r = n[t];
              i.update(r, e, o);
            }
            M && M(t, e);
          }),
            (this.setAnimationLoop = function (t) {
              M = t;
            }),
            (this.dispose = function () {});
        }
        function Us(t) {
          function e(e, n) {
            (e.opacity.value = n.opacity),
              n.color && e.diffuse.value.copy(n.color),
              n.emissive &&
                e.emissive.value
                  .copy(n.emissive)
                  .multiplyScalar(n.emissiveIntensity),
              n.map && (e.map.value = n.map),
              n.alphaMap && (e.alphaMap.value = n.alphaMap),
              n.specularMap && (e.specularMap.value = n.specularMap);
            const i = t.get(n).envMap;
            if (i) {
              (e.envMap.value = i),
                (e.flipEnvMap.value =
                  i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1),
                (e.reflectivity.value = n.reflectivity),
                (e.refractionRatio.value = n.refractionRatio);
              const r = t.get(i).__maxMipLevel;
              void 0 !== r && (e.maxMipLevel.value = r);
            }
            let r, a;
            n.lightMap &&
              ((e.lightMap.value = n.lightMap),
              (e.lightMapIntensity.value = n.lightMapIntensity)),
              n.aoMap &&
                ((e.aoMap.value = n.aoMap),
                (e.aoMapIntensity.value = n.aoMapIntensity)),
              n.map
                ? (r = n.map)
                : n.specularMap
                ? (r = n.specularMap)
                : n.displacementMap
                ? (r = n.displacementMap)
                : n.normalMap
                ? (r = n.normalMap)
                : n.bumpMap
                ? (r = n.bumpMap)
                : n.roughnessMap
                ? (r = n.roughnessMap)
                : n.metalnessMap
                ? (r = n.metalnessMap)
                : n.alphaMap
                ? (r = n.alphaMap)
                : n.emissiveMap
                ? (r = n.emissiveMap)
                : n.clearcoatMap
                ? (r = n.clearcoatMap)
                : n.clearcoatNormalMap
                ? (r = n.clearcoatNormalMap)
                : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
              void 0 !== r &&
                (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix)),
              n.aoMap ? (a = n.aoMap) : n.lightMap && (a = n.lightMap),
              void 0 !== a &&
                (a.isWebGLRenderTarget && (a = a.texture),
                !0 === a.matrixAutoUpdate && a.updateMatrix(),
                e.uv2Transform.value.copy(a.matrix));
          }
          function n(e, n) {
            (e.roughness.value = n.roughness),
              (e.metalness.value = n.metalness),
              n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
              n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
              n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
              n.bumpMap &&
                ((e.bumpMap.value = n.bumpMap),
                (e.bumpScale.value = n.bumpScale),
                n.side === m && (e.bumpScale.value *= -1)),
              n.normalMap &&
                ((e.normalMap.value = n.normalMap),
                e.normalScale.value.copy(n.normalScale),
                n.side === m && e.normalScale.value.negate()),
              n.displacementMap &&
                ((e.displacementMap.value = n.displacementMap),
                (e.displacementScale.value = n.displacementScale),
                (e.displacementBias.value = n.displacementBias));
            t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
          }
          return {
            refreshFogUniforms: function (t, e) {
              t.fogColor.value.copy(e.color),
                e.isFog
                  ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                  : e.isFogExp2 && (t.fogDensity.value = e.density);
            },
            refreshMaterialUniforms: function (t, i, r, a) {
              i.isMeshBasicMaterial
                ? e(t, i)
                : i.isMeshLambertMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                  })(t, i))
                : i.isMeshToonMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === m && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === m && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshPhongMaterial
                ? (e(t, i),
                  (function (t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4)),
                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === m && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === m && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshStandardMaterial
                ? (e(t, i),
                  i.isMeshPhysicalMaterial
                    ? (function (t, e) {
                        n(t, e),
                          (t.reflectivity.value = e.reflectivity),
                          (t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.sheen && t.sheen.value.copy(e.sheen);
                        e.clearcoatMap &&
                          (t.clearcoatMap.value = e.clearcoatMap);
                        e.clearcoatRoughnessMap &&
                          (t.clearcoatRoughnessMap.value =
                            e.clearcoatRoughnessMap);
                        e.clearcoatNormalMap &&
                          (t.clearcoatNormalScale.value.copy(
                            e.clearcoatNormalScale,
                          ),
                          (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                          e.side === m &&
                            t.clearcoatNormalScale.value.negate());
                        (t.transmission.value = e.transmission),
                          e.transmissionMap &&
                            (t.transmissionMap.value = e.transmissionMap);
                      })(t, i)
                    : n(t, i))
                : i.isMeshMatcapMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === m && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === m && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshDepthMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshDistanceMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                    t.referencePosition.value.copy(e.referencePosition),
                      (t.nearDistance.value = e.nearDistance),
                      (t.farDistance.value = e.farDistance);
                  })(t, i))
                : i.isMeshNormalMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === m && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === m && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isLineBasicMaterial
                ? ((function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity);
                  })(t, i),
                  i.isLineDashedMaterial &&
                    (function (t, e) {
                      (t.dashSize.value = e.dashSize),
                        (t.totalSize.value = e.dashSize + e.gapSize),
                        (t.scale.value = e.scale);
                    })(t, i))
                : i.isPointsMaterial
                ? (function (t, e, n, i) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * n),
                      (t.scale.value = 0.5 * i),
                      e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let r;
                    e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);
                    void 0 !== r &&
                      (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                      t.uvTransform.value.copy(r.matrix));
                  })(t, i, r, a)
                : i.isSpriteMaterial
                ? (function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let n;
                    e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      t.uvTransform.value.copy(n.matrix));
                  })(t, i)
                : i.isShadowMaterial
                ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
                : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
            },
          };
        }
        function js(t) {
          const e =
              void 0 !== (t = t || {}).canvas
                ? t.canvas
                : (function () {
                    const t = document.createElementNS(
                      'http://www.w3.org/1999/xhtml',
                      'canvas',
                    );
                    return (t.style.display = 'block'), t;
                  })(),
            n = void 0 !== t.context ? t.context : null,
            i = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            a = void 0 === t.stencil || t.stencil,
            o = void 0 !== t.antialias && t.antialias,
            s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            c = void 0 !== t.powerPreference ? t.powerPreference : 'default',
            u =
              void 0 !== t.failIfMajorPerformanceCaveat &&
              t.failIfMajorPerformanceCaveat;
          let h = null,
            d = null;
          const p = [],
            f = [];
          (this.domElement = e),
            (this.debug = { checkShaderErrors: !0 }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.gammaFactor = 2),
            (this.outputEncoding = Je),
            (this.physicallyCorrectLights = !1),
            (this.toneMapping = K),
            (this.toneMappingExposure = 1);
          const m = this;
          let g = !1,
            y = 0,
            v = 0,
            x = null,
            b = -1,
            _ = null;
          const w = new Xn(),
            M = new Xn();
          let q = null,
            S = e.width,
            T = e.height,
            E = 1,
            A = null,
            L = null;
          const R = new Xn(0, 0, S, T),
            C = new Xn(0, 0, S, T);
          let P = !1;
          const k = new Ea();
          let I = !1,
            D = !1;
          const O = new Ai(),
            N = new Zn(),
            z = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          function F() {
            return null === x ? E : 1;
          }
          let B,
            U,
            j,
            G,
            H,
            V,
            W,
            X,
            Y,
            $,
            J,
            Z,
            Q,
            tt,
            et,
            nt,
            it,
            rt,
            at,
            ot,
            st,
            lt,
            ct = n;
          function ut(t, n) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i],
                a = e.getContext(r, n);
              if (null !== a) return a;
            }
            return null;
          }
          try {
            const t = {
              alpha: i,
              depth: r,
              stencil: a,
              antialias: o,
              premultipliedAlpha: s,
              preserveDrawingBuffer: l,
              powerPreference: c,
              failIfMajorPerformanceCaveat: u,
            };
            if (
              (e.addEventListener('webglcontextlost', pt, !1),
              e.addEventListener('webglcontextrestored', ft, !1),
              null === ct)
            ) {
              const e = ['webgl2', 'webgl', 'experimental-webgl'];
              if (
                (!0 === m.isWebGL1Renderer && e.shift(),
                (ct = ut(e, t)),
                null === ct)
              )
                throw ut(e)
                  ? new Error(
                      'Error creating WebGL context with your selected attributes.',
                    )
                  : new Error('Error creating WebGL context.');
            }
            void 0 === ct.getShaderPrecisionFormat &&
              (ct.getShaderPrecisionFormat = function () {
                return { rangeMin: 1, rangeMax: 1, precision: 1 };
              });
          } catch (t) {
            throw (console.error('THREE.WebGLRenderer: ' + t.message), t);
          }
          function ht() {
            (B = new Ba(ct)),
              (U = new Na(ct, B, t)),
              B.init(U),
              (st = new Os(ct, B, U)),
              (j = new Is(ct, B, U)),
              (G = new Ga(ct)),
              (H = new bs()),
              (V = new Ds(ct, B, j, H, U, st, G)),
              (W = new Fa(m)),
              (X = new La(ct, U)),
              (lt = new Da(ct, B, X, U)),
              (Y = new Ua(ct, X, G, lt)),
              ($ = new Xa(ct, Y, X, G)),
              (rt = new Wa(ct)),
              (et = new za(H)),
              (J = new xs(m, W, B, U, lt, et)),
              (Z = new Us(H)),
              (Q = new qs(H)),
              (tt = new Rs(B, U)),
              (it = new Ia(m, W, j, $, s)),
              (nt = new ks(m, $, U)),
              (at = new Oa(ct, B, G, U)),
              (ot = new ja(ct, B, G, U)),
              (G.programs = J.programs),
              (m.capabilities = U),
              (m.extensions = B),
              (m.properties = H),
              (m.renderLists = Q),
              (m.shadowMap = nt),
              (m.state = j),
              (m.info = G);
          }
          ht();
          const dt = new Bs(m, ct);
          function pt(t) {
            t.preventDefault(),
              console.log('THREE.WebGLRenderer: Context Lost.'),
              (g = !0);
          }
          function ft() {
            console.log('THREE.WebGLRenderer: Context Restored.'), (g = !1);
            const t = G.autoReset,
              e = nt.enabled,
              n = nt.autoUpdate,
              i = nt.needsUpdate,
              r = nt.type;
            ht(),
              (G.autoReset = t),
              (nt.enabled = e),
              (nt.autoUpdate = n),
              (nt.needsUpdate = i),
              (nt.type = r);
          }
          function mt(t) {
            const e = t.target;
            e.removeEventListener('dispose', mt),
              (function (t) {
                (function (t) {
                  const e = H.get(t).programs;
                  void 0 !== e &&
                    e.forEach(function (t) {
                      J.releaseProgram(t);
                    });
                })(t),
                  H.remove(t);
              })(e);
          }
          (this.xr = dt),
            (this.getContext = function () {
              return ct;
            }),
            (this.getContextAttributes = function () {
              return ct.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const t = B.get('WEBGL_lose_context');
              t && t.loseContext();
            }),
            (this.forceContextRestore = function () {
              const t = B.get('WEBGL_lose_context');
              t && t.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return E;
            }),
            (this.setPixelRatio = function (t) {
              void 0 !== t && ((E = t), this.setSize(S, T, !1));
            }),
            (this.getSize = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    'WebGLRenderer: .getsize() now requires a Vector2 as an argument',
                  ),
                  (t = new Bn())),
                t.set(S, T)
              );
            }),
            (this.setSize = function (t, n, i) {
              dt.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
                  )
                : ((S = t),
                  (T = n),
                  (e.width = Math.floor(t * E)),
                  (e.height = Math.floor(n * E)),
                  !1 !== i &&
                    ((e.style.width = t + 'px'), (e.style.height = n + 'px')),
                  this.setViewport(0, 0, t, n));
            }),
            (this.getDrawingBufferSize = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument',
                  ),
                  (t = new Bn())),
                t.set(S * E, T * E).floor()
              );
            }),
            (this.setDrawingBufferSize = function (t, n, i) {
              (S = t),
                (T = n),
                (E = i),
                (e.width = Math.floor(t * i)),
                (e.height = Math.floor(n * i)),
                this.setViewport(0, 0, t, n);
            }),
            (this.getCurrentViewport = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument',
                  ),
                  (t = new Xn())),
                t.copy(w)
              );
            }),
            (this.getViewport = function (t) {
              return t.copy(R);
            }),
            (this.setViewport = function (t, e, n, i) {
              t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i),
                j.viewport(w.copy(R).multiplyScalar(E).floor());
            }),
            (this.getScissor = function (t) {
              return t.copy(C);
            }),
            (this.setScissor = function (t, e, n, i) {
              t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i),
                j.scissor(M.copy(C).multiplyScalar(E).floor());
            }),
            (this.getScissorTest = function () {
              return P;
            }),
            (this.setScissorTest = function (t) {
              j.setScissorTest((P = t));
            }),
            (this.setOpaqueSort = function (t) {
              A = t;
            }),
            (this.setTransparentSort = function (t) {
              L = t;
            }),
            (this.getClearColor = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    'WebGLRenderer: .getClearColor() now requires a Color as an argument',
                  ),
                  (t = new Mr())),
                t.copy(it.getClearColor())
              );
            }),
            (this.setClearColor = function () {
              it.setClearColor.apply(it, arguments);
            }),
            (this.getClearAlpha = function () {
              return it.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              it.setClearAlpha.apply(it, arguments);
            }),
            (this.clear = function (t, e, n) {
              let i = 0;
              (void 0 === t || t) && (i |= 16384),
                (void 0 === e || e) && (i |= 256),
                (void 0 === n || n) && (i |= 1024),
                ct.clear(i);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              e.removeEventListener('webglcontextlost', pt, !1),
                e.removeEventListener('webglcontextrestored', ft, !1),
                Q.dispose(),
                tt.dispose(),
                H.dispose(),
                W.dispose(),
                $.dispose(),
                lt.dispose(),
                dt.dispose(),
                dt.removeEventListener('sessionstart', yt),
                dt.removeEventListener('sessionend', vt),
                xt.stop();
            }),
            (this.renderBufferImmediate = function (t, e) {
              lt.initAttributes();
              const n = H.get(t);
              t.hasPositions && !n.position && (n.position = ct.createBuffer()),
                t.hasNormals && !n.normal && (n.normal = ct.createBuffer()),
                t.hasUvs && !n.uv && (n.uv = ct.createBuffer()),
                t.hasColors && !n.color && (n.color = ct.createBuffer());
              const i = e.getAttributes();
              t.hasPositions &&
                (ct.bindBuffer(34962, n.position),
                ct.bufferData(34962, t.positionArray, 35048),
                lt.enableAttribute(i.position),
                ct.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
                t.hasNormals &&
                  (ct.bindBuffer(34962, n.normal),
                  ct.bufferData(34962, t.normalArray, 35048),
                  lt.enableAttribute(i.normal),
                  ct.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
                t.hasUvs &&
                  (ct.bindBuffer(34962, n.uv),
                  ct.bufferData(34962, t.uvArray, 35048),
                  lt.enableAttribute(i.uv),
                  ct.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
                t.hasColors &&
                  (ct.bindBuffer(34962, n.color),
                  ct.bufferData(34962, t.colorArray, 35048),
                  lt.enableAttribute(i.color),
                  ct.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
                lt.disableUnusedAttributes(),
                ct.drawArrays(4, 0, t.count),
                (t.count = 0);
            }),
            (this.renderBufferDirect = function (t, e, n, i, r, a) {
              null === e && (e = z);
              const o = r.isMesh && r.matrixWorld.determinant() < 0,
                s = Tt(t, e, i, r);
              j.setMaterial(i, o);
              let l = n.index;
              const c = n.attributes.position;
              if (null === l) {
                if (void 0 === c || 0 === c.count) return;
              } else if (0 === l.count) return;
              let u,
                h = 1;
              !0 === i.wireframe && ((l = Y.getWireframeAttribute(n)), (h = 2)),
                (i.morphTargets || i.morphNormals) && rt.update(r, n, i, s),
                lt.setup(r, i, s, n, l);
              let d = at;
              null !== l && ((u = X.get(l)), (d = ot), d.setIndex(u));
              const p = null !== l ? l.count : c.count,
                f = n.drawRange.start * h,
                m = n.drawRange.count * h,
                g = null !== a ? a.start * h : 0,
                y = null !== a ? a.count * h : 1 / 0,
                v = Math.max(f, g),
                x = Math.min(p, f + m, g + y) - 1,
                b = Math.max(0, x - v + 1);
              if (0 !== b) {
                if (r.isMesh)
                  !0 === i.wireframe
                    ? (j.setLineWidth(i.wireframeLinewidth * F()), d.setMode(1))
                    : d.setMode(4);
                else if (r.isLine) {
                  let t = i.linewidth;
                  void 0 === t && (t = 1),
                    j.setLineWidth(t * F()),
                    r.isLineSegments
                      ? d.setMode(1)
                      : r.isLineLoop
                      ? d.setMode(2)
                      : d.setMode(3);
                } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                if (r.isInstancedMesh) d.renderInstances(v, b, r.count);
                else if (n.isInstancedBufferGeometry) {
                  const t = Math.min(n.instanceCount, n._maxInstanceCount);
                  d.renderInstances(v, b, t);
                } else d.render(v, b);
              }
            }),
            (this.compile = function (t, e) {
              (d = tt.get(t)),
                d.init(),
                t.traverseVisible(function (t) {
                  t.isLight &&
                    t.layers.test(e.layers) &&
                    (d.pushLight(t), t.castShadow && d.pushShadow(t));
                }),
                d.setupLights(),
                t.traverse(function (e) {
                  const n = e.material;
                  if (n)
                    if (Array.isArray(n))
                      for (let i = 0; i < n.length; i++) {
                        Mt(n[i], t, e);
                      }
                    else Mt(n, t, e);
                });
            });
          let gt = null;
          function yt() {
            xt.stop();
          }
          function vt() {
            xt.start();
          }
          const xt = new Aa();
          function bt(t, e, n, i) {
            if (!1 === t.visible) return;
            if (t.layers.test(e.layers))
              if (t.isGroup) n = t.renderOrder;
              else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
              else if (t.isLight)
                d.pushLight(t), t.castShadow && d.pushShadow(t);
              else if (t.isSprite) {
                if (!t.frustumCulled || k.intersectsSprite(t)) {
                  i && N.setFromMatrixPosition(t.matrixWorld).applyMatrix4(O);
                  const e = $.update(t),
                    r = t.material;
                  r.visible && h.push(t, e, r, n, N.z, null);
                }
              } else if (t.isImmediateRenderObject)
                i && N.setFromMatrixPosition(t.matrixWorld).applyMatrix4(O),
                  h.push(t, null, t.material, n, N.z, null);
              else if (
                (t.isMesh || t.isLine || t.isPoints) &&
                (t.isSkinnedMesh &&
                  t.skeleton.frame !== G.render.frame &&
                  (t.skeleton.update(), (t.skeleton.frame = G.render.frame)),
                !t.frustumCulled || k.intersectsObject(t))
              ) {
                i && N.setFromMatrixPosition(t.matrixWorld).applyMatrix4(O);
                const e = $.update(t),
                  r = t.material;
                if (Array.isArray(r)) {
                  const i = e.groups;
                  for (let a = 0, o = i.length; a < o; a++) {
                    const o = i[a],
                      s = r[o.materialIndex];
                    s && s.visible && h.push(t, e, s, n, N.z, o);
                  }
                } else r.visible && h.push(t, e, r, n, N.z, null);
              }
            const r = t.children;
            for (let t = 0, a = r.length; t < a; t++) bt(r[t], e, n, i);
          }
          function _t(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null;
            for (let r = 0, a = t.length; r < a; r++) {
              const a = t[r],
                o = a.object,
                s = a.geometry,
                l = null === i ? a.material : i,
                c = a.group;
              if (n.isArrayCamera) {
                const t = n.cameras;
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = t[n];
                  o.layers.test(i.layers) &&
                    (j.viewport(w.copy(i.viewport)),
                    d.setupLightsView(i),
                    wt(o, e, i, s, l, c));
                }
              } else wt(o, e, n, s, l, c);
            }
          }
          function wt(t, e, n, i, r, a) {
            if (
              (t.onBeforeRender(m, e, n, i, r, a),
              t.modelViewMatrix.multiplyMatrices(
                n.matrixWorldInverse,
                t.matrixWorld,
              ),
              t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
              t.isImmediateRenderObject)
            ) {
              const i = Tt(n, e, r, t);
              j.setMaterial(r),
                lt.reset(),
                (function (t, e) {
                  t.render(function (t) {
                    m.renderBufferImmediate(t, e);
                  });
                })(t, i);
            } else m.renderBufferDirect(n, e, i, r, t, a);
            t.onAfterRender(m, e, n, i, r, a);
          }
          function Mt(t, e, n) {
            !0 !== e.isScene && (e = z);
            const i = H.get(t),
              r = d.state.lights,
              a = d.state.shadowsArray,
              o = r.state.version,
              s = J.getParameters(t, r.state, a, e, n),
              l = J.getProgramCacheKey(s);
            let c = i.programs;
            (i.environment = t.isMeshStandardMaterial ? e.environment : null),
              (i.fog = e.fog),
              (i.envMap = W.get(t.envMap || i.environment)),
              void 0 === c &&
                (t.addEventListener('dispose', mt),
                (c = new Map()),
                (i.programs = c));
            let u = c.get(l);
            if (void 0 !== u) {
              if (i.currentProgram === u && i.lightsStateVersion === o)
                return St(t, s), u;
            } else
              (s.uniforms = J.getUniforms(t)),
                t.onBeforeCompile(s, m),
                (u = J.acquireProgram(s, l)),
                c.set(l, u),
                (i.uniforms = s.uniforms);
            const h = i.uniforms;
            ((t.isShaderMaterial || t.isRawShaderMaterial) &&
              !0 !== t.clipping) ||
              (h.clippingPlanes = et.uniform),
              St(t, s),
              (i.needsLights = (function (t) {
                return (
                  t.isMeshLambertMaterial ||
                  t.isMeshToonMaterial ||
                  t.isMeshPhongMaterial ||
                  t.isMeshStandardMaterial ||
                  t.isShadowMaterial ||
                  (t.isShaderMaterial && !0 === t.lights)
                );
              })(t)),
              (i.lightsStateVersion = o),
              i.needsLights &&
                ((h.ambientLightColor.value = r.state.ambient),
                (h.lightProbe.value = r.state.probe),
                (h.directionalLights.value = r.state.directional),
                (h.directionalLightShadows.value = r.state.directionalShadow),
                (h.spotLights.value = r.state.spot),
                (h.spotLightShadows.value = r.state.spotShadow),
                (h.rectAreaLights.value = r.state.rectArea),
                (h.ltc_1.value = r.state.rectAreaLTC1),
                (h.ltc_2.value = r.state.rectAreaLTC2),
                (h.pointLights.value = r.state.point),
                (h.pointLightShadows.value = r.state.pointShadow),
                (h.hemisphereLights.value = r.state.hemi),
                (h.directionalShadowMap.value = r.state.directionalShadowMap),
                (h.directionalShadowMatrix.value =
                  r.state.directionalShadowMatrix),
                (h.spotShadowMap.value = r.state.spotShadowMap),
                (h.spotShadowMatrix.value = r.state.spotShadowMatrix),
                (h.pointShadowMap.value = r.state.pointShadowMap),
                (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
            const p = u.getUniforms(),
              f = Ko.seqWithValue(p.seq, h);
            return (i.currentProgram = u), (i.uniformsList = f), u;
          }
          function St(t, e) {
            const n = H.get(t);
            (n.outputEncoding = e.outputEncoding),
              (n.instancing = e.instancing),
              (n.numClippingPlanes = e.numClippingPlanes),
              (n.numIntersection = e.numClipIntersection),
              (n.vertexAlphas = e.vertexAlphas);
          }
          function Tt(t, e, n, i) {
            !0 !== e.isScene && (e = z), V.resetTextureUnits();
            const r = e.fog,
              a = n.isMeshStandardMaterial ? e.environment : null,
              o = null === x ? m.outputEncoding : x.texture.encoding,
              s = W.get(n.envMap || a),
              l =
                !0 === n.vertexColors &&
                i.geometry.attributes.color &&
                4 === i.geometry.attributes.color.itemSize,
              c = H.get(n),
              u = d.state.lights;
            if (!0 === I && (!0 === D || t !== _)) {
              const e = t === _ && n.id === b;
              et.setState(n, t, e);
            }
            let h = !1;
            n.version === c.__version
              ? (c.needsLights && c.lightsStateVersion !== u.state.version) ||
                c.outputEncoding !== o ||
                (i.isInstancedMesh && !1 === c.instancing)
                ? (h = !0)
                : i.isInstancedMesh || !0 !== c.instancing
                ? c.envMap !== s || (n.fog && c.fog !== r)
                  ? (h = !0)
                  : void 0 === c.numClippingPlanes ||
                    (c.numClippingPlanes === et.numPlanes &&
                      c.numIntersection === et.numIntersection)
                  ? c.vertexAlphas !== l && (h = !0)
                  : (h = !0)
                : (h = !0)
              : ((h = !0), (c.__version = n.version));
            let p = c.currentProgram;
            !0 === h && (p = Mt(n, e, i));
            let f = !1,
              g = !1,
              y = !1;
            const v = p.getUniforms(),
              w = c.uniforms;
            if (
              (j.useProgram(p.program) && ((f = !0), (g = !0), (y = !0)),
              n.id !== b && ((b = n.id), (g = !0)),
              f || _ !== t)
            ) {
              if (
                (v.setValue(ct, 'projectionMatrix', t.projectionMatrix),
                U.logarithmicDepthBuffer &&
                  v.setValue(
                    ct,
                    'logDepthBufFC',
                    2 / (Math.log(t.far + 1) / Math.LN2),
                  ),
                _ !== t && ((_ = t), (g = !0), (y = !0)),
                n.isShaderMaterial ||
                  n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshStandardMaterial ||
                  n.envMap)
              ) {
                const e = v.map.cameraPosition;
                void 0 !== e &&
                  e.setValue(ct, N.setFromMatrixPosition(t.matrixWorld));
              }
              (n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshLambertMaterial ||
                n.isMeshBasicMaterial ||
                n.isMeshStandardMaterial ||
                n.isShaderMaterial) &&
                v.setValue(ct, 'isOrthographic', !0 === t.isOrthographicCamera),
                (n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshLambertMaterial ||
                  n.isMeshBasicMaterial ||
                  n.isMeshStandardMaterial ||
                  n.isShaderMaterial ||
                  n.isShadowMaterial ||
                  n.skinning) &&
                  v.setValue(ct, 'viewMatrix', t.matrixWorldInverse);
            }
            if (n.skinning) {
              v.setOptional(ct, i, 'bindMatrix'),
                v.setOptional(ct, i, 'bindMatrixInverse');
              const t = i.skeleton;
              if (t) {
                const e = t.bones;
                if (U.floatVertexTextures) {
                  if (null === t.boneTexture) {
                    let n = Math.sqrt(4 * e.length);
                    (n = Fn.ceilPowerOfTwo(n)), (n = Math.max(n, 4));
                    const i = new Float32Array(n * n * 4);
                    i.set(t.boneMatrices);
                    const r = new qa(i, n, n, zt, Rt);
                    (t.boneMatrices = i),
                      (t.boneTexture = r),
                      (t.boneTextureSize = n);
                  }
                  v.setValue(ct, 'boneTexture', t.boneTexture, V),
                    v.setValue(ct, 'boneTextureSize', t.boneTextureSize);
                } else v.setOptional(ct, t, 'boneMatrices');
              }
            }
            var M, q;
            return (
              (g || c.receiveShadow !== i.receiveShadow) &&
                ((c.receiveShadow = i.receiveShadow),
                v.setValue(ct, 'receiveShadow', i.receiveShadow)),
              g &&
                (v.setValue(ct, 'toneMappingExposure', m.toneMappingExposure),
                c.needsLights &&
                  ((q = y),
                  ((M = w).ambientLightColor.needsUpdate = q),
                  (M.lightProbe.needsUpdate = q),
                  (M.directionalLights.needsUpdate = q),
                  (M.directionalLightShadows.needsUpdate = q),
                  (M.pointLights.needsUpdate = q),
                  (M.pointLightShadows.needsUpdate = q),
                  (M.spotLights.needsUpdate = q),
                  (M.spotLightShadows.needsUpdate = q),
                  (M.rectAreaLights.needsUpdate = q),
                  (M.hemisphereLights.needsUpdate = q)),
                r && n.fog && Z.refreshFogUniforms(w, r),
                Z.refreshMaterialUniforms(w, n, E, T),
                Ko.upload(ct, c.uniformsList, w, V)),
              n.isShaderMaterial &&
                !0 === n.uniformsNeedUpdate &&
                (Ko.upload(ct, c.uniformsList, w, V),
                (n.uniformsNeedUpdate = !1)),
              n.isSpriteMaterial && v.setValue(ct, 'center', i.center),
              v.setValue(ct, 'modelViewMatrix', i.modelViewMatrix),
              v.setValue(ct, 'normalMatrix', i.normalMatrix),
              v.setValue(ct, 'modelMatrix', i.matrixWorld),
              p
            );
          }
          xt.setAnimationLoop(function (t) {
            gt && gt(t);
          }),
            'undefined' != typeof window && xt.setContext(window),
            (this.setAnimationLoop = function (t) {
              (gt = t),
                dt.setAnimationLoop(t),
                null === t ? xt.stop() : xt.start();
            }),
            dt.addEventListener('sessionstart', yt),
            dt.addEventListener('sessionend', vt),
            (this.render = function (t, e) {
              let n, i;
              if (
                (void 0 !== arguments[2] &&
                  (console.warn(
                    'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.',
                  ),
                  (n = arguments[2])),
                void 0 !== arguments[3] &&
                  (console.warn(
                    'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.',
                  ),
                  (i = arguments[3])),
                void 0 !== e && !0 !== e.isCamera)
              )
                return void console.error(
                  'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
                );
              if (!0 === g) return;
              !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === dt.enabled &&
                  !0 === dt.isPresenting &&
                  (e = dt.getCamera(e)),
                !0 === t.isScene && t.onBeforeRender(m, t, e, n || x),
                (d = tt.get(t, f.length)),
                d.init(),
                f.push(d),
                O.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                k.setFromProjectionMatrix(O),
                (D = this.localClippingEnabled),
                (I = et.init(this.clippingPlanes, D, e)),
                (h = Q.get(t, p.length)),
                h.init(),
                p.push(h),
                bt(t, e, 0, m.sortObjects),
                h.finish(),
                !0 === m.sortObjects && h.sort(A, L),
                !0 === I && et.beginShadows();
              const r = d.state.shadowsArray;
              nt.render(r, t, e),
                d.setupLights(),
                d.setupLightsView(e),
                !0 === I && et.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                void 0 !== n && this.setRenderTarget(n),
                it.render(h, t, e, i);
              const a = h.opaque,
                o = h.transparent;
              a.length > 0 && _t(a, t, e),
                o.length > 0 && _t(o, t, e),
                null !== x &&
                  (V.updateRenderTargetMipmap(x),
                  V.updateMultisampleRenderTarget(x)),
                !0 === t.isScene && t.onAfterRender(m, t, e),
                j.buffers.depth.setTest(!0),
                j.buffers.depth.setMask(!0),
                j.buffers.color.setMask(!0),
                j.setPolygonOffset(!1),
                lt.resetDefaultState(),
                (b = -1),
                (_ = null),
                f.pop(),
                (d = f.length > 0 ? f[f.length - 1] : null),
                p.pop(),
                (h = p.length > 0 ? p[p.length - 1] : null);
            }),
            (this.getActiveCubeFace = function () {
              return y;
            }),
            (this.getActiveMipmapLevel = function () {
              return v;
            }),
            (this.getRenderTarget = function () {
              return x;
            }),
            (this.setRenderTarget = function (t, e = 0, n = 0) {
              (x = t),
                (y = e),
                (v = n),
                t &&
                  void 0 === H.get(t).__webglFramebuffer &&
                  V.setupRenderTarget(t);
              let i = null,
                r = !1,
                a = !1;
              if (t) {
                const n = t.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (a = !0);
                const o = H.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget
                  ? ((i = o[e]), (r = !0))
                  : (i = t.isWebGLMultisampleRenderTarget
                      ? H.get(t).__webglMultisampledFramebuffer
                      : o),
                  w.copy(t.viewport),
                  M.copy(t.scissor),
                  (q = t.scissorTest);
              } else
                w.copy(R).multiplyScalar(E).floor(),
                  M.copy(C).multiplyScalar(E).floor(),
                  (q = P);
              if (
                (j.bindFramebuffer(36160, i),
                j.viewport(w),
                j.scissor(M),
                j.setScissorTest(q),
                r)
              ) {
                const i = H.get(t.texture);
                ct.framebufferTexture2D(
                  36160,
                  36064,
                  34069 + e,
                  i.__webglTexture,
                  n,
                );
              } else if (a) {
                const i = H.get(t.texture),
                  r = e || 0;
                ct.framebufferTextureLayer(
                  36160,
                  36064,
                  i.__webglTexture,
                  n || 0,
                  r,
                );
              }
            }),
            (this.readRenderTargetPixels = function (t, e, n, i, r, a, o) {
              if (!t || !t.isWebGLRenderTarget)
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
                );
              let s = H.get(t).__webglFramebuffer;
              if (
                (t.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s)
              ) {
                j.bindFramebuffer(36160, s);
                try {
                  const o = t.texture,
                    s = o.format,
                    l = o.type;
                  if (s !== zt && st.convert(s) !== ct.getParameter(35739))
                    return void console.error(
                      'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
                    );
                  const c =
                    l === Ct &&
                    (B.has('EXT_color_buffer_half_float') ||
                      (U.isWebGL2 && B.has('EXT_color_buffer_float')));
                  if (
                    !(
                      l === qt ||
                      st.convert(l) === ct.getParameter(35738) ||
                      (l === Rt &&
                        (U.isWebGL2 ||
                          B.has('OES_texture_float') ||
                          B.has('WEBGL_color_buffer_float'))) ||
                      c
                    )
                  )
                    return void console.error(
                      'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
                    );
                  36053 === ct.checkFramebufferStatus(36160)
                    ? e >= 0 &&
                      e <= t.width - i &&
                      n >= 0 &&
                      n <= t.height - r &&
                      ct.readPixels(e, n, i, r, st.convert(s), st.convert(l), a)
                    : console.error(
                        'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.',
                      );
                } finally {
                  const t = null !== x ? H.get(x).__webglFramebuffer : null;
                  j.bindFramebuffer(36160, t);
                }
              }
            }),
            (this.copyFramebufferToTexture = function (t, e, n = 0) {
              const i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                a = Math.floor(e.image.height * i),
                o = st.convert(e.format);
              V.setTexture2D(e, 0),
                ct.copyTexImage2D(3553, n, o, t.x, t.y, r, a, 0),
                j.unbindTexture();
            }),
            (this.copyTextureToTexture = function (t, e, n, i = 0) {
              const r = e.image.width,
                a = e.image.height,
                o = st.convert(n.format),
                s = st.convert(n.type);
              V.setTexture2D(n, 0),
                ct.pixelStorei(37440, n.flipY),
                ct.pixelStorei(37441, n.premultiplyAlpha),
                ct.pixelStorei(3317, n.unpackAlignment),
                e.isDataTexture
                  ? ct.texSubImage2D(
                      3553,
                      i,
                      t.x,
                      t.y,
                      r,
                      a,
                      o,
                      s,
                      e.image.data,
                    )
                  : e.isCompressedTexture
                  ? ct.compressedTexSubImage2D(
                      3553,
                      i,
                      t.x,
                      t.y,
                      e.mipmaps[0].width,
                      e.mipmaps[0].height,
                      o,
                      e.mipmaps[0].data,
                    )
                  : ct.texSubImage2D(3553, i, t.x, t.y, o, s, e.image),
                0 === i && n.generateMipmaps && ct.generateMipmap(3553),
                j.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
              if (m.isWebGL1Renderer)
                return void console.warn(
                  'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.',
                );
              const { width: a, height: o, data: s } = n.image,
                l = st.convert(i.format),
                c = st.convert(i.type);
              let u;
              if (i.isDataTexture3D) V.setTexture3D(i, 0), (u = 32879);
              else {
                if (!i.isDataTexture2DArray)
                  return void console.warn(
                    'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.',
                  );
                V.setTexture2DArray(i, 0), (u = 35866);
              }
              ct.pixelStorei(37440, i.flipY),
                ct.pixelStorei(37441, i.premultiplyAlpha),
                ct.pixelStorei(3317, i.unpackAlignment);
              const h = ct.getParameter(3314),
                d = ct.getParameter(32878),
                p = ct.getParameter(3316),
                f = ct.getParameter(3315),
                g = ct.getParameter(32877);
              ct.pixelStorei(3314, a),
                ct.pixelStorei(32878, o),
                ct.pixelStorei(3316, t.min.x),
                ct.pixelStorei(3315, t.min.y),
                ct.pixelStorei(32877, t.min.z),
                ct.texSubImage3D(
                  u,
                  r,
                  e.x,
                  e.y,
                  e.z,
                  t.max.x - t.min.x + 1,
                  t.max.y - t.min.y + 1,
                  t.max.z - t.min.z + 1,
                  l,
                  c,
                  s,
                ),
                ct.pixelStorei(3314, h),
                ct.pixelStorei(32878, d),
                ct.pixelStorei(3316, p),
                ct.pixelStorei(3315, f),
                ct.pixelStorei(32877, g),
                0 === r && i.generateMipmaps && ct.generateMipmap(u),
                j.unbindTexture();
            }),
            (this.initTexture = function (t) {
              V.setTexture2D(t, 0), j.unbindTexture();
            }),
            (this.resetState = function () {
              (y = 0), (v = 0), (x = null), j.reset(), lt.reset();
            }),
            'undefined' != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent('observe', { detail: this }),
              );
        }
        (zs.prototype.isGroup = !0),
          Object.assign(Fs.prototype, {
            constructor: Fs,
            getHandSpace: function () {
              return (
                null === this._hand &&
                  ((this._hand = new zs()),
                  (this._hand.matrixAutoUpdate = !1),
                  (this._hand.visible = !1),
                  (this._hand.joints = {}),
                  (this._hand.inputState = { pinching: !1 })),
                this._hand
              );
            },
            getTargetRaySpace: function () {
              return (
                null === this._targetRay &&
                  ((this._targetRay = new zs()),
                  (this._targetRay.matrixAutoUpdate = !1),
                  (this._targetRay.visible = !1)),
                this._targetRay
              );
            },
            getGripSpace: function () {
              return (
                null === this._grip &&
                  ((this._grip = new zs()),
                  (this._grip.matrixAutoUpdate = !1),
                  (this._grip.visible = !1)),
                this._grip
              );
            },
            dispatchEvent: function (t) {
              return (
                null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
              );
            },
            disconnect: function (t) {
              return (
                this.dispatchEvent({ type: 'disconnected', data: t }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
              );
            },
            update: function (t, e, n) {
              let i = null,
                r = null,
                a = null;
              const o = this._targetRay,
                s = this._grip,
                l = this._hand;
              if (t && 'visible-blurred' !== e.session.visibilityState)
                if (
                  (null !== o &&
                    ((i = e.getPose(t.targetRaySpace, n)),
                    null !== i &&
                      (o.matrix.fromArray(i.transform.matrix),
                      o.matrix.decompose(o.position, o.rotation, o.scale))),
                  l && t.hand)
                ) {
                  a = !0;
                  for (const i of t.hand.values()) {
                    const t = e.getJointPose(i, n);
                    if (void 0 === l.joints[i.jointName]) {
                      const t = new zs();
                      (t.matrixAutoUpdate = !1),
                        (t.visible = !1),
                        (l.joints[i.jointName] = t),
                        l.add(t);
                    }
                    const r = l.joints[i.jointName];
                    null !== t &&
                      (r.matrix.fromArray(t.transform.matrix),
                      r.matrix.decompose(r.position, r.rotation, r.scale),
                      (r.jointRadius = t.radius)),
                      (r.visible = null !== t);
                  }
                  const i = l.joints['index-finger-tip'],
                    r = l.joints['thumb-tip'],
                    o = i.position.distanceTo(r.position),
                    s = 0.02,
                    c = 0.005;
                  l.inputState.pinching && o > s + c
                    ? ((l.inputState.pinching = !1),
                      this.dispatchEvent({
                        type: 'pinchend',
                        handedness: t.handedness,
                        target: this,
                      }))
                    : !l.inputState.pinching &&
                      o <= s - c &&
                      ((l.inputState.pinching = !0),
                      this.dispatchEvent({
                        type: 'pinchstart',
                        handedness: t.handedness,
                        target: this,
                      }));
                } else
                  null !== s &&
                    t.gripSpace &&
                    ((r = e.getPose(t.gripSpace, n)),
                    null !== r &&
                      (s.matrix.fromArray(r.transform.matrix),
                      s.matrix.decompose(s.position, s.rotation, s.scale)));
              return (
                null !== o && (o.visible = null !== i),
                null !== s && (s.visible = null !== r),
                null !== l && (l.visible = null !== a),
                this
              );
            },
          }),
          Object.assign(Bs.prototype, On.prototype);
        class Gs extends js {}
        Gs.prototype.isWebGL1Renderer = !0;
        class Hs {
          constructor(t, e = 25e-5) {
            (this.name = ''), (this.color = new Mr(t)), (this.density = e);
          }
          clone() {
            return new Hs(this.color, this.density);
          }
          toJSON() {
            return {
              type: 'FogExp2',
              color: this.color.getHex(),
              density: this.density,
            };
          }
        }
        Hs.prototype.isFogExp2 = !0;
        class Vs {
          constructor(t, e = 1, n = 1e3) {
            (this.name = ''),
              (this.color = new Mr(t)),
              (this.near = e),
              (this.far = n);
          }
          clone() {
            return new Vs(this.color, this.near, this.far);
          }
          toJSON() {
            return {
              type: 'Fog',
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          }
        }
        Vs.prototype.isFog = !0;
        class Ws extends Qi {
          constructor() {
            super(),
              (this.type = 'Scene'),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.overrideMaterial = null),
              (this.autoUpdate = !0),
              'undefined' != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent('observe', { detail: this }),
                );
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.environment &&
                (this.environment = t.environment.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              null !== t.overrideMaterial &&
                (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.autoUpdate = t.autoUpdate),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              null !== this.background &&
                (e.object.background = this.background.toJSON(t)),
              null !== this.environment &&
                (e.object.environment = this.environment.toJSON(t)),
              null !== this.fog && (e.object.fog = this.fog.toJSON()),
              e
            );
          }
        }
        function Xs(t, e) {
          (this.array = t),
            (this.stride = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.usage = Sn),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = Fn.generateUUID());
        }
        (Ws.prototype.isScene = !0),
          Object.defineProperty(Xs.prototype, 'needsUpdate', {
            set: function (t) {
              !0 === t && this.version++;
            },
          }),
          Object.assign(Xs.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function () {},
            setUsage: function (t) {
              return (this.usage = t), this;
            },
            copy: function (t) {
              return (
                (this.array = new t.array.constructor(t.array)),
                (this.count = t.count),
                (this.stride = t.stride),
                (this.usage = t.usage),
                this
              );
            },
            copyAt: function (t, e, n) {
              (t *= this.stride), (n *= e.stride);
              for (let i = 0, r = this.stride; i < r; i++)
                this.array[t + i] = e.array[n + i];
              return this;
            },
            set: function (t, e = 0) {
              return this.array.set(t, e), this;
            },
            clone: function (t) {
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid &&
                  (this.array.buffer._uuid = Fn.generateUUID()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                  (t.arrayBuffers[this.array.buffer._uuid] =
                    this.array.slice(0).buffer);
              const e = new Xs(
                new this.array.constructor(
                  t.arrayBuffers[this.array.buffer._uuid],
                ),
                this.stride,
              );
              return e.setUsage(this.usage), e;
            },
            onUpload: function (t) {
              return (this.onUploadCallback = t), this;
            },
            toJSON: function (t) {
              return (
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid &&
                  (this.array.buffer._uuid = Fn.generateUUID()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                  (t.arrayBuffers[this.array.buffer._uuid] =
                    Array.prototype.slice.call(
                      new Uint32Array(this.array.buffer),
                    )),
                {
                  uuid: this.uuid,
                  buffer: this.array.buffer._uuid,
                  type: this.array.constructor.name,
                  stride: this.stride,
                }
              );
            },
          });
        const Ys = new Zn();
        function $s(t, e, n, i) {
          (this.name = ''),
            (this.data = t),
            (this.itemSize = e),
            (this.offset = n),
            (this.normalized = !0 === i);
        }
        Object.defineProperties($s.prototype, {
          count: {
            get: function () {
              return this.data.count;
            },
          },
          array: {
            get: function () {
              return this.data.array;
            },
          },
          needsUpdate: {
            set: function (t) {
              this.data.needsUpdate = t;
            },
          },
        }),
          Object.assign($s.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function (t) {
              for (let e = 0, n = this.data.count; e < n; e++)
                (Ys.x = this.getX(e)),
                  (Ys.y = this.getY(e)),
                  (Ys.z = this.getZ(e)),
                  Ys.applyMatrix4(t),
                  this.setXYZ(e, Ys.x, Ys.y, Ys.z);
              return this;
            },
            applyNormalMatrix: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Ys.x = this.getX(e)),
                  (Ys.y = this.getY(e)),
                  (Ys.z = this.getZ(e)),
                  Ys.applyNormalMatrix(t),
                  this.setXYZ(e, Ys.x, Ys.y, Ys.z);
              return this;
            },
            transformDirection: function (t) {
              for (let e = 0, n = this.count; e < n; e++)
                (Ys.x = this.getX(e)),
                  (Ys.y = this.getY(e)),
                  (Ys.z = this.getZ(e)),
                  Ys.transformDirection(t),
                  this.setXYZ(e, Ys.x, Ys.y, Ys.z);
              return this;
            },
            setX: function (t, e) {
              return (
                (this.data.array[t * this.data.stride + this.offset] = e), this
              );
            },
            setY: function (t, e) {
              return (
                (this.data.array[t * this.data.stride + this.offset + 1] = e),
                this
              );
            },
            setZ: function (t, e) {
              return (
                (this.data.array[t * this.data.stride + this.offset + 2] = e),
                this
              );
            },
            setW: function (t, e) {
              return (
                (this.data.array[t * this.data.stride + this.offset + 3] = e),
                this
              );
            },
            getX: function (t) {
              return this.data.array[t * this.data.stride + this.offset];
            },
            getY: function (t) {
              return this.data.array[t * this.data.stride + this.offset + 1];
            },
            getZ: function (t) {
              return this.data.array[t * this.data.stride + this.offset + 2];
            },
            getW: function (t) {
              return this.data.array[t * this.data.stride + this.offset + 3];
            },
            setXY: function (t, e, n) {
              return (
                (t = t * this.data.stride + this.offset),
                (this.data.array[t + 0] = e),
                (this.data.array[t + 1] = n),
                this
              );
            },
            setXYZ: function (t, e, n, i) {
              return (
                (t = t * this.data.stride + this.offset),
                (this.data.array[t + 0] = e),
                (this.data.array[t + 1] = n),
                (this.data.array[t + 2] = i),
                this
              );
            },
            setXYZW: function (t, e, n, i, r) {
              return (
                (t = t * this.data.stride + this.offset),
                (this.data.array[t + 0] = e),
                (this.data.array[t + 1] = n),
                (this.data.array[t + 2] = i),
                (this.data.array[t + 3] = r),
                this
              );
            },
            clone: function (t) {
              if (void 0 === t) {
                console.log(
                  'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.',
                );
                const t = [];
                for (let e = 0; e < this.count; e++) {
                  const n = e * this.data.stride + this.offset;
                  for (let e = 0; e < this.itemSize; e++)
                    t.push(this.data.array[n + e]);
                }
                return new Er(
                  new this.array.constructor(t),
                  this.itemSize,
                  this.normalized,
                );
              }
              return (
                void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] &&
                  (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                new $s(
                  t.interleavedBuffers[this.data.uuid],
                  this.itemSize,
                  this.offset,
                  this.normalized,
                )
              );
            },
            toJSON: function (t) {
              if (void 0 === t) {
                console.log(
                  'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.',
                );
                const t = [];
                for (let e = 0; e < this.count; e++) {
                  const n = e * this.data.stride + this.offset;
                  for (let e = 0; e < this.itemSize; e++)
                    t.push(this.data.array[n + e]);
                }
                return {
                  itemSize: this.itemSize,
                  type: this.array.constructor.name,
                  array: t,
                  normalized: this.normalized,
                };
              }
              return (
                void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] &&
                  (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                {
                  isInterleavedBufferAttribute: !0,
                  itemSize: this.itemSize,
                  data: this.data.uuid,
                  offset: this.offset,
                  normalized: this.normalized,
                }
              );
            },
          });
        class Js extends gr {
          constructor(t) {
            super(),
              (this.type = 'SpriteMaterial'),
              (this.color = new Mr(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.rotation = 0),
              (this.sizeAttenuation = !0),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.rotation = t.rotation),
              (this.sizeAttenuation = t.sizeAttenuation),
              this
            );
          }
        }
        let Zs;
        Js.prototype.isSpriteMaterial = !0;
        const Ks = new Zn(),
          Qs = new Zn(),
          tl = new Zn(),
          el = new Bn(),
          nl = new Bn(),
          il = new Ai(),
          rl = new Zn(),
          al = new Zn(),
          ol = new Zn(),
          sl = new Bn(),
          ll = new Bn(),
          cl = new Bn();
        class ul extends Qi {
          constructor(t) {
            if ((super(), (this.type = 'Sprite'), void 0 === Zs)) {
              Zs = new Yr();
              const t = new Xs(
                new Float32Array([
                  -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                  -0.5, 0.5, 0, 0, 1,
                ]),
                5,
              );
              Zs.setIndex([0, 1, 2, 0, 2, 3]),
                Zs.setAttribute('position', new $s(t, 3, 0, !1)),
                Zs.setAttribute('uv', new $s(t, 2, 3, !1));
            }
            (this.geometry = Zs),
              (this.material = void 0 !== t ? t : new Js()),
              (this.center = new Bn(0.5, 0.5));
          }
          raycast(t, e) {
            null === t.camera &&
              console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
              ),
              Qs.setFromMatrixScale(this.matrixWorld),
              il.copy(t.camera.matrixWorld),
              this.modelViewMatrix.multiplyMatrices(
                t.camera.matrixWorldInverse,
                this.matrixWorld,
              ),
              tl.setFromMatrixPosition(this.modelViewMatrix),
              t.camera.isPerspectiveCamera &&
                !1 === this.material.sizeAttenuation &&
                Qs.multiplyScalar(-tl.z);
            const n = this.material.rotation;
            let i, r;
            0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
            const a = this.center;
            hl(rl.set(-0.5, -0.5, 0), tl, a, Qs, i, r),
              hl(al.set(0.5, -0.5, 0), tl, a, Qs, i, r),
              hl(ol.set(0.5, 0.5, 0), tl, a, Qs, i, r),
              sl.set(0, 0),
              ll.set(1, 0),
              cl.set(1, 1);
            let o = t.ray.intersectTriangle(rl, al, ol, !1, Ks);
            if (
              null === o &&
              (hl(al.set(-0.5, 0.5, 0), tl, a, Qs, i, r),
              ll.set(0, 1),
              (o = t.ray.intersectTriangle(rl, ol, al, !1, Ks)),
              null === o)
            )
              return;
            const s = t.ray.origin.distanceTo(Ks);
            s < t.near ||
              s > t.far ||
              e.push({
                distance: s,
                point: Ks.clone(),
                uv: fr.getUV(Ks, rl, al, ol, sl, ll, cl, new Bn()),
                face: null,
                object: this,
              });
          }
          copy(t) {
            return (
              super.copy(t),
              void 0 !== t.center && this.center.copy(t.center),
              (this.material = t.material),
              this
            );
          }
        }
        function hl(t, e, n, i, r, a) {
          el.subVectors(t, n).addScalar(0.5).multiply(i),
            void 0 !== r
              ? ((nl.x = a * el.x - r * el.y), (nl.y = r * el.x + a * el.y))
              : nl.copy(el),
            t.copy(e),
            (t.x += nl.x),
            (t.y += nl.y),
            t.applyMatrix4(il);
        }
        ul.prototype.isSprite = !0;
        const dl = new Zn(),
          pl = new Zn();
        class fl extends Qi {
          constructor() {
            super(),
              (this._currentLevel = 0),
              (this.type = 'LOD'),
              Object.defineProperties(this, {
                levels: { enumerable: !0, value: [] },
                isLOD: { value: !0 },
              }),
              (this.autoUpdate = !0);
          }
          copy(t) {
            super.copy(t, !1);
            const e = t.levels;
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              this.addLevel(n.object.clone(), n.distance);
            }
            return (this.autoUpdate = t.autoUpdate), this;
          }
          addLevel(t, e = 0) {
            e = Math.abs(e);
            const n = this.levels;
            let i;
            for (i = 0; i < n.length && !(e < n[i].distance); i++);
            return (
              n.splice(i, 0, { distance: e, object: t }), this.add(t), this
            );
          }
          getCurrentLevel() {
            return this._currentLevel;
          }
          getObjectForDistance(t) {
            const e = this.levels;
            if (e.length > 0) {
              let n, i;
              for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
              return e[n - 1].object;
            }
            return null;
          }
          raycast(t, e) {
            if (this.levels.length > 0) {
              dl.setFromMatrixPosition(this.matrixWorld);
              const n = t.ray.origin.distanceTo(dl);
              this.getObjectForDistance(n).raycast(t, e);
            }
          }
          update(t) {
            const e = this.levels;
            if (e.length > 1) {
              dl.setFromMatrixPosition(t.matrixWorld),
                pl.setFromMatrixPosition(this.matrixWorld);
              const n = dl.distanceTo(pl) / t.zoom;
              let i, r;
              for (
                e[0].object.visible = !0, i = 1, r = e.length;
                i < r && n >= e[i].distance;
                i++
              )
                (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
              for (this._currentLevel = i - 1; i < r; i++)
                e[i].object.visible = !1;
            }
          }
          toJSON(t) {
            const e = super.toJSON(t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1),
              (e.object.levels = []);
            const n = this.levels;
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              e.object.levels.push({
                object: i.object.uuid,
                distance: i.distance,
              });
            }
            return e;
          }
        }
        const ml = new Zn(),
          gl = new Xn(),
          yl = new Xn(),
          vl = new Zn(),
          xl = new Ai();
        function bl(t, e) {
          da.call(this, t, e),
            (this.type = 'SkinnedMesh'),
            (this.bindMode = 'attached'),
            (this.bindMatrix = new Ai()),
            (this.bindMatrixInverse = new Ai());
        }
        function _l() {
          Qi.call(this), (this.type = 'Bone');
        }
        (bl.prototype = Object.assign(Object.create(da.prototype), {
          constructor: bl,
          isSkinnedMesh: !0,
          copy: function (t) {
            return (
              da.prototype.copy.call(this, t),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              this
            );
          },
          bind: function (t, e) {
            (this.skeleton = t),
              void 0 === e &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert();
          },
          pose: function () {
            this.skeleton.pose();
          },
          normalizeSkinWeights: function () {
            const t = new Xn(),
              e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
              (t.x = e.getX(n)),
                (t.y = e.getY(n)),
                (t.z = e.getZ(n)),
                (t.w = e.getW(n));
              const i = 1 / t.manhattanLength();
              i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
          },
          updateMatrixWorld: function (t) {
            da.prototype.updateMatrixWorld.call(this, t),
              'attached' === this.bindMode
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : 'detached' === this.bindMode
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn(
                    'THREE.SkinnedMesh: Unrecognized bindMode: ' +
                      this.bindMode,
                  );
          },
          boneTransform: function (t, e) {
            const n = this.skeleton,
              i = this.geometry;
            gl.fromBufferAttribute(i.attributes.skinIndex, t),
              yl.fromBufferAttribute(i.attributes.skinWeight, t),
              ml
                .fromBufferAttribute(i.attributes.position, t)
                .applyMatrix4(this.bindMatrix),
              e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
              const i = yl.getComponent(t);
              if (0 !== i) {
                const r = gl.getComponent(t);
                xl.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                  e.addScaledVector(vl.copy(ml).applyMatrix4(xl), i);
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
          },
        })),
          (_l.prototype = Object.assign(Object.create(Qi.prototype), {
            constructor: _l,
            isBone: !0,
          }));
        const wl = new Ai(),
          Ml = new Ai();
        class ql {
          constructor(t = [], e = []) {
            (this.uuid = Fn.generateUUID()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              (this.frame = -1),
              this.init();
          }
          init() {
            const t = this.bones,
              e = this.boneInverses;
            if (
              ((this.boneMatrices = new Float32Array(16 * t.length)),
              0 === e.length)
            )
              this.calculateInverses();
            else if (t.length !== e.length) {
              console.warn(
                'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.',
              ),
                (this.boneInverses = []);
              for (let t = 0, e = this.bones.length; t < e; t++)
                this.boneInverses.push(new Ai());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new Ai();
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e);
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e && e.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale));
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i] ? t[i].matrixWorld : Ml;
              wl.multiplyMatrices(r, e[i]), wl.toArray(n, 16 * i);
            }
            null !== i && (i.needsUpdate = !0);
          }
          clone() {
            return new ql(this.bones, this.boneInverses);
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e];
              if (n.name === t) return n;
            }
          }
          dispose() {
            null !== this.boneTexture &&
              (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, i = t.bones.length; n < i; n++) {
              const i = t.bones[n];
              let r = e[i];
              void 0 === r &&
                (console.warn('THREE.Skeleton: No bone found with UUID:', i),
                (r = new _l())),
                this.bones.push(r),
                this.boneInverses.push(new Ai().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: 'Skeleton',
                generator: 'Skeleton.toJSON',
              },
              bones: [],
              boneInverses: [],
            };
            t.uuid = this.uuid;
            const e = this.bones,
              n = this.boneInverses;
            for (let i = 0, r = e.length; i < r; i++) {
              const r = e[i];
              t.bones.push(r.uuid);
              const a = n[i];
              t.boneInverses.push(a.toArray());
            }
            return t;
          }
        }
        const Sl = new Ai(),
          Tl = new Ai(),
          El = [],
          Al = new da();
        function Ll(t, e, n) {
          da.call(this, t, e),
            (this.instanceMatrix = new Er(new Float32Array(16 * n), 16)),
            (this.instanceColor = null),
            (this.count = n),
            (this.frustumCulled = !1);
        }
        Ll.prototype = Object.assign(Object.create(da.prototype), {
          constructor: Ll,
          isInstancedMesh: !0,
          copy: function (t) {
            return (
              da.prototype.copy.call(this, t),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor &&
                (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              this
            );
          },
          getColorAt: function (t, e) {
            e.fromArray(this.instanceColor.array, 3 * t);
          },
          getMatrixAt: function (t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t);
          },
          raycast: function (t, e) {
            const n = this.matrixWorld,
              i = this.count;
            if (
              ((Al.geometry = this.geometry),
              (Al.material = this.material),
              void 0 !== Al.material)
            )
              for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, Sl),
                  Tl.multiplyMatrices(n, Sl),
                  (Al.matrixWorld = Tl),
                  Al.raycast(t, El);
                for (let t = 0, n = El.length; t < n; t++) {
                  const n = El[t];
                  (n.instanceId = r), (n.object = this), e.push(n);
                }
                El.length = 0;
              }
          },
          setColorAt: function (t, e) {
            null === this.instanceColor &&
              (this.instanceColor = new Er(
                new Float32Array(3 * this.count),
                3,
              )),
              e.toArray(this.instanceColor.array, 3 * t);
          },
          setMatrixAt: function (t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t);
          },
          updateMorphTargets: function () {},
          dispose: function () {
            this.dispatchEvent({ type: 'dispose' });
          },
        });
        class Rl extends gr {
          constructor(t) {
            super(),
              (this.type = 'LineBasicMaterial'),
              (this.color = new Mr(16777215)),
              (this.linewidth = 1),
              (this.linecap = 'round'),
              (this.linejoin = 'round'),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        Rl.prototype.isLineBasicMaterial = !0;
        const Cl = new Zn(),
          Pl = new Zn(),
          kl = new Ai(),
          Il = new Ei(),
          Dl = new xi();
        function Ol(t = new Yr(), e = new Rl()) {
          Qi.call(this),
            (this.type = 'Line'),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        Ol.prototype = Object.assign(Object.create(Qi.prototype), {
          constructor: Ol,
          isLine: !0,
          copy: function (t) {
            return (
              Qi.prototype.copy.call(this, t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          },
          computeLineDistances: function () {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [0];
                for (let t = 1, i = e.count; t < i; t++)
                  Cl.fromBufferAttribute(e, t - 1),
                    Pl.fromBufferAttribute(e, t),
                    (n[t] = n[t - 1]),
                    (n[t] += Cl.distanceTo(Pl));
                t.setAttribute('lineDistance', new Or(n, 1));
              } else
                console.warn(
                  'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                );
            else
              t.isGeometry &&
                console.error(
                  'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
            return this;
          },
          raycast: function (t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Line.threshold,
              a = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Dl.copy(n.boundingSphere),
              Dl.applyMatrix4(i),
              (Dl.radius += r),
              !1 === t.ray.intersectsSphere(Dl))
            )
              return;
            kl.copy(i).invert(), Il.copy(t.ray).applyMatrix4(kl);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              s = o * o,
              l = new Zn(),
              c = new Zn(),
              u = new Zn(),
              h = new Zn(),
              d = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
              const i = n.index,
                r = n.attributes.position;
              if (null !== i) {
                for (
                  let n = Math.max(0, a.start),
                    o = Math.min(i.count, a.start + a.count) - 1;
                  n < o;
                  n += d
                ) {
                  const a = i.getX(n),
                    o = i.getX(n + 1);
                  l.fromBufferAttribute(r, a), c.fromBufferAttribute(r, o);
                  if (Il.distanceSqToSegment(l, c, h, u) > s) continue;
                  h.applyMatrix4(this.matrixWorld);
                  const d = t.ray.origin.distanceTo(h);
                  d < t.near ||
                    d > t.far ||
                    e.push({
                      distance: d,
                      point: u.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              } else {
                for (
                  let n = Math.max(0, a.start),
                    i = Math.min(r.count, a.start + a.count) - 1;
                  n < i;
                  n += d
                ) {
                  l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
                  if (Il.distanceSqToSegment(l, c, h, u) > s) continue;
                  h.applyMatrix4(this.matrixWorld);
                  const i = t.ray.origin.distanceTo(h);
                  i < t.near ||
                    i > t.far ||
                    e.push({
                      distance: i,
                      point: u.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              }
            } else
              n.isGeometry &&
                console.error(
                  'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
          },
          updateMorphTargets: function () {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
            }
          },
        });
        const Nl = new Zn(),
          zl = new Zn();
        function Fl(t, e) {
          Ol.call(this, t, e), (this.type = 'LineSegments');
        }
        Fl.prototype = Object.assign(Object.create(Ol.prototype), {
          constructor: Fl,
          isLineSegments: !0,
          computeLineDistances: function () {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [];
                for (let t = 0, i = e.count; t < i; t += 2)
                  Nl.fromBufferAttribute(e, t),
                    zl.fromBufferAttribute(e, t + 1),
                    (n[t] = 0 === t ? 0 : n[t - 1]),
                    (n[t + 1] = n[t] + Nl.distanceTo(zl));
                t.setAttribute('lineDistance', new Or(n, 1));
              } else
                console.warn(
                  'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                );
            else
              t.isGeometry &&
                console.error(
                  'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
            return this;
          },
        });
        class Bl extends Ol {
          constructor(t, e) {
            super(t, e), (this.type = 'LineLoop');
          }
        }
        Bl.prototype.isLineLoop = !0;
        class Ul extends gr {
          constructor(t) {
            super(),
              (this.type = 'PointsMaterial'),
              (this.color = new Mr(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        Ul.prototype.isPointsMaterial = !0;
        const jl = new Ai(),
          Gl = new Ei(),
          Hl = new xi(),
          Vl = new Zn();
        function Wl(t = new Yr(), e = new Ul()) {
          Qi.call(this),
            (this.type = 'Points'),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        function Xl(t, e, n, i, r, a, o) {
          const s = Gl.distanceSqToPoint(t);
          if (s < n) {
            const n = new Zn();
            Gl.closestPointToPoint(t, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            a.push({
              distance: l,
              distanceToRay: Math.sqrt(s),
              point: n,
              index: e,
              face: null,
              object: o,
            });
          }
        }
        Wl.prototype = Object.assign(Object.create(Qi.prototype), {
          constructor: Wl,
          isPoints: !0,
          copy: function (t) {
            return (
              Qi.prototype.copy.call(this, t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          },
          raycast: function (t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Points.threshold,
              a = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Hl.copy(n.boundingSphere),
              Hl.applyMatrix4(i),
              (Hl.radius += r),
              !1 === t.ray.intersectsSphere(Hl))
            )
              return;
            jl.copy(i).invert(), Gl.copy(t.ray).applyMatrix4(jl);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              s = o * o;
            if (n.isBufferGeometry) {
              const r = n.index,
                o = n.attributes.position;
              if (null !== r) {
                for (
                  let n = Math.max(0, a.start),
                    l = Math.min(r.count, a.start + a.count);
                  n < l;
                  n++
                ) {
                  const a = r.getX(n);
                  Vl.fromBufferAttribute(o, a), Xl(Vl, a, s, i, t, e, this);
                }
              } else {
                for (
                  let n = Math.max(0, a.start),
                    r = Math.min(o.count, a.start + a.count);
                  n < r;
                  n++
                )
                  Vl.fromBufferAttribute(o, n), Xl(Vl, n, s, i, t, e, this);
              }
            } else
              console.error(
                'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              );
          },
          updateMorphTargets: function () {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
                );
            }
          },
        });
        class Yl extends Vn {
          constructor(t, e, n, i, r, a, o, s, l) {
            super(t, e, n, i, r, a, o, s, l),
              (this.format = void 0 !== o ? o : Nt),
              (this.minFilter = void 0 !== a ? a : xt),
              (this.magFilter = void 0 !== r ? r : xt),
              (this.generateMipmaps = !1);
            const c = this;
            'requestVideoFrameCallback' in t &&
              t.requestVideoFrameCallback(function e() {
                (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
              });
          }
          clone() {
            return new this.constructor(this.image).copy(this);
          }
          update() {
            const t = this.image;
            !1 === 'requestVideoFrameCallback' in t &&
              t.readyState >= t.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0);
          }
        }
        Yl.prototype.isVideoTexture = !0;
        class $l extends Vn {
          constructor(t, e, n, i, r, a, o, s, l, c, u, h) {
            super(null, a, o, s, l, c, i, r, u, h),
              (this.image = { width: e, height: n }),
              (this.mipmaps = t),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }
        $l.prototype.isCompressedTexture = !0;
        class Jl extends Vn {
          constructor(t, e, n, i, r, a, o, s, l) {
            super(t, e, n, i, r, a, o, s, l), (this.needsUpdate = !0);
          }
        }
        Jl.prototype.isCanvasTexture = !0;
        class Zl extends Vn {
          constructor(t, e, n, i, r, a, o, s, l, c) {
            if ((c = void 0 !== c ? c : jt) !== jt && c !== Gt)
              throw new Error(
                'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
              );
            void 0 === n && c === jt && (n = Et),
              void 0 === n && c === Gt && (n = Dt),
              super(null, i, r, a, o, s, c, n, l),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== o ? o : ft),
              (this.minFilter = void 0 !== s ? s : ft),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }
        Zl.prototype.isDepthTexture = !0;
        class Kl extends Yr {
          constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
            super(),
              (this.type = 'CircleGeometry'),
              (this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: i,
              }),
              (e = Math.max(3, e));
            const r = [],
              a = [],
              o = [],
              s = [],
              l = new Zn(),
              c = new Bn();
            a.push(0, 0, 0), o.push(0, 0, 1), s.push(0.5, 0.5);
            for (let r = 0, u = 3; r <= e; r++, u += 3) {
              const h = n + (r / e) * i;
              (l.x = t * Math.cos(h)),
                (l.y = t * Math.sin(h)),
                a.push(l.x, l.y, l.z),
                o.push(0, 0, 1),
                (c.x = (a[u] / t + 1) / 2),
                (c.y = (a[u + 1] / t + 1) / 2),
                s.push(c.x, c.y);
            }
            for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
            this.setIndex(r),
              this.setAttribute('position', new Or(a, 3)),
              this.setAttribute('normal', new Or(o, 3)),
              this.setAttribute('uv', new Or(s, 2));
          }
        }
        class Ql extends Yr {
          constructor(
            t = 1,
            e = 1,
            n = 1,
            i = 8,
            r = 1,
            a = !1,
            o = 0,
            s = 2 * Math.PI,
          ) {
            super(),
              (this.type = 'CylinderGeometry'),
              (this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: a,
                thetaStart: o,
                thetaLength: s,
              });
            const l = this;
            (i = Math.floor(i)), (r = Math.floor(r));
            const c = [],
              u = [],
              h = [],
              d = [];
            let p = 0;
            const f = [],
              m = n / 2;
            let g = 0;
            function y(n) {
              const r = p,
                a = new Bn(),
                f = new Zn();
              let y = 0;
              const v = !0 === n ? t : e,
                x = !0 === n ? 1 : -1;
              for (let t = 1; t <= i; t++)
                u.push(0, m * x, 0), h.push(0, x, 0), d.push(0.5, 0.5), p++;
              const b = p;
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * s + o,
                  n = Math.cos(e),
                  r = Math.sin(e);
                (f.x = v * r),
                  (f.y = m * x),
                  (f.z = v * n),
                  u.push(f.x, f.y, f.z),
                  h.push(0, x, 0),
                  (a.x = 0.5 * n + 0.5),
                  (a.y = 0.5 * r * x + 0.5),
                  d.push(a.x, a.y),
                  p++;
              }
              for (let t = 0; t < i; t++) {
                const e = r + t,
                  i = b + t;
                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (y += 3);
              }
              l.addGroup(g, y, !0 === n ? 1 : 2), (g += y);
            }
            !(function () {
              const a = new Zn(),
                y = new Zn();
              let v = 0;
              const x = (e - t) / n;
              for (let l = 0; l <= r; l++) {
                const c = [],
                  g = l / r,
                  v = g * (e - t) + t;
                for (let t = 0; t <= i; t++) {
                  const e = t / i,
                    r = e * s + o,
                    l = Math.sin(r),
                    f = Math.cos(r);
                  (y.x = v * l),
                    (y.y = -g * n + m),
                    (y.z = v * f),
                    u.push(y.x, y.y, y.z),
                    a.set(l, x, f).normalize(),
                    h.push(a.x, a.y, a.z),
                    d.push(e, 1 - g),
                    c.push(p++);
                }
                f.push(c);
              }
              for (let t = 0; t < i; t++)
                for (let e = 0; e < r; e++) {
                  const n = f[e][t],
                    i = f[e + 1][t],
                    r = f[e + 1][t + 1],
                    a = f[e][t + 1];
                  c.push(n, i, a), c.push(i, r, a), (v += 6);
                }
              l.addGroup(g, v, 0), (g += v);
            })(),
              !1 === a && (t > 0 && y(!0), e > 0 && y(!1)),
              this.setIndex(c),
              this.setAttribute('position', new Or(u, 3)),
              this.setAttribute('normal', new Or(h, 3)),
              this.setAttribute('uv', new Or(d, 2));
          }
        }
        class tc extends Ql {
          constructor(
            t = 1,
            e = 1,
            n = 8,
            i = 1,
            r = !1,
            a = 0,
            o = 2 * Math.PI,
          ) {
            super(0, t, e, n, i, r, a, o),
              (this.type = 'ConeGeometry'),
              (this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: a,
                thetaLength: o,
              });
          }
        }
        class ec extends Yr {
          constructor(t, e, n = 1, i = 0) {
            super(),
              (this.type = 'PolyhedronGeometry'),
              (this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: i,
              });
            const r = [],
              a = [];
            function o(t, e, n, i) {
              const r = i + 1,
                a = [];
              for (let i = 0; i <= r; i++) {
                a[i] = [];
                const o = t.clone().lerp(n, i / r),
                  s = e.clone().lerp(n, i / r),
                  l = r - i;
                for (let t = 0; t <= l; t++)
                  a[i][t] = 0 === t && i === r ? o : o.clone().lerp(s, t / l);
              }
              for (let t = 0; t < r; t++)
                for (let e = 0; e < 2 * (r - t) - 1; e++) {
                  const n = Math.floor(e / 2);
                  e % 2 == 0
                    ? (s(a[t][n + 1]), s(a[t + 1][n]), s(a[t][n]))
                    : (s(a[t][n + 1]), s(a[t + 1][n + 1]), s(a[t + 1][n]));
                }
            }
            function s(t) {
              r.push(t.x, t.y, t.z);
            }
            function l(e, n) {
              const i = 3 * e;
              (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
            }
            function c(t, e, n, i) {
              i < 0 && 1 === t.x && (a[e] = t.x - 1),
                0 === n.x && 0 === n.z && (a[e] = i / 2 / Math.PI + 0.5);
            }
            function u(t) {
              return Math.atan2(t.z, -t.x);
            }
            !(function (t) {
              const n = new Zn(),
                i = new Zn(),
                r = new Zn();
              for (let a = 0; a < e.length; a += 3)
                l(e[a + 0], n), l(e[a + 1], i), l(e[a + 2], r), o(n, i, r, t);
            })(i),
              (function (t) {
                const e = new Zn();
                for (let n = 0; n < r.length; n += 3)
                  (e.x = r[n + 0]),
                    (e.y = r[n + 1]),
                    (e.z = r[n + 2]),
                    e.normalize().multiplyScalar(t),
                    (r[n + 0] = e.x),
                    (r[n + 1] = e.y),
                    (r[n + 2] = e.z);
              })(n),
              (function () {
                const t = new Zn();
                for (let n = 0; n < r.length; n += 3) {
                  (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
                  const i = u(t) / 2 / Math.PI + 0.5,
                    o =
                      ((e = t),
                      Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) /
                        Math.PI +
                        0.5);
                  a.push(i, 1 - o);
                }
                var e;
                (function () {
                  const t = new Zn(),
                    e = new Zn(),
                    n = new Zn(),
                    i = new Zn(),
                    o = new Bn(),
                    s = new Bn(),
                    l = new Bn();
                  for (let h = 0, d = 0; h < r.length; h += 9, d += 6) {
                    t.set(r[h + 0], r[h + 1], r[h + 2]),
                      e.set(r[h + 3], r[h + 4], r[h + 5]),
                      n.set(r[h + 6], r[h + 7], r[h + 8]),
                      o.set(a[d + 0], a[d + 1]),
                      s.set(a[d + 2], a[d + 3]),
                      l.set(a[d + 4], a[d + 5]),
                      i.copy(t).add(e).add(n).divideScalar(3);
                    const p = u(i);
                    c(o, d + 0, t, p), c(s, d + 2, e, p), c(l, d + 4, n, p);
                  }
                })(),
                  (function () {
                    for (let t = 0; t < a.length; t += 6) {
                      const e = a[t + 0],
                        n = a[t + 2],
                        i = a[t + 4],
                        r = Math.max(e, n, i),
                        o = Math.min(e, n, i);
                      r > 0.9 &&
                        o < 0.1 &&
                        (e < 0.2 && (a[t + 0] += 1),
                        n < 0.2 && (a[t + 2] += 1),
                        i < 0.2 && (a[t + 4] += 1));
                    }
                  })();
              })(),
              this.setAttribute('position', new Or(r, 3)),
              this.setAttribute('normal', new Or(r.slice(), 3)),
              this.setAttribute('uv', new Or(a, 2)),
              0 === i ? this.computeVertexNormals() : this.normalizeNormals();
          }
        }
        class nc extends ec {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2,
              i = 1 / n;
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                0,
                -n,
                0,
                -i,
                n,
                0,
                -i,
                -n,
                0,
                i,
                n,
                0,
                i,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              t,
              e,
            ),
              (this.type = 'DodecahedronGeometry'),
              (this.parameters = { radius: t, detail: e });
          }
        }
        const ic = new Zn(),
          rc = new Zn(),
          ac = new Zn(),
          oc = new fr();
        class sc extends Yr {
          constructor(t, e) {
            if (
              (super(),
              (this.type = 'EdgesGeometry'),
              (this.parameters = { thresholdAngle: e }),
              (e = void 0 !== e ? e : 1),
              !0 === t.isGeometry)
            )
              return void console.error(
                'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              );
            const n = Math.pow(10, 4),
              i = Math.cos(Fn.DEG2RAD * e),
              r = t.getIndex(),
              a = t.getAttribute('position'),
              o = r ? r.count : a.count,
              s = [0, 0, 0],
              l = ['a', 'b', 'c'],
              c = new Array(3),
              u = {},
              h = [];
            for (let t = 0; t < o; t += 3) {
              r
                ? ((s[0] = r.getX(t)),
                  (s[1] = r.getX(t + 1)),
                  (s[2] = r.getX(t + 2)))
                : ((s[0] = t), (s[1] = t + 1), (s[2] = t + 2));
              const { a: e, b: o, c: d } = oc;
              if (
                (e.fromBufferAttribute(a, s[0]),
                o.fromBufferAttribute(a, s[1]),
                d.fromBufferAttribute(a, s[2]),
                oc.getNormal(ac),
                (c[0] = `${Math.round(e.x * n)},${Math.round(
                  e.y * n,
                )},${Math.round(e.z * n)}`),
                (c[1] = `${Math.round(o.x * n)},${Math.round(
                  o.y * n,
                )},${Math.round(o.z * n)}`),
                (c[2] = `${Math.round(d.x * n)},${Math.round(
                  d.y * n,
                )},${Math.round(d.z * n)}`),
                c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
              )
                for (let t = 0; t < 3; t++) {
                  const e = (t + 1) % 3,
                    n = c[t],
                    r = c[e],
                    a = oc[l[t]],
                    o = oc[l[e]],
                    d = `${n}_${r}`,
                    p = `${r}_${n}`;
                  p in u && u[p]
                    ? (ac.dot(u[p].normal) <= i &&
                        (h.push(a.x, a.y, a.z), h.push(o.x, o.y, o.z)),
                      (u[p] = null))
                    : d in u ||
                      (u[d] = {
                        index0: s[t],
                        index1: s[e],
                        normal: ac.clone(),
                      });
                }
            }
            for (const t in u)
              if (u[t]) {
                const { index0: e, index1: n } = u[t];
                ic.fromBufferAttribute(a, e),
                  rc.fromBufferAttribute(a, n),
                  h.push(ic.x, ic.y, ic.z),
                  h.push(rc.x, rc.y, rc.z);
              }
            this.setAttribute('position', new Or(h, 3));
          }
        }
        const lc = function (t, e, n) {
          n = n || 2;
          const i = e && e.length,
            r = i ? e[0] * n : t.length;
          let a = cc(t, 0, r, n, !0);
          const o = [];
          if (!a || a.next === a.prev) return o;
          let s, l, c, u, h, d, p;
          if (
            (i &&
              (a = (function (t, e, n, i) {
                const r = [];
                let a, o, s, l, c;
                for (a = 0, o = e.length; a < o; a++)
                  (s = e[a] * i),
                    (l = a < o - 1 ? e[a + 1] * i : t.length),
                    (c = cc(t, s, l, i, !1)),
                    c === c.next && (c.steiner = !0),
                    r.push(bc(c));
                for (r.sort(gc), a = 0; a < r.length; a++)
                  yc(r[a], n), (n = uc(n, n.next));
                return n;
              })(t, e, a, n)),
            t.length > 80 * n)
          ) {
            (s = c = t[0]), (l = u = t[1]);
            for (let e = n; e < r; e += n)
              (h = t[e]),
                (d = t[e + 1]),
                h < s && (s = h),
                d < l && (l = d),
                h > c && (c = h),
                d > u && (u = d);
            (p = Math.max(c - s, u - l)), (p = 0 !== p ? 1 / p : 0);
          }
          return hc(a, o, n, s, l, p), o;
        };
        function cc(t, e, n, i, r) {
          let a, o;
          if (
            r ===
            (function (t, e, n, i) {
              let r = 0;
              for (let a = e, o = n - i; a < n; a += i)
                (r += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
              return r;
            })(t, e, n, i) >
              0
          )
            for (a = e; a < n; a += i) o = Rc(a, t[a], t[a + 1], o);
          else for (a = n - i; a >= e; a -= i) o = Rc(a, t[a], t[a + 1], o);
          return o && qc(o, o.next) && (Cc(o), (o = o.next)), o;
        }
        function uc(t, e) {
          if (!t) return t;
          e || (e = t);
          let n,
            i = t;
          do {
            if (
              ((n = !1),
              i.steiner || (!qc(i, i.next) && 0 !== Mc(i.prev, i, i.next)))
            )
              i = i.next;
            else {
              if ((Cc(i), (i = e = i.prev), i === i.next)) break;
              n = !0;
            }
          } while (n || i !== e);
          return e;
        }
        function hc(t, e, n, i, r, a, o) {
          if (!t) return;
          !o &&
            a &&
            (function (t, e, n, i) {
              let r = t;
              do {
                null === r.z && (r.z = xc(r.x, r.y, e, n, i)),
                  (r.prevZ = r.prev),
                  (r.nextZ = r.next),
                  (r = r.next);
              } while (r !== t);
              (r.prevZ.nextZ = null),
                (r.prevZ = null),
                (function (t) {
                  let e,
                    n,
                    i,
                    r,
                    a,
                    o,
                    s,
                    l,
                    c = 1;
                  do {
                    for (n = t, t = null, a = null, o = 0; n; ) {
                      for (
                        o++, i = n, s = 0, e = 0;
                        e < c && (s++, (i = i.nextZ), i);
                        e++
                      );
                      for (l = c; s > 0 || (l > 0 && i); )
                        0 !== s && (0 === l || !i || n.z <= i.z)
                          ? ((r = n), (n = n.nextZ), s--)
                          : ((r = i), (i = i.nextZ), l--),
                          a ? (a.nextZ = r) : (t = r),
                          (r.prevZ = a),
                          (a = r);
                      n = i;
                    }
                    (a.nextZ = null), (c *= 2);
                  } while (o > 1);
                })(r);
            })(t, i, r, a);
          let s,
            l,
            c = t;
          for (; t.prev !== t.next; )
            if (((s = t.prev), (l = t.next), a ? pc(t, i, r, a) : dc(t)))
              e.push(s.i / n),
                e.push(t.i / n),
                e.push(l.i / n),
                Cc(t),
                (t = l.next),
                (c = l.next);
            else if ((t = l) === c) {
              o
                ? 1 === o
                  ? hc((t = fc(uc(t), e, n)), e, n, i, r, a, 2)
                  : 2 === o && mc(t, e, n, i, r, a)
                : hc(uc(t), e, n, i, r, a, 1);
              break;
            }
        }
        function dc(t) {
          const e = t.prev,
            n = t,
            i = t.next;
          if (Mc(e, n, i) >= 0) return !1;
          let r = t.next.next;
          for (; r !== t.prev; ) {
            if (
              _c(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
              Mc(r.prev, r, r.next) >= 0
            )
              return !1;
            r = r.next;
          }
          return !0;
        }
        function pc(t, e, n, i) {
          const r = t.prev,
            a = t,
            o = t.next;
          if (Mc(r, a, o) >= 0) return !1;
          const s = r.x < a.x ? (r.x < o.x ? r.x : o.x) : a.x < o.x ? a.x : o.x,
            l = r.y < a.y ? (r.y < o.y ? r.y : o.y) : a.y < o.y ? a.y : o.y,
            c = r.x > a.x ? (r.x > o.x ? r.x : o.x) : a.x > o.x ? a.x : o.x,
            u = r.y > a.y ? (r.y > o.y ? r.y : o.y) : a.y > o.y ? a.y : o.y,
            h = xc(s, l, e, n, i),
            d = xc(c, u, e, n, i);
          let p = t.prevZ,
            f = t.nextZ;
          for (; p && p.z >= h && f && f.z <= d; ) {
            if (
              p !== t.prev &&
              p !== t.next &&
              _c(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
              Mc(p.prev, p, p.next) >= 0
            )
              return !1;
            if (
              ((p = p.prevZ),
              f !== t.prev &&
                f !== t.next &&
                _c(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
                Mc(f.prev, f, f.next) >= 0)
            )
              return !1;
            f = f.nextZ;
          }
          for (; p && p.z >= h; ) {
            if (
              p !== t.prev &&
              p !== t.next &&
              _c(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) &&
              Mc(p.prev, p, p.next) >= 0
            )
              return !1;
            p = p.prevZ;
          }
          for (; f && f.z <= d; ) {
            if (
              f !== t.prev &&
              f !== t.next &&
              _c(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
              Mc(f.prev, f, f.next) >= 0
            )
              return !1;
            f = f.nextZ;
          }
          return !0;
        }
        function fc(t, e, n) {
          let i = t;
          do {
            const r = i.prev,
              a = i.next.next;
            !qc(r, a) &&
              Sc(r, i, i.next, a) &&
              Ac(r, a) &&
              Ac(a, r) &&
              (e.push(r.i / n),
              e.push(i.i / n),
              e.push(a.i / n),
              Cc(i),
              Cc(i.next),
              (i = t = a)),
              (i = i.next);
          } while (i !== t);
          return uc(i);
        }
        function mc(t, e, n, i, r, a) {
          let o = t;
          do {
            let t = o.next.next;
            for (; t !== o.prev; ) {
              if (o.i !== t.i && wc(o, t)) {
                let s = Lc(o, t);
                return (
                  (o = uc(o, o.next)),
                  (s = uc(s, s.next)),
                  hc(o, e, n, i, r, a),
                  void hc(s, e, n, i, r, a)
                );
              }
              t = t.next;
            }
            o = o.next;
          } while (o !== t);
        }
        function gc(t, e) {
          return t.x - e.x;
        }
        function yc(t, e) {
          if (
            (e = (function (t, e) {
              let n = e;
              const i = t.x,
                r = t.y;
              let a,
                o = -1 / 0;
              do {
                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                  const t =
                    n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                  if (t <= i && t > o) {
                    if (((o = t), t === i)) {
                      if (r === n.y) return n;
                      if (r === n.next.y) return n.next;
                    }
                    a = n.x < n.next.x ? n : n.next;
                  }
                }
                n = n.next;
              } while (n !== e);
              if (!a) return null;
              if (i === o) return a;
              const s = a,
                l = a.x,
                c = a.y;
              let u,
                h = 1 / 0;
              n = a;
              do {
                i >= n.x &&
                  n.x >= l &&
                  i !== n.x &&
                  _c(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) &&
                  ((u = Math.abs(r - n.y) / (i - n.x)),
                  Ac(n, t) &&
                    (u < h ||
                      (u === h && (n.x > a.x || (n.x === a.x && vc(a, n))))) &&
                    ((a = n), (h = u))),
                  (n = n.next);
              } while (n !== s);
              return a;
            })(t, e))
          ) {
            const n = Lc(e, t);
            uc(e, e.next), uc(n, n.next);
          }
        }
        function vc(t, e) {
          return Mc(t.prev, t, e.prev) < 0 && Mc(e.next, t, t.next) < 0;
        }
        function xc(t, e, n, i, r) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t =
                  252645135 &
                  ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                    (t << 4))) |
                  (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e =
                  252645135 &
                  ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                    (e << 4))) |
                  (e << 2))) |
                (e << 1))) <<
              1)
          );
        }
        function bc(t) {
          let e = t,
            n = t;
          do {
            (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
          } while (e !== t);
          return n;
        }
        function _c(t, e, n, i, r, a, o, s) {
          return (
            (r - o) * (e - s) - (t - o) * (a - s) >= 0 &&
            (t - o) * (i - s) - (n - o) * (e - s) >= 0 &&
            (n - o) * (a - s) - (r - o) * (i - s) >= 0
          );
        }
        function wc(t, e) {
          return (
            t.next.i !== e.i &&
            t.prev.i !== e.i &&
            !(function (t, e) {
              let n = t;
              do {
                if (
                  n.i !== t.i &&
                  n.next.i !== t.i &&
                  n.i !== e.i &&
                  n.next.i !== e.i &&
                  Sc(n, n.next, t, e)
                )
                  return !0;
                n = n.next;
              } while (n !== t);
              return !1;
            })(t, e) &&
            ((Ac(t, e) &&
              Ac(e, t) &&
              (function (t, e) {
                let n = t,
                  i = !1;
                const r = (t.x + e.x) / 2,
                  a = (t.y + e.y) / 2;
                do {
                  n.y > a != n.next.y > a &&
                    n.next.y !== n.y &&
                    r <
                      ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x &&
                    (i = !i),
                    (n = n.next);
                } while (n !== t);
                return i;
              })(t, e) &&
              (Mc(t.prev, t, e.prev) || Mc(t, e.prev, e))) ||
              (qc(t, e) &&
                Mc(t.prev, t, t.next) > 0 &&
                Mc(e.prev, e, e.next) > 0))
          );
        }
        function Mc(t, e, n) {
          return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
        }
        function qc(t, e) {
          return t.x === e.x && t.y === e.y;
        }
        function Sc(t, e, n, i) {
          const r = Ec(Mc(t, e, n)),
            a = Ec(Mc(t, e, i)),
            o = Ec(Mc(n, i, t)),
            s = Ec(Mc(n, i, e));
          return (
            (r !== a && o !== s) ||
            !(0 !== r || !Tc(t, n, e)) ||
            !(0 !== a || !Tc(t, i, e)) ||
            !(0 !== o || !Tc(n, t, i)) ||
            !(0 !== s || !Tc(n, e, i))
          );
        }
        function Tc(t, e, n) {
          return (
            e.x <= Math.max(t.x, n.x) &&
            e.x >= Math.min(t.x, n.x) &&
            e.y <= Math.max(t.y, n.y) &&
            e.y >= Math.min(t.y, n.y)
          );
        }
        function Ec(t) {
          return t > 0 ? 1 : t < 0 ? -1 : 0;
        }
        function Ac(t, e) {
          return Mc(t.prev, t, t.next) < 0
            ? Mc(t, e, t.next) >= 0 && Mc(t, t.prev, e) >= 0
            : Mc(t, e, t.prev) < 0 || Mc(t, t.next, e) < 0;
        }
        function Lc(t, e) {
          const n = new Pc(t.i, t.x, t.y),
            i = new Pc(e.i, e.x, e.y),
            r = t.next,
            a = e.prev;
          return (
            (t.next = e),
            (e.prev = t),
            (n.next = r),
            (r.prev = n),
            (i.next = n),
            (n.prev = i),
            (a.next = i),
            (i.prev = a),
            i
          );
        }
        function Rc(t, e, n, i) {
          const r = new Pc(t, e, n);
          return (
            i
              ? ((r.next = i.next),
                (r.prev = i),
                (i.next.prev = r),
                (i.next = r))
              : ((r.prev = r), (r.next = r)),
            r
          );
        }
        function Cc(t) {
          (t.next.prev = t.prev),
            (t.prev.next = t.next),
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }
        function Pc(t, e, n) {
          (this.i = t),
            (this.x = e),
            (this.y = n),
            (this.prev = null),
            (this.next = null),
            (this.z = null),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1);
        }
        const kc = {
          area: function (t) {
            const e = t.length;
            let n = 0;
            for (let i = e - 1, r = 0; r < e; i = r++)
              n += t[i].x * t[r].y - t[r].x * t[i].y;
            return 0.5 * n;
          },
          isClockWise: function (t) {
            return kc.area(t) < 0;
          },
          triangulateShape: function (t, e) {
            const n = [],
              i = [],
              r = [];
            Ic(t), Dc(n, t);
            let a = t.length;
            e.forEach(Ic);
            for (let t = 0; t < e.length; t++)
              i.push(a), (a += e[t].length), Dc(n, e[t]);
            const o = lc(n, i);
            for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3));
            return r;
          },
        };
        function Ic(t) {
          const e = t.length;
          e > 2 && t[e - 1].equals(t[0]) && t.pop();
        }
        function Dc(t, e) {
          for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
        }
        class Oc extends Yr {
          constructor(t, e) {
            super(),
              (this.type = 'ExtrudeGeometry'),
              (this.parameters = { shapes: t, options: e }),
              (t = Array.isArray(t) ? t : [t]);
            const n = this,
              i = [],
              r = [];
            for (let e = 0, n = t.length; e < n; e++) {
              a(t[e]);
            }
            function a(t) {
              const a = [],
                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                s = void 0 !== e.steps ? e.steps : 1;
              let l = void 0 !== e.depth ? e.depth : 100,
                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                u = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                h = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
              const f = e.extrudePath,
                m = void 0 !== e.UVGenerator ? e.UVGenerator : Nc;
              void 0 !== e.amount &&
                (console.warn(
                  'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.',
                ),
                (l = e.amount));
              let g,
                y,
                v,
                x,
                b,
                _ = !1;
              f &&
                ((g = f.getSpacedPoints(s)),
                (_ = !0),
                (c = !1),
                (y = f.computeFrenetFrames(s, !1)),
                (v = new Zn()),
                (x = new Zn()),
                (b = new Zn())),
                c || ((p = 0), (u = 0), (h = 0), (d = 0));
              const w = t.extractPoints(o);
              let M = w.shape;
              const q = w.holes;
              if (!kc.isClockWise(M)) {
                M = M.reverse();
                for (let t = 0, e = q.length; t < e; t++) {
                  const e = q[t];
                  kc.isClockWise(e) && (q[t] = e.reverse());
                }
              }
              const S = kc.triangulateShape(M, q),
                T = M;
              for (let t = 0, e = q.length; t < e; t++) {
                const e = q[t];
                M = M.concat(e);
              }
              function E(t, e, n) {
                return (
                  e ||
                    console.error('THREE.ExtrudeGeometry: vec does not exist'),
                  e.clone().multiplyScalar(n).add(t)
                );
              }
              const A = M.length,
                L = S.length;
              function R(t, e, n) {
                let i, r, a;
                const o = t.x - e.x,
                  s = t.y - e.y,
                  l = n.x - t.x,
                  c = n.y - t.y,
                  u = o * o + s * s,
                  h = o * c - s * l;
                if (Math.abs(h) > Number.EPSILON) {
                  const h = Math.sqrt(u),
                    d = Math.sqrt(l * l + c * c),
                    p = e.x - s / h,
                    f = e.y + o / h,
                    m =
                      ((n.x - c / d - p) * c - (n.y + l / d - f) * l) /
                      (o * c - s * l);
                  (i = p + o * m - t.x), (r = f + s * m - t.y);
                  const g = i * i + r * r;
                  if (g <= 2) return new Bn(i, r);
                  a = Math.sqrt(g / 2);
                } else {
                  let t = !1;
                  o > Number.EPSILON
                    ? l > Number.EPSILON && (t = !0)
                    : o < -Number.EPSILON
                    ? l < -Number.EPSILON && (t = !0)
                    : Math.sign(s) === Math.sign(c) && (t = !0),
                    t
                      ? ((i = -s), (r = o), (a = Math.sqrt(u)))
                      : ((i = o), (r = s), (a = Math.sqrt(u / 2)));
                }
                return new Bn(i / a, r / a);
              }
              const C = [];
              for (
                let t = 0, e = T.length, n = e - 1, i = t + 1;
                t < e;
                t++, n++, i++
              )
                n === e && (n = 0),
                  i === e && (i = 0),
                  (C[t] = R(T[t], T[n], T[i]));
              const P = [];
              let k,
                I = C.concat();
              for (let t = 0, e = q.length; t < e; t++) {
                const e = q[t];
                k = [];
                for (
                  let t = 0, n = e.length, i = n - 1, r = t + 1;
                  t < n;
                  t++, i++, r++
                )
                  i === n && (i = 0),
                    r === n && (r = 0),
                    (k[t] = R(e[t], e[i], e[r]));
                P.push(k), (I = I.concat(k));
              }
              for (let t = 0; t < p; t++) {
                const e = t / p,
                  n = u * Math.cos((e * Math.PI) / 2),
                  i = h * Math.sin((e * Math.PI) / 2) + d;
                for (let t = 0, e = T.length; t < e; t++) {
                  const e = E(T[t], C[t], i);
                  N(e.x, e.y, -n);
                }
                for (let t = 0, e = q.length; t < e; t++) {
                  const e = q[t];
                  k = P[t];
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = E(e[t], k[t], i);
                    N(r.x, r.y, -n);
                  }
                }
              }
              const D = h + d;
              for (let t = 0; t < A; t++) {
                const e = c ? E(M[t], I[t], D) : M[t];
                _
                  ? (x.copy(y.normals[0]).multiplyScalar(e.x),
                    v.copy(y.binormals[0]).multiplyScalar(e.y),
                    b.copy(g[0]).add(x).add(v),
                    N(b.x, b.y, b.z))
                  : N(e.x, e.y, 0);
              }
              for (let t = 1; t <= s; t++)
                for (let e = 0; e < A; e++) {
                  const n = c ? E(M[e], I[e], D) : M[e];
                  _
                    ? (x.copy(y.normals[t]).multiplyScalar(n.x),
                      v.copy(y.binormals[t]).multiplyScalar(n.y),
                      b.copy(g[t]).add(x).add(v),
                      N(b.x, b.y, b.z))
                    : N(n.x, n.y, (l / s) * t);
                }
              for (let t = p - 1; t >= 0; t--) {
                const e = t / p,
                  n = u * Math.cos((e * Math.PI) / 2),
                  i = h * Math.sin((e * Math.PI) / 2) + d;
                for (let t = 0, e = T.length; t < e; t++) {
                  const e = E(T[t], C[t], i);
                  N(e.x, e.y, l + n);
                }
                for (let t = 0, e = q.length; t < e; t++) {
                  const e = q[t];
                  k = P[t];
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = E(e[t], k[t], i);
                    _
                      ? N(r.x, r.y + g[s - 1].y, g[s - 1].x + n)
                      : N(r.x, r.y, l + n);
                  }
                }
              }
              function O(t, e) {
                let n = t.length;
                for (; --n >= 0; ) {
                  const i = n;
                  let r = n - 1;
                  r < 0 && (r = t.length - 1);
                  for (let t = 0, n = s + 2 * p; t < n; t++) {
                    const n = A * t,
                      a = A * (t + 1);
                    F(e + i + n, e + r + n, e + r + a, e + i + a);
                  }
                }
              }
              function N(t, e, n) {
                a.push(t), a.push(e), a.push(n);
              }
              function z(t, e, r) {
                B(t), B(e), B(r);
                const a = i.length / 3,
                  o = m.generateTopUV(n, i, a - 3, a - 2, a - 1);
                U(o[0]), U(o[1]), U(o[2]);
              }
              function F(t, e, r, a) {
                B(t), B(e), B(a), B(e), B(r), B(a);
                const o = i.length / 3,
                  s = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                U(s[0]), U(s[1]), U(s[3]), U(s[1]), U(s[2]), U(s[3]);
              }
              function B(t) {
                i.push(a[3 * t + 0]),
                  i.push(a[3 * t + 1]),
                  i.push(a[3 * t + 2]);
              }
              function U(t) {
                r.push(t.x), r.push(t.y);
              }
              !(function () {
                const t = i.length / 3;
                if (c) {
                  let t = 0,
                    e = A * t;
                  for (let t = 0; t < L; t++) {
                    const n = S[t];
                    z(n[2] + e, n[1] + e, n[0] + e);
                  }
                  (t = s + 2 * p), (e = A * t);
                  for (let t = 0; t < L; t++) {
                    const n = S[t];
                    z(n[0] + e, n[1] + e, n[2] + e);
                  }
                } else {
                  for (let t = 0; t < L; t++) {
                    const e = S[t];
                    z(e[2], e[1], e[0]);
                  }
                  for (let t = 0; t < L; t++) {
                    const e = S[t];
                    z(e[0] + A * s, e[1] + A * s, e[2] + A * s);
                  }
                }
                n.addGroup(t, i.length / 3 - t, 0);
              })(),
                (function () {
                  const t = i.length / 3;
                  let e = 0;
                  O(T, e), (e += T.length);
                  for (let t = 0, n = q.length; t < n; t++) {
                    const n = q[t];
                    O(n, e), (e += n.length);
                  }
                  n.addGroup(t, i.length / 3 - t, 1);
                })();
            }
            this.setAttribute('position', new Or(i, 3)),
              this.setAttribute('uv', new Or(r, 2)),
              this.computeVertexNormals();
          }
          toJSON() {
            const t = Yr.prototype.toJSON.call(this);
            return (function (t, e, n) {
              if (((n.shapes = []), Array.isArray(t)))
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e];
                  n.shapes.push(i.uuid);
                }
              else n.shapes.push(t.uuid);
              void 0 !== e.extrudePath &&
                (n.options.extrudePath = e.extrudePath.toJSON());
              return n;
            })(this.parameters.shapes, this.parameters.options, t);
          }
        }
        const Nc = {
          generateTopUV: function (t, e, n, i, r) {
            const a = e[3 * n],
              o = e[3 * n + 1],
              s = e[3 * i],
              l = e[3 * i + 1],
              c = e[3 * r],
              u = e[3 * r + 1];
            return [new Bn(a, o), new Bn(s, l), new Bn(c, u)];
          },
          generateSideWallUV: function (t, e, n, i, r, a) {
            const o = e[3 * n],
              s = e[3 * n + 1],
              l = e[3 * n + 2],
              c = e[3 * i],
              u = e[3 * i + 1],
              h = e[3 * i + 2],
              d = e[3 * r],
              p = e[3 * r + 1],
              f = e[3 * r + 2],
              m = e[3 * a],
              g = e[3 * a + 1],
              y = e[3 * a + 2];
            return Math.abs(s - u) < 0.01
              ? [
                  new Bn(o, 1 - l),
                  new Bn(c, 1 - h),
                  new Bn(d, 1 - f),
                  new Bn(m, 1 - y),
                ]
              : [
                  new Bn(s, 1 - l),
                  new Bn(u, 1 - h),
                  new Bn(p, 1 - f),
                  new Bn(g, 1 - y),
                ];
          },
        };
        class zc extends ec {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2;
            super(
              [
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                0,
                0,
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                n,
                0,
                -1,
                n,
                0,
                1,
                -n,
                0,
                -1,
                -n,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
              ],
              t,
              e,
            ),
              (this.type = 'IcosahedronGeometry'),
              (this.parameters = { radius: t, detail: e });
          }
        }
        class Fc extends Yr {
          constructor(t, e = 12, n = 0, i = 2 * Math.PI) {
            super(),
              (this.type = 'LatheGeometry'),
              (this.parameters = {
                points: t,
                segments: e,
                phiStart: n,
                phiLength: i,
              }),
              (e = Math.floor(e)),
              (i = Fn.clamp(i, 0, 2 * Math.PI));
            const r = [],
              a = [],
              o = [],
              s = 1 / e,
              l = new Zn(),
              c = new Bn();
            for (let r = 0; r <= e; r++) {
              const u = n + r * s * i,
                h = Math.sin(u),
                d = Math.cos(u);
              for (let n = 0; n <= t.length - 1; n++)
                (l.x = t[n].x * h),
                  (l.y = t[n].y),
                  (l.z = t[n].x * d),
                  a.push(l.x, l.y, l.z),
                  (c.x = r / e),
                  (c.y = n / (t.length - 1)),
                  o.push(c.x, c.y);
            }
            for (let n = 0; n < e; n++)
              for (let e = 0; e < t.length - 1; e++) {
                const i = e + n * t.length,
                  a = i,
                  o = i + t.length,
                  s = i + t.length + 1,
                  l = i + 1;
                r.push(a, o, l), r.push(o, s, l);
              }
            if (
              (this.setIndex(r),
              this.setAttribute('position', new Or(a, 3)),
              this.setAttribute('uv', new Or(o, 2)),
              this.computeVertexNormals(),
              i === 2 * Math.PI)
            ) {
              const n = this.attributes.normal.array,
                i = new Zn(),
                r = new Zn(),
                a = new Zn(),
                o = e * t.length * 3;
              for (let e = 0, s = 0; e < t.length; e++, s += 3)
                (i.x = n[s + 0]),
                  (i.y = n[s + 1]),
                  (i.z = n[s + 2]),
                  (r.x = n[o + s + 0]),
                  (r.y = n[o + s + 1]),
                  (r.z = n[o + s + 2]),
                  a.addVectors(i, r).normalize(),
                  (n[s + 0] = n[o + s + 0] = a.x),
                  (n[s + 1] = n[o + s + 1] = a.y),
                  (n[s + 2] = n[o + s + 2] = a.z);
            }
          }
        }
        class Bc extends ec {
          constructor(t = 1, e = 0) {
            super(
              [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
              [
                0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4,
                1, 4, 2,
              ],
              t,
              e,
            ),
              (this.type = 'OctahedronGeometry'),
              (this.parameters = { radius: t, detail: e });
          }
        }
        function Uc(t, e, n) {
          Yr.call(this),
            (this.type = 'ParametricGeometry'),
            (this.parameters = { func: t, slices: e, stacks: n });
          const i = [],
            r = [],
            a = [],
            o = [],
            s = 1e-5,
            l = new Zn(),
            c = new Zn(),
            u = new Zn(),
            h = new Zn(),
            d = new Zn();
          t.length < 3 &&
            console.error(
              'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.',
            );
          const p = e + 1;
          for (let i = 0; i <= n; i++) {
            const p = i / n;
            for (let n = 0; n <= e; n++) {
              const i = n / e;
              t(i, p, c),
                r.push(c.x, c.y, c.z),
                i - s >= 0
                  ? (t(i - s, p, u), h.subVectors(c, u))
                  : (t(i + s, p, u), h.subVectors(u, c)),
                p - s >= 0
                  ? (t(i, p - s, u), d.subVectors(c, u))
                  : (t(i, p + s, u), d.subVectors(u, c)),
                l.crossVectors(h, d).normalize(),
                a.push(l.x, l.y, l.z),
                o.push(i, p);
            }
          }
          for (let t = 0; t < n; t++)
            for (let n = 0; n < e; n++) {
              const e = t * p + n,
                r = t * p + n + 1,
                a = (t + 1) * p + n + 1,
                o = (t + 1) * p + n;
              i.push(e, r, o), i.push(r, a, o);
            }
          this.setIndex(i),
            this.setAttribute('position', new Or(r, 3)),
            this.setAttribute('normal', new Or(a, 3)),
            this.setAttribute('uv', new Or(o, 2));
        }
        (Uc.prototype = Object.create(Yr.prototype)),
          (Uc.prototype.constructor = Uc);
        class jc extends Yr {
          constructor(t = 0.5, e = 1, n = 8, i = 1, r = 0, a = 2 * Math.PI) {
            super(),
              (this.type = 'RingGeometry'),
              (this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: a,
              }),
              (n = Math.max(3, n));
            const o = [],
              s = [],
              l = [],
              c = [];
            let u = t;
            const h = (e - t) / (i = Math.max(1, i)),
              d = new Zn(),
              p = new Bn();
            for (let t = 0; t <= i; t++) {
              for (let t = 0; t <= n; t++) {
                const i = r + (t / n) * a;
                (d.x = u * Math.cos(i)),
                  (d.y = u * Math.sin(i)),
                  s.push(d.x, d.y, d.z),
                  l.push(0, 0, 1),
                  (p.x = (d.x / e + 1) / 2),
                  (p.y = (d.y / e + 1) / 2),
                  c.push(p.x, p.y);
              }
              u += h;
            }
            for (let t = 0; t < i; t++) {
              const e = t * (n + 1);
              for (let t = 0; t < n; t++) {
                const i = t + e,
                  r = i,
                  a = i + n + 1,
                  s = i + n + 2,
                  l = i + 1;
                o.push(r, a, l), o.push(a, s, l);
              }
            }
            this.setIndex(o),
              this.setAttribute('position', new Or(s, 3)),
              this.setAttribute('normal', new Or(l, 3)),
              this.setAttribute('uv', new Or(c, 2));
          }
        }
        class Gc extends Yr {
          constructor(t, e = 12) {
            super(),
              (this.type = 'ShapeGeometry'),
              (this.parameters = { shapes: t, curveSegments: e });
            const n = [],
              i = [],
              r = [],
              a = [];
            let o = 0,
              s = 0;
            if (!1 === Array.isArray(t)) l(t);
            else
              for (let e = 0; e < t.length; e++)
                l(t[e]), this.addGroup(o, s, e), (o += s), (s = 0);
            function l(t) {
              const o = i.length / 3,
                l = t.extractPoints(e);
              let c = l.shape;
              const u = l.holes;
              !1 === kc.isClockWise(c) && (c = c.reverse());
              for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t];
                !0 === kc.isClockWise(e) && (u[t] = e.reverse());
              }
              const h = kc.triangulateShape(c, u);
              for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t];
                c = c.concat(e);
              }
              for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                i.push(e.x, e.y, 0), r.push(0, 0, 1), a.push(e.x, e.y);
              }
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t],
                  i = e[0] + o,
                  r = e[1] + o,
                  a = e[2] + o;
                n.push(i, r, a), (s += 3);
              }
            }
            this.setIndex(n),
              this.setAttribute('position', new Or(i, 3)),
              this.setAttribute('normal', new Or(r, 3)),
              this.setAttribute('uv', new Or(a, 2));
          }
          toJSON() {
            const t = Yr.prototype.toJSON.call(this);
            return (function (t, e) {
              if (((e.shapes = []), Array.isArray(t)))
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = t[n];
                  e.shapes.push(i.uuid);
                }
              else e.shapes.push(t.uuid);
              return e;
            })(this.parameters.shapes, t);
          }
        }
        class Hc extends Yr {
          constructor(
            t = 1,
            e = 8,
            n = 6,
            i = 0,
            r = 2 * Math.PI,
            a = 0,
            o = Math.PI,
          ) {
            super(),
              (this.type = 'SphereGeometry'),
              (this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: a,
                thetaLength: o,
              }),
              (e = Math.max(3, Math.floor(e))),
              (n = Math.max(2, Math.floor(n)));
            const s = Math.min(a + o, Math.PI);
            let l = 0;
            const c = [],
              u = new Zn(),
              h = new Zn(),
              d = [],
              p = [],
              f = [],
              m = [];
            for (let d = 0; d <= n; d++) {
              const g = [],
                y = d / n;
              let v = 0;
              0 == d && 0 == a
                ? (v = 0.5 / e)
                : d == n && s == Math.PI && (v = -0.5 / e);
              for (let n = 0; n <= e; n++) {
                const s = n / e;
                (u.x = -t * Math.cos(i + s * r) * Math.sin(a + y * o)),
                  (u.y = t * Math.cos(a + y * o)),
                  (u.z = t * Math.sin(i + s * r) * Math.sin(a + y * o)),
                  p.push(u.x, u.y, u.z),
                  h.copy(u).normalize(),
                  f.push(h.x, h.y, h.z),
                  m.push(s + v, 1 - y),
                  g.push(l++);
              }
              c.push(g);
            }
            for (let t = 0; t < n; t++)
              for (let i = 0; i < e; i++) {
                const e = c[t][i + 1],
                  r = c[t][i],
                  o = c[t + 1][i],
                  l = c[t + 1][i + 1];
                (0 !== t || a > 0) && d.push(e, r, l),
                  (t !== n - 1 || s < Math.PI) && d.push(r, o, l);
              }
            this.setIndex(d),
              this.setAttribute('position', new Or(p, 3)),
              this.setAttribute('normal', new Or(f, 3)),
              this.setAttribute('uv', new Or(m, 2));
          }
        }
        class Vc extends ec {
          constructor(t = 1, e = 0) {
            super(
              [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
              [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
              t,
              e,
            ),
              (this.type = 'TetrahedronGeometry'),
              (this.parameters = { radius: t, detail: e });
          }
        }
        class Wc extends Oc {
          constructor(t, e = {}) {
            const n = e.font;
            if (!n || !n.isFont)
              return (
                console.error(
                  'THREE.TextGeometry: font parameter is not an instance of THREE.Font.',
                ),
                new Yr()
              );
            const i = n.generateShapes(t, e.size);
            (e.depth = void 0 !== e.height ? e.height : 50),
              void 0 === e.bevelThickness && (e.bevelThickness = 10),
              void 0 === e.bevelSize && (e.bevelSize = 8),
              void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
              super(i, e),
              (this.type = 'TextGeometry');
          }
        }
        class Xc extends Yr {
          constructor(t = 1, e = 0.4, n = 8, i = 6, r = 2 * Math.PI) {
            super(),
              (this.type = 'TorusGeometry'),
              (this.parameters = {
                radius: t,
                tube: e,
                radialSegments: n,
                tubularSegments: i,
                arc: r,
              }),
              (n = Math.floor(n)),
              (i = Math.floor(i));
            const a = [],
              o = [],
              s = [],
              l = [],
              c = new Zn(),
              u = new Zn(),
              h = new Zn();
            for (let a = 0; a <= n; a++)
              for (let d = 0; d <= i; d++) {
                const p = (d / i) * r,
                  f = (a / n) * Math.PI * 2;
                (u.x = (t + e * Math.cos(f)) * Math.cos(p)),
                  (u.y = (t + e * Math.cos(f)) * Math.sin(p)),
                  (u.z = e * Math.sin(f)),
                  o.push(u.x, u.y, u.z),
                  (c.x = t * Math.cos(p)),
                  (c.y = t * Math.sin(p)),
                  h.subVectors(u, c).normalize(),
                  s.push(h.x, h.y, h.z),
                  l.push(d / i),
                  l.push(a / n);
              }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * t + e - 1,
                  r = (i + 1) * (t - 1) + e - 1,
                  o = (i + 1) * (t - 1) + e,
                  s = (i + 1) * t + e;
                a.push(n, r, s), a.push(r, o, s);
              }
            this.setIndex(a),
              this.setAttribute('position', new Or(o, 3)),
              this.setAttribute('normal', new Or(s, 3)),
              this.setAttribute('uv', new Or(l, 2));
          }
        }
        class Yc extends Yr {
          constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, a = 3) {
            super(),
              (this.type = 'TorusKnotGeometry'),
              (this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: n,
                radialSegments: i,
                p: r,
                q: a,
              }),
              (n = Math.floor(n)),
              (i = Math.floor(i));
            const o = [],
              s = [],
              l = [],
              c = [],
              u = new Zn(),
              h = new Zn(),
              d = new Zn(),
              p = new Zn(),
              f = new Zn(),
              m = new Zn(),
              g = new Zn();
            for (let o = 0; o <= n; ++o) {
              const v = (o / n) * r * Math.PI * 2;
              y(v, r, a, t, d),
                y(v + 0.01, r, a, t, p),
                m.subVectors(p, d),
                g.addVectors(p, d),
                f.crossVectors(m, g),
                g.crossVectors(f, m),
                f.normalize(),
                g.normalize();
              for (let t = 0; t <= i; ++t) {
                const r = (t / i) * Math.PI * 2,
                  a = -e * Math.cos(r),
                  p = e * Math.sin(r);
                (u.x = d.x + (a * g.x + p * f.x)),
                  (u.y = d.y + (a * g.y + p * f.y)),
                  (u.z = d.z + (a * g.z + p * f.z)),
                  s.push(u.x, u.y, u.z),
                  h.subVectors(u, d).normalize(),
                  l.push(h.x, h.y, h.z),
                  c.push(o / n),
                  c.push(t / i);
              }
            }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                  r = (i + 1) * t + (e - 1),
                  a = (i + 1) * t + e,
                  s = (i + 1) * (t - 1) + e;
                o.push(n, r, s), o.push(r, a, s);
              }
            function y(t, e, n, i, r) {
              const a = Math.cos(t),
                o = Math.sin(t),
                s = (n / e) * t,
                l = Math.cos(s);
              (r.x = i * (2 + l) * 0.5 * a),
                (r.y = i * (2 + l) * o * 0.5),
                (r.z = i * Math.sin(s) * 0.5);
            }
            this.setIndex(o),
              this.setAttribute('position', new Or(s, 3)),
              this.setAttribute('normal', new Or(l, 3)),
              this.setAttribute('uv', new Or(c, 2));
          }
        }
        class $c extends Yr {
          constructor(t, e = 64, n = 1, i = 8, r = !1) {
            super(),
              (this.type = 'TubeGeometry'),
              (this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: i,
                closed: r,
              });
            const a = t.computeFrenetFrames(e, r);
            (this.tangents = a.tangents),
              (this.normals = a.normals),
              (this.binormals = a.binormals);
            const o = new Zn(),
              s = new Zn(),
              l = new Bn();
            let c = new Zn();
            const u = [],
              h = [],
              d = [],
              p = [];
            function f(r) {
              c = t.getPointAt(r / e, c);
              const l = a.normals[r],
                d = a.binormals[r];
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * Math.PI * 2,
                  r = Math.sin(e),
                  a = -Math.cos(e);
                (s.x = a * l.x + r * d.x),
                  (s.y = a * l.y + r * d.y),
                  (s.z = a * l.z + r * d.z),
                  s.normalize(),
                  h.push(s.x, s.y, s.z),
                  (o.x = c.x + n * s.x),
                  (o.y = c.y + n * s.y),
                  (o.z = c.z + n * s.z),
                  u.push(o.x, o.y, o.z);
              }
            }
            !(function () {
              for (let t = 0; t < e; t++) f(t);
              f(!1 === r ? e : 0),
                (function () {
                  for (let t = 0; t <= e; t++)
                    for (let n = 0; n <= i; n++)
                      (l.x = t / e), (l.y = n / i), d.push(l.x, l.y);
                })(),
                (function () {
                  for (let t = 1; t <= e; t++)
                    for (let e = 1; e <= i; e++) {
                      const n = (i + 1) * (t - 1) + (e - 1),
                        r = (i + 1) * t + (e - 1),
                        a = (i + 1) * t + e,
                        o = (i + 1) * (t - 1) + e;
                      p.push(n, r, o), p.push(r, a, o);
                    }
                })();
            })(),
              this.setIndex(p),
              this.setAttribute('position', new Or(u, 3)),
              this.setAttribute('normal', new Or(h, 3)),
              this.setAttribute('uv', new Or(d, 2));
          }
          toJSON() {
            const t = Yr.prototype.toJSON.call(this);
            return (t.path = this.parameters.path.toJSON()), t;
          }
        }
        class Jc extends Yr {
          constructor(t) {
            if (
              (super(), (this.type = 'WireframeGeometry'), !0 === t.isGeometry)
            )
              return void console.error(
                'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
              );
            const e = [],
              n = [0, 0],
              i = {},
              r = new Zn();
            if (null !== t.index) {
              const a = t.attributes.position,
                o = t.index;
              let s = t.groups;
              0 === s.length &&
                (s = [{ start: 0, count: o.count, materialIndex: 0 }]);
              for (let t = 0, e = s.length; t < e; ++t) {
                const e = s[t],
                  r = e.start;
                for (let t = r, a = r + e.count; t < a; t += 3)
                  for (let e = 0; e < 3; e++) {
                    const r = o.getX(t + e),
                      a = o.getX(t + ((e + 1) % 3));
                    (n[0] = Math.min(r, a)), (n[1] = Math.max(r, a));
                    const s = n[0] + ',' + n[1];
                    void 0 === i[s] && (i[s] = { index1: n[0], index2: n[1] });
                  }
              }
              for (const t in i) {
                const n = i[t];
                r.fromBufferAttribute(a, n.index1),
                  e.push(r.x, r.y, r.z),
                  r.fromBufferAttribute(a, n.index2),
                  e.push(r.x, r.y, r.z);
              }
            } else {
              const n = t.attributes.position;
              for (let t = 0, i = n.count / 3; t < i; t++)
                for (let i = 0; i < 3; i++) {
                  const a = 3 * t + i;
                  r.fromBufferAttribute(n, a), e.push(r.x, r.y, r.z);
                  const o = 3 * t + ((i + 1) % 3);
                  r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z);
                }
            }
            this.setAttribute('position', new Or(e, 3));
          }
        }
        var Zc = Object.freeze({
          __proto__: null,
          BoxGeometry: fa,
          BoxBufferGeometry: fa,
          CircleGeometry: Kl,
          CircleBufferGeometry: Kl,
          ConeGeometry: tc,
          ConeBufferGeometry: tc,
          CylinderGeometry: Ql,
          CylinderBufferGeometry: Ql,
          DodecahedronGeometry: nc,
          DodecahedronBufferGeometry: nc,
          EdgesGeometry: sc,
          ExtrudeGeometry: Oc,
          ExtrudeBufferGeometry: Oc,
          IcosahedronGeometry: zc,
          IcosahedronBufferGeometry: zc,
          LatheGeometry: Fc,
          LatheBufferGeometry: Fc,
          OctahedronGeometry: Bc,
          OctahedronBufferGeometry: Bc,
          ParametricGeometry: Uc,
          ParametricBufferGeometry: Uc,
          PlaneGeometry: Ra,
          PlaneBufferGeometry: Ra,
          PolyhedronGeometry: ec,
          PolyhedronBufferGeometry: ec,
          RingGeometry: jc,
          RingBufferGeometry: jc,
          ShapeGeometry: Gc,
          ShapeBufferGeometry: Gc,
          SphereGeometry: Hc,
          SphereBufferGeometry: Hc,
          TetrahedronGeometry: Vc,
          TetrahedronBufferGeometry: Vc,
          TextGeometry: Wc,
          TextBufferGeometry: Wc,
          TorusGeometry: Xc,
          TorusBufferGeometry: Xc,
          TorusKnotGeometry: Yc,
          TorusKnotBufferGeometry: Yc,
          TubeGeometry: $c,
          TubeBufferGeometry: $c,
          WireframeGeometry: Jc,
        });
        class Kc extends gr {
          constructor(t) {
            super(),
              (this.type = 'ShadowMaterial'),
              (this.color = new Mr(0)),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return super.copy(t), this.color.copy(t.color), this;
          }
        }
        Kc.prototype.isShadowMaterial = !0;
        class Qc extends va {
          constructor(t) {
            super(t), (this.type = 'RawShaderMaterial');
          }
        }
        function tu(t) {
          gr.call(this),
            (this.defines = { STANDARD: '' }),
            (this.type = 'MeshStandardMaterial'),
            (this.color = new Mr(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Mr(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = sn),
            (this.normalScale = new Bn(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = 'round'),
            (this.wireframeLinejoin = 'round'),
            (this.skinning = !1),
            (this.morphTargets = !1),
            (this.morphNormals = !1),
            (this.flatShading = !1),
            (this.vertexTangents = !1),
            this.setValues(t);
        }
        function eu(t) {
          tu.call(this),
            (this.defines = { STANDARD: '', PHYSICAL: '' }),
            (this.type = 'MeshPhysicalMaterial'),
            (this.clearcoat = 0),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Bn(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.reflectivity = 0.5),
            Object.defineProperty(this, 'ior', {
              get: function () {
                return (
                  (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity)
                );
              },
              set: function (t) {
                this.reflectivity = Fn.clamp((2.5 * (t - 1)) / (t + 1), 0, 1);
              },
            }),
            (this.sheen = null),
            (this.transmission = 0),
            (this.transmissionMap = null),
            this.setValues(t);
        }
        (Qc.prototype.isRawShaderMaterial = !0),
          (tu.prototype = Object.create(gr.prototype)),
          (tu.prototype.constructor = tu),
          (tu.prototype.isMeshStandardMaterial = !0),
          (tu.prototype.copy = function (t) {
            return (
              gr.prototype.copy.call(this, t),
              (this.defines = { STANDARD: '' }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              (this.vertexTangents = t.vertexTangents),
              this
            );
          }),
          (eu.prototype = Object.create(tu.prototype)),
          (eu.prototype.constructor = eu),
          (eu.prototype.isMeshPhysicalMaterial = !0),
          (eu.prototype.copy = function (t) {
            return (
              tu.prototype.copy.call(this, t),
              (this.defines = { STANDARD: '', PHYSICAL: '' }),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.reflectivity = t.reflectivity),
              t.sheen
                ? (this.sheen = (this.sheen || new Mr()).copy(t.sheen))
                : (this.sheen = null),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              this
            );
          });
        class nu extends gr {
          constructor(t) {
            super(),
              (this.type = 'MeshPhongMaterial'),
              (this.color = new Mr(16777215)),
              (this.specular = new Mr(1118481)),
              (this.shininess = 30),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Mr(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = sn),
              (this.normalScale = new Bn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = $),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              this.specular.copy(t.specular),
              (this.shininess = t.shininess),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        nu.prototype.isMeshPhongMaterial = !0;
        class iu extends gr {
          constructor(t) {
            super(),
              (this.defines = { TOON: '' }),
              (this.type = 'MeshToonMaterial'),
              (this.color = new Mr(16777215)),
              (this.map = null),
              (this.gradientMap = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Mr(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = sn),
              (this.normalScale = new Bn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.gradientMap = t.gradientMap),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            );
          }
        }
        iu.prototype.isMeshToonMaterial = !0;
        class ru extends gr {
          constructor(t) {
            super(),
              (this.type = 'MeshNormalMaterial'),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = sn),
              (this.normalScale = new Bn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        ru.prototype.isMeshNormalMaterial = !0;
        class au extends gr {
          constructor(t) {
            super(),
              (this.type = 'MeshLambertMaterial'),
              (this.color = new Mr(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Mr(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = $),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = 'round'),
              (this.wireframeLinejoin = 'round'),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            );
          }
        }
        au.prototype.isMeshLambertMaterial = !0;
        class ou extends gr {
          constructor(t) {
            super(),
              (this.defines = { MATCAP: '' }),
              (this.type = 'MeshMatcapMaterial'),
              (this.color = new Mr(16777215)),
              (this.matcap = null),
              (this.map = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = sn),
              (this.normalScale = new Bn(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { MATCAP: '' }),
              this.color.copy(t.color),
              (this.matcap = t.matcap),
              (this.map = t.map),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        ou.prototype.isMeshMatcapMaterial = !0;
        class su extends Rl {
          constructor(t) {
            super(),
              (this.type = 'LineDashedMaterial'),
              (this.scale = 1),
              (this.dashSize = 3),
              (this.gapSize = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.scale = t.scale),
              (this.dashSize = t.dashSize),
              (this.gapSize = t.gapSize),
              this
            );
          }
        }
        su.prototype.isLineDashedMaterial = !0;
        var lu = Object.freeze({
          __proto__: null,
          ShadowMaterial: Kc,
          SpriteMaterial: Js,
          RawShaderMaterial: Qc,
          ShaderMaterial: va,
          PointsMaterial: Ul,
          MeshPhysicalMaterial: eu,
          MeshStandardMaterial: tu,
          MeshPhongMaterial: nu,
          MeshToonMaterial: iu,
          MeshNormalMaterial: ru,
          MeshLambertMaterial: au,
          MeshDepthMaterial: Cs,
          MeshDistanceMaterial: Ps,
          MeshBasicMaterial: qr,
          MeshMatcapMaterial: ou,
          LineDashedMaterial: su,
          LineBasicMaterial: Rl,
          Material: gr,
        });
        const cu = {
          arraySlice: function (t, e, n) {
            return cu.isTypedArray(t)
              ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
              : t.slice(e, n);
          },
          convertArray: function (t, e, n) {
            return !t || (!n && t.constructor === e)
              ? t
              : 'number' == typeof e.BYTES_PER_ELEMENT
              ? new e(t)
              : Array.prototype.slice.call(t);
          },
          isTypedArray: function (t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView);
          },
          getKeyframeOrder: function (t) {
            const e = t.length,
              n = new Array(e);
            for (let t = 0; t !== e; ++t) n[t] = t;
            return (
              n.sort(function (e, n) {
                return t[e] - t[n];
              }),
              n
            );
          },
          sortedArray: function (t, e, n) {
            const i = t.length,
              r = new t.constructor(i);
            for (let a = 0, o = 0; o !== i; ++a) {
              const i = n[a] * e;
              for (let n = 0; n !== e; ++n) r[o++] = t[i + n];
            }
            return r;
          },
          flattenJSON: function (t, e, n, i) {
            let r = 1,
              a = t[0];
            for (; void 0 !== a && void 0 === a[i]; ) a = t[r++];
            if (void 0 === a) return;
            let o = a[i];
            if (void 0 !== o)
              if (Array.isArray(o))
                do {
                  (o = a[i]),
                    void 0 !== o && (e.push(a.time), n.push.apply(n, o)),
                    (a = t[r++]);
                } while (void 0 !== a);
              else if (void 0 !== o.toArray)
                do {
                  (o = a[i]),
                    void 0 !== o && (e.push(a.time), o.toArray(n, n.length)),
                    (a = t[r++]);
                } while (void 0 !== a);
              else
                do {
                  (o = a[i]),
                    void 0 !== o && (e.push(a.time), n.push(o)),
                    (a = t[r++]);
                } while (void 0 !== a);
          },
          subclip: function (t, e, n, i, r = 30) {
            const a = t.clone();
            a.name = e;
            const o = [];
            for (let t = 0; t < a.tracks.length; ++t) {
              const e = a.tracks[t],
                s = e.getValueSize(),
                l = [],
                c = [];
              for (let t = 0; t < e.times.length; ++t) {
                const a = e.times[t] * r;
                if (!(a < n || a >= i)) {
                  l.push(e.times[t]);
                  for (let n = 0; n < s; ++n) c.push(e.values[t * s + n]);
                }
              }
              0 !== l.length &&
                ((e.times = cu.convertArray(l, e.times.constructor)),
                (e.values = cu.convertArray(c, e.values.constructor)),
                o.push(e));
            }
            a.tracks = o;
            let s = 1 / 0;
            for (let t = 0; t < a.tracks.length; ++t)
              s > a.tracks[t].times[0] && (s = a.tracks[t].times[0]);
            for (let t = 0; t < a.tracks.length; ++t) a.tracks[t].shift(-1 * s);
            return a.resetDuration(), a;
          },
          makeClipAdditive: function (t, e = 0, n = t, i = 30) {
            i <= 0 && (i = 30);
            const r = n.tracks.length,
              a = e / i;
            for (let e = 0; e < r; ++e) {
              const i = n.tracks[e],
                r = i.ValueTypeName;
              if ('bool' === r || 'string' === r) continue;
              const o = t.tracks.find(function (t) {
                return t.name === i.name && t.ValueTypeName === r;
              });
              if (void 0 === o) continue;
              let s = 0;
              const l = i.getValueSize();
              i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (s = l / 3);
              let c = 0;
              const u = o.getValueSize();
              o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (c = u / 3);
              const h = i.times.length - 1;
              let d;
              if (a <= i.times[0]) {
                const t = s,
                  e = l - s;
                d = cu.arraySlice(i.values, t, e);
              } else if (a >= i.times[h]) {
                const t = h * l + s,
                  e = t + l - s;
                d = cu.arraySlice(i.values, t, e);
              } else {
                const t = i.createInterpolant(),
                  e = s,
                  n = l - s;
                t.evaluate(a), (d = cu.arraySlice(t.resultBuffer, e, n));
              }
              if ('quaternion' === r) {
                new Jn().fromArray(d).normalize().conjugate().toArray(d);
              }
              const p = o.times.length;
              for (let t = 0; t < p; ++t) {
                const e = t * u + c;
                if ('quaternion' === r)
                  Jn.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                else {
                  const t = u - 2 * c;
                  for (let n = 0; n < t; ++n) o.values[e + n] -= d[n];
                }
              }
            }
            return (t.blendMode = We), t;
          },
        };
        function uu(t, e, n, i) {
          (this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
            (this.sampleValues = e),
            (this.valueSize = n);
        }
        function hu(t, e, n, i) {
          uu.call(this, t, e, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0);
        }
        function du(t, e, n, i) {
          uu.call(this, t, e, n, i);
        }
        function pu(t, e, n, i) {
          uu.call(this, t, e, n, i);
        }
        Object.assign(uu.prototype, {
          evaluate: function (t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
              i = e[n],
              r = e[n - 1];
            t: {
              e: {
                let a;
                n: {
                  i: if (!(t < i)) {
                    for (let a = n + 2; ; ) {
                      if (void 0 === i) {
                        if (t < r) break i;
                        return (
                          (n = e.length),
                          (this._cachedIndex = n),
                          this.afterEnd_(n - 1, t, r)
                        );
                      }
                      if (n === a) break;
                      if (((r = i), (i = e[++n]), t < i)) break e;
                    }
                    a = e.length;
                    break n;
                  }
                  if (t >= r) break t;
                  {
                    const o = e[1];
                    t < o && ((n = 2), (r = o));
                    for (let a = n - 2; ; ) {
                      if (void 0 === r)
                        return (
                          (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                        );
                      if (n === a) break;
                      if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                    }
                    (a = n), (n = 0);
                  }
                }
                for (; n < a; ) {
                  const i = (n + a) >>> 1;
                  t < e[i] ? (a = i) : (n = i + 1);
                }
                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                if (void 0 === i)
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.afterEnd_(n - 1, r, t)
                  );
              }
              (this._cachedIndex = n), this.intervalChanged_(n, r, i);
            }
            return this.interpolate_(n, r, t, i);
          },
          settings: null,
          DefaultSettings_: {},
          getSettings_: function () {
            return this.settings || this.DefaultSettings_;
          },
          copySampleValue_: function (t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i;
            for (let t = 0; t !== i; ++t) e[t] = n[r + t];
            return e;
          },
          interpolate_: function () {
            throw new Error('call to abstract method');
          },
          intervalChanged_: function () {},
        }),
          Object.assign(uu.prototype, {
            beforeStart_: uu.prototype.copySampleValue_,
            afterEnd_: uu.prototype.copySampleValue_,
          }),
          (hu.prototype = Object.assign(Object.create(uu.prototype), {
            constructor: hu,
            DefaultSettings_: { endingStart: je, endingEnd: je },
            intervalChanged_: function (t, e, n) {
              const i = this.parameterPositions;
              let r = t - 2,
                a = t + 1,
                o = i[r],
                s = i[a];
              if (void 0 === o)
                switch (this.getSettings_().endingStart) {
                  case Ge:
                    (r = t), (o = 2 * e - n);
                    break;
                  case He:
                    (r = i.length - 2), (o = e + i[r] - i[r + 1]);
                    break;
                  default:
                    (r = t), (o = n);
                }
              if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                  case Ge:
                    (a = t), (s = 2 * n - e);
                    break;
                  case He:
                    (a = 1), (s = n + i[1] - i[0]);
                    break;
                  default:
                    (a = t - 1), (s = e);
                }
              const l = 0.5 * (n - e),
                c = this.valueSize;
              (this._weightPrev = l / (e - o)),
                (this._weightNext = l / (s - n)),
                (this._offsetPrev = r * c),
                (this._offsetNext = a * c);
            },
            interpolate_: function (t, e, n, i) {
              const r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = t * o,
                l = s - o,
                c = this._offsetPrev,
                u = this._offsetNext,
                h = this._weightPrev,
                d = this._weightNext,
                p = (n - e) / (i - e),
                f = p * p,
                m = f * p,
                g = -h * m + 2 * h * f - h * p,
                y = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
                v = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
                x = d * m - d * f;
              for (let t = 0; t !== o; ++t)
                r[t] =
                  g * a[c + t] + y * a[l + t] + v * a[s + t] + x * a[u + t];
              return r;
            },
          })),
          (du.prototype = Object.assign(Object.create(uu.prototype), {
            constructor: du,
            interpolate_: function (t, e, n, i) {
              const r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = t * o,
                l = s - o,
                c = (n - e) / (i - e),
                u = 1 - c;
              for (let t = 0; t !== o; ++t) r[t] = a[l + t] * u + a[s + t] * c;
              return r;
            },
          })),
          (pu.prototype = Object.assign(Object.create(uu.prototype), {
            constructor: pu,
            interpolate_: function (t) {
              return this.copySampleValue_(t - 1);
            },
          }));
        class fu {
          constructor(t, e, n, i) {
            if (void 0 === t)
              throw new Error('THREE.KeyframeTrack: track name is undefined');
            if (void 0 === e || 0 === e.length)
              throw new Error(
                'THREE.KeyframeTrack: no keyframes in track named ' + t,
              );
            (this.name = t),
              (this.times = cu.convertArray(e, this.TimeBufferType)),
              (this.values = cu.convertArray(n, this.ValueBufferType)),
              this.setInterpolation(i || this.DefaultInterpolation);
          }
          static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
              n = {
                name: t.name,
                times: cu.convertArray(t.times, Array),
                values: cu.convertArray(t.values, Array),
              };
              const e = t.getInterpolation();
              e !== t.DefaultInterpolation && (n.interpolation = e);
            }
            return (n.type = t.ValueTypeName), n;
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new pu(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodLinear(t) {
            return new du(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodSmooth(t) {
            return new hu(this.times, this.values, this.getValueSize(), t);
          }
          setInterpolation(t) {
            let e;
            switch (t) {
              case Fe:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case Be:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case Ue:
                e = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === e) {
              const e =
                'unsupported interpolation for ' +
                this.ValueTypeName +
                ' keyframe track named ' +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn('THREE.KeyframeTrack:', e), this;
            }
            return (this.createInterpolant = e), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return Fe;
              case this.InterpolantFactoryMethodLinear:
                return Be;
              case this.InterpolantFactoryMethodSmooth:
                return Ue;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
            }
            return this;
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
            }
            return this;
          }
          trim(t, e) {
            const n = this.times,
              i = n.length;
            let r = 0,
              a = i - 1;
            for (; r !== i && n[r] < t; ) ++r;
            for (; -1 !== a && n[a] > e; ) --a;
            if ((++a, 0 !== r || a !== i)) {
              r >= a && ((a = Math.max(a, 1)), (r = a - 1));
              const t = this.getValueSize();
              (this.times = cu.arraySlice(n, r, a)),
                (this.values = cu.arraySlice(this.values, r * t, a * t));
            }
            return this;
          }
          validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 &&
              (console.error(
                'THREE.KeyframeTrack: Invalid value size in track.',
                this,
              ),
              (t = !1));
            const n = this.times,
              i = this.values,
              r = n.length;
            0 === r &&
              (console.error('THREE.KeyframeTrack: Track is empty.', this),
              (t = !1));
            let a = null;
            for (let e = 0; e !== r; e++) {
              const i = n[e];
              if ('number' == typeof i && isNaN(i)) {
                console.error(
                  'THREE.KeyframeTrack: Time is not a valid number.',
                  this,
                  e,
                  i,
                ),
                  (t = !1);
                break;
              }
              if (null !== a && a > i) {
                console.error(
                  'THREE.KeyframeTrack: Out of order keys.',
                  this,
                  e,
                  i,
                  a,
                ),
                  (t = !1);
                break;
              }
              a = i;
            }
            if (void 0 !== i && cu.isTypedArray(i))
              for (let e = 0, n = i.length; e !== n; ++e) {
                const n = i[e];
                if (isNaN(n)) {
                  console.error(
                    'THREE.KeyframeTrack: Value is not a valid number.',
                    this,
                    e,
                    n,
                  ),
                    (t = !1);
                  break;
                }
              }
            return t;
          }
          optimize() {
            const t = cu.arraySlice(this.times),
              e = cu.arraySlice(this.values),
              n = this.getValueSize(),
              i = this.getInterpolation() === Ue,
              r = t.length - 1;
            let a = 1;
            for (let o = 1; o < r; ++o) {
              let r = !1;
              const s = t[o];
              if (s !== t[o + 1] && (1 !== o || s !== t[0]))
                if (i) r = !0;
                else {
                  const t = o * n,
                    i = t - n,
                    a = t + n;
                  for (let o = 0; o !== n; ++o) {
                    const n = e[t + o];
                    if (n !== e[i + o] || n !== e[a + o]) {
                      r = !0;
                      break;
                    }
                  }
                }
              if (r) {
                if (o !== a) {
                  t[a] = t[o];
                  const i = o * n,
                    r = a * n;
                  for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
                }
                ++a;
              }
            }
            if (r > 0) {
              t[a] = t[r];
              for (let t = r * n, i = a * n, o = 0; o !== n; ++o)
                e[i + o] = e[t + o];
              ++a;
            }
            return (
              a !== t.length
                ? ((this.times = cu.arraySlice(t, 0, a)),
                  (this.values = cu.arraySlice(e, 0, a * n)))
                : ((this.times = t), (this.values = e)),
              this
            );
          }
          clone() {
            const t = cu.arraySlice(this.times, 0),
              e = cu.arraySlice(this.values, 0),
              n = new (0, this.constructor)(this.name, t, e);
            return (n.createInterpolant = this.createInterpolant), n;
          }
        }
        (fu.prototype.TimeBufferType = Float32Array),
          (fu.prototype.ValueBufferType = Float32Array),
          (fu.prototype.DefaultInterpolation = Be);
        class mu extends fu {}
        (mu.prototype.ValueTypeName = 'bool'),
          (mu.prototype.ValueBufferType = Array),
          (mu.prototype.DefaultInterpolation = Fe),
          (mu.prototype.InterpolantFactoryMethodLinear = void 0),
          (mu.prototype.InterpolantFactoryMethodSmooth = void 0);
        class gu extends fu {}
        gu.prototype.ValueTypeName = 'color';
        class yu extends fu {}
        function vu(t, e, n, i) {
          uu.call(this, t, e, n, i);
        }
        (yu.prototype.ValueTypeName = 'number'),
          (vu.prototype = Object.assign(Object.create(uu.prototype), {
            constructor: vu,
            interpolate_: function (t, e, n, i) {
              const r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = (n - e) / (i - e);
              let l = t * o;
              for (let t = l + o; l !== t; l += 4)
                Jn.slerpFlat(r, 0, a, l - o, a, l, s);
              return r;
            },
          }));
        class xu extends fu {
          InterpolantFactoryMethodLinear(t) {
            return new vu(this.times, this.values, this.getValueSize(), t);
          }
        }
        (xu.prototype.ValueTypeName = 'quaternion'),
          (xu.prototype.DefaultInterpolation = Be),
          (xu.prototype.InterpolantFactoryMethodSmooth = void 0);
        class bu extends fu {}
        (bu.prototype.ValueTypeName = 'string'),
          (bu.prototype.ValueBufferType = Array),
          (bu.prototype.DefaultInterpolation = Fe),
          (bu.prototype.InterpolantFactoryMethodLinear = void 0),
          (bu.prototype.InterpolantFactoryMethodSmooth = void 0);
        class _u extends fu {}
        _u.prototype.ValueTypeName = 'vector';
        class wu {
          constructor(t, e = -1, n, i = Ve) {
            (this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = i),
              (this.uuid = Fn.generateUUID()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t)
              e.push(Mu(n[t]).scale(i));
            const r = new this(t.name, t.duration, e, t.blendMode);
            return (r.uuid = t.uuid), r;
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode,
              };
            for (let t = 0, i = n.length; t !== i; ++t) e.push(fu.toJSON(n[t]));
            return i;
          }
          static CreateFromMorphTargetSequence(t, e, n, i) {
            const r = e.length,
              a = [];
            for (let t = 0; t < r; t++) {
              let o = [],
                s = [];
              o.push((t + r - 1) % r, t, (t + 1) % r), s.push(0, 1, 0);
              const l = cu.getKeyframeOrder(o);
              (o = cu.sortedArray(o, 1, l)),
                (s = cu.sortedArray(s, 1, l)),
                i || 0 !== o[0] || (o.push(r), s.push(s[0])),
                a.push(
                  new yu(
                    '.morphTargetInfluences[' + e[t].name + ']',
                    o,
                    s,
                  ).scale(1 / n),
                );
            }
            return new this(t, -1, a);
          }
          static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
              const e = t;
              n = (e.geometry && e.geometry.animations) || e.animations;
            }
            for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const i = {},
              r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                a = n.name.match(r);
              if (a && a.length > 1) {
                const t = a[1];
                let e = i[t];
                e || (i[t] = e = []), e.push(n);
              }
            }
            const a = [];
            for (const t in i)
              a.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
            return a;
          }
          static parseAnimation(t, e) {
            if (!t)
              return (
                console.error(
                  'THREE.AnimationClip: No animation in JSONLoader data.',
                ),
                null
              );
            const n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  const a = [],
                    o = [];
                  cu.flattenJSON(n, a, o, i),
                    0 !== a.length && r.push(new t(e, a, o));
                }
              },
              i = [],
              r = t.name || 'default',
              a = t.fps || 30,
              o = t.blendMode;
            let s = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
              const r = l[t].keys;
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const t = {};
                  let e;
                  for (e = 0; e < r.length; e++)
                    if (r[e].morphTargets)
                      for (let n = 0; n < r[e].morphTargets.length; n++)
                        t[r[e].morphTargets[n]] = -1;
                  for (const n in t) {
                    const t = [],
                      a = [];
                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                      const i = r[e];
                      t.push(i.time), a.push(i.morphTarget === n ? 1 : 0);
                    }
                    i.push(new yu('.morphTargetInfluence[' + n + ']', t, a));
                  }
                  s = t.length * (a || 1);
                } else {
                  const a = '.bones[' + e[t].name + ']';
                  n(_u, a + '.position', r, 'pos', i),
                    n(xu, a + '.quaternion', r, 'rot', i),
                    n(_u, a + '.scale', r, 'scl', i);
                }
            }
            if (0 === i.length) return null;
            return new this(r, s, i, o);
          }
          resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e];
              t = Math.max(t, n.times[n.times.length - 1]);
            }
            return (this.duration = t), this;
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].trim(0, this.duration);
            return this;
          }
          validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
              t = t && this.tracks[e].validate();
            return t;
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].optimize();
            return this;
          }
          clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
              t.push(this.tracks[e].clone());
            return new this.constructor(
              this.name,
              this.duration,
              t,
              this.blendMode,
            );
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        }
        function Mu(t) {
          if (void 0 === t.type)
            throw new Error(
              'THREE.KeyframeTrack: track type undefined, can not parse',
            );
          const e = (function (t) {
            switch (t.toLowerCase()) {
              case 'scalar':
              case 'double':
              case 'float':
              case 'number':
              case 'integer':
                return yu;
              case 'vector':
              case 'vector2':
              case 'vector3':
              case 'vector4':
                return _u;
              case 'color':
                return gu;
              case 'quaternion':
                return xu;
              case 'bool':
              case 'boolean':
                return mu;
              case 'string':
                return bu;
            }
            throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t);
          })(t.type);
          if (void 0 === t.times) {
            const e = [],
              n = [];
            cu.flattenJSON(t.keys, e, n, 'value'),
              (t.times = e),
              (t.values = n);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        }
        const qu = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
        function Su(t, e, n) {
          const i = this;
          let r = !1,
            a = 0,
            o = 0,
            s = void 0;
          const l = [];
          (this.onStart = void 0),
            (this.onLoad = t),
            (this.onProgress = e),
            (this.onError = n),
            (this.itemStart = function (t) {
              o++,
                !1 === r && void 0 !== i.onStart && i.onStart(t, a, o),
                (r = !0);
            }),
            (this.itemEnd = function (t) {
              a++,
                void 0 !== i.onProgress && i.onProgress(t, a, o),
                a === o && ((r = !1), void 0 !== i.onLoad && i.onLoad());
            }),
            (this.itemError = function (t) {
              void 0 !== i.onError && i.onError(t);
            }),
            (this.resolveURL = function (t) {
              return s ? s(t) : t;
            }),
            (this.setURLModifier = function (t) {
              return (s = t), this;
            }),
            (this.addHandler = function (t, e) {
              return l.push(t, e), this;
            }),
            (this.removeHandler = function (t) {
              const e = l.indexOf(t);
              return -1 !== e && l.splice(e, 2), this;
            }),
            (this.getHandler = function (t) {
              for (let e = 0, n = l.length; e < n; e += 2) {
                const n = l[e],
                  i = l[e + 1];
                if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
              }
              return null;
            });
        }
        const Tu = new Su();
        function Eu(t) {
          (this.manager = void 0 !== t ? t : Tu),
            (this.crossOrigin = 'anonymous'),
            (this.withCredentials = !1),
            (this.path = ''),
            (this.resourcePath = ''),
            (this.requestHeader = {});
        }
        Object.assign(Eu.prototype, {
          load: function () {},
          loadAsync: function (t, e) {
            const n = this;
            return new Promise(function (i, r) {
              n.load(t, i, e, r);
            });
          },
          parse: function () {},
          setCrossOrigin: function (t) {
            return (this.crossOrigin = t), this;
          },
          setWithCredentials: function (t) {
            return (this.withCredentials = t), this;
          },
          setPath: function (t) {
            return (this.path = t), this;
          },
          setResourcePath: function (t) {
            return (this.resourcePath = t), this;
          },
          setRequestHeader: function (t) {
            return (this.requestHeader = t), this;
          },
        });
        const Au = {};
        function Lu(t) {
          Eu.call(this, t);
        }
        Lu.prototype = Object.assign(Object.create(Eu.prototype), {
          constructor: Lu,
          load: function (t, e, n, i) {
            void 0 === t && (t = ''),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              a = qu.get(t);
            if (void 0 !== a)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(a), r.manager.itemEnd(t);
                }, 0),
                a
              );
            if (void 0 !== Au[t])
              return void Au[t].push({ onLoad: e, onProgress: n, onError: i });
            const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
            let s;
            if (o) {
              const n = o[1],
                a = !!o[2];
              let s = o[3];
              (s = decodeURIComponent(s)), a && (s = atob(s));
              try {
                let i;
                const a = (this.responseType || '').toLowerCase();
                switch (a) {
                  case 'arraybuffer':
                  case 'blob':
                    const t = new Uint8Array(s.length);
                    for (let e = 0; e < s.length; e++) t[e] = s.charCodeAt(e);
                    i =
                      'blob' === a
                        ? new Blob([t.buffer], { type: n })
                        : t.buffer;
                    break;
                  case 'document':
                    const e = new DOMParser();
                    i = e.parseFromString(s, n);
                    break;
                  case 'json':
                    i = JSON.parse(s);
                    break;
                  default:
                    i = s;
                }
                setTimeout(function () {
                  e && e(i), r.manager.itemEnd(t);
                }, 0);
              } catch (e) {
                setTimeout(function () {
                  i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
                }, 0);
              }
            } else {
              (Au[t] = []),
                Au[t].push({ onLoad: e, onProgress: n, onError: i }),
                (s = new XMLHttpRequest()),
                s.open('GET', t, !0),
                s.addEventListener(
                  'load',
                  function (e) {
                    const n = this.response,
                      i = Au[t];
                    if (
                      (delete Au[t], 200 === this.status || 0 === this.status)
                    ) {
                      0 === this.status &&
                        console.warn(
                          'THREE.FileLoader: HTTP Status 0 received.',
                        ),
                        qu.add(t, n);
                      for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t];
                        e.onLoad && e.onLoad(n);
                      }
                      r.manager.itemEnd(t);
                    } else {
                      for (let t = 0, n = i.length; t < n; t++) {
                        const n = i[t];
                        n.onError && n.onError(e);
                      }
                      r.manager.itemError(t), r.manager.itemEnd(t);
                    }
                  },
                  !1,
                ),
                s.addEventListener(
                  'progress',
                  function (e) {
                    const n = Au[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t];
                      i.onProgress && i.onProgress(e);
                    }
                  },
                  !1,
                ),
                s.addEventListener(
                  'error',
                  function (e) {
                    const n = Au[t];
                    delete Au[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t];
                      i.onError && i.onError(e);
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t);
                  },
                  !1,
                ),
                s.addEventListener(
                  'abort',
                  function (e) {
                    const n = Au[t];
                    delete Au[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t];
                      i.onError && i.onError(e);
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t);
                  },
                  !1,
                ),
                void 0 !== this.responseType &&
                  (s.responseType = this.responseType),
                void 0 !== this.withCredentials &&
                  (s.withCredentials = this.withCredentials),
                s.overrideMimeType &&
                  s.overrideMimeType(
                    void 0 !== this.mimeType ? this.mimeType : 'text/plain',
                  );
              for (const t in this.requestHeader)
                s.setRequestHeader(t, this.requestHeader[t]);
              s.send(null);
            }
            return r.manager.itemStart(t), s;
          },
          setResponseType: function (t) {
            return (this.responseType = t), this;
          },
          setMimeType: function (t) {
            return (this.mimeType = t), this;
          },
        });
        class Ru extends Eu {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              a = new Lu(this.manager);
            a.setPath(this.path),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(this.withCredentials),
              a.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)));
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i,
              );
          }
          parse(t) {
            const e = [];
            for (let n = 0; n < t.length; n++) {
              const i = wu.parse(t[n]);
              e.push(i);
            }
            return e;
          }
        }
        function Cu(t) {
          Eu.call(this, t);
        }
        Cu.prototype = Object.assign(Object.create(Eu.prototype), {
          constructor: Cu,
          load: function (t, e, n, i) {
            const r = this,
              a = [],
              o = new $l(),
              s = new Lu(this.manager);
            s.setPath(this.path),
              s.setResponseType('arraybuffer'),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(r.withCredentials);
            let l = 0;
            function c(c) {
              s.load(
                t[c],
                function (t) {
                  const n = r.parse(t, !0);
                  (a[c] = {
                    width: n.width,
                    height: n.height,
                    format: n.format,
                    mipmaps: n.mipmaps,
                  }),
                    (l += 1),
                    6 === l &&
                      (1 === n.mipmapCount && (o.minFilter = xt),
                      (o.image = a),
                      (o.format = n.format),
                      (o.needsUpdate = !0),
                      e && e(o));
                },
                n,
                i,
              );
            }
            if (Array.isArray(t))
              for (let e = 0, n = t.length; e < n; ++e) c(e);
            else
              s.load(
                t,
                function (t) {
                  const n = r.parse(t, !0);
                  if (n.isCubemap) {
                    const t = n.mipmaps.length / n.mipmapCount;
                    for (let e = 0; e < t; e++) {
                      a[e] = { mipmaps: [] };
                      for (let t = 0; t < n.mipmapCount; t++)
                        a[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                          (a[e].format = n.format),
                          (a[e].width = n.width),
                          (a[e].height = n.height);
                    }
                    o.image = a;
                  } else
                    (o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.mipmaps = n.mipmaps);
                  1 === n.mipmapCount && (o.minFilter = xt),
                    (o.format = n.format),
                    (o.needsUpdate = !0),
                    e && e(o);
                },
                n,
                i,
              );
            return o;
          },
        });
        class Pu extends Eu {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              a = qu.get(t);
            if (void 0 !== a)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(a), r.manager.itemEnd(t);
                }, 0),
                a
              );
            const o = document.createElementNS(
              'http://www.w3.org/1999/xhtml',
              'img',
            );
            function s() {
              o.removeEventListener('load', s, !1),
                o.removeEventListener('error', l, !1),
                qu.add(t, this),
                e && e(this),
                r.manager.itemEnd(t);
            }
            function l(e) {
              o.removeEventListener('load', s, !1),
                o.removeEventListener('error', l, !1),
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t);
            }
            return (
              o.addEventListener('load', s, !1),
              o.addEventListener('error', l, !1),
              'data:' !== t.substr(0, 5) &&
                void 0 !== this.crossOrigin &&
                (o.crossOrigin = this.crossOrigin),
              r.manager.itemStart(t),
              (o.src = t),
              o
            );
          }
        }
        class ku extends Eu {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = new wa(),
              a = new Pu(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            let o = 0;
            function s(n) {
              a.load(
                t[n],
                function (t) {
                  (r.images[n] = t),
                    o++,
                    6 === o && ((r.needsUpdate = !0), e && e(r));
                },
                void 0,
                i,
              );
            }
            for (let e = 0; e < t.length; ++e) s(e);
            return r;
          }
        }
        function Iu(t) {
          Eu.call(this, t);
        }
        function Du(t) {
          Eu.call(this, t);
        }
        function Ou() {
          (this.type = 'Curve'), (this.arcLengthDivisions = 200);
        }
        (Iu.prototype = Object.assign(Object.create(Eu.prototype), {
          constructor: Iu,
          load: function (t, e, n, i) {
            const r = this,
              a = new qa(),
              o = new Lu(this.manager);
            return (
              o.setResponseType('arraybuffer'),
              o.setRequestHeader(this.requestHeader),
              o.setPath(this.path),
              o.setWithCredentials(r.withCredentials),
              o.load(
                t,
                function (t) {
                  const n = r.parse(t);
                  n &&
                    (void 0 !== n.image
                      ? (a.image = n.image)
                      : void 0 !== n.data &&
                        ((a.image.width = n.width),
                        (a.image.height = n.height),
                        (a.image.data = n.data)),
                    (a.wrapS = void 0 !== n.wrapS ? n.wrapS : dt),
                    (a.wrapT = void 0 !== n.wrapT ? n.wrapT : dt),
                    (a.magFilter = void 0 !== n.magFilter ? n.magFilter : xt),
                    (a.minFilter = void 0 !== n.minFilter ? n.minFilter : xt),
                    (a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                    void 0 !== n.encoding && (a.encoding = n.encoding),
                    void 0 !== n.flipY && (a.flipY = n.flipY),
                    void 0 !== n.format && (a.format = n.format),
                    void 0 !== n.type && (a.type = n.type),
                    void 0 !== n.mipmaps &&
                      ((a.mipmaps = n.mipmaps), (a.minFilter = wt)),
                    1 === n.mipmapCount && (a.minFilter = xt),
                    void 0 !== n.generateMipmaps &&
                      (a.generateMipmaps = n.generateMipmaps),
                    (a.needsUpdate = !0),
                    e && e(a, n));
                },
                n,
                i,
              ),
              a
            );
          },
        })),
          (Du.prototype = Object.assign(Object.create(Eu.prototype), {
            constructor: Du,
            load: function (t, e, n, i) {
              const r = new Vn(),
                a = new Pu(this.manager);
              return (
                a.setCrossOrigin(this.crossOrigin),
                a.setPath(this.path),
                a.load(
                  t,
                  function (n) {
                    r.image = n;
                    const i =
                      t.search(/\.jpe?g($|\?)/i) > 0 ||
                      0 === t.search(/^data\:image\/jpeg/);
                    (r.format = i ? Nt : zt),
                      (r.needsUpdate = !0),
                      void 0 !== e && e(r);
                  },
                  n,
                  i,
                ),
                r
              );
            },
          })),
          Object.assign(Ou.prototype, {
            getPoint: function () {
              return (
                console.warn('THREE.Curve: .getPoint() not implemented.'), null
              );
            },
            getPointAt: function (t, e) {
              const n = this.getUtoTmapping(t);
              return this.getPoint(n, e);
            },
            getPoints: function (t = 5) {
              const e = [];
              for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
              return e;
            },
            getSpacedPoints: function (t = 5) {
              const e = [];
              for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
              return e;
            },
            getLength: function () {
              const t = this.getLengths();
              return t[t.length - 1];
            },
            getLengths: function (t) {
              if (
                (void 0 === t && (t = this.arcLengthDivisions),
                this.cacheArcLengths &&
                  this.cacheArcLengths.length === t + 1 &&
                  !this.needsUpdate)
              )
                return this.cacheArcLengths;
              this.needsUpdate = !1;
              const e = [];
              let n,
                i = this.getPoint(0),
                r = 0;
              e.push(0);
              for (let a = 1; a <= t; a++)
                (n = this.getPoint(a / t)),
                  (r += n.distanceTo(i)),
                  e.push(r),
                  (i = n);
              return (this.cacheArcLengths = e), e;
            },
            updateArcLengths: function () {
              (this.needsUpdate = !0), this.getLengths();
            },
            getUtoTmapping: function (t, e) {
              const n = this.getLengths();
              let i = 0;
              const r = n.length;
              let a;
              a = e || t * n[r - 1];
              let o,
                s = 0,
                l = r - 1;
              for (; s <= l; )
                if (((i = Math.floor(s + (l - s) / 2)), (o = n[i] - a), o < 0))
                  s = i + 1;
                else {
                  if (!(o > 0)) {
                    l = i;
                    break;
                  }
                  l = i - 1;
                }
              if (((i = l), n[i] === a)) return i / (r - 1);
              const c = n[i];
              return (i + (a - c) / (n[i + 1] - c)) / (r - 1);
            },
            getTangent: function (t, e) {
              let n = t - 1e-4,
                i = t + 1e-4;
              n < 0 && (n = 0), i > 1 && (i = 1);
              const r = this.getPoint(n),
                a = this.getPoint(i),
                o = e || (r.isVector2 ? new Bn() : new Zn());
              return o.copy(a).sub(r).normalize(), o;
            },
            getTangentAt: function (t, e) {
              const n = this.getUtoTmapping(t);
              return this.getTangent(n, e);
            },
            computeFrenetFrames: function (t, e) {
              const n = new Zn(),
                i = [],
                r = [],
                a = [],
                o = new Zn(),
                s = new Ai();
              for (let e = 0; e <= t; e++) {
                const n = e / t;
                (i[e] = this.getTangentAt(n, new Zn())), i[e].normalize();
              }
              (r[0] = new Zn()), (a[0] = new Zn());
              let l = Number.MAX_VALUE;
              const c = Math.abs(i[0].x),
                u = Math.abs(i[0].y),
                h = Math.abs(i[0].z);
              c <= l && ((l = c), n.set(1, 0, 0)),
                u <= l && ((l = u), n.set(0, 1, 0)),
                h <= l && n.set(0, 0, 1),
                o.crossVectors(i[0], n).normalize(),
                r[0].crossVectors(i[0], o),
                a[0].crossVectors(i[0], r[0]);
              for (let e = 1; e <= t; e++) {
                if (
                  ((r[e] = r[e - 1].clone()),
                  (a[e] = a[e - 1].clone()),
                  o.crossVectors(i[e - 1], i[e]),
                  o.length() > Number.EPSILON)
                ) {
                  o.normalize();
                  const t = Math.acos(Fn.clamp(i[e - 1].dot(i[e]), -1, 1));
                  r[e].applyMatrix4(s.makeRotationAxis(o, t));
                }
                a[e].crossVectors(i[e], r[e]);
              }
              if (!0 === e) {
                let e = Math.acos(Fn.clamp(r[0].dot(r[t]), -1, 1));
                (e /= t), i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                for (let n = 1; n <= t; n++)
                  r[n].applyMatrix4(s.makeRotationAxis(i[n], e * n)),
                    a[n].crossVectors(i[n], r[n]);
              }
              return { tangents: i, normals: r, binormals: a };
            },
            clone: function () {
              return new this.constructor().copy(this);
            },
            copy: function (t) {
              return (this.arcLengthDivisions = t.arcLengthDivisions), this;
            },
            toJSON: function () {
              const t = {
                metadata: {
                  version: 4.5,
                  type: 'Curve',
                  generator: 'Curve.toJSON',
                },
              };
              return (
                (t.arcLengthDivisions = this.arcLengthDivisions),
                (t.type = this.type),
                t
              );
            },
            fromJSON: function (t) {
              return (this.arcLengthDivisions = t.arcLengthDivisions), this;
            },
          });
        class Nu extends Ou {
          constructor(
            t = 0,
            e = 0,
            n = 1,
            i = 1,
            r = 0,
            a = 2 * Math.PI,
            o = !1,
            s = 0,
          ) {
            super(),
              (this.type = 'EllipseCurve'),
              (this.aX = t),
              (this.aY = e),
              (this.xRadius = n),
              (this.yRadius = i),
              (this.aStartAngle = r),
              (this.aEndAngle = a),
              (this.aClockwise = o),
              (this.aRotation = s);
          }
          getPoint(t, e) {
            const n = e || new Bn(),
              i = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const a = Math.abs(r) < Number.EPSILON;
            for (; r < 0; ) r += i;
            for (; r > i; ) r -= i;
            r < Number.EPSILON && (r = a ? 0 : i),
              !0 !== this.aClockwise || a || (r === i ? (r = -i) : (r -= i));
            const o = this.aStartAngle + t * r;
            let s = this.aX + this.xRadius * Math.cos(o),
              l = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
              const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = s - this.aX,
                i = l - this.aY;
              (s = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
            }
            return n.set(s, l);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.aX = this.aX),
              (t.aY = this.aY),
              (t.xRadius = this.xRadius),
              (t.yRadius = this.yRadius),
              (t.aStartAngle = this.aStartAngle),
              (t.aEndAngle = this.aEndAngle),
              (t.aClockwise = this.aClockwise),
              (t.aRotation = this.aRotation),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
        }
        Nu.prototype.isEllipseCurve = !0;
        class zu extends Nu {
          constructor(t, e, n, i, r, a) {
            super(t, e, n, n, i, r, a), (this.type = 'ArcCurve');
          }
        }
        function Fu() {
          let t = 0,
            e = 0,
            n = 0,
            i = 0;
          function r(r, a, o, s) {
            (t = r),
              (e = o),
              (n = -3 * r + 3 * a - 2 * o - s),
              (i = 2 * r - 2 * a + o + s);
          }
          return {
            initCatmullRom: function (t, e, n, i, a) {
              r(e, n, a * (n - t), a * (i - e));
            },
            initNonuniformCatmullRom: function (t, e, n, i, a, o, s) {
              let l = (e - t) / a - (n - t) / (a + o) + (n - e) / o,
                c = (n - e) / o - (i - e) / (o + s) + (i - n) / s;
              (l *= o), (c *= o), r(e, n, l, c);
            },
            calc: function (r) {
              const a = r * r;
              return t + e * r + n * a + i * (a * r);
            },
          };
        }
        zu.prototype.isArcCurve = !0;
        const Bu = new Zn(),
          Uu = new Fu(),
          ju = new Fu(),
          Gu = new Fu();
        class Hu extends Ou {
          constructor(t = [], e = !1, n = 'centripetal', i = 0.5) {
            super(),
              (this.type = 'CatmullRomCurve3'),
              (this.points = t),
              (this.closed = e),
              (this.curveType = n),
              (this.tension = i);
          }
          getPoint(t, e = new Zn()) {
            const n = e,
              i = this.points,
              r = i.length,
              a = (r - (this.closed ? 0 : 1)) * t;
            let o,
              s,
              l = Math.floor(a),
              c = a - l;
            this.closed
              ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
              : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
              this.closed || l > 0
                ? (o = i[(l - 1) % r])
                : (Bu.subVectors(i[0], i[1]).add(i[0]), (o = Bu));
            const u = i[l % r],
              h = i[(l + 1) % r];
            if (
              (this.closed || l + 2 < r
                ? (s = i[(l + 2) % r])
                : (Bu.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (s = Bu)),
              'centripetal' === this.curveType || 'chordal' === this.curveType)
            ) {
              const t = 'chordal' === this.curveType ? 0.5 : 0.25;
              let e = Math.pow(o.distanceToSquared(u), t),
                n = Math.pow(u.distanceToSquared(h), t),
                i = Math.pow(h.distanceToSquared(s), t);
              n < 1e-4 && (n = 1),
                e < 1e-4 && (e = n),
                i < 1e-4 && (i = n),
                Uu.initNonuniformCatmullRom(o.x, u.x, h.x, s.x, e, n, i),
                ju.initNonuniformCatmullRom(o.y, u.y, h.y, s.y, e, n, i),
                Gu.initNonuniformCatmullRom(o.z, u.z, h.z, s.z, e, n, i);
            } else
              'catmullrom' === this.curveType &&
                (Uu.initCatmullRom(o.x, u.x, h.x, s.x, this.tension),
                ju.initCatmullRom(o.y, u.y, h.y, s.y, this.tension),
                Gu.initCatmullRom(o.z, u.z, h.z, s.z, this.tension));
            return n.set(Uu.calc(c), ju.calc(c), Gu.calc(c)), n;
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return (
              (t.closed = this.closed),
              (t.curveType = this.curveType),
              (t.tension = this.tension),
              t
            );
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new Zn().fromArray(n));
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
        }
        function Vu(t, e, n, i, r) {
          const a = 0.5 * (i - e),
            o = 0.5 * (r - n),
            s = t * t;
          return (
            (2 * n - 2 * i + a + o) * (t * s) +
            (-3 * n + 3 * i - 2 * a - o) * s +
            a * t +
            n
          );
        }
        function Wu(t, e, n, i) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * e;
            })(t, e) +
            (function (t, e) {
              return 2 * (1 - t) * t * e;
            })(t, n) +
            (function (t, e) {
              return t * t * e;
            })(t, i)
          );
        }
        function Xu(t, e, n, i, r) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * n * e;
            })(t, e) +
            (function (t, e) {
              const n = 1 - t;
              return 3 * n * n * t * e;
            })(t, n) +
            (function (t, e) {
              return 3 * (1 - t) * t * t * e;
            })(t, i) +
            (function (t, e) {
              return t * t * t * e;
            })(t, r)
          );
        }
        Hu.prototype.isCatmullRomCurve3 = !0;
        class Yu extends Ou {
          constructor(t = new Bn(), e = new Bn(), n = new Bn(), i = new Bn()) {
            super(),
              (this.type = 'CubicBezierCurve'),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = i);
          }
          getPoint(t, e = new Bn()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              a = this.v2,
              o = this.v3;
            return (
              n.set(Xu(t, i.x, r.x, a.x, o.x), Xu(t, i.y, r.y, a.y, o.y)), n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        Yu.prototype.isCubicBezierCurve = !0;
        class $u extends Ou {
          constructor(t = new Zn(), e = new Zn(), n = new Zn(), i = new Zn()) {
            super(),
              (this.type = 'CubicBezierCurve3'),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = i);
          }
          getPoint(t, e = new Zn()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              a = this.v2,
              o = this.v3;
            return (
              n.set(
                Xu(t, i.x, r.x, a.x, o.x),
                Xu(t, i.y, r.y, a.y, o.y),
                Xu(t, i.z, r.z, a.z, o.z),
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        $u.prototype.isCubicBezierCurve3 = !0;
        class Ju extends Ou {
          constructor(t = new Bn(), e = new Bn()) {
            super(), (this.type = 'LineCurve'), (this.v1 = t), (this.v2 = e);
          }
          getPoint(t, e = new Bn()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          getTangent(t, e) {
            const n = e || new Bn();
            return n.copy(this.v2).sub(this.v1).normalize(), n;
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Ju.prototype.isLineCurve = !0;
        class Zu extends Ou {
          constructor(t = new Zn(), e = new Zn()) {
            super(),
              (this.type = 'LineCurve3'),
              (this.isLineCurve3 = !0),
              (this.v1 = t),
              (this.v2 = e);
          }
          getPoint(t, e = new Zn()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        class Ku extends Ou {
          constructor(t = new Bn(), e = new Bn(), n = new Bn()) {
            super(),
              (this.type = 'QuadraticBezierCurve'),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new Bn()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              a = this.v2;
            return n.set(Wu(t, i.x, r.x, a.x), Wu(t, i.y, r.y, a.y)), n;
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Ku.prototype.isQuadraticBezierCurve = !0;
        class Qu extends Ou {
          constructor(t = new Zn(), e = new Zn(), n = new Zn()) {
            super(),
              (this.type = 'QuadraticBezierCurve3'),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new Zn()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              a = this.v2;
            return (
              n.set(
                Wu(t, i.x, r.x, a.x),
                Wu(t, i.y, r.y, a.y),
                Wu(t, i.z, r.z, a.z),
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Qu.prototype.isQuadraticBezierCurve3 = !0;
        class th extends Ou {
          constructor(t = []) {
            super(), (this.type = 'SplineCurve'), (this.points = t);
          }
          getPoint(t, e = new Bn()) {
            const n = e,
              i = this.points,
              r = (i.length - 1) * t,
              a = Math.floor(r),
              o = r - a,
              s = i[0 === a ? a : a - 1],
              l = i[a],
              c = i[a > i.length - 2 ? i.length - 1 : a + 1],
              u = i[a > i.length - 3 ? i.length - 1 : a + 2];
            return (
              n.set(Vu(o, s.x, l.x, c.x, u.x), Vu(o, s.y, l.y, c.y, u.y)), n
            );
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new Bn().fromArray(n));
            }
            return this;
          }
        }
        th.prototype.isSplineCurve = !0;
        var eh = Object.freeze({
          __proto__: null,
          ArcCurve: zu,
          CatmullRomCurve3: Hu,
          CubicBezierCurve: Yu,
          CubicBezierCurve3: $u,
          EllipseCurve: Nu,
          LineCurve: Ju,
          LineCurve3: Zu,
          QuadraticBezierCurve: Ku,
          QuadraticBezierCurve3: Qu,
          SplineCurve: th,
        });
        class nh extends Ou {
          constructor() {
            super(),
              (this.type = 'CurvePath'),
              (this.curves = []),
              (this.autoClose = !1);
          }
          add(t) {
            this.curves.push(t);
          }
          closePath() {
            const t = this.curves[0].getPoint(0),
              e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Ju(e, t));
          }
          getPoint(t) {
            const e = t * this.getLength(),
              n = this.getCurveLengths();
            let i = 0;
            for (; i < n.length; ) {
              if (n[i] >= e) {
                const t = n[i] - e,
                  r = this.curves[i],
                  a = r.getLength(),
                  o = 0 === a ? 0 : 1 - t / a;
                return r.getPointAt(o);
              }
              i++;
            }
            return null;
          }
          getLength() {
            const t = this.getCurveLengths();
            return t[t.length - 1];
          }
          updateArcLengths() {
            (this.needsUpdate = !0),
              (this.cacheLengths = null),
              this.getCurveLengths();
          }
          getCurveLengths() {
            if (
              this.cacheLengths &&
              this.cacheLengths.length === this.curves.length
            )
              return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, i = this.curves.length; n < i; n++)
              (e += this.curves[n].getLength()), t.push(e);
            return (this.cacheLengths = t), t;
          }
          getSpacedPoints(t = 40) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e;
          }
          getPoints(t = 12) {
            const e = [];
            let n;
            for (let i = 0, r = this.curves; i < r.length; i++) {
              const a = r[i],
                o =
                  a && a.isEllipseCurve
                    ? 2 * t
                    : a && (a.isLineCurve || a.isLineCurve3)
                    ? 1
                    : a && a.isSplineCurve
                    ? t * a.points.length
                    : t,
                s = a.getPoints(o);
              for (let t = 0; t < s.length; t++) {
                const i = s[t];
                (n && n.equals(i)) || (e.push(i), (n = i));
              }
            }
            return (
              this.autoClose &&
                e.length > 1 &&
                !e[e.length - 1].equals(e[0]) &&
                e.push(e[0]),
              e
            );
          }
          copy(t) {
            super.copy(t), (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(n.clone());
            }
            return (this.autoClose = t.autoClose), this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.autoClose = this.autoClose), (t.curves = []);
            for (let e = 0, n = this.curves.length; e < n; e++) {
              const n = this.curves[e];
              t.curves.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t),
              (this.autoClose = t.autoClose),
              (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(new eh[n.type]().fromJSON(n));
            }
            return this;
          }
        }
        class ih extends nh {
          constructor(t) {
            super(),
              (this.type = 'Path'),
              (this.currentPoint = new Bn()),
              t && this.setFromPoints(t);
          }
          setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++)
              this.lineTo(t[e].x, t[e].y);
            return this;
          }
          moveTo(t, e) {
            return this.currentPoint.set(t, e), this;
          }
          lineTo(t, e) {
            const n = new Ju(this.currentPoint.clone(), new Bn(t, e));
            return this.curves.push(n), this.currentPoint.set(t, e), this;
          }
          quadraticCurveTo(t, e, n, i) {
            const r = new Ku(
              this.currentPoint.clone(),
              new Bn(t, e),
              new Bn(n, i),
            );
            return this.curves.push(r), this.currentPoint.set(n, i), this;
          }
          bezierCurveTo(t, e, n, i, r, a) {
            const o = new Yu(
              this.currentPoint.clone(),
              new Bn(t, e),
              new Bn(n, i),
              new Bn(r, a),
            );
            return this.curves.push(o), this.currentPoint.set(r, a), this;
          }
          splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t),
              n = new th(e);
            return (
              this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
            );
          }
          arc(t, e, n, i, r, a) {
            const o = this.currentPoint.x,
              s = this.currentPoint.y;
            return this.absarc(t + o, e + s, n, i, r, a), this;
          }
          absarc(t, e, n, i, r, a) {
            return this.absellipse(t, e, n, n, i, r, a), this;
          }
          ellipse(t, e, n, i, r, a, o, s) {
            const l = this.currentPoint.x,
              c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, i, r, a, o, s), this;
          }
          absellipse(t, e, n, i, r, a, o, s) {
            const l = new Nu(t, e, n, i, r, a, o, s);
            if (this.curves.length > 0) {
              const t = l.getPoint(0);
              t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c), this;
          }
          copy(t) {
            return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.currentPoint = this.currentPoint.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.currentPoint.fromArray(t.currentPoint),
              this
            );
          }
        }
        class rh extends ih {
          constructor(t) {
            super(t),
              (this.uuid = Fn.generateUUID()),
              (this.type = 'Shape'),
              (this.holes = []);
          }
          getPointsHoles(t) {
            const e = [];
            for (let n = 0, i = this.holes.length; n < i; n++)
              e[n] = this.holes[n].getPoints(t);
            return e;
          }
          extractPoints(t) {
            return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
          }
          copy(t) {
            super.copy(t), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.uuid = this.uuid), (t.holes = []);
            for (let e = 0, n = this.holes.length; e < n; e++) {
              const n = this.holes[e];
              t.holes.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(new ih().fromJSON(n));
            }
            return this;
          }
        }
        class ah extends Qi {
          constructor(t, e = 1) {
            super(),
              (this.type = 'Light'),
              (this.color = new Mr(t)),
              (this.intensity = e);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.intensity = t.intensity),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (e.object.shadow = this.shadow.toJSON()),
              e
            );
          }
        }
        ah.prototype.isLight = !0;
        class oh extends ah {
          constructor(t, e, n) {
            super(t, n),
              (this.type = 'HemisphereLight'),
              this.position.copy(Qi.DefaultUp),
              this.updateMatrix(),
              (this.groundColor = new Mr(e));
          }
          copy(t) {
            return (
              ah.prototype.copy.call(this, t),
              this.groundColor.copy(t.groundColor),
              this
            );
          }
        }
        oh.prototype.isHemisphereLight = !0;
        const sh = new Ai(),
          lh = new Zn(),
          ch = new Zn();
        class uh {
          constructor(t) {
            (this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.mapSize = new Bn(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new Ai()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new Ea()),
              (this._frameExtents = new Bn(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new Xn(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix;
            lh.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(lh),
              ch.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(ch),
              e.updateMatrixWorld(),
              sh.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(sh),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(e.projectionMatrix),
              n.multiply(e.matrixWorldInverse);
          }
          getViewport(t) {
            return this._viewports[t];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          }
        }
        class hh extends uh {
          constructor() {
            super(new ba(50, 1, 0.5, 500)), (this.focus = 1);
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * Fn.RAD2DEG * t.angle * this.focus,
              i = this.mapSize.width / this.mapSize.height,
              r = t.distance || e.far;
            (n === e.fov && i === e.aspect && r === e.far) ||
              ((e.fov = n),
              (e.aspect = i),
              (e.far = r),
              e.updateProjectionMatrix()),
              super.updateMatrices(t);
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this;
          }
        }
        hh.prototype.isSpotLightShadow = !0;
        class dh extends ah {
          constructor(t, e, n = 0, i = Math.PI / 3, r = 0, a = 1) {
            super(t, e),
              (this.type = 'SpotLight'),
              this.position.copy(Qi.DefaultUp),
              this.updateMatrix(),
              (this.target = new Qi()),
              (this.distance = n),
              (this.angle = i),
              (this.penumbra = r),
              (this.decay = a),
              (this.shadow = new hh());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / Math.PI;
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        dh.prototype.isSpotLight = !0;
        const ph = new Ai(),
          fh = new Zn(),
          mh = new Zn();
        class gh extends uh {
          constructor() {
            super(new ba(90, 1, 0.5, 500)),
              (this._frameExtents = new Bn(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new Xn(2, 1, 1, 1),
                new Xn(0, 1, 1, 1),
                new Xn(3, 1, 1, 1),
                new Xn(1, 1, 1, 1),
                new Xn(3, 0, 1, 1),
                new Xn(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new Zn(1, 0, 0),
                new Zn(-1, 0, 0),
                new Zn(0, 0, 1),
                new Zn(0, 0, -1),
                new Zn(0, 1, 0),
                new Zn(0, -1, 0),
              ]),
              (this._cubeUps = [
                new Zn(0, 1, 0),
                new Zn(0, 1, 0),
                new Zn(0, 1, 0),
                new Zn(0, 1, 0),
                new Zn(0, 0, 1),
                new Zn(0, 0, -1),
              ]);
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              i = this.matrix,
              r = t.distance || n.far;
            r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
              fh.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(fh),
              mh.copy(n.position),
              mh.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(mh),
              n.updateMatrixWorld(),
              i.makeTranslation(-fh.x, -fh.y, -fh.z),
              ph.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(ph);
          }
        }
        gh.prototype.isPointLightShadow = !0;
        class yh extends ah {
          constructor(t, e, n = 0, i = 1) {
            super(t, e),
              (this.type = 'PointLight'),
              (this.distance = n),
              (this.decay = i),
              (this.shadow = new gh());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        yh.prototype.isPointLight = !0;
        class vh extends xa {
          constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, a = 2e3) {
            super(),
              (this.type = 'OrthographicCamera'),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = i),
              (this.near = r),
              (this.far = a),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          }
          setViewOffset(t, e, n, i, r, a) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = a),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2;
            let r = n - t,
              a = n + t,
              o = i + e,
              s = i - e;
            if (null !== this.view && this.view.enabled) {
              const t =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (r += t * this.view.offsetX),
                (a = r + t * this.view.width),
                (o -= e * this.view.offsetY),
                (s = o - e * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              r,
              a,
              o,
              s,
              this.near,
              this.far,
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = Qi.prototype.toJSON.call(this, t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              e
            );
          }
        }
        vh.prototype.isOrthographicCamera = !0;
        class xh extends uh {
          constructor() {
            super(new vh(-5, 5, 5, -5, 0.5, 500));
          }
        }
        xh.prototype.isDirectionalLightShadow = !0;
        class bh extends ah {
          constructor(t, e) {
            super(t, e),
              (this.type = 'DirectionalLight'),
              this.position.copy(Qi.DefaultUp),
              this.updateMatrix(),
              (this.target = new Qi()),
              (this.shadow = new xh());
          }
          copy(t) {
            return (
              super.copy(t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        bh.prototype.isDirectionalLight = !0;
        class _h extends ah {
          constructor(t, e) {
            super(t, e), (this.type = 'AmbientLight');
          }
        }
        _h.prototype.isAmbientLight = !0;
        class wh extends ah {
          constructor(t, e, n = 10, i = 10) {
            super(t, e),
              (this.type = 'RectAreaLight'),
              (this.width = n),
              (this.height = i);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.width = t.width),
              (this.height = t.height),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.width = this.width), (e.object.height = this.height), e
            );
          }
        }
        wh.prototype.isRectAreaLight = !0;
        class Mh {
          constructor() {
            this.coefficients = [];
            for (let t = 0; t < 9; t++) this.coefficients.push(new Zn());
          }
          set(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
            return this;
          }
          zero() {
            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
            return this;
          }
          getAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              a = this.coefficients;
            return (
              e.copy(a[0]).multiplyScalar(0.282095),
              e.addScaledVector(a[1], 0.488603 * i),
              e.addScaledVector(a[2], 0.488603 * r),
              e.addScaledVector(a[3], 0.488603 * n),
              e.addScaledVector(a[4], n * i * 1.092548),
              e.addScaledVector(a[5], i * r * 1.092548),
              e.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)),
              e.addScaledVector(a[7], n * r * 1.092548),
              e.addScaledVector(a[8], 0.546274 * (n * n - i * i)),
              e
            );
          }
          getIrradianceAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              a = this.coefficients;
            return (
              e.copy(a[0]).multiplyScalar(0.886227),
              e.addScaledVector(a[1], 1.023328 * i),
              e.addScaledVector(a[2], 1.023328 * r),
              e.addScaledVector(a[3], 1.023328 * n),
              e.addScaledVector(a[4], 0.858086 * n * i),
              e.addScaledVector(a[5], 0.858086 * i * r),
              e.addScaledVector(a[6], 0.743125 * r * r - 0.247708),
              e.addScaledVector(a[7], 0.858086 * n * r),
              e.addScaledVector(a[8], 0.429043 * (n * n - i * i)),
              e
            );
          }
          add(t) {
            for (let e = 0; e < 9; e++)
              this.coefficients[e].add(t.coefficients[e]);
            return this;
          }
          addScaledSH(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this;
          }
          scale(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
            return this;
          }
          lerp(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].lerp(t.coefficients[n], e);
            return this;
          }
          equals(t) {
            for (let e = 0; e < 9; e++)
              if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
            return !0;
          }
          copy(t) {
            return this.set(t.coefficients);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          fromArray(t, e = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
            return t;
          }
          static getBasisAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z;
            (e[0] = 0.282095),
              (e[1] = 0.488603 * i),
              (e[2] = 0.488603 * r),
              (e[3] = 0.488603 * n),
              (e[4] = 1.092548 * n * i),
              (e[5] = 1.092548 * i * r),
              (e[6] = 0.315392 * (3 * r * r - 1)),
              (e[7] = 1.092548 * n * r),
              (e[8] = 0.546274 * (n * n - i * i));
          }
        }
        Mh.prototype.isSphericalHarmonics3 = !0;
        class qh extends ah {
          constructor(t = new Mh(), e = 1) {
            super(void 0, e), (this.sh = t);
          }
          copy(t) {
            return super.copy(t), this.sh.copy(t.sh), this;
          }
          fromJSON(t) {
            return (
              (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (e.object.sh = this.sh.toArray()), e;
          }
        }
        qh.prototype.isLightProbe = !0;
        class Sh extends Eu {
          constructor(t) {
            super(t), (this.textures = {});
          }
          load(t, e, n, i) {
            const r = this,
              a = new Lu(r.manager);
            a.setPath(r.path),
              a.setRequestHeader(r.requestHeader),
              a.setWithCredentials(r.withCredentials),
              a.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)));
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i,
              );
          }
          parse(t) {
            const e = this.textures;
            function n(t) {
              return (
                void 0 === e[t] &&
                  console.warn('THREE.MaterialLoader: Undefined texture', t),
                e[t]
              );
            }
            const i = new lu[t.type]();
            if (
              (void 0 !== t.uuid && (i.uuid = t.uuid),
              void 0 !== t.name && (i.name = t.name),
              void 0 !== t.color &&
                void 0 !== i.color &&
                i.color.setHex(t.color),
              void 0 !== t.roughness && (i.roughness = t.roughness),
              void 0 !== t.metalness && (i.metalness = t.metalness),
              void 0 !== t.sheen && (i.sheen = new Mr().setHex(t.sheen)),
              void 0 !== t.emissive &&
                void 0 !== i.emissive &&
                i.emissive.setHex(t.emissive),
              void 0 !== t.specular &&
                void 0 !== i.specular &&
                i.specular.setHex(t.specular),
              void 0 !== t.shininess && (i.shininess = t.shininess),
              void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
              void 0 !== t.clearcoatRoughness &&
                (i.clearcoatRoughness = t.clearcoatRoughness),
              void 0 !== t.fog && (i.fog = t.fog),
              void 0 !== t.flatShading && (i.flatShading = t.flatShading),
              void 0 !== t.blending && (i.blending = t.blending),
              void 0 !== t.combine && (i.combine = t.combine),
              void 0 !== t.side && (i.side = t.side),
              void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
              void 0 !== t.opacity && (i.opacity = t.opacity),
              void 0 !== t.transparent && (i.transparent = t.transparent),
              void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
              void 0 !== t.depthTest && (i.depthTest = t.depthTest),
              void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
              void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
              void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
              void 0 !== t.stencilWriteMask &&
                (i.stencilWriteMask = t.stencilWriteMask),
              void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
              void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
              void 0 !== t.stencilFuncMask &&
                (i.stencilFuncMask = t.stencilFuncMask),
              void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
              void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
              void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
              void 0 !== t.wireframe && (i.wireframe = t.wireframe),
              void 0 !== t.wireframeLinewidth &&
                (i.wireframeLinewidth = t.wireframeLinewidth),
              void 0 !== t.wireframeLinecap &&
                (i.wireframeLinecap = t.wireframeLinecap),
              void 0 !== t.wireframeLinejoin &&
                (i.wireframeLinejoin = t.wireframeLinejoin),
              void 0 !== t.rotation && (i.rotation = t.rotation),
              1 !== t.linewidth && (i.linewidth = t.linewidth),
              void 0 !== t.dashSize && (i.dashSize = t.dashSize),
              void 0 !== t.gapSize && (i.gapSize = t.gapSize),
              void 0 !== t.scale && (i.scale = t.scale),
              void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
              void 0 !== t.polygonOffsetFactor &&
                (i.polygonOffsetFactor = t.polygonOffsetFactor),
              void 0 !== t.polygonOffsetUnits &&
                (i.polygonOffsetUnits = t.polygonOffsetUnits),
              void 0 !== t.skinning && (i.skinning = t.skinning),
              void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
              void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
              void 0 !== t.dithering && (i.dithering = t.dithering),
              void 0 !== t.alphaToCoverage &&
                (i.alphaToCoverage = t.alphaToCoverage),
              void 0 !== t.premultipliedAlpha &&
                (i.premultipliedAlpha = t.premultipliedAlpha),
              void 0 !== t.vertexTangents &&
                (i.vertexTangents = t.vertexTangents),
              void 0 !== t.visible && (i.visible = t.visible),
              void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
              void 0 !== t.userData && (i.userData = t.userData),
              void 0 !== t.vertexColors &&
                ('number' == typeof t.vertexColors
                  ? (i.vertexColors = t.vertexColors > 0)
                  : (i.vertexColors = t.vertexColors)),
              void 0 !== t.uniforms)
            )
              for (const e in t.uniforms) {
                const r = t.uniforms[e];
                switch (((i.uniforms[e] = {}), r.type)) {
                  case 't':
                    i.uniforms[e].value = n(r.value);
                    break;
                  case 'c':
                    i.uniforms[e].value = new Mr().setHex(r.value);
                    break;
                  case 'v2':
                    i.uniforms[e].value = new Bn().fromArray(r.value);
                    break;
                  case 'v3':
                    i.uniforms[e].value = new Zn().fromArray(r.value);
                    break;
                  case 'v4':
                    i.uniforms[e].value = new Xn().fromArray(r.value);
                    break;
                  case 'm3':
                    i.uniforms[e].value = new Un().fromArray(r.value);
                    break;
                  case 'm4':
                    i.uniforms[e].value = new Ai().fromArray(r.value);
                    break;
                  default:
                    i.uniforms[e].value = r.value;
                }
              }
            if (
              (void 0 !== t.defines && (i.defines = t.defines),
              void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
              void 0 !== t.fragmentShader &&
                (i.fragmentShader = t.fragmentShader),
              void 0 !== t.extensions)
            )
              for (const e in t.extensions) i.extensions[e] = t.extensions[e];
            if (
              (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
              void 0 !== t.size && (i.size = t.size),
              void 0 !== t.sizeAttenuation &&
                (i.sizeAttenuation = t.sizeAttenuation),
              void 0 !== t.map && (i.map = n(t.map)),
              void 0 !== t.matcap && (i.matcap = n(t.matcap)),
              void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
              void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
              void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
              void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
              void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
              void 0 !== t.normalScale)
            ) {
              let e = t.normalScale;
              !1 === Array.isArray(e) && (e = [e, e]),
                (i.normalScale = new Bn().fromArray(e));
            }
            return (
              void 0 !== t.displacementMap &&
                (i.displacementMap = n(t.displacementMap)),
              void 0 !== t.displacementScale &&
                (i.displacementScale = t.displacementScale),
              void 0 !== t.displacementBias &&
                (i.displacementBias = t.displacementBias),
              void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
              void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
              void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
              void 0 !== t.emissiveIntensity &&
                (i.emissiveIntensity = t.emissiveIntensity),
              void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
              void 0 !== t.envMap && (i.envMap = n(t.envMap)),
              void 0 !== t.envMapIntensity &&
                (i.envMapIntensity = t.envMapIntensity),
              void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
              void 0 !== t.refractionRatio &&
                (i.refractionRatio = t.refractionRatio),
              void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
              void 0 !== t.lightMapIntensity &&
                (i.lightMapIntensity = t.lightMapIntensity),
              void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
              void 0 !== t.aoMapIntensity &&
                (i.aoMapIntensity = t.aoMapIntensity),
              void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
              void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
              void 0 !== t.clearcoatRoughnessMap &&
                (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
              void 0 !== t.clearcoatNormalMap &&
                (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
              void 0 !== t.clearcoatNormalScale &&
                (i.clearcoatNormalScale = new Bn().fromArray(
                  t.clearcoatNormalScale,
                )),
              void 0 !== t.transmission && (i.transmission = t.transmission),
              void 0 !== t.transmissionMap &&
                (i.transmissionMap = n(t.transmissionMap)),
              i
            );
          }
          setTextures(t) {
            return (this.textures = t), this;
          }
        }
        const Th = {
          decodeText: function (t) {
            if ('undefined' != typeof TextDecoder)
              return new TextDecoder().decode(t);
            let e = '';
            for (let n = 0, i = t.length; n < i; n++)
              e += String.fromCharCode(t[n]);
            try {
              return decodeURIComponent(escape(e));
            } catch (t) {
              return e;
            }
          },
          extractUrlBase: function (t) {
            const e = t.lastIndexOf('/');
            return -1 === e ? './' : t.substr(0, e + 1);
          },
        };
        function Eh() {
          Yr.call(this),
            (this.type = 'InstancedBufferGeometry'),
            (this.instanceCount = 1 / 0);
        }
        function Ah(t, e, n, i) {
          'number' == typeof n &&
            ((i = n),
            (n = !1),
            console.error(
              'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',
            )),
            Er.call(this, t, e, n),
            (this.meshPerAttribute = i || 1);
        }
        (Eh.prototype = Object.assign(Object.create(Yr.prototype), {
          constructor: Eh,
          isInstancedBufferGeometry: !0,
          copy: function (t) {
            return (
              Yr.prototype.copy.call(this, t),
              (this.instanceCount = t.instanceCount),
              this
            );
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          toJSON: function () {
            const t = Yr.prototype.toJSON.call(this);
            return (
              (t.instanceCount = this.instanceCount),
              (t.isInstancedBufferGeometry = !0),
              t
            );
          },
        })),
          (Ah.prototype = Object.assign(Object.create(Er.prototype), {
            constructor: Ah,
            isInstancedBufferAttribute: !0,
            copy: function (t) {
              return (
                Er.prototype.copy.call(this, t),
                (this.meshPerAttribute = t.meshPerAttribute),
                this
              );
            },
            toJSON: function () {
              const t = Er.prototype.toJSON.call(this);
              return (
                (t.meshPerAttribute = this.meshPerAttribute),
                (t.isInstancedBufferAttribute = !0),
                t
              );
            },
          }));
        class Lh extends Eu {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              a = new Lu(r.manager);
            a.setPath(r.path),
              a.setRequestHeader(r.requestHeader),
              a.setWithCredentials(r.withCredentials),
              a.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)));
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i,
              );
          }
          parse(t) {
            const e = {},
              n = {};
            function i(t, i) {
              if (void 0 !== e[i]) return e[i];
              const r = t.interleavedBuffers[i],
                a = (function (t, e) {
                  if (void 0 !== n[e]) return n[e];
                  const i = t.arrayBuffers[e],
                    r = new Uint32Array(i).buffer;
                  return (n[e] = r), r;
                })(t, r.buffer),
                o = new Xs(Br(r.type, a), r.stride);
              return (o.uuid = r.uuid), (e[i] = o), o;
            }
            const r = t.isInstancedBufferGeometry ? new Eh() : new Yr(),
              a = t.data.index;
            if (void 0 !== a) {
              const t = Br(a.type, a.array);
              r.setIndex(new Er(t, 1));
            }
            const o = t.data.attributes;
            for (const e in o) {
              const n = o[e];
              let a;
              if (n.isInterleavedBufferAttribute) {
                a = new $s(
                  i(t.data, n.data),
                  n.itemSize,
                  n.offset,
                  n.normalized,
                );
              } else {
                const t = Br(n.type, n.array);
                a = new (n.isInstancedBufferAttribute ? Ah : Er)(
                  t,
                  n.itemSize,
                  n.normalized,
                );
              }
              void 0 !== n.name && (a.name = n.name),
                void 0 !== n.usage && a.setUsage(n.usage),
                void 0 !== n.updateRange &&
                  ((a.updateRange.offset = n.updateRange.offset),
                  (a.updateRange.count = n.updateRange.count)),
                r.setAttribute(e, a);
            }
            const s = t.data.morphAttributes;
            if (s)
              for (const e in s) {
                const n = s[e],
                  a = [];
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = n[e];
                  let o;
                  if (r.isInterleavedBufferAttribute) {
                    o = new $s(
                      i(t.data, r.data),
                      r.itemSize,
                      r.offset,
                      r.normalized,
                    );
                  } else {
                    o = new Er(Br(r.type, r.array), r.itemSize, r.normalized);
                  }
                  void 0 !== r.name && (o.name = r.name), a.push(o);
                }
                r.morphAttributes[e] = a;
              }
            t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
            const l = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== l)
              for (let t = 0, e = l.length; t !== e; ++t) {
                const e = l[t];
                r.addGroup(e.start, e.count, e.materialIndex);
              }
            const c = t.data.boundingSphere;
            if (void 0 !== c) {
              const t = new Zn();
              void 0 !== c.center && t.fromArray(c.center),
                (r.boundingSphere = new xi(t, c.radius));
            }
            return (
              t.name && (r.name = t.name),
              t.userData && (r.userData = t.userData),
              r
            );
          }
        }
        class Rh extends Eu {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              a = '' === this.path ? Th.extractUrlBase(t) : this.path;
            this.resourcePath = this.resourcePath || a;
            const o = new Lu(this.manager);
            o.setPath(this.path),
              o.setRequestHeader(this.requestHeader),
              o.setWithCredentials(this.withCredentials),
              o.load(
                t,
                function (n) {
                  let a = null;
                  try {
                    a = JSON.parse(n);
                  } catch (e) {
                    return (
                      void 0 !== i && i(e),
                      void console.error(
                        "THREE:ObjectLoader: Can't parse " + t + '.',
                        e.message,
                      )
                    );
                  }
                  const o = a.metadata;
                  void 0 !== o &&
                  void 0 !== o.type &&
                  'geometry' !== o.type.toLowerCase()
                    ? r.parse(a, e)
                    : console.error("THREE.ObjectLoader: Can't load " + t);
                },
                n,
                i,
              );
          }
          parse(t, e) {
            const n = this.parseAnimations(t.animations),
              i = this.parseShapes(t.shapes),
              r = this.parseGeometries(t.geometries, i),
              a = this.parseImages(t.images, function () {
                void 0 !== e && e(l);
              }),
              o = this.parseTextures(t.textures, a),
              s = this.parseMaterials(t.materials, o),
              l = this.parseObject(t.object, r, s, n),
              c = this.parseSkeletons(t.skeletons, l);
            if ((this.bindSkeletons(l, c), void 0 !== e)) {
              let t = !1;
              for (const e in a)
                if (a[e] instanceof HTMLImageElement) {
                  t = !0;
                  break;
                }
              !1 === t && e(l);
            }
            return l;
          }
          parseShapes(t) {
            const e = {};
            if (void 0 !== t)
              for (let n = 0, i = t.length; n < i; n++) {
                const i = new rh().fromJSON(t[n]);
                e[i.uuid] = i;
              }
            return e;
          }
          parseSkeletons(t, e) {
            const n = {},
              i = {};
            if (
              (e.traverse(function (t) {
                t.isBone && (i[t.uuid] = t);
              }),
              void 0 !== t)
            )
              for (let e = 0, r = t.length; e < r; e++) {
                const r = new ql().fromJSON(t[e], i);
                n[r.uuid] = r;
              }
            return n;
          }
          parseGeometries(t, e) {
            const n = {};
            let i;
            if (void 0 !== t) {
              const r = new Lh();
              for (let a = 0, o = t.length; a < o; a++) {
                let o;
                const s = t[a];
                switch (s.type) {
                  case 'PlaneGeometry':
                  case 'PlaneBufferGeometry':
                    o = new Zc[s.type](
                      s.width,
                      s.height,
                      s.widthSegments,
                      s.heightSegments,
                    );
                    break;
                  case 'BoxGeometry':
                  case 'BoxBufferGeometry':
                    o = new Zc[s.type](
                      s.width,
                      s.height,
                      s.depth,
                      s.widthSegments,
                      s.heightSegments,
                      s.depthSegments,
                    );
                    break;
                  case 'CircleGeometry':
                  case 'CircleBufferGeometry':
                    o = new Zc[s.type](
                      s.radius,
                      s.segments,
                      s.thetaStart,
                      s.thetaLength,
                    );
                    break;
                  case 'CylinderGeometry':
                  case 'CylinderBufferGeometry':
                    o = new Zc[s.type](
                      s.radiusTop,
                      s.radiusBottom,
                      s.height,
                      s.radialSegments,
                      s.heightSegments,
                      s.openEnded,
                      s.thetaStart,
                      s.thetaLength,
                    );
                    break;
                  case 'ConeGeometry':
                  case 'ConeBufferGeometry':
                    o = new Zc[s.type](
                      s.radius,
                      s.height,
                      s.radialSegments,
                      s.heightSegments,
                      s.openEnded,
                      s.thetaStart,
                      s.thetaLength,
                    );
                    break;
                  case 'SphereGeometry':
                  case 'SphereBufferGeometry':
                    o = new Zc[s.type](
                      s.radius,
                      s.widthSegments,
                      s.heightSegments,
                      s.phiStart,
                      s.phiLength,
                      s.thetaStart,
                      s.thetaLength,
                    );
                    break;
                  case 'DodecahedronGeometry':
                  case 'DodecahedronBufferGeometry':
                  case 'IcosahedronGeometry':
                  case 'IcosahedronBufferGeometry':
                  case 'OctahedronGeometry':
                  case 'OctahedronBufferGeometry':
                  case 'TetrahedronGeometry':
                  case 'TetrahedronBufferGeometry':
                    o = new Zc[s.type](s.radius, s.detail);
                    break;
                  case 'RingGeometry':
                  case 'RingBufferGeometry':
                    o = new Zc[s.type](
                      s.innerRadius,
                      s.outerRadius,
                      s.thetaSegments,
                      s.phiSegments,
                      s.thetaStart,
                      s.thetaLength,
                    );
                    break;
                  case 'TorusGeometry':
                  case 'TorusBufferGeometry':
                    o = new Zc[s.type](
                      s.radius,
                      s.tube,
                      s.radialSegments,
                      s.tubularSegments,
                      s.arc,
                    );
                    break;
                  case 'TorusKnotGeometry':
                  case 'TorusKnotBufferGeometry':
                    o = new Zc[s.type](
                      s.radius,
                      s.tube,
                      s.tubularSegments,
                      s.radialSegments,
                      s.p,
                      s.q,
                    );
                    break;
                  case 'TubeGeometry':
                  case 'TubeBufferGeometry':
                    o = new Zc[s.type](
                      new eh[s.path.type]().fromJSON(s.path),
                      s.tubularSegments,
                      s.radius,
                      s.radialSegments,
                      s.closed,
                    );
                    break;
                  case 'LatheGeometry':
                  case 'LatheBufferGeometry':
                    o = new Zc[s.type](
                      s.points,
                      s.segments,
                      s.phiStart,
                      s.phiLength,
                    );
                    break;
                  case 'PolyhedronGeometry':
                  case 'PolyhedronBufferGeometry':
                    o = new Zc[s.type](
                      s.vertices,
                      s.indices,
                      s.radius,
                      s.details,
                    );
                    break;
                  case 'ShapeGeometry':
                  case 'ShapeBufferGeometry':
                    i = [];
                    for (let t = 0, n = s.shapes.length; t < n; t++) {
                      const n = e[s.shapes[t]];
                      i.push(n);
                    }
                    o = new Zc[s.type](i, s.curveSegments);
                    break;
                  case 'ExtrudeGeometry':
                  case 'ExtrudeBufferGeometry':
                    i = [];
                    for (let t = 0, n = s.shapes.length; t < n; t++) {
                      const n = e[s.shapes[t]];
                      i.push(n);
                    }
                    const t = s.options.extrudePath;
                    void 0 !== t &&
                      (s.options.extrudePath = new eh[t.type]().fromJSON(t)),
                      (o = new Zc[s.type](i, s.options));
                    break;
                  case 'BufferGeometry':
                  case 'InstancedBufferGeometry':
                    o = r.parse(s);
                    break;
                  case 'Geometry':
                    console.error(
                      'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.',
                    );
                    break;
                  default:
                    console.warn(
                      'THREE.ObjectLoader: Unsupported geometry type "' +
                        s.type +
                        '"',
                    );
                    continue;
                }
                (o.uuid = s.uuid),
                  void 0 !== s.name && (o.name = s.name),
                  !0 === o.isBufferGeometry &&
                    void 0 !== s.userData &&
                    (o.userData = s.userData),
                  (n[s.uuid] = o);
              }
            }
            return n;
          }
          parseMaterials(t, e) {
            const n = {},
              i = {};
            if (void 0 !== t) {
              const r = new Sh();
              r.setTextures(e);
              for (let e = 0, a = t.length; e < a; e++) {
                const a = t[e];
                if ('MultiMaterial' === a.type) {
                  const t = [];
                  for (let e = 0; e < a.materials.length; e++) {
                    const i = a.materials[e];
                    void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),
                      t.push(n[i.uuid]);
                  }
                  i[a.uuid] = t;
                } else
                  void 0 === n[a.uuid] && (n[a.uuid] = r.parse(a)),
                    (i[a.uuid] = n[a.uuid]);
              }
            }
            return i;
          }
          parseAnimations(t) {
            const e = {};
            if (void 0 !== t)
              for (let n = 0; n < t.length; n++) {
                const i = t[n],
                  r = wu.parse(i);
                e[r.uuid] = r;
              }
            return e;
          }
          parseImages(t, e) {
            const n = this,
              i = {};
            let r;
            function a(t) {
              if ('string' == typeof t) {
                const e = t;
                return (function (t) {
                  return (
                    n.manager.itemStart(t),
                    r.load(
                      t,
                      function () {
                        n.manager.itemEnd(t);
                      },
                      void 0,
                      function () {
                        n.manager.itemError(t), n.manager.itemEnd(t);
                      },
                    )
                  );
                })(
                  /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e,
                );
              }
              return t.data
                ? { data: Br(t.type, t.data), width: t.width, height: t.height }
                : null;
            }
            if (void 0 !== t && t.length > 0) {
              const n = new Su(e);
              (r = new Pu(n)), r.setCrossOrigin(this.crossOrigin);
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e],
                  r = n.url;
                if (Array.isArray(r)) {
                  i[n.uuid] = [];
                  for (let t = 0, e = r.length; t < e; t++) {
                    const e = a(r[t]);
                    null !== e &&
                      (e instanceof HTMLImageElement
                        ? i[n.uuid].push(e)
                        : i[n.uuid].push(new qa(e.data, e.width, e.height)));
                  }
                } else {
                  const t = a(n.url);
                  null !== t && (i[n.uuid] = t);
                }
              }
            }
            return i;
          }
          parseTextures(t, e) {
            function n(t, e) {
              return 'number' == typeof t
                ? t
                : (console.warn(
                    'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
                    t,
                  ),
                  e[t]);
            }
            const i = {};
            if (void 0 !== t)
              for (let r = 0, a = t.length; r < a; r++) {
                const a = t[r];
                let o;
                void 0 === a.image &&
                  console.warn(
                    'THREE.ObjectLoader: No "image" specified for',
                    a.uuid,
                  ),
                  void 0 === e[a.image] &&
                    console.warn(
                      'THREE.ObjectLoader: Undefined image',
                      a.image,
                    );
                const s = e[a.image];
                Array.isArray(s)
                  ? ((o = new wa(s)), 6 === s.length && (o.needsUpdate = !0))
                  : ((o =
                      s && s.data
                        ? new qa(s.data, s.width, s.height)
                        : new Vn(s)),
                    s && (o.needsUpdate = !0)),
                  (o.uuid = a.uuid),
                  void 0 !== a.name && (o.name = a.name),
                  void 0 !== a.mapping && (o.mapping = n(a.mapping, Ch)),
                  void 0 !== a.offset && o.offset.fromArray(a.offset),
                  void 0 !== a.repeat && o.repeat.fromArray(a.repeat),
                  void 0 !== a.center && o.center.fromArray(a.center),
                  void 0 !== a.rotation && (o.rotation = a.rotation),
                  void 0 !== a.wrap &&
                    ((o.wrapS = n(a.wrap[0], Ph)),
                    (o.wrapT = n(a.wrap[1], Ph))),
                  void 0 !== a.format && (o.format = a.format),
                  void 0 !== a.type && (o.type = a.type),
                  void 0 !== a.encoding && (o.encoding = a.encoding),
                  void 0 !== a.minFilter && (o.minFilter = n(a.minFilter, kh)),
                  void 0 !== a.magFilter && (o.magFilter = n(a.magFilter, kh)),
                  void 0 !== a.anisotropy && (o.anisotropy = a.anisotropy),
                  void 0 !== a.flipY && (o.flipY = a.flipY),
                  void 0 !== a.premultiplyAlpha &&
                    (o.premultiplyAlpha = a.premultiplyAlpha),
                  void 0 !== a.unpackAlignment &&
                    (o.unpackAlignment = a.unpackAlignment),
                  (i[a.uuid] = o);
              }
            return i;
          }
          parseObject(t, e, n, i) {
            let r, a, o;
            function s(t) {
              return (
                void 0 === e[t] &&
                  console.warn('THREE.ObjectLoader: Undefined geometry', t),
                e[t]
              );
            }
            function l(t) {
              if (void 0 !== t) {
                if (Array.isArray(t)) {
                  const e = [];
                  for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i];
                    void 0 === n[r] &&
                      console.warn('THREE.ObjectLoader: Undefined material', r),
                      e.push(n[r]);
                  }
                  return e;
                }
                return (
                  void 0 === n[t] &&
                    console.warn('THREE.ObjectLoader: Undefined material', t),
                  n[t]
                );
              }
            }
            switch (t.type) {
              case 'Scene':
                (r = new Ws()),
                  void 0 !== t.background &&
                    Number.isInteger(t.background) &&
                    (r.background = new Mr(t.background)),
                  void 0 !== t.fog &&
                    ('Fog' === t.fog.type
                      ? (r.fog = new Vs(t.fog.color, t.fog.near, t.fog.far))
                      : 'FogExp2' === t.fog.type &&
                        (r.fog = new Hs(t.fog.color, t.fog.density)));
                break;
              case 'PerspectiveCamera':
                (r = new ba(t.fov, t.aspect, t.near, t.far)),
                  void 0 !== t.focus && (r.focus = t.focus),
                  void 0 !== t.zoom && (r.zoom = t.zoom),
                  void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge),
                  void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset),
                  void 0 !== t.view && (r.view = Object.assign({}, t.view));
                break;
              case 'OrthographicCamera':
                (r = new vh(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                  void 0 !== t.zoom && (r.zoom = t.zoom),
                  void 0 !== t.view && (r.view = Object.assign({}, t.view));
                break;
              case 'AmbientLight':
                r = new _h(t.color, t.intensity);
                break;
              case 'DirectionalLight':
                r = new bh(t.color, t.intensity);
                break;
              case 'PointLight':
                r = new yh(t.color, t.intensity, t.distance, t.decay);
                break;
              case 'RectAreaLight':
                r = new wh(t.color, t.intensity, t.width, t.height);
                break;
              case 'SpotLight':
                r = new dh(
                  t.color,
                  t.intensity,
                  t.distance,
                  t.angle,
                  t.penumbra,
                  t.decay,
                );
                break;
              case 'HemisphereLight':
                r = new oh(t.color, t.groundColor, t.intensity);
                break;
              case 'LightProbe':
                r = new qh().fromJSON(t);
                break;
              case 'SkinnedMesh':
                (a = s(t.geometry)),
                  (o = l(t.material)),
                  (r = new bl(a, o)),
                  void 0 !== t.bindMode && (r.bindMode = t.bindMode),
                  void 0 !== t.bindMatrix &&
                    r.bindMatrix.fromArray(t.bindMatrix),
                  void 0 !== t.skeleton && (r.skeleton = t.skeleton);
                break;
              case 'Mesh':
                (a = s(t.geometry)), (o = l(t.material)), (r = new da(a, o));
                break;
              case 'InstancedMesh':
                (a = s(t.geometry)), (o = l(t.material));
                const e = t.count,
                  n = t.instanceMatrix,
                  i = t.instanceColor;
                (r = new Ll(a, o, e)),
                  (r.instanceMatrix = new Er(new Float32Array(n.array), 16)),
                  void 0 !== i &&
                    (r.instanceColor = new Er(
                      new Float32Array(i.array),
                      i.itemSize,
                    ));
                break;
              case 'LOD':
                r = new fl();
                break;
              case 'Line':
                r = new Ol(s(t.geometry), l(t.material));
                break;
              case 'LineLoop':
                r = new Bl(s(t.geometry), l(t.material));
                break;
              case 'LineSegments':
                r = new Fl(s(t.geometry), l(t.material));
                break;
              case 'PointCloud':
              case 'Points':
                r = new Wl(s(t.geometry), l(t.material));
                break;
              case 'Sprite':
                r = new ul(l(t.material));
                break;
              case 'Group':
                r = new zs();
                break;
              case 'Bone':
                r = new _l();
                break;
              default:
                r = new Qi();
            }
            if (
              ((r.uuid = t.uuid),
              void 0 !== t.name && (r.name = t.name),
              void 0 !== t.matrix
                ? (r.matrix.fromArray(t.matrix),
                  void 0 !== t.matrixAutoUpdate &&
                    (r.matrixAutoUpdate = t.matrixAutoUpdate),
                  r.matrixAutoUpdate &&
                    r.matrix.decompose(r.position, r.quaternion, r.scale))
                : (void 0 !== t.position && r.position.fromArray(t.position),
                  void 0 !== t.rotation && r.rotation.fromArray(t.rotation),
                  void 0 !== t.quaternion &&
                    r.quaternion.fromArray(t.quaternion),
                  void 0 !== t.scale && r.scale.fromArray(t.scale)),
              void 0 !== t.castShadow && (r.castShadow = t.castShadow),
              void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow),
              t.shadow &&
                (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias),
                void 0 !== t.shadow.normalBias &&
                  (r.shadow.normalBias = t.shadow.normalBias),
                void 0 !== t.shadow.radius &&
                  (r.shadow.radius = t.shadow.radius),
                void 0 !== t.shadow.mapSize &&
                  r.shadow.mapSize.fromArray(t.shadow.mapSize),
                void 0 !== t.shadow.camera &&
                  (r.shadow.camera = this.parseObject(t.shadow.camera))),
              void 0 !== t.visible && (r.visible = t.visible),
              void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled),
              void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder),
              void 0 !== t.userData && (r.userData = t.userData),
              void 0 !== t.layers && (r.layers.mask = t.layers),
              void 0 !== t.children)
            ) {
              const a = t.children;
              for (let t = 0; t < a.length; t++)
                r.add(this.parseObject(a[t], e, n, i));
            }
            if (void 0 !== t.animations) {
              const e = t.animations;
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                r.animations.push(i[n]);
              }
            }
            if ('LOD' === t.type) {
              void 0 !== t.autoUpdate && (r.autoUpdate = t.autoUpdate);
              const e = t.levels;
              for (let t = 0; t < e.length; t++) {
                const n = e[t],
                  i = r.getObjectByProperty('uuid', n.object);
                void 0 !== i && r.addLevel(i, n.distance);
              }
            }
            return r;
          }
          bindSkeletons(t, e) {
            0 !== Object.keys(e).length &&
              t.traverse(function (t) {
                if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                  const n = e[t.skeleton];
                  void 0 === n
                    ? console.warn(
                        'THREE.ObjectLoader: No skeleton found with UUID:',
                        t.skeleton,
                      )
                    : t.bind(n, t.bindMatrix);
                }
              });
          }
          setTexturePath(t) {
            return (
              console.warn(
                'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().',
              ),
              this.setResourcePath(t)
            );
          }
        }
        const Ch = {
            UVMapping: rt,
            CubeReflectionMapping: at,
            CubeRefractionMapping: ot,
            EquirectangularReflectionMapping: st,
            EquirectangularRefractionMapping: lt,
            CubeUVReflectionMapping: ct,
            CubeUVRefractionMapping: ut,
          },
          Ph = {
            RepeatWrapping: ht,
            ClampToEdgeWrapping: dt,
            MirroredRepeatWrapping: pt,
          },
          kh = {
            NearestFilter: ft,
            NearestMipmapNearestFilter: mt,
            NearestMipmapLinearFilter: yt,
            LinearFilter: xt,
            LinearMipmapNearestFilter: bt,
            LinearMipmapLinearFilter: wt,
          };
        function Ih(t) {
          'undefined' == typeof createImageBitmap &&
            console.warn(
              'THREE.ImageBitmapLoader: createImageBitmap() not supported.',
            ),
            'undefined' == typeof fetch &&
              console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
            Eu.call(this, t),
            (this.options = { premultiplyAlpha: 'none' });
        }
        Ih.prototype = Object.assign(Object.create(Eu.prototype), {
          constructor: Ih,
          isImageBitmapLoader: !0,
          setOptions: function (t) {
            return (this.options = t), this;
          },
          load: function (t, e, n, i) {
            void 0 === t && (t = ''),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              a = qu.get(t);
            if (void 0 !== a)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(a), r.manager.itemEnd(t);
                }, 0),
                a
              );
            const o = {};
            (o.credentials =
              'anonymous' === this.crossOrigin ? 'same-origin' : 'include'),
              (o.headers = this.requestHeader),
              fetch(t, o)
                .then(function (t) {
                  return t.blob();
                })
                .then(function (t) {
                  return createImageBitmap(
                    t,
                    Object.assign(r.options, { colorSpaceConversion: 'none' }),
                  );
                })
                .then(function (n) {
                  qu.add(t, n), e && e(n), r.manager.itemEnd(t);
                })
                .catch(function (e) {
                  i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
                }),
              r.manager.itemStart(t);
          },
        });
        class Dh {
          constructor() {
            (this.type = 'ShapePath'),
              (this.color = new Mr()),
              (this.subPaths = []),
              (this.currentPath = null);
          }
          moveTo(t, e) {
            return (
              (this.currentPath = new ih()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(t, e),
              this
            );
          }
          lineTo(t, e) {
            return this.currentPath.lineTo(t, e), this;
          }
          quadraticCurveTo(t, e, n, i) {
            return this.currentPath.quadraticCurveTo(t, e, n, i), this;
          }
          bezierCurveTo(t, e, n, i, r, a) {
            return this.currentPath.bezierCurveTo(t, e, n, i, r, a), this;
          }
          splineThru(t) {
            return this.currentPath.splineThru(t), this;
          }
          toShapes(t, e) {
            function n(t) {
              const e = [];
              for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n],
                  r = new rh();
                (r.curves = i.curves), e.push(r);
              }
              return e;
            }
            function i(t, e) {
              const n = e.length;
              let i = !1;
              for (let r = n - 1, a = 0; a < n; r = a++) {
                let n = e[r],
                  o = e[a],
                  s = o.x - n.x,
                  l = o.y - n.y;
                if (Math.abs(l) > Number.EPSILON) {
                  if (
                    (l < 0 && ((n = e[a]), (s = -s), (o = e[r]), (l = -l)),
                    t.y < n.y || t.y > o.y)
                  )
                    continue;
                  if (t.y === n.y) {
                    if (t.x === n.x) return !0;
                  } else {
                    const e = l * (t.x - n.x) - s * (t.y - n.y);
                    if (0 === e) return !0;
                    if (e < 0) continue;
                    i = !i;
                  }
                } else {
                  if (t.y !== n.y) continue;
                  if ((o.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= o.x))
                    return !0;
                }
              }
              return i;
            }
            const r = kc.isClockWise,
              a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === e) return n(a);
            let o, s, l;
            const c = [];
            if (1 === a.length)
              return (
                (s = a[0]), (l = new rh()), (l.curves = s.curves), c.push(l), c
              );
            let u = !r(a[0].getPoints());
            u = t ? !u : u;
            const h = [],
              d = [];
            let p,
              f,
              m = [],
              g = 0;
            (d[g] = void 0), (m[g] = []);
            for (let e = 0, n = a.length; e < n; e++)
              (s = a[e]),
                (p = s.getPoints()),
                (o = r(p)),
                (o = t ? !o : o),
                o
                  ? (!u && d[g] && g++,
                    (d[g] = { s: new rh(), p: p }),
                    (d[g].s.curves = s.curves),
                    u && g++,
                    (m[g] = []))
                  : m[g].push({ h: s, p: p[0] });
            if (!d[0]) return n(a);
            if (d.length > 1) {
              let t = !1;
              const e = [];
              for (let t = 0, e = d.length; t < e; t++) h[t] = [];
              for (let n = 0, r = d.length; n < r; n++) {
                const r = m[n];
                for (let a = 0; a < r.length; a++) {
                  const o = r[a];
                  let s = !0;
                  for (let r = 0; r < d.length; r++)
                    i(o.p, d[r].p) &&
                      (n !== r && e.push({ froms: n, tos: r, hole: a }),
                      s ? ((s = !1), h[r].push(o)) : (t = !0));
                  s && h[n].push(o);
                }
              }
              e.length > 0 && (t || (m = h));
            }
            for (let t = 0, e = d.length; t < e; t++) {
              (l = d[t].s), c.push(l), (f = m[t]);
              for (let t = 0, e = f.length; t < e; t++) l.holes.push(f[t].h);
            }
            return c;
          }
        }
        class Oh {
          constructor(t) {
            (this.type = 'Font'), (this.data = t);
          }
          generateShapes(t, e = 100) {
            const n = [],
              i = (function (t, e, n) {
                const i = Array.from(t),
                  r = e / n.resolution,
                  a =
                    (n.boundingBox.yMax -
                      n.boundingBox.yMin +
                      n.underlineThickness) *
                    r,
                  o = [];
                let s = 0,
                  l = 0;
                for (let t = 0; t < i.length; t++) {
                  const e = i[t];
                  if ('\n' === e) (s = 0), (l -= a);
                  else {
                    const t = Nh(e, r, s, l, n);
                    (s += t.offsetX), o.push(t.path);
                  }
                }
                return o;
              })(t, e, this.data);
            for (let t = 0, e = i.length; t < e; t++)
              Array.prototype.push.apply(n, i[t].toShapes());
            return n;
          }
        }
        function Nh(t, e, n, i, r) {
          const a = r.glyphs[t] || r.glyphs['?'];
          if (!a)
            return void console.error(
              'THREE.Font: character "' +
                t +
                '" does not exists in font family ' +
                r.familyName +
                '.',
            );
          const o = new Dh();
          let s, l, c, u, h, d, p, f;
          if (a.o) {
            const t = a._cachedOutline || (a._cachedOutline = a.o.split(' '));
            for (let r = 0, a = t.length; r < a; ) {
              switch (t[r++]) {
                case 'm':
                  (s = t[r++] * e + n), (l = t[r++] * e + i), o.moveTo(s, l);
                  break;
                case 'l':
                  (s = t[r++] * e + n), (l = t[r++] * e + i), o.lineTo(s, l);
                  break;
                case 'q':
                  (c = t[r++] * e + n),
                    (u = t[r++] * e + i),
                    (h = t[r++] * e + n),
                    (d = t[r++] * e + i),
                    o.quadraticCurveTo(h, d, c, u);
                  break;
                case 'b':
                  (c = t[r++] * e + n),
                    (u = t[r++] * e + i),
                    (h = t[r++] * e + n),
                    (d = t[r++] * e + i),
                    (p = t[r++] * e + n),
                    (f = t[r++] * e + i),
                    o.bezierCurveTo(h, d, p, f, c, u);
              }
            }
          }
          return { offsetX: a.ha * e, path: o };
        }
        Oh.prototype.isFont = !0;
        class zh extends Eu {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              a = new Lu(this.manager);
            a.setPath(this.path),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(r.withCredentials),
              a.load(
                t,
                function (t) {
                  let n;
                  try {
                    n = JSON.parse(t);
                  } catch (e) {
                    console.warn(
                      'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.',
                    ),
                      (n = JSON.parse(t.substring(65, t.length - 2)));
                  }
                  const i = r.parse(n);
                  e && e(i);
                },
                n,
                i,
              );
          }
          parse(t) {
            return new Oh(t);
          }
        }
        let Fh;
        const Bh = {
          getContext: function () {
            return (
              void 0 === Fh &&
                (Fh = new (window.AudioContext || window.webkitAudioContext)()),
              Fh
            );
          },
          setContext: function (t) {
            Fh = t;
          },
        };
        class Uh extends Eu {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              a = new Lu(this.manager);
            a.setResponseType('arraybuffer'),
              a.setPath(this.path),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(this.withCredentials),
              a.load(
                t,
                function (n) {
                  try {
                    const t = n.slice(0);
                    Bh.getContext().decodeAudioData(t, function (t) {
                      e(t);
                    });
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i,
              );
          }
        }
        class jh extends qh {
          constructor(t, e, n = 1) {
            super(void 0, n);
            const i = new Mr().set(t),
              r = new Mr().set(e),
              a = new Zn(i.r, i.g, i.b),
              o = new Zn(r.r, r.g, r.b),
              s = Math.sqrt(Math.PI),
              l = s * Math.sqrt(0.75);
            this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
              this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(l);
          }
        }
        jh.prototype.isHemisphereLightProbe = !0;
        class Gh extends qh {
          constructor(t, e = 1) {
            super(void 0, e);
            const n = new Mr().set(t);
            this.sh.coefficients[0]
              .set(n.r, n.g, n.b)
              .multiplyScalar(2 * Math.sqrt(Math.PI));
          }
        }
        Gh.prototype.isAmbientLightProbe = !0;
        const Hh = new Ai(),
          Vh = new Ai();
        class Wh {
          constructor() {
            (this.type = 'StereoCamera'),
              (this.aspect = 1),
              (this.eyeSep = 0.064),
              (this.cameraL = new ba()),
              this.cameraL.layers.enable(1),
              (this.cameraL.matrixAutoUpdate = !1),
              (this.cameraR = new ba()),
              this.cameraR.layers.enable(2),
              (this.cameraR.matrixAutoUpdate = !1),
              (this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null,
              });
          }
          update(t) {
            const e = this._cache;
            if (
              e.focus !== t.focus ||
              e.fov !== t.fov ||
              e.aspect !== t.aspect * this.aspect ||
              e.near !== t.near ||
              e.far !== t.far ||
              e.zoom !== t.zoom ||
              e.eyeSep !== this.eyeSep
            ) {
              (e.focus = t.focus),
                (e.fov = t.fov),
                (e.aspect = t.aspect * this.aspect),
                (e.near = t.near),
                (e.far = t.far),
                (e.zoom = t.zoom),
                (e.eyeSep = this.eyeSep);
              const n = t.projectionMatrix.clone(),
                i = e.eyeSep / 2,
                r = (i * e.near) / e.focus,
                a = (e.near * Math.tan(Fn.DEG2RAD * e.fov * 0.5)) / e.zoom;
              let o, s;
              (Vh.elements[12] = -i),
                (Hh.elements[12] = i),
                (o = -a * e.aspect + r),
                (s = a * e.aspect + r),
                (n.elements[0] = (2 * e.near) / (s - o)),
                (n.elements[8] = (s + o) / (s - o)),
                this.cameraL.projectionMatrix.copy(n),
                (o = -a * e.aspect - r),
                (s = a * e.aspect - r),
                (n.elements[0] = (2 * e.near) / (s - o)),
                (n.elements[8] = (s + o) / (s - o)),
                this.cameraR.projectionMatrix.copy(n);
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Vh),
              this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Hh);
          }
        }
        class Xh {
          constructor(t) {
            (this.autoStart = void 0 === t || t),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          start() {
            (this.startTime = Yh()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
          }
          getDelta() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              const e = Yh();
              (t = (e - this.oldTime) / 1e3),
                (this.oldTime = e),
                (this.elapsedTime += t);
            }
            return t;
          }
        }
        function Yh() {
          return ('undefined' == typeof performance ? Date : performance).now();
        }
        const $h = new Zn(),
          Jh = new Jn(),
          Zh = new Zn(),
          Kh = new Zn();
        class Qh extends Qi {
          constructor() {
            super(),
              (this.type = 'AudioListener'),
              (this.context = Bh.getContext()),
              (this.gain = this.context.createGain()),
              this.gain.connect(this.context.destination),
              (this.filter = null),
              (this.timeDelta = 0),
              (this._clock = new Xh());
          }
          getInput() {
            return this.gain;
          }
          removeFilter() {
            return (
              null !== this.filter &&
                (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
              this
            );
          }
          getFilter() {
            return this.filter;
          }
          setFilter(t) {
            return (
              null !== this.filter
                ? (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
              (this.filter = t),
              this.gain.connect(this.filter),
              this.filter.connect(this.context.destination),
              this
            );
          }
          getMasterVolume() {
            return this.gain.gain.value;
          }
          setMasterVolume(t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t);
            const e = this.context.listener,
              n = this.up;
            if (
              ((this.timeDelta = this._clock.getDelta()),
              this.matrixWorld.decompose($h, Jh, Zh),
              Kh.set(0, 0, -1).applyQuaternion(Jh),
              e.positionX)
            ) {
              const t = this.context.currentTime + this.timeDelta;
              e.positionX.linearRampToValueAtTime($h.x, t),
                e.positionY.linearRampToValueAtTime($h.y, t),
                e.positionZ.linearRampToValueAtTime($h.z, t),
                e.forwardX.linearRampToValueAtTime(Kh.x, t),
                e.forwardY.linearRampToValueAtTime(Kh.y, t),
                e.forwardZ.linearRampToValueAtTime(Kh.z, t),
                e.upX.linearRampToValueAtTime(n.x, t),
                e.upY.linearRampToValueAtTime(n.y, t),
                e.upZ.linearRampToValueAtTime(n.z, t);
            } else
              e.setPosition($h.x, $h.y, $h.z),
                e.setOrientation(Kh.x, Kh.y, Kh.z, n.x, n.y, n.z);
          }
        }
        class td extends Qi {
          constructor(t) {
            super(),
              (this.type = 'Audio'),
              (this.listener = t),
              (this.context = t.context),
              (this.gain = this.context.createGain()),
              this.gain.connect(t.getInput()),
              (this.autoplay = !1),
              (this.buffer = null),
              (this.detune = 0),
              (this.loop = !1),
              (this.loopStart = 0),
              (this.loopEnd = 0),
              (this.offset = 0),
              (this.duration = void 0),
              (this.playbackRate = 1),
              (this.isPlaying = !1),
              (this.hasPlaybackControl = !0),
              (this.source = null),
              (this.sourceType = 'empty'),
              (this._startedAt = 0),
              (this._progress = 0),
              (this._connected = !1),
              (this.filters = []);
          }
          getOutput() {
            return this.gain;
          }
          setNodeSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'audioNode'),
              (this.source = t),
              this.connect(),
              this
            );
          }
          setMediaElementSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaNode'),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            );
          }
          setMediaStreamSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = 'mediaStreamNode'),
              (this.source = this.context.createMediaStreamSource(t)),
              this.connect(),
              this
            );
          }
          setBuffer(t) {
            return (
              (this.buffer = t),
              (this.sourceType = 'buffer'),
              this.autoplay && this.play(),
              this
            );
          }
          play(t = 0) {
            if (!0 === this.isPlaying)
              return void console.warn(
                'THREE.Audio: Audio is already playing.',
              );
            if (!1 === this.hasPlaybackControl)
              return void console.warn(
                'THREE.Audio: this Audio has no playback control.',
              );
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(
                this._startedAt,
                this._progress + this.offset,
                this.duration,
              ),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            );
          }
          pause() {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) *
                    this.playbackRate),
                  !0 === this.loop &&
                    (this._progress =
                      this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              );
            console.warn('THREE.Audio: this Audio has no playback control.');
          }
          stop() {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this._progress = 0),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1),
                this
              );
            console.warn('THREE.Audio: this Audio has no playback control.');
          }
          connect() {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].connect(this.filters[t]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return (this._connected = !0), this;
          }
          disconnect() {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].disconnect(this.filters[t]);
              this.filters[this.filters.length - 1].disconnect(
                this.getOutput(),
              );
            } else this.source.disconnect(this.getOutput());
            return (this._connected = !1), this;
          }
          getFilters() {
            return this.filters;
          }
          setFilters(t) {
            return (
              t || (t = []),
              !0 === this._connected
                ? (this.disconnect(),
                  (this.filters = t.slice()),
                  this.connect())
                : (this.filters = t.slice()),
              this
            );
          }
          setDetune(t) {
            if (((this.detune = t), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(
                    this.detune,
                    this.context.currentTime,
                    0.01,
                  ),
                this
              );
          }
          getDetune() {
            return this.detune;
          }
          getFilter() {
            return this.getFilters()[0];
          }
          setFilter(t) {
            return this.setFilters(t ? [t] : []);
          }
          setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01,
                  ),
                this
              );
            console.warn('THREE.Audio: this Audio has no playback control.');
          }
          getPlaybackRate() {
            return this.playbackRate;
          }
          onEnded() {
            this.isPlaying = !1;
          }
          getLoop() {
            return !1 === this.hasPlaybackControl
              ? (console.warn(
                  'THREE.Audio: this Audio has no playback control.',
                ),
                !1)
              : this.loop;
          }
          setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.loop = t),
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
              );
            console.warn('THREE.Audio: this Audio has no playback control.');
          }
          setLoopStart(t) {
            return (this.loopStart = t), this;
          }
          setLoopEnd(t) {
            return (this.loopEnd = t), this;
          }
          getVolume() {
            return this.gain.gain.value;
          }
          setVolume(t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          }
        }
        const ed = new Zn(),
          nd = new Jn(),
          id = new Zn(),
          rd = new Zn();
        class ad extends td {
          constructor(t) {
            super(t),
              (this.panner = this.context.createPanner()),
              (this.panner.panningModel = 'HRTF'),
              this.panner.connect(this.gain);
          }
          getOutput() {
            return this.panner;
          }
          getRefDistance() {
            return this.panner.refDistance;
          }
          setRefDistance(t) {
            return (this.panner.refDistance = t), this;
          }
          getRolloffFactor() {
            return this.panner.rolloffFactor;
          }
          setRolloffFactor(t) {
            return (this.panner.rolloffFactor = t), this;
          }
          getDistanceModel() {
            return this.panner.distanceModel;
          }
          setDistanceModel(t) {
            return (this.panner.distanceModel = t), this;
          }
          getMaxDistance() {
            return this.panner.maxDistance;
          }
          setMaxDistance(t) {
            return (this.panner.maxDistance = t), this;
          }
          setDirectionalCone(t, e, n) {
            return (
              (this.panner.coneInnerAngle = t),
              (this.panner.coneOuterAngle = e),
              (this.panner.coneOuterGain = n),
              this
            );
          }
          updateMatrixWorld(t) {
            if (
              (super.updateMatrixWorld(t),
              !0 === this.hasPlaybackControl && !1 === this.isPlaying)
            )
              return;
            this.matrixWorld.decompose(ed, nd, id),
              rd.set(0, 0, 1).applyQuaternion(nd);
            const e = this.panner;
            if (e.positionX) {
              const t = this.context.currentTime + this.listener.timeDelta;
              e.positionX.linearRampToValueAtTime(ed.x, t),
                e.positionY.linearRampToValueAtTime(ed.y, t),
                e.positionZ.linearRampToValueAtTime(ed.z, t),
                e.orientationX.linearRampToValueAtTime(rd.x, t),
                e.orientationY.linearRampToValueAtTime(rd.y, t),
                e.orientationZ.linearRampToValueAtTime(rd.z, t);
            } else
              e.setPosition(ed.x, ed.y, ed.z),
                e.setOrientation(rd.x, rd.y, rd.z);
          }
        }
        class od {
          constructor(t, e = 2048) {
            (this.analyser = t.context.createAnalyser()),
              (this.analyser.fftSize = e),
              (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
              t.getOutput().connect(this.analyser);
          }
          getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
          }
          getAverageFrequency() {
            let t = 0;
            const e = this.getFrequencyData();
            for (let n = 0; n < e.length; n++) t += e[n];
            return t / e.length;
          }
        }
        class sd {
          constructor(t, e, n) {
            let i, r, a;
            switch (((this.binding = t), (this.valueSize = n), e)) {
              case 'quaternion':
                (i = this._slerp),
                  (r = this._slerpAdditive),
                  (a = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5);
                break;
              case 'string':
              case 'bool':
                (i = this._select),
                  (r = this._select),
                  (a = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n));
                break;
              default:
                (i = this._lerp),
                  (r = this._lerpAdditive),
                  (a = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n));
            }
            (this._mixBufferRegion = i),
              (this._mixBufferRegionAdditive = r),
              (this._setIdentity = a),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          accumulate(t, e) {
            const n = this.buffer,
              i = this.valueSize,
              r = t * i + i;
            let a = this.cumulativeWeight;
            if (0 === a) {
              for (let t = 0; t !== i; ++t) n[r + t] = n[t];
              a = e;
            } else {
              a += e;
              const t = e / a;
              this._mixBufferRegion(n, r, 0, t, i);
            }
            this.cumulativeWeight = a;
          }
          accumulateAdditive(t) {
            const e = this.buffer,
              n = this.valueSize,
              i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(e, i, 0, t, n),
              (this.cumulativeWeightAdditive += t);
          }
          apply(t) {
            const e = this.valueSize,
              n = this.buffer,
              i = t * e + e,
              r = this.cumulativeWeight,
              a = this.cumulativeWeightAdditive,
              o = this.binding;
            if (
              ((this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              r < 1)
            ) {
              const t = e * this._origIndex;
              this._mixBufferRegion(n, i, t, 1 - r, e);
            }
            a > 0 &&
              this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
              if (n[t] !== n[t + e]) {
                o.setValue(n, i);
                break;
              }
          }
          saveOriginalState() {
            const t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              i = n * this._origIndex;
            t.getValue(e, i);
            for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
            this._setIdentity(),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0);
          }
          restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t);
          }
          _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize,
              e = t + this.valueSize;
            for (let n = t; n < e; n++) this.buffer[n] = 0;
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[this._addIndex * this.valueSize + 3] = 1);
          }
          _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize,
              e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++)
              this.buffer[e + n] = this.buffer[t + n];
          }
          _select(t, e, n, i, r) {
            if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
          }
          _slerp(t, e, n, i) {
            Jn.slerpFlat(t, e, t, e, t, n, i);
          }
          _slerpAdditive(t, e, n, i, r) {
            const a = this._workIndex * r;
            Jn.multiplyQuaternionsFlat(t, a, t, e, t, n),
              Jn.slerpFlat(t, e, t, e, t, a, i);
          }
          _lerp(t, e, n, i, r) {
            const a = 1 - i;
            for (let o = 0; o !== r; ++o) {
              const r = e + o;
              t[r] = t[r] * a + t[n + o] * i;
            }
          }
          _lerpAdditive(t, e, n, i, r) {
            for (let a = 0; a !== r; ++a) {
              const r = e + a;
              t[r] = t[r] + t[n + a] * i;
            }
          }
        }
        const ld = new RegExp('[\\[\\]\\.:\\/]', 'g'),
          cd = '[^' + '\\[\\]\\.:\\/'.replace('\\.', '') + ']',
          ud = /((?:WC+[\/:])*)/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
          hd = /(WCOD+)?/.source.replace('WCOD', cd),
          dd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
            'WC',
            '[^\\[\\]\\.:\\/]',
          ),
          pd = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', '[^\\[\\]\\.:\\/]'),
          fd = new RegExp('^' + ud + hd + dd + pd + '$'),
          md = ['material', 'materials', 'bones'];
        function gd(t, e, n) {
          const i = n || yd.parseTrackName(e);
          (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
        }
        function yd(t, e, n) {
          (this.path = e),
            (this.parsedPath = n || yd.parseTrackName(e)),
            (this.node = yd.findNode(t, this.parsedPath.nodeName) || t),
            (this.rootNode = t);
        }
        Object.assign(gd.prototype, {
          getValue: function (t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
              i = this._bindings[n];
            void 0 !== i && i.getValue(t, e);
          },
          setValue: function (t, e) {
            const n = this._bindings;
            for (
              let i = this._targetGroup.nCachedObjects_, r = n.length;
              i !== r;
              ++i
            )
              n[i].setValue(t, e);
          },
          bind: function () {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].bind();
          },
          unbind: function () {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].unbind();
          },
        }),
          Object.assign(yd, {
            Composite: gd,
            create: function (t, e, n) {
              return t && t.isAnimationObjectGroup
                ? new yd.Composite(t, e, n)
                : new yd(t, e, n);
            },
            sanitizeNodeName: function (t) {
              return t.replace(/\s/g, '_').replace(ld, '');
            },
            parseTrackName: function (t) {
              const e = fd.exec(t);
              if (!e)
                throw new Error(
                  'PropertyBinding: Cannot parse trackName: ' + t,
                );
              const n = {
                  nodeName: e[2],
                  objectName: e[3],
                  objectIndex: e[4],
                  propertyName: e[5],
                  propertyIndex: e[6],
                },
                i = n.nodeName && n.nodeName.lastIndexOf('.');
              if (void 0 !== i && -1 !== i) {
                const t = n.nodeName.substring(i + 1);
                -1 !== md.indexOf(t) &&
                  ((n.nodeName = n.nodeName.substring(0, i)),
                  (n.objectName = t));
              }
              if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error(
                  'PropertyBinding: can not parse propertyName from trackName: ' +
                    t,
                );
              return n;
            },
            findNode: function (t, e) {
              if (
                !e ||
                '' === e ||
                '.' === e ||
                -1 === e ||
                e === t.name ||
                e === t.uuid
              )
                return t;
              if (t.skeleton) {
                const n = t.skeleton.getBoneByName(e);
                if (void 0 !== n) return n;
              }
              if (t.children) {
                const n = function (t) {
                    for (let i = 0; i < t.length; i++) {
                      const r = t[i];
                      if (r.name === e || r.uuid === e) return r;
                      const a = n(r.children);
                      if (a) return a;
                    }
                    return null;
                  },
                  i = n(t.children);
                if (i) return i;
              }
              return null;
            },
          }),
          Object.assign(yd.prototype, {
            _getValue_unavailable: function () {},
            _setValue_unavailable: function () {},
            BindingType: {
              Direct: 0,
              EntireArray: 1,
              ArrayElement: 2,
              HasFromToArray: 3,
            },
            Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
            GetterByBindingType: [
              function (t, e) {
                t[e] = this.node[this.propertyName];
              },
              function (t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
              },
              function (t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex];
              },
              function (t, e) {
                this.resolvedProperty.toArray(t, e);
              },
            ],
            SetterByBindingTypeAndVersioning: [
              [
                function (t, e) {
                  this.targetObject[this.propertyName] = t[e];
                },
                function (t, e) {
                  (this.targetObject[this.propertyName] = t[e]),
                    (this.targetObject.needsUpdate = !0);
                },
                function (t, e) {
                  (this.targetObject[this.propertyName] = t[e]),
                    (this.targetObject.matrixWorldNeedsUpdate = !0);
                },
              ],
              [
                function (t, e) {
                  const n = this.resolvedProperty;
                  for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                },
                function (t, e) {
                  const n = this.resolvedProperty;
                  for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                  this.targetObject.needsUpdate = !0;
                },
                function (t, e) {
                  const n = this.resolvedProperty;
                  for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                  this.targetObject.matrixWorldNeedsUpdate = !0;
                },
              ],
              [
                function (t, e) {
                  this.resolvedProperty[this.propertyIndex] = t[e];
                },
                function (t, e) {
                  (this.resolvedProperty[this.propertyIndex] = t[e]),
                    (this.targetObject.needsUpdate = !0);
                },
                function (t, e) {
                  (this.resolvedProperty[this.propertyIndex] = t[e]),
                    (this.targetObject.matrixWorldNeedsUpdate = !0);
                },
              ],
              [
                function (t, e) {
                  this.resolvedProperty.fromArray(t, e);
                },
                function (t, e) {
                  this.resolvedProperty.fromArray(t, e),
                    (this.targetObject.needsUpdate = !0);
                },
                function (t, e) {
                  this.resolvedProperty.fromArray(t, e),
                    (this.targetObject.matrixWorldNeedsUpdate = !0);
                },
              ],
            ],
            getValue: function (t, e) {
              this.bind(), this.getValue(t, e);
            },
            setValue: function (t, e) {
              this.bind(), this.setValue(t, e);
            },
            bind: function () {
              let t = this.node;
              const e = this.parsedPath,
                n = e.objectName,
                i = e.propertyName;
              let r = e.propertyIndex;
              if (
                (t ||
                  ((t =
                    yd.findNode(this.rootNode, e.nodeName) || this.rootNode),
                  (this.node = t)),
                (this.getValue = this._getValue_unavailable),
                (this.setValue = this._setValue_unavailable),
                !t)
              )
                return void console.error(
                  'THREE.PropertyBinding: Trying to update node for track: ' +
                    this.path +
                    " but it wasn't found.",
                );
              if (n) {
                let i = e.objectIndex;
                switch (n) {
                  case 'materials':
                    if (!t.material)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                        this,
                      );
                    if (!t.material.materials)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                        this,
                      );
                    t = t.material.materials;
                    break;
                  case 'bones':
                    if (!t.skeleton)
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                        this,
                      );
                    t = t.skeleton.bones;
                    for (let e = 0; e < t.length; e++)
                      if (t[e].name === i) {
                        i = e;
                        break;
                      }
                    break;
                  default:
                    if (void 0 === t[n])
                      return void console.error(
                        'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                        this,
                      );
                    t = t[n];
                }
                if (void 0 !== i) {
                  if (void 0 === t[i])
                    return void console.error(
                      'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                      this,
                      t,
                    );
                  t = t[i];
                }
              }
              const a = t[i];
              if (void 0 === a) {
                const n = e.nodeName;
                return void console.error(
                  'THREE.PropertyBinding: Trying to update property for track: ' +
                    n +
                    '.' +
                    i +
                    " but it wasn't found.",
                  t,
                );
              }
              let o = this.Versioning.None;
              (this.targetObject = t),
                void 0 !== t.needsUpdate
                  ? (o = this.Versioning.NeedsUpdate)
                  : void 0 !== t.matrixWorldNeedsUpdate &&
                    (o = this.Versioning.MatrixWorldNeedsUpdate);
              let s = this.BindingType.Direct;
              if (void 0 !== r) {
                if ('morphTargetInfluences' === i) {
                  if (!t.geometry)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                      this,
                    );
                  if (!t.geometry.isBufferGeometry)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
                      this,
                    );
                  if (!t.geometry.morphAttributes)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                      this,
                    );
                  void 0 !== t.morphTargetDictionary[r] &&
                    (r = t.morphTargetDictionary[r]);
                }
                (s = this.BindingType.ArrayElement),
                  (this.resolvedProperty = a),
                  (this.propertyIndex = r);
              } else
                void 0 !== a.fromArray && void 0 !== a.toArray
                  ? ((s = this.BindingType.HasFromToArray),
                    (this.resolvedProperty = a))
                  : Array.isArray(a)
                  ? ((s = this.BindingType.EntireArray),
                    (this.resolvedProperty = a))
                  : (this.propertyName = i);
              (this.getValue = this.GetterByBindingType[s]),
                (this.setValue = this.SetterByBindingTypeAndVersioning[s][o]);
            },
            unbind: function () {
              (this.node = null),
                (this.getValue = this._getValue_unbound),
                (this.setValue = this._setValue_unbound);
            },
          }),
          Object.assign(yd.prototype, {
            _getValue_unbound: yd.prototype.getValue,
            _setValue_unbound: yd.prototype.setValue,
          });
        class vd {
          constructor() {
            (this.uuid = Fn.generateUUID()),
              (this._objects = Array.prototype.slice.call(arguments)),
              (this.nCachedObjects_ = 0);
            const t = {};
            this._indicesByUUID = t;
            for (let e = 0, n = arguments.length; e !== n; ++e)
              t[arguments[e].uuid] = e;
            (this._paths = []),
              (this._parsedPaths = []),
              (this._bindings = []),
              (this._bindingsIndicesByPath = {});
            const e = this;
            this.stats = {
              objects: {
                get total() {
                  return e._objects.length;
                },
                get inUse() {
                  return this.total - e.nCachedObjects_;
                },
              },
              get bindingsPerObject() {
                return e._bindings.length;
              },
            };
          }
          add() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._paths,
              i = this._parsedPaths,
              r = this._bindings,
              a = r.length;
            let o = void 0,
              s = t.length,
              l = this.nCachedObjects_;
            for (let c = 0, u = arguments.length; c !== u; ++c) {
              const u = arguments[c],
                h = u.uuid;
              let d = e[h];
              if (void 0 === d) {
                (d = s++), (e[h] = d), t.push(u);
                for (let t = 0, e = a; t !== e; ++t)
                  r[t].push(new yd(u, n[t], i[t]));
              } else if (d < l) {
                o = t[d];
                const s = --l,
                  c = t[s];
                (e[c.uuid] = d), (t[d] = c), (e[h] = s), (t[s] = u);
                for (let t = 0, e = a; t !== e; ++t) {
                  const e = r[t],
                    a = e[s];
                  let o = e[d];
                  (e[d] = a),
                    void 0 === o && (o = new yd(u, n[t], i[t])),
                    (e[s] = o);
                }
              } else
                t[d] !== o &&
                  console.error(
                    'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.',
                  );
            }
            this.nCachedObjects_ = l;
          }
          remove() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length;
            let r = this.nCachedObjects_;
            for (let a = 0, o = arguments.length; a !== o; ++a) {
              const o = arguments[a],
                s = o.uuid,
                l = e[s];
              if (void 0 !== l && l >= r) {
                const a = r++,
                  c = t[a];
                (e[c.uuid] = l), (t[l] = c), (e[s] = a), (t[a] = o);
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t],
                    i = e[a],
                    r = e[l];
                  (e[l] = i), (e[a] = r);
                }
              }
            }
            this.nCachedObjects_ = r;
          }
          uncache() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length;
            let r = this.nCachedObjects_,
              a = t.length;
            for (let o = 0, s = arguments.length; o !== s; ++o) {
              const s = arguments[o].uuid,
                l = e[s];
              if (void 0 !== l)
                if ((delete e[s], l < r)) {
                  const o = --r,
                    s = t[o],
                    c = --a,
                    u = t[c];
                  (e[s.uuid] = l),
                    (t[l] = s),
                    (e[u.uuid] = o),
                    (t[o] = u),
                    t.pop();
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t],
                      i = e[o],
                      r = e[c];
                    (e[l] = i), (e[o] = r), e.pop();
                  }
                } else {
                  const r = --a,
                    o = t[r];
                  r > 0 && (e[o.uuid] = l), (t[l] = o), t.pop();
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t];
                    (e[l] = e[r]), e.pop();
                  }
                }
            }
            this.nCachedObjects_ = r;
          }
          subscribe_(t, e) {
            const n = this._bindingsIndicesByPath;
            let i = n[t];
            const r = this._bindings;
            if (void 0 !== i) return r[i];
            const a = this._paths,
              o = this._parsedPaths,
              s = this._objects,
              l = s.length,
              c = this.nCachedObjects_,
              u = new Array(l);
            (i = r.length), (n[t] = i), a.push(t), o.push(e), r.push(u);
            for (let n = c, i = s.length; n !== i; ++n) {
              const i = s[n];
              u[n] = new yd(i, t, e);
            }
            return u;
          }
          unsubscribe_(t) {
            const e = this._bindingsIndicesByPath,
              n = e[t];
            if (void 0 !== n) {
              const i = this._paths,
                r = this._parsedPaths,
                a = this._bindings,
                o = a.length - 1,
                s = a[o];
              (e[t[o]] = n),
                (a[n] = s),
                a.pop(),
                (r[n] = r[o]),
                r.pop(),
                (i[n] = i[o]),
                i.pop();
            }
          }
        }
        vd.prototype.isAnimationObjectGroup = !0;
        class xd {
          constructor(t, e, n = null, i = e.blendMode) {
            (this._mixer = t),
              (this._clip = e),
              (this._localRoot = n),
              (this.blendMode = i);
            const r = e.tracks,
              a = r.length,
              o = new Array(a),
              s = { endingStart: je, endingEnd: je };
            for (let t = 0; t !== a; ++t) {
              const e = r[t].createInterpolant(null);
              (o[t] = e), (e.settings = s);
            }
            (this._interpolantSettings = s),
              (this._interpolants = o),
              (this._propertyBindings = new Array(a)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = Ne),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          play() {
            return this._mixer._activateAction(this), this;
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset();
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          }
          isScheduled() {
            return this._mixer._isActiveAction(this);
          }
          startAt(t) {
            return (this._startTime = t), this;
          }
          setLoop(t, e) {
            return (this.loop = t), (this.repetitions = e), this;
          }
          setEffectiveWeight(t) {
            return (
              (this.weight = t),
              (this._effectiveWeight = this.enabled ? t : 0),
              this.stopFading()
            );
          }
          getEffectiveWeight() {
            return this._effectiveWeight;
          }
          fadeIn(t) {
            return this._scheduleFading(t, 0, 1);
          }
          fadeOut(t) {
            return this._scheduleFading(t, 1, 0);
          }
          crossFadeFrom(t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              const n = this._clip.duration,
                i = t._clip.duration,
                r = i / n,
                a = n / i;
              t.warp(1, r, e), this.warp(a, 1, e);
            }
            return this;
          }
          crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n);
          }
          stopFading() {
            const t = this._weightInterpolant;
            return (
              null !== t &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          setEffectiveTimeScale(t) {
            return (
              (this.timeScale = t),
              (this._effectiveTimeScale = this.paused ? 0 : t),
              this.stopWarping()
            );
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale;
          }
          setDuration(t) {
            return (
              (this.timeScale = this._clip.duration / t), this.stopWarping()
            );
          }
          syncWith(t) {
            return (
              (this.time = t.time),
              (this.timeScale = t.timeScale),
              this.stopWarping()
            );
          }
          halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t);
          }
          warp(t, e, n) {
            const i = this._mixer,
              r = i.time,
              a = this.timeScale;
            let o = this._timeScaleInterpolant;
            null === o &&
              ((o = i._lendControlInterpolant()),
              (this._timeScaleInterpolant = o));
            const s = o.parameterPositions,
              l = o.sampleValues;
            return (
              (s[0] = r), (s[1] = r + n), (l[0] = t / a), (l[1] = e / a), this
            );
          }
          stopWarping() {
            const t = this._timeScaleInterpolant;
            return (
              null !== t &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          getMixer() {
            return this._mixer;
          }
          getClip() {
            return this._clip;
          }
          getRoot() {
            return this._localRoot || this._mixer._root;
          }
          _update(t, e, n, i) {
            if (!this.enabled) return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
              const i = (t - r) * n;
              if (i < 0 || 0 === n) return;
              (this._startTime = null), (e = n * i);
            }
            e *= this._updateTimeScale(t);
            const a = this._updateTime(e),
              o = this._updateWeight(t);
            if (o > 0) {
              const t = this._interpolants,
                e = this._propertyBindings;
              switch (this.blendMode) {
                case We:
                  for (let n = 0, i = t.length; n !== i; ++n)
                    t[n].evaluate(a), e[n].accumulateAdditive(o);
                  break;
                case Ve:
                default:
                  for (let n = 0, r = t.length; n !== r; ++n)
                    t[n].evaluate(a), e[n].accumulate(i, o);
              }
            }
          }
          _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
              e = this.weight;
              const n = this._weightInterpolant;
              if (null !== n) {
                const i = n.evaluate(t)[0];
                (e *= i),
                  t > n.parameterPositions[1] &&
                    (this.stopFading(), 0 === i && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = e), e;
          }
          _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
              e = this.timeScale;
              const n = this._timeScaleInterpolant;
              if (null !== n) {
                (e *= n.evaluate(t)[0]),
                  t > n.parameterPositions[1] &&
                    (this.stopWarping(),
                    0 === e ? (this.paused = !0) : (this.timeScale = e));
              }
            }
            return (this._effectiveTimeScale = e), e;
          }
          _updateTime(t) {
            const e = this._clip.duration,
              n = this.loop;
            let i = this.time + t,
              r = this._loopCount;
            const a = n === ze;
            if (0 === t) return -1 === r ? i : a && 1 == (1 & r) ? e - i : i;
            if (n === Oe) {
              -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              t: {
                if (i >= e) i = e;
                else {
                  if (!(i < 0)) {
                    this.time = i;
                    break t;
                  }
                  i = 0;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: t < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === r &&
                  (t >= 0
                    ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                    : this._setEndings(0 === this.repetitions, !0, a)),
                i >= e || i < 0)
              ) {
                const n = Math.floor(i / e);
                (i -= e * n), (r += Math.abs(n));
                const o = this.repetitions - r;
                if (o <= 0)
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (i = t > 0 ? e : 0),
                    (this.time = i),
                    this._mixer.dispatchEvent({
                      type: 'finished',
                      action: this,
                      direction: t > 0 ? 1 : -1,
                    });
                else {
                  if (1 === o) {
                    const e = t < 0;
                    this._setEndings(e, !e, a);
                  } else this._setEndings(!1, !1, a);
                  (this._loopCount = r),
                    (this.time = i),
                    this._mixer.dispatchEvent({
                      type: 'loop',
                      action: this,
                      loopDelta: n,
                    });
                }
              } else this.time = i;
              if (a && 1 == (1 & r)) return e - i;
            }
            return i;
          }
          _setEndings(t, e, n) {
            const i = this._interpolantSettings;
            n
              ? ((i.endingStart = Ge), (i.endingEnd = Ge))
              : ((i.endingStart = t ? (this.zeroSlopeAtStart ? Ge : je) : He),
                (i.endingEnd = e ? (this.zeroSlopeAtEnd ? Ge : je) : He));
          }
          _scheduleFading(t, e, n) {
            const i = this._mixer,
              r = i.time;
            let a = this._weightInterpolant;
            null === a &&
              ((a = i._lendControlInterpolant()),
              (this._weightInterpolant = a));
            const o = a.parameterPositions,
              s = a.sampleValues;
            return (o[0] = r), (s[0] = e), (o[1] = r + t), (s[1] = n), this;
          }
        }
        class bd extends On {
          constructor(t) {
            super(),
              (this._root = t),
              this._initMemoryManager(),
              (this._accuIndex = 0),
              (this.time = 0),
              (this.timeScale = 1);
          }
          _bindAction(t, e) {
            const n = t._localRoot || this._root,
              i = t._clip.tracks,
              r = i.length,
              a = t._propertyBindings,
              o = t._interpolants,
              s = n.uuid,
              l = this._bindingsByRootAndName;
            let c = l[s];
            void 0 === c && ((c = {}), (l[s] = c));
            for (let t = 0; t !== r; ++t) {
              const r = i[t],
                l = r.name;
              let u = c[l];
              if (void 0 !== u) a[t] = u;
              else {
                if (((u = a[t]), void 0 !== u)) {
                  null === u._cacheIndex &&
                    (++u.referenceCount, this._addInactiveBinding(u, s, l));
                  continue;
                }
                const i = e && e._propertyBindings[t].binding.parsedPath;
                (u = new sd(
                  yd.create(n, l, i),
                  r.ValueTypeName,
                  r.getValueSize(),
                )),
                  ++u.referenceCount,
                  this._addInactiveBinding(u, s, l),
                  (a[t] = u);
              }
              o[t].resultBuffer = u.buffer;
            }
          }
          _activateAction(t) {
            if (!this._isActiveAction(t)) {
              if (null === t._cacheIndex) {
                const e = (t._localRoot || this._root).uuid,
                  n = t._clip.uuid,
                  i = this._actionsByClip[n];
                this._bindAction(t, i && i.knownActions[0]),
                  this._addInactiveAction(t, n, e);
              }
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == n.useCount++ &&
                  (this._lendBinding(n), n.saveOriginalState());
              }
              this._lendAction(t);
            }
          }
          _deactivateAction(t) {
            if (this._isActiveAction(t)) {
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.useCount &&
                  (n.restoreOriginalState(), this._takeBackBinding(n));
              }
              this._takeBackAction(t);
            }
          }
          _initMemoryManager() {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            const t = this;
            this.stats = {
              actions: {
                get total() {
                  return t._actions.length;
                },
                get inUse() {
                  return t._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return t._bindings.length;
                },
                get inUse() {
                  return t._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return t._controlInterpolants.length;
                },
                get inUse() {
                  return t._nActiveControlInterpolants;
                },
              },
            };
          }
          _isActiveAction(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions;
          }
          _addInactiveAction(t, e, n) {
            const i = this._actions,
              r = this._actionsByClip;
            let a = r[e];
            if (void 0 === a)
              (a = { knownActions: [t], actionByRoot: {} }),
                (t._byClipCacheIndex = 0),
                (r[e] = a);
            else {
              const e = a.knownActions;
              (t._byClipCacheIndex = e.length), e.push(t);
            }
            (t._cacheIndex = i.length), i.push(t), (a.actionByRoot[n] = t);
          }
          _removeInactiveAction(t) {
            const e = this._actions,
              n = e[e.length - 1],
              i = t._cacheIndex;
            (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
            const r = t._clip.uuid,
              a = this._actionsByClip,
              o = a[r],
              s = o.knownActions,
              l = s[s.length - 1],
              c = t._byClipCacheIndex;
            (l._byClipCacheIndex = c),
              (s[c] = l),
              s.pop(),
              (t._byClipCacheIndex = null);
            delete o.actionByRoot[(t._localRoot || this._root).uuid],
              0 === s.length && delete a[r],
              this._removeInactiveBindingsForAction(t);
          }
          _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == --n.referenceCount && this._removeInactiveBinding(n);
            }
          }
          _lendAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = this._nActiveActions++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _takeBackAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = --this._nActiveActions,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _addInactiveBinding(t, e, n) {
            const i = this._bindingsByRootAndName,
              r = this._bindings;
            let a = i[e];
            void 0 === a && ((a = {}), (i[e] = a)),
              (a[n] = t),
              (t._cacheIndex = r.length),
              r.push(t);
          }
          _removeInactiveBinding(t) {
            const e = this._bindings,
              n = t.binding,
              i = n.rootNode.uuid,
              r = n.path,
              a = this._bindingsByRootAndName,
              o = a[i],
              s = e[e.length - 1],
              l = t._cacheIndex;
            (s._cacheIndex = l),
              (e[l] = s),
              e.pop(),
              delete o[r],
              0 === Object.keys(o).length && delete a[i];
          }
          _lendBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = this._nActiveBindings++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _takeBackBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = --this._nActiveBindings,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _lendControlInterpolant() {
            const t = this._controlInterpolants,
              e = this._nActiveControlInterpolants++;
            let n = t[e];
            return (
              void 0 === n &&
                ((n = new du(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  this._controlInterpolantsResultBuffer,
                )),
                (n.__cacheIndex = e),
                (t[e] = n)),
              n
            );
          }
          _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants,
              n = t.__cacheIndex,
              i = --this._nActiveControlInterpolants,
              r = e[i];
            (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
          }
          clipAction(t, e, n) {
            const i = e || this._root,
              r = i.uuid;
            let a = 'string' == typeof t ? wu.findByName(i, t) : t;
            const o = null !== a ? a.uuid : t,
              s = this._actionsByClip[o];
            let l = null;
            if (
              (void 0 === n && (n = null !== a ? a.blendMode : Ve),
              void 0 !== s)
            ) {
              const t = s.actionByRoot[r];
              if (void 0 !== t && t.blendMode === n) return t;
              (l = s.knownActions[0]), null === a && (a = l._clip);
            }
            if (null === a) return null;
            const c = new xd(this, a, e, n);
            return this._bindAction(c, l), this._addInactiveAction(c, o, r), c;
          }
          existingAction(t, e) {
            const n = e || this._root,
              i = n.uuid,
              r = 'string' == typeof t ? wu.findByName(n, t) : t,
              a = r ? r.uuid : t,
              o = this._actionsByClip[a];
            return (void 0 !== o && o.actionByRoot[i]) || null;
          }
          stopAllAction() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
            return this;
          }
          update(t) {
            t *= this.timeScale;
            const e = this._actions,
              n = this._nActiveActions,
              i = (this.time += t),
              r = Math.sign(t),
              a = (this._accuIndex ^= 1);
            for (let o = 0; o !== n; ++o) {
              e[o]._update(i, t, r, a);
            }
            const o = this._bindings,
              s = this._nActiveBindings;
            for (let t = 0; t !== s; ++t) o[t].apply(a);
            return this;
          }
          setTime(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++)
              this._actions[t].time = 0;
            return this.update(t);
          }
          getRoot() {
            return this._root;
          }
          uncacheClip(t) {
            const e = this._actions,
              n = t.uuid,
              i = this._actionsByClip,
              r = i[n];
            if (void 0 !== r) {
              const t = r.knownActions;
              for (let n = 0, i = t.length; n !== i; ++n) {
                const i = t[n];
                this._deactivateAction(i);
                const r = i._cacheIndex,
                  a = e[e.length - 1];
                (i._cacheIndex = null),
                  (i._byClipCacheIndex = null),
                  (a._cacheIndex = r),
                  (e[r] = a),
                  e.pop(),
                  this._removeInactiveBindingsForAction(i);
              }
              delete i[n];
            }
          }
          uncacheRoot(t) {
            const e = t.uuid,
              n = this._actionsByClip;
            for (const t in n) {
              const i = n[t].actionByRoot[e];
              void 0 !== i &&
                (this._deactivateAction(i), this._removeInactiveAction(i));
            }
            const i = this._bindingsByRootAndName[e];
            if (void 0 !== i)
              for (const t in i) {
                const e = i[t];
                e.restoreOriginalState(), this._removeInactiveBinding(e);
              }
          }
          uncacheAction(t, e) {
            const n = this.existingAction(t, e);
            null !== n &&
              (this._deactivateAction(n), this._removeInactiveAction(n));
          }
        }
        bd.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class _d {
          constructor(t) {
            'string' == typeof t &&
              (console.warn(
                'THREE.Uniform: Type parameter is no longer needed.',
              ),
              (t = arguments[1])),
              (this.value = t);
          }
          clone() {
            return new _d(
              void 0 === this.value.clone ? this.value : this.value.clone(),
            );
          }
        }
        function wd(t, e, n) {
          Xs.call(this, t, e), (this.meshPerAttribute = n || 1);
        }
        function Md(t, e, n, i, r) {
          (this.buffer = t),
            (this.type = e),
            (this.itemSize = n),
            (this.elementSize = i),
            (this.count = r),
            (this.version = 0);
        }
        function qd(t, e, n = 0, i = 1 / 0) {
          (this.ray = new Ei(t, e)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new Fi()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            }),
            Object.defineProperties(this.params, {
              PointCloud: {
                get: function () {
                  return (
                    console.warn(
                      'THREE.Raycaster: params.PointCloud has been renamed to params.Points.',
                    ),
                    this.Points
                  );
                },
              },
            });
        }
        function Sd(t, e) {
          return t.distance - e.distance;
        }
        function Td(t, e, n, i) {
          if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++) Td(i[t], e, n, !0);
          }
        }
        (wd.prototype = Object.assign(Object.create(Xs.prototype), {
          constructor: wd,
          isInstancedInterleavedBuffer: !0,
          copy: function (t) {
            return (
              Xs.prototype.copy.call(this, t),
              (this.meshPerAttribute = t.meshPerAttribute),
              this
            );
          },
          clone: function (t) {
            const e = Xs.prototype.clone.call(this, t);
            return (e.meshPerAttribute = this.meshPerAttribute), e;
          },
          toJSON: function (t) {
            const e = Xs.prototype.toJSON.call(this, t);
            return (
              (e.isInstancedInterleavedBuffer = !0),
              (e.meshPerAttribute = this.meshPerAttribute),
              e
            );
          },
        })),
          Object.defineProperty(Md.prototype, 'needsUpdate', {
            set: function (t) {
              !0 === t && this.version++;
            },
          }),
          Object.assign(Md.prototype, {
            isGLBufferAttribute: !0,
            setBuffer: function (t) {
              return (this.buffer = t), this;
            },
            setType: function (t, e) {
              return (this.type = t), (this.elementSize = e), this;
            },
            setItemSize: function (t) {
              return (this.itemSize = t), this;
            },
            setCount: function (t) {
              return (this.count = t), this;
            },
          }),
          Object.assign(qd.prototype, {
            set: function (t, e) {
              this.ray.set(t, e);
            },
            setFromCamera: function (t, e) {
              e && e.isPerspectiveCamera
                ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                  this.ray.direction
                    .set(t.x, t.y, 0.5)
                    .unproject(e)
                    .sub(this.ray.origin)
                    .normalize(),
                  (this.camera = e))
                : e && e.isOrthographicCamera
                ? (this.ray.origin
                    .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                    .unproject(e),
                  this.ray.direction
                    .set(0, 0, -1)
                    .transformDirection(e.matrixWorld),
                  (this.camera = e))
                : console.error(
                    'THREE.Raycaster: Unsupported camera type: ' + e.type,
                  );
            },
            intersectObject: function (t, e = !1, n = []) {
              return Td(t, this, n, e), n.sort(Sd), n;
            },
            intersectObjects: function (t, e = !1, n = []) {
              for (let i = 0, r = t.length; i < r; i++) Td(t[i], this, n, e);
              return n.sort(Sd), n;
            },
          });
        class Ed {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          set(t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          }
          makeSafe() {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)),
                  (this.phi = Math.acos(Fn.clamp(e / this.radius, -1, 1)))),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class Ad {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          }
          set(t, e, n) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.theta = t.theta),
              (this.y = t.y),
              this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + n * n)),
              (this.theta = Math.atan2(t, n)),
              (this.y = e),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const Ld = new Bn();
        class Rd {
          constructor(t = new Bn(1 / 0, 1 / 0), e = new Bn(-1 / 0, -1 / 0)) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = Ld.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = 1 / 0),
              (this.max.x = this.max.y = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          }
          getCenter(t) {
            return (
              void 0 === t &&
                (console.warn(
                  'THREE.Box2: .getCenter() target is now required',
                ),
                (t = new Bn())),
              this.isEmpty()
                ? t.set(0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          }
          getSize(t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Box2: .getSize() target is now required'),
                (t = new Bn())),
              this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            );
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y
            );
          }
          getParameter(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  'THREE.Box2: .getParameter() target is now required',
                ),
                (e = new Bn())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y),
              )
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y
            );
          }
          clampPoint(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  'THREE.Box2: .clampPoint() target is now required',
                ),
                (e = new Bn())),
              e.copy(t).clamp(this.min, this.max)
            );
          }
          distanceToPoint(t) {
            return Ld.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this;
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        Rd.prototype.isBox2 = !0;
        const Cd = new Zn(),
          Pd = new Zn();
        class kd {
          constructor(t = new Zn(), e = new Zn()) {
            (this.start = t), (this.end = e);
          }
          set(t, e) {
            return this.start.copy(t), this.end.copy(e), this;
          }
          copy(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this;
          }
          getCenter(t) {
            return (
              void 0 === t &&
                (console.warn(
                  'THREE.Line3: .getCenter() target is now required',
                ),
                (t = new Zn())),
              t.addVectors(this.start, this.end).multiplyScalar(0.5)
            );
          }
          delta(t) {
            return (
              void 0 === t &&
                (console.warn('THREE.Line3: .delta() target is now required'),
                (t = new Zn())),
              t.subVectors(this.end, this.start)
            );
          }
          distanceSq() {
            return this.start.distanceToSquared(this.end);
          }
          distance() {
            return this.start.distanceTo(this.end);
          }
          at(t, e) {
            return (
              void 0 === e &&
                (console.warn('THREE.Line3: .at() target is now required'),
                (e = new Zn())),
              this.delta(e).multiplyScalar(t).add(this.start)
            );
          }
          closestPointToPointParameter(t, e) {
            Cd.subVectors(t, this.start), Pd.subVectors(this.end, this.start);
            const n = Pd.dot(Pd);
            let i = Pd.dot(Cd) / n;
            return e && (i = Fn.clamp(i, 0, 1)), i;
          }
          closestPointToPoint(t, e, n) {
            const i = this.closestPointToPointParameter(t, e);
            return (
              void 0 === n &&
                (console.warn(
                  'THREE.Line3: .closestPointToPoint() target is now required',
                ),
                (n = new Zn())),
              this.delta(n).multiplyScalar(i).add(this.start)
            );
          }
          applyMatrix4(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
          }
          equals(t) {
            return t.start.equals(this.start) && t.end.equals(this.end);
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function Id(t) {
          Qi.call(this),
            (this.material = t),
            (this.render = function () {}),
            (this.hasPositions = !1),
            (this.hasNormals = !1),
            (this.hasColors = !1),
            (this.hasUvs = !1),
            (this.positionArray = null),
            (this.normalArray = null),
            (this.colorArray = null),
            (this.uvArray = null),
            (this.count = 0);
        }
        (Id.prototype = Object.create(Qi.prototype)),
          (Id.prototype.constructor = Id),
          (Id.prototype.isImmediateRenderObject = !0);
        const Dd = new Zn();
        class Od extends Qi {
          constructor(t, e) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = e);
            const n = new Yr(),
              i = [
                0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0,
                0, 1, 1, 0, 0, 0, 0, -1, 1,
              ];
            for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
              const r = (t / n) * Math.PI * 2,
                a = (e / n) * Math.PI * 2;
              i.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1);
            }
            n.setAttribute('position', new Or(i, 3));
            const r = new Rl({ fog: !1, toneMapped: !1 });
            (this.cone = new Fl(n, r)), this.add(this.cone), this.update();
          }
          dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose();
          }
          update() {
            this.light.updateMatrixWorld();
            const t = this.light.distance ? this.light.distance : 1e3,
              e = t * Math.tan(this.light.angle);
            this.cone.scale.set(e, e, t),
              Dd.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(Dd),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
          }
        }
        const Nd = new Zn(),
          zd = new Ai(),
          Fd = new Ai();
        class Bd extends Fl {
          constructor(t) {
            const e = (function t(e) {
                const n = [];
                e && e.isBone && n.push(e);
                for (let i = 0; i < e.children.length; i++)
                  n.push.apply(n, t(e.children[i]));
                return n;
              })(t),
              n = new Yr(),
              i = [],
              r = [],
              a = new Mr(0, 0, 1),
              o = new Mr(0, 1, 0);
            for (let t = 0; t < e.length; t++) {
              const n = e[t];
              n.parent &&
                n.parent.isBone &&
                (i.push(0, 0, 0),
                i.push(0, 0, 0),
                r.push(a.r, a.g, a.b),
                r.push(o.r, o.g, o.b));
            }
            n.setAttribute('position', new Or(i, 3)),
              n.setAttribute('color', new Or(r, 3));
            super(
              n,
              new Rl({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0,
              }),
            ),
              (this.type = 'SkeletonHelper'),
              (this.isSkeletonHelper = !0),
              (this.root = t),
              (this.bones = e),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1);
          }
          updateMatrixWorld(t) {
            const e = this.bones,
              n = this.geometry,
              i = n.getAttribute('position');
            Fd.copy(this.root.matrixWorld).invert();
            for (let t = 0, n = 0; t < e.length; t++) {
              const r = e[t];
              r.parent &&
                r.parent.isBone &&
                (zd.multiplyMatrices(Fd, r.matrixWorld),
                Nd.setFromMatrixPosition(zd),
                i.setXYZ(n, Nd.x, Nd.y, Nd.z),
                zd.multiplyMatrices(Fd, r.parent.matrixWorld),
                Nd.setFromMatrixPosition(zd),
                i.setXYZ(n + 1, Nd.x, Nd.y, Nd.z),
                (n += 2));
            }
            (n.getAttribute('position').needsUpdate = !0),
              super.updateMatrixWorld(t);
          }
        }
        class Ud extends da {
          constructor(t, e, n) {
            super(
              new Hc(e, 4, 2),
              new qr({ wireframe: !0, fog: !1, toneMapped: !1 }),
            ),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.color = n),
              (this.type = 'PointLightHelper'),
              (this.matrix = this.light.matrixWorld),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
          update() {
            void 0 !== this.color
              ? this.material.color.set(this.color)
              : this.material.color.copy(this.light.color);
          }
        }
        const jd = new Zn(),
          Gd = new Mr(),
          Hd = new Mr();
        class Vd extends Qi {
          constructor(t, e, n) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = n);
            const i = new Bc(e);
            i.rotateY(0.5 * Math.PI),
              (this.material = new qr({
                wireframe: !0,
                fog: !1,
                toneMapped: !1,
              })),
              void 0 === this.color && (this.material.vertexColors = !0);
            const r = i.getAttribute('position'),
              a = new Float32Array(3 * r.count);
            i.setAttribute('color', new Er(a, 3)),
              this.add(new da(i, this.material)),
              this.update();
          }
          dispose() {
            this.children[0].geometry.dispose(),
              this.children[0].material.dispose();
          }
          update() {
            const t = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
              const e = t.geometry.getAttribute('color');
              Gd.copy(this.light.color), Hd.copy(this.light.groundColor);
              for (let t = 0, n = e.count; t < n; t++) {
                const i = t < n / 2 ? Gd : Hd;
                e.setXYZ(t, i.r, i.g, i.b);
              }
              e.needsUpdate = !0;
            }
            t.lookAt(jd.setFromMatrixPosition(this.light.matrixWorld).negate());
          }
        }
        class Wd extends Fl {
          constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
            (n = new Mr(n)), (i = new Mr(i));
            const r = e / 2,
              a = t / e,
              o = t / 2,
              s = [],
              l = [];
            for (let t = 0, c = 0, u = -o; t <= e; t++, u += a) {
              s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
              const e = t === r ? n : i;
              e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3);
            }
            const c = new Yr();
            c.setAttribute('position', new Or(s, 3)),
              c.setAttribute('color', new Or(l, 3));
            super(c, new Rl({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'GridHelper');
          }
        }
        class Xd extends Fl {
          constructor(t = 10, e = 16, n = 8, i = 64, r = 4473924, a = 8947848) {
            (r = new Mr(r)), (a = new Mr(a));
            const o = [],
              s = [];
            for (let n = 0; n <= e; n++) {
              const i = (n / e) * (2 * Math.PI),
                l = Math.sin(i) * t,
                c = Math.cos(i) * t;
              o.push(0, 0, 0), o.push(l, 0, c);
              const u = 1 & n ? r : a;
              s.push(u.r, u.g, u.b), s.push(u.r, u.g, u.b);
            }
            for (let e = 0; e <= n; e++) {
              const l = 1 & e ? r : a,
                c = t - (t / n) * e;
              for (let t = 0; t < i; t++) {
                let e = (t / i) * (2 * Math.PI),
                  n = Math.sin(e) * c,
                  r = Math.cos(e) * c;
                o.push(n, 0, r),
                  s.push(l.r, l.g, l.b),
                  (e = ((t + 1) / i) * (2 * Math.PI)),
                  (n = Math.sin(e) * c),
                  (r = Math.cos(e) * c),
                  o.push(n, 0, r),
                  s.push(l.r, l.g, l.b);
              }
            }
            const l = new Yr();
            l.setAttribute('position', new Or(o, 3)),
              l.setAttribute('color', new Or(s, 3));
            super(l, new Rl({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'PolarGridHelper');
          }
        }
        const Yd = new Zn(),
          $d = new Zn(),
          Jd = new Zn();
        class Zd extends Qi {
          constructor(t, e, n) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = n),
              void 0 === e && (e = 1);
            let i = new Yr();
            i.setAttribute(
              'position',
              new Or([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3),
            );
            const r = new Rl({ fog: !1, toneMapped: !1 });
            (this.lightPlane = new Ol(i, r)),
              this.add(this.lightPlane),
              (i = new Yr()),
              i.setAttribute('position', new Or([0, 0, 0, 0, 0, 1], 3)),
              (this.targetLine = new Ol(i, r)),
              this.add(this.targetLine),
              this.update();
          }
          dispose() {
            this.lightPlane.geometry.dispose(),
              this.lightPlane.material.dispose(),
              this.targetLine.geometry.dispose(),
              this.targetLine.material.dispose();
          }
          update() {
            Yd.setFromMatrixPosition(this.light.matrixWorld),
              $d.setFromMatrixPosition(this.light.target.matrixWorld),
              Jd.subVectors($d, Yd),
              this.lightPlane.lookAt($d),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt($d),
              (this.targetLine.scale.z = Jd.length());
          }
        }
        const Kd = new Zn(),
          Qd = new xa();
        class tp extends Fl {
          constructor(t) {
            const e = new Yr(),
              n = new Rl({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              i = [],
              r = [],
              a = {},
              o = new Mr(16755200),
              s = new Mr(16711680),
              l = new Mr(43775),
              c = new Mr(16777215),
              u = new Mr(3355443);
            function h(t, e, n) {
              d(t, n), d(e, n);
            }
            function d(t, e) {
              i.push(0, 0, 0),
                r.push(e.r, e.g, e.b),
                void 0 === a[t] && (a[t] = []),
                a[t].push(i.length / 3 - 1);
            }
            h('n1', 'n2', o),
              h('n2', 'n4', o),
              h('n4', 'n3', o),
              h('n3', 'n1', o),
              h('f1', 'f2', o),
              h('f2', 'f4', o),
              h('f4', 'f3', o),
              h('f3', 'f1', o),
              h('n1', 'f1', o),
              h('n2', 'f2', o),
              h('n3', 'f3', o),
              h('n4', 'f4', o),
              h('p', 'n1', s),
              h('p', 'n2', s),
              h('p', 'n3', s),
              h('p', 'n4', s),
              h('u1', 'u2', l),
              h('u2', 'u3', l),
              h('u3', 'u1', l),
              h('c', 't', c),
              h('p', 'c', u),
              h('cn1', 'cn2', u),
              h('cn3', 'cn4', u),
              h('cf1', 'cf2', u),
              h('cf3', 'cf4', u),
              e.setAttribute('position', new Or(i, 3)),
              e.setAttribute('color', new Or(r, 3)),
              super(e, n),
              (this.type = 'CameraHelper'),
              (this.camera = t),
              this.camera.updateProjectionMatrix &&
                this.camera.updateProjectionMatrix(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = a),
              this.update();
          }
          update() {
            const t = this.geometry,
              e = this.pointMap;
            Qd.projectionMatrixInverse.copy(
              this.camera.projectionMatrixInverse,
            ),
              ep('c', e, t, Qd, 0, 0, -1),
              ep('t', e, t, Qd, 0, 0, 1),
              ep('n1', e, t, Qd, -1, -1, -1),
              ep('n2', e, t, Qd, 1, -1, -1),
              ep('n3', e, t, Qd, -1, 1, -1),
              ep('n4', e, t, Qd, 1, 1, -1),
              ep('f1', e, t, Qd, -1, -1, 1),
              ep('f2', e, t, Qd, 1, -1, 1),
              ep('f3', e, t, Qd, -1, 1, 1),
              ep('f4', e, t, Qd, 1, 1, 1),
              ep('u1', e, t, Qd, 0.7, 1.1, -1),
              ep('u2', e, t, Qd, -0.7, 1.1, -1),
              ep('u3', e, t, Qd, 0, 2, -1),
              ep('cf1', e, t, Qd, -1, 0, 1),
              ep('cf2', e, t, Qd, 1, 0, 1),
              ep('cf3', e, t, Qd, 0, -1, 1),
              ep('cf4', e, t, Qd, 0, 1, 1),
              ep('cn1', e, t, Qd, -1, 0, -1),
              ep('cn2', e, t, Qd, 1, 0, -1),
              ep('cn3', e, t, Qd, 0, -1, -1),
              ep('cn4', e, t, Qd, 0, 1, -1),
              (t.getAttribute('position').needsUpdate = !0);
          }
        }
        function ep(t, e, n, i, r, a, o) {
          Kd.set(r, a, o).unproject(i);
          const s = e[t];
          if (void 0 !== s) {
            const t = n.getAttribute('position');
            for (let e = 0, n = s.length; e < n; e++)
              t.setXYZ(s[e], Kd.x, Kd.y, Kd.z);
          }
        }
        const np = new ti();
        class ip extends Fl {
          constructor(t, e = 16776960) {
            const n = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              i = new Float32Array(24),
              r = new Yr();
            r.setIndex(new Er(n, 1)),
              r.setAttribute('position', new Er(i, 3)),
              super(r, new Rl({ color: e, toneMapped: !1 })),
              (this.object = t),
              (this.type = 'BoxHelper'),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          update(t) {
            if (
              (void 0 !== t &&
                console.warn(
                  'THREE.BoxHelper: .update() has no longer arguments.',
                ),
              void 0 !== this.object && np.setFromObject(this.object),
              np.isEmpty())
            )
              return;
            const e = np.min,
              n = np.max,
              i = this.geometry.attributes.position,
              r = i.array;
            (r[0] = n.x),
              (r[1] = n.y),
              (r[2] = n.z),
              (r[3] = e.x),
              (r[4] = n.y),
              (r[5] = n.z),
              (r[6] = e.x),
              (r[7] = e.y),
              (r[8] = n.z),
              (r[9] = n.x),
              (r[10] = e.y),
              (r[11] = n.z),
              (r[12] = n.x),
              (r[13] = n.y),
              (r[14] = e.z),
              (r[15] = e.x),
              (r[16] = n.y),
              (r[17] = e.z),
              (r[18] = e.x),
              (r[19] = e.y),
              (r[20] = e.z),
              (r[21] = n.x),
              (r[22] = e.y),
              (r[23] = e.z),
              (i.needsUpdate = !0),
              this.geometry.computeBoundingSphere();
          }
          setFromObject(t) {
            return (this.object = t), this.update(), this;
          }
          copy(t) {
            return (
              Fl.prototype.copy.call(this, t), (this.object = t.object), this
            );
          }
        }
        class rp extends Fl {
          constructor(t, e = 16776960) {
            const n = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              i = new Yr();
            i.setIndex(new Er(n, 1)),
              i.setAttribute(
                'position',
                new Or(
                  [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                    -1, -1, -1, 1, -1, -1,
                  ],
                  3,
                ),
              ),
              super(i, new Rl({ color: e, toneMapped: !1 })),
              (this.box = t),
              (this.type = 'Box3Helper'),
              this.geometry.computeBoundingSphere();
          }
          updateMatrixWorld(t) {
            const e = this.box;
            e.isEmpty() ||
              (e.getCenter(this.position),
              e.getSize(this.scale),
              this.scale.multiplyScalar(0.5),
              super.updateMatrixWorld(t));
          }
        }
        class ap extends Ol {
          constructor(t, e = 1, n = 16776960) {
            const i = n,
              r = new Yr();
            r.setAttribute(
              'position',
              new Or(
                [
                  1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,
                  1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
                ],
                3,
              ),
            ),
              r.computeBoundingSphere(),
              super(r, new Rl({ color: i, toneMapped: !1 })),
              (this.type = 'PlaneHelper'),
              (this.plane = t),
              (this.size = e);
            const a = new Yr();
            a.setAttribute(
              'position',
              new Or(
                [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                3,
              ),
            ),
              a.computeBoundingSphere(),
              this.add(
                new da(
                  a,
                  new qr({
                    color: i,
                    opacity: 0.2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1,
                  }),
                ),
              );
          }
          updateMatrixWorld(t) {
            let e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8),
              this.scale.set(0.5 * this.size, 0.5 * this.size, e),
              (this.children[0].material.side = e < 0 ? m : f),
              this.lookAt(this.plane.normal),
              super.updateMatrixWorld(t);
          }
        }
        const op = new Zn();
        let sp, lp;
        class cp extends Qi {
          constructor(
            t = new Zn(0, 0, 1),
            e = new Zn(0, 0, 0),
            n = 1,
            i = 16776960,
            r = 0.2 * n,
            a = 0.2 * r,
          ) {
            super(),
              (this.type = 'ArrowHelper'),
              void 0 === sp &&
                ((sp = new Yr()),
                sp.setAttribute('position', new Or([0, 0, 0, 0, 1, 0], 3)),
                (lp = new Ql(0, 0.5, 1, 5, 1)),
                lp.translate(0, -0.5, 0)),
              this.position.copy(e),
              (this.line = new Ol(sp, new Rl({ color: i, toneMapped: !1 }))),
              (this.line.matrixAutoUpdate = !1),
              this.add(this.line),
              (this.cone = new da(lp, new qr({ color: i, toneMapped: !1 }))),
              (this.cone.matrixAutoUpdate = !1),
              this.add(this.cone),
              this.setDirection(t),
              this.setLength(n, r, a);
          }
          setDirection(t) {
            if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
            else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
            else {
              op.set(t.z, 0, -t.x).normalize();
              const e = Math.acos(t.y);
              this.quaternion.setFromAxisAngle(op, e);
            }
          }
          setLength(t, e = 0.2 * t, n = 0.2 * e) {
            this.line.scale.set(1, Math.max(1e-4, t - e), 1),
              this.line.updateMatrix(),
              this.cone.scale.set(n, e, n),
              (this.cone.position.y = t),
              this.cone.updateMatrix();
          }
          setColor(t) {
            this.line.material.color.set(t), this.cone.material.color.set(t);
          }
          copy(t) {
            return (
              super.copy(t, !1),
              this.line.copy(t.line),
              this.cone.copy(t.cone),
              this
            );
          }
        }
        class up extends Fl {
          constructor(t = 1) {
            const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
              n = new Yr();
            n.setAttribute('position', new Or(e, 3)),
              n.setAttribute(
                'color',
                new Or(
                  [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                  3,
                ),
              );
            super(n, new Rl({ vertexColors: !0, toneMapped: !1 })),
              (this.type = 'AxesHelper');
          }
        }
        const hp = new Float32Array(1),
          dp = new Int32Array(hp.buffer),
          pp = {
            toHalfFloat: function (t) {
              hp[0] = t;
              const e = dp[0];
              let n = (e >> 16) & 32768,
                i = (e >> 12) & 2047;
              const r = (e >> 23) & 255;
              return r < 103
                ? n
                : r > 142
                ? ((n |= 31744), (n |= (255 == r ? 0 : 1) && 8388607 & e), n)
                : r < 113
                ? ((i |= 2048),
                  (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)),
                  n)
                : ((n |= ((r - 112) << 10) | (i >> 1)), (n += 1 & i), n);
            },
          },
          fp = Math.pow(2, 8),
          mp = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          gp = 5 + mp.length,
          yp = {
            [Je]: 0,
            [Ze]: 1,
            [Qe]: 2,
            [en]: 3,
            [nn]: 4,
            [rn]: 5,
            [Ke]: 6,
          },
          vp = new qr({ side: m, depthWrite: !1, depthTest: !1 }),
          xp = new da(new fa(), vp),
          bp = new vh(),
          { _lodPlanes: _p, _sizeLods: wp, _sigmas: Mp } = Pp(),
          qp = new Mr();
        let Sp = null;
        const Tp = (1 + Math.sqrt(5)) / 2,
          Ep = 1 / Tp,
          Ap = [
            new Zn(1, 1, 1),
            new Zn(-1, 1, 1),
            new Zn(1, 1, -1),
            new Zn(-1, 1, -1),
            new Zn(0, Tp, Ep),
            new Zn(0, Tp, -Ep),
            new Zn(Ep, 0, Tp),
            new Zn(-Ep, 0, Tp),
            new Zn(Tp, Ep, 0),
            new Zn(-Tp, Ep, 0),
          ];
        function Lp(t) {
          const e = Math.max(t.r, t.g, t.b),
            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
          t.multiplyScalar(Math.pow(2, -n));
          return (n + 128) / 255;
        }
        class Rp {
          constructor(t) {
            (this._renderer = t),
              (this._pingPongRenderTarget = null),
              (this._blurMaterial = (function (t) {
                const e = new Float32Array(t),
                  n = new Zn(0, 1, 0);
                return new Qc({
                  name: 'SphericalGaussianBlur',
                  defines: { n: t },
                  uniforms: {
                    envMap: { value: null },
                    samples: { value: 1 },
                    weights: { value: e },
                    latitudinal: { value: !1 },
                    dTheta: { value: 0 },
                    mipInt: { value: 0 },
                    poleAxis: { value: n },
                    inputEncoding: { value: yp[Je] },
                    outputEncoding: { value: yp[Je] },
                  },
                  vertexShader: Np(),
                  fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${zp()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                  blending: x,
                  depthTest: !1,
                  depthWrite: !1,
                });
              })(20)),
              (this._equirectShader = null),
              (this._cubemapShader = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(t, e = 0, n = 0.1, i = 100) {
            Sp = this._renderer.getRenderTarget();
            const r = this._allocateTargets();
            return (
              this._sceneToCubeUV(t, n, i, r),
              e > 0 && this._blur(r, 0, 0, e),
              this._applyPMREM(r),
              this._cleanup(r),
              r
            );
          }
          fromEquirectangular(t) {
            return this._fromTexture(t);
          }
          fromCubemap(t) {
            return this._fromTexture(t);
          }
          compileCubemapShader() {
            null === this._cubemapShader &&
              ((this._cubemapShader = Op()),
              this._compileMaterial(this._cubemapShader));
          }
          compileEquirectangularShader() {
            null === this._equirectShader &&
              ((this._equirectShader = Dp()),
              this._compileMaterial(this._equirectShader));
          }
          dispose() {
            this._blurMaterial.dispose(),
              null !== this._cubemapShader && this._cubemapShader.dispose(),
              null !== this._equirectShader && this._equirectShader.dispose();
            for (let t = 0; t < _p.length; t++) _p[t].dispose();
          }
          _cleanup(t) {
            this._pingPongRenderTarget.dispose(),
              this._renderer.setRenderTarget(Sp),
              (t.scissorTest = !1),
              Ip(t, 0, 0, t.width, t.height);
          }
          _fromTexture(t) {
            Sp = this._renderer.getRenderTarget();
            const e = this._allocateTargets(t);
            return (
              this._textureToCubeUV(t, e),
              this._applyPMREM(e),
              this._cleanup(e),
              e
            );
          }
          _allocateTargets(t) {
            const e = {
                magFilter: ft,
                minFilter: ft,
                generateMipmaps: !1,
                type: qt,
                format: Ut,
                encoding: Cp(t) ? t.encoding : Qe,
                depthBuffer: !1,
              },
              n = kp(e);
            return (
              (n.depthBuffer = !t), (this._pingPongRenderTarget = kp(e)), n
            );
          }
          _compileMaterial(t) {
            const e = new da(_p[0], t);
            this._renderer.compile(e, bp);
          }
          _sceneToCubeUV(t, e, n, i) {
            const r = new ba(90, 1, e, n),
              a = [1, -1, 1, 1, 1, 1],
              o = [1, 1, 1, -1, -1, -1],
              s = this._renderer,
              l = s.autoClear,
              c = s.outputEncoding,
              u = s.toneMapping;
            s.getClearColor(qp),
              (s.toneMapping = K),
              (s.outputEncoding = Je),
              (s.autoClear = !1);
            let h = !1;
            const d = t.background;
            if (d) {
              if (d.isColor) {
                vp.color.copy(d).convertSRGBToLinear(), (t.background = null);
                const e = Lp(vp.color);
                (vp.opacity = e), (h = !0);
              }
            } else {
              vp.color.copy(qp).convertSRGBToLinear();
              const t = Lp(vp.color);
              (vp.opacity = t), (h = !0);
            }
            for (let e = 0; e < 6; e++) {
              const n = e % 3;
              0 == n
                ? (r.up.set(0, a[e], 0), r.lookAt(o[e], 0, 0))
                : 1 == n
                ? (r.up.set(0, 0, a[e]), r.lookAt(0, o[e], 0))
                : (r.up.set(0, a[e], 0), r.lookAt(0, 0, o[e])),
                Ip(i, n * fp, e > 2 ? fp : 0, fp, fp),
                s.setRenderTarget(i),
                h && s.render(xp, r),
                s.render(t, r);
            }
            (s.toneMapping = u), (s.outputEncoding = c), (s.autoClear = l);
          }
          _textureToCubeUV(t, e) {
            const n = this._renderer;
            t.isCubeTexture
              ? null == this._cubemapShader && (this._cubemapShader = Op())
              : null == this._equirectShader && (this._equirectShader = Dp());
            const i = t.isCubeTexture
                ? this._cubemapShader
                : this._equirectShader,
              r = new da(_p[0], i),
              a = i.uniforms;
            (a.envMap.value = t),
              t.isCubeTexture ||
                a.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
              (a.inputEncoding.value = yp[t.encoding]),
              (a.outputEncoding.value = yp[e.texture.encoding]),
              Ip(e, 0, 0, 3 * fp, 2 * fp),
              n.setRenderTarget(e),
              n.render(r, bp);
          }
          _applyPMREM(t) {
            const e = this._renderer,
              n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < gp; e++) {
              const n = Math.sqrt(Mp[e] * Mp[e] - Mp[e - 1] * Mp[e - 1]),
                i = Ap[(e - 1) % Ap.length];
              this._blur(t, e - 1, e, n, i);
            }
            e.autoClear = n;
          }
          _blur(t, e, n, i, r) {
            const a = this._pingPongRenderTarget;
            this._halfBlur(t, a, e, n, i, 'latitudinal', r),
              this._halfBlur(a, t, n, n, i, 'longitudinal', r);
          }
          _halfBlur(t, e, n, i, r, a, o) {
            const s = this._renderer,
              l = this._blurMaterial;
            'latitudinal' !== a &&
              'longitudinal' !== a &&
              console.error(
                'blur direction must be either latitudinal or longitudinal!',
              );
            const c = new da(_p[i], l),
              u = l.uniforms,
              h = wp[n] - 1,
              d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
              p = r / d,
              f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
            f > 20 &&
              console.warn(
                `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`,
              );
            const m = [];
            let g = 0;
            for (let t = 0; t < 20; ++t) {
              const e = t / p,
                n = Math.exp((-e * e) / 2);
              m.push(n), 0 == t ? (g += n) : t < f && (g += 2 * n);
            }
            for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
            (u.envMap.value = t.texture),
              (u.samples.value = f),
              (u.weights.value = m),
              (u.latitudinal.value = 'latitudinal' === a),
              o && (u.poleAxis.value = o),
              (u.dTheta.value = d),
              (u.mipInt.value = 8 - n),
              (u.inputEncoding.value = yp[t.texture.encoding]),
              (u.outputEncoding.value = yp[t.texture.encoding]);
            const y = wp[i];
            Ip(
              e,
              3 * Math.max(0, fp - 2 * y),
              (0 === i ? 0 : 2 * fp) + 2 * y * (i > 4 ? i - 8 + 4 : 0),
              3 * y,
              2 * y,
            ),
              s.setRenderTarget(e),
              s.render(c, bp);
          }
        }
        function Cp(t) {
          return (
            void 0 !== t &&
            t.type === qt &&
            (t.encoding === Je || t.encoding === Ze || t.encoding === Ke)
          );
        }
        function Pp() {
          const t = [],
            e = [],
            n = [];
          let i = 8;
          for (let r = 0; r < gp; r++) {
            const a = Math.pow(2, i);
            e.push(a);
            let o = 1 / a;
            r > 4 ? (o = mp[r - 8 + 4 - 1]) : 0 == r && (o = 0), n.push(o);
            const s = 1 / (a - 1),
              l = -s / 2,
              c = 1 + s / 2,
              u = [l, l, c, l, c, c, l, l, c, c, l, c],
              h = 6,
              d = 6,
              p = 3,
              f = 2,
              m = 1,
              g = new Float32Array(p * d * h),
              y = new Float32Array(f * d * h),
              v = new Float32Array(m * d * h);
            for (let t = 0; t < h; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              g.set(i, p * d * t), y.set(u, f * d * t);
              const r = [t, t, t, t, t, t];
              v.set(r, m * d * t);
            }
            const x = new Yr();
            x.setAttribute('position', new Er(g, p)),
              x.setAttribute('uv', new Er(y, f)),
              x.setAttribute('faceIndex', new Er(v, m)),
              t.push(x),
              i > 4 && i--;
          }
          return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
        }
        function kp(t) {
          const e = new Yn(3 * fp, 3 * fp, t);
          return (
            (e.texture.mapping = ct),
            (e.texture.name = 'PMREM.cubeUv'),
            (e.scissorTest = !0),
            e
          );
        }
        function Ip(t, e, n, i, r) {
          t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
        }
        function Dp() {
          const t = new Bn(1, 1);
          return new Qc({
            name: 'EquirectangularToCubeUV',
            uniforms: {
              envMap: { value: null },
              texelSize: { value: t },
              inputEncoding: { value: yp[Je] },
              outputEncoding: { value: yp[Je] },
            },
            vertexShader: Np(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${zp()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: x,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function Op() {
          return new Qc({
            name: 'CubemapToCubeUV',
            uniforms: {
              envMap: { value: null },
              inputEncoding: { value: yp[Je] },
              outputEncoding: { value: yp[Je] },
            },
            vertexShader: Np(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${zp()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: x,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function Np() {
          return '\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t';
        }
        function zp() {
          return '\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t';
        }
        const Fp = 0,
          Bp = 1,
          Up = 0,
          jp = 1,
          Gp = 2;
        function Hp(t) {
          return (
            console.warn(
              'THREE.MeshFaceMaterial has been removed. Use an Array instead.',
            ),
            t
          );
        }
        function Vp(t = []) {
          return (
            console.warn(
              'THREE.MultiMaterial has been removed. Use an Array instead.',
            ),
            (t.isMultiMaterial = !0),
            (t.materials = t),
            (t.clone = function () {
              return t.slice();
            }),
            t
          );
        }
        function Wp(t, e) {
          return (
            console.warn('THREE.PointCloud has been renamed to THREE.Points.'),
            new Wl(t, e)
          );
        }
        function Xp(t) {
          return (
            console.warn('THREE.Particle has been renamed to THREE.Sprite.'),
            new ul(t)
          );
        }
        function Yp(t, e) {
          return (
            console.warn(
              'THREE.ParticleSystem has been renamed to THREE.Points.',
            ),
            new Wl(t, e)
          );
        }
        function $p(t) {
          return (
            console.warn(
              'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.',
            ),
            new Ul(t)
          );
        }
        function Jp(t) {
          return (
            console.warn(
              'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.',
            ),
            new Ul(t)
          );
        }
        function Zp(t) {
          return (
            console.warn(
              'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.',
            ),
            new Ul(t)
          );
        }
        function Kp(t, e, n) {
          return (
            console.warn(
              'THREE.Vertex has been removed. Use THREE.Vector3 instead.',
            ),
            new Zn(t, e, n)
          );
        }
        function Qp(t, e) {
          return (
            console.warn(
              'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.',
            ),
            new Er(t, e).setUsage(Tn)
          );
        }
        function tf(t, e) {
          return (
            console.warn(
              'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.',
            ),
            new Ar(t, e)
          );
        }
        function ef(t, e) {
          return (
            console.warn(
              'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.',
            ),
            new Lr(t, e)
          );
        }
        function nf(t, e) {
          return (
            console.warn(
              'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.',
            ),
            new Rr(t, e)
          );
        }
        function rf(t, e) {
          return (
            console.warn(
              'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.',
            ),
            new Cr(t, e)
          );
        }
        function af(t, e) {
          return (
            console.warn(
              'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.',
            ),
            new Pr(t, e)
          );
        }
        function of(t, e) {
          return (
            console.warn(
              'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.',
            ),
            new kr(t, e)
          );
        }
        function sf(t, e) {
          return (
            console.warn(
              'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.',
            ),
            new Ir(t, e)
          );
        }
        function lf(t, e) {
          return (
            console.warn(
              'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.',
            ),
            new Or(t, e)
          );
        }
        function cf(t, e) {
          return (
            console.warn(
              'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.',
            ),
            new Nr(t, e)
          );
        }
        function uf(t) {
          return (
            console.warn(
              'THREE.AxisHelper has been renamed to THREE.AxesHelper.',
            ),
            new up(t)
          );
        }
        function hf(t, e) {
          return (
            console.warn(
              'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.',
            ),
            new ip(t, e)
          );
        }
        function df(t, e) {
          return (
            console.warn(
              'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.',
            ),
            new Fl(
              new sc(t.geometry),
              new Rl({ color: void 0 !== e ? e : 16777215 }),
            )
          );
        }
        function pf(t, e) {
          return (
            console.warn(
              'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.',
            ),
            new Fl(
              new Jc(t.geometry),
              new Rl({ color: void 0 !== e ? e : 16777215 }),
            )
          );
        }
        function ff(t) {
          return (
            console.warn(
              'THREE.XHRLoader has been renamed to THREE.FileLoader.',
            ),
            new Lu(t)
          );
        }
        function mf(t) {
          return (
            console.warn(
              'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.',
            ),
            new Iu(t)
          );
        }
        function gf(t, e, n) {
          return (
            console.warn(
              'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).',
            ),
            new Ma(t, n)
          );
        }
        function yf() {
          console.error('THREE.CanvasRenderer has been removed');
        }
        function vf() {
          console.error('THREE.JSONLoader has been removed.');
        }
        (Ou.create = function (t, e) {
          return (
            console.log('THREE.Curve.create() has been deprecated'),
            (t.prototype = Object.create(Ou.prototype)),
            (t.prototype.constructor = t),
            (t.prototype.getPoint = e),
            t
          );
        }),
          (ih.prototype.fromPoints = function (t) {
            return (
              console.warn(
                'THREE.Path: .fromPoints() has been renamed to .setFromPoints().',
              ),
              this.setFromPoints(t)
            );
          }),
          (Wd.prototype.setColors = function () {
            console.error(
              'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.',
            );
          }),
          (Bd.prototype.update = function () {
            console.error(
              'THREE.SkeletonHelper: update() no longer needs to be called.',
            );
          }),
          (Eu.prototype.extractUrlBase = function (t) {
            return (
              console.warn(
                'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.',
              ),
              Th.extractUrlBase(t)
            );
          }),
          (Eu.Handlers = {
            add: function () {
              console.error(
                'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.',
              );
            },
            get: function () {
              console.error(
                'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.',
              );
            },
          }),
          (Rd.prototype.center = function (t) {
            return (
              console.warn(
                'THREE.Box2: .center() has been renamed to .getCenter().',
              ),
              this.getCenter(t)
            );
          }),
          (Rd.prototype.empty = function () {
            return (
              console.warn(
                'THREE.Box2: .empty() has been renamed to .isEmpty().',
              ),
              this.isEmpty()
            );
          }),
          (Rd.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().',
              ),
              this.intersectsBox(t)
            );
          }),
          (Rd.prototype.size = function (t) {
            return (
              console.warn(
                'THREE.Box2: .size() has been renamed to .getSize().',
              ),
              this.getSize(t)
            );
          }),
          (ti.prototype.center = function (t) {
            return (
              console.warn(
                'THREE.Box3: .center() has been renamed to .getCenter().',
              ),
              this.getCenter(t)
            );
          }),
          (ti.prototype.empty = function () {
            return (
              console.warn(
                'THREE.Box3: .empty() has been renamed to .isEmpty().',
              ),
              this.isEmpty()
            );
          }),
          (ti.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().',
              ),
              this.intersectsBox(t)
            );
          }),
          (ti.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().',
              ),
              this.intersectsSphere(t)
            );
          }),
          (ti.prototype.size = function (t) {
            return (
              console.warn(
                'THREE.Box3: .size() has been renamed to .getSize().',
              ),
              this.getSize(t)
            );
          }),
          (xi.prototype.empty = function () {
            return (
              console.warn(
                'THREE.Sphere: .empty() has been renamed to .isEmpty().',
              ),
              this.isEmpty()
            );
          }),
          (Ea.prototype.setFromMatrix = function (t) {
            return (
              console.warn(
                'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().',
              ),
              this.setFromProjectionMatrix(t)
            );
          }),
          (kd.prototype.center = function (t) {
            return (
              console.warn(
                'THREE.Line3: .center() has been renamed to .getCenter().',
              ),
              this.getCenter(t)
            );
          }),
          (Fn.random16 = function () {
            return (
              console.warn(
                'THREE.Math: .random16() has been deprecated. Use Math.random() instead.',
              ),
              Math.random()
            );
          }),
          (Fn.nearestPowerOfTwo = function (t) {
            return (
              console.warn(
                'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().',
              ),
              Fn.floorPowerOfTwo(t)
            );
          }),
          (Fn.nextPowerOfTwo = function (t) {
            return (
              console.warn(
                'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().',
              ),
              Fn.ceilPowerOfTwo(t)
            );
          }),
          (Un.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
              ),
              this.toArray(t, e)
            );
          }),
          (Un.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.',
              ),
              t.applyMatrix3(this)
            );
          }),
          (Un.prototype.multiplyVector3Array = function () {
            console.error(
              'THREE.Matrix3: .multiplyVector3Array() has been removed.',
            );
          }),
          (Un.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.',
              ),
              t.applyMatrix3(this)
            );
          }),
          (Un.prototype.applyToVector3Array = function () {
            console.error(
              'THREE.Matrix3: .applyToVector3Array() has been removed.',
            );
          }),
          (Un.prototype.getInverse = function (t) {
            return (
              console.warn(
                'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',
              ),
              this.copy(t).invert()
            );
          }),
          (Ai.prototype.extractPosition = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().',
              ),
              this.copyPosition(t)
            );
          }),
          (Ai.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
              ),
              this.toArray(t, e)
            );
          }),
          (Ai.prototype.getPosition = function () {
            return (
              console.warn(
                'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.',
              ),
              new Zn().setFromMatrixColumn(this, 3)
            );
          }),
          (Ai.prototype.setRotationFromQuaternion = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().',
              ),
              this.makeRotationFromQuaternion(t)
            );
          }),
          (Ai.prototype.multiplyToArray = function () {
            console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
          }),
          (Ai.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.',
              ),
              t.applyMatrix4(this)
            );
          }),
          (Ai.prototype.multiplyVector4 = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.',
              ),
              t.applyMatrix4(this)
            );
          }),
          (Ai.prototype.multiplyVector3Array = function () {
            console.error(
              'THREE.Matrix4: .multiplyVector3Array() has been removed.',
            );
          }),
          (Ai.prototype.rotateAxis = function (t) {
            console.warn(
              'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.',
            ),
              t.transformDirection(this);
          }),
          (Ai.prototype.crossVector = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.',
              ),
              t.applyMatrix4(this)
            );
          }),
          (Ai.prototype.translate = function () {
            console.error('THREE.Matrix4: .translate() has been removed.');
          }),
          (Ai.prototype.rotateX = function () {
            console.error('THREE.Matrix4: .rotateX() has been removed.');
          }),
          (Ai.prototype.rotateY = function () {
            console.error('THREE.Matrix4: .rotateY() has been removed.');
          }),
          (Ai.prototype.rotateZ = function () {
            console.error('THREE.Matrix4: .rotateZ() has been removed.');
          }),
          (Ai.prototype.rotateByAxis = function () {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
          }),
          (Ai.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.',
              ),
              t.applyMatrix4(this)
            );
          }),
          (Ai.prototype.applyToVector3Array = function () {
            console.error(
              'THREE.Matrix4: .applyToVector3Array() has been removed.',
            );
          }),
          (Ai.prototype.makeFrustum = function (t, e, n, i, r, a) {
            return (
              console.warn(
                'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.',
              ),
              this.makePerspective(t, e, i, n, r, a)
            );
          }),
          (Ai.prototype.getInverse = function (t) {
            return (
              console.warn(
                'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.',
              ),
              this.copy(t).invert()
            );
          }),
          (ir.prototype.isIntersectionLine = function (t) {
            return (
              console.warn(
                'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().',
              ),
              this.intersectsLine(t)
            );
          }),
          (Jn.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',
              ),
              t.applyQuaternion(this)
            );
          }),
          (Jn.prototype.inverse = function () {
            return (
              console.warn(
                'THREE.Quaternion: .inverse() has been renamed to invert().',
              ),
              this.invert()
            );
          }),
          (Ei.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().',
              ),
              this.intersectsBox(t)
            );
          }),
          (Ei.prototype.isIntersectionPlane = function (t) {
            return (
              console.warn(
                'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().',
              ),
              this.intersectsPlane(t)
            );
          }),
          (Ei.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().',
              ),
              this.intersectsSphere(t)
            );
          }),
          (fr.prototype.area = function () {
            return (
              console.warn(
                'THREE.Triangle: .area() has been renamed to .getArea().',
              ),
              this.getArea()
            );
          }),
          (fr.prototype.barycoordFromPoint = function (t, e) {
            return (
              console.warn(
                'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
              ),
              this.getBarycoord(t, e)
            );
          }),
          (fr.prototype.midpoint = function (t) {
            return (
              console.warn(
                'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().',
              ),
              this.getMidpoint(t)
            );
          }),
          (fr.prototypenormal = function (t) {
            return (
              console.warn(
                'THREE.Triangle: .normal() has been renamed to .getNormal().',
              ),
              this.getNormal(t)
            );
          }),
          (fr.prototype.plane = function (t) {
            return (
              console.warn(
                'THREE.Triangle: .plane() has been renamed to .getPlane().',
              ),
              this.getPlane(t)
            );
          }),
          (fr.barycoordFromPoint = function (t, e, n, i, r) {
            return (
              console.warn(
                'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
              ),
              fr.getBarycoord(t, e, n, i, r)
            );
          }),
          (fr.normal = function (t, e, n, i) {
            return (
              console.warn(
                'THREE.Triangle: .normal() has been renamed to .getNormal().',
              ),
              fr.getNormal(t, e, n, i)
            );
          }),
          (rh.prototype.extractAllPoints = function (t) {
            return (
              console.warn(
                'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.',
              ),
              this.extractPoints(t)
            );
          }),
          (rh.prototype.extrude = function (t) {
            return (
              console.warn(
                'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.',
              ),
              new Oc(this, t)
            );
          }),
          (rh.prototype.makeGeometry = function (t) {
            return (
              console.warn(
                'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.',
              ),
              new Gc(this, t)
            );
          }),
          (Bn.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().',
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (Bn.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (Bn.prototype.lengthManhattan = function () {
            return (
              console.warn(
                'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().',
              ),
              this.manhattanLength()
            );
          }),
          (Zn.prototype.setEulerFromRotationMatrix = function () {
            console.error(
              'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.',
            );
          }),
          (Zn.prototype.setEulerFromQuaternion = function () {
            console.error(
              'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.',
            );
          }),
          (Zn.prototype.getPositionFromMatrix = function (t) {
            return (
              console.warn(
                'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().',
              ),
              this.setFromMatrixPosition(t)
            );
          }),
          (Zn.prototype.getScaleFromMatrix = function (t) {
            return (
              console.warn(
                'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().',
              ),
              this.setFromMatrixScale(t)
            );
          }),
          (Zn.prototype.getColumnFromMatrix = function (t, e) {
            return (
              console.warn(
                'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().',
              ),
              this.setFromMatrixColumn(e, t)
            );
          }),
          (Zn.prototype.applyProjection = function (t) {
            return (
              console.warn(
                'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.',
              ),
              this.applyMatrix4(t)
            );
          }),
          (Zn.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().',
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (Zn.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (Zn.prototype.lengthManhattan = function () {
            return (
              console.warn(
                'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().',
              ),
              this.manhattanLength()
            );
          }),
          (Xn.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().',
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (Xn.prototype.lengthManhattan = function () {
            return (
              console.warn(
                'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().',
              ),
              this.manhattanLength()
            );
          }),
          (Qi.prototype.getChildByName = function (t) {
            return (
              console.warn(
                'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().',
              ),
              this.getObjectByName(t)
            );
          }),
          (Qi.prototype.renderDepth = function () {
            console.warn(
              'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.',
            );
          }),
          (Qi.prototype.translate = function (t, e) {
            return (
              console.warn(
                'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.',
              ),
              this.translateOnAxis(e, t)
            );
          }),
          (Qi.prototype.getWorldRotation = function () {
            console.error(
              'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.',
            );
          }),
          (Qi.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().',
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(Qi.prototype, {
            eulerOrder: {
              get: function () {
                return (
                  console.warn(
                    'THREE.Object3D: .eulerOrder is now .rotation.order.',
                  ),
                  this.rotation.order
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.Object3D: .eulerOrder is now .rotation.order.',
                ),
                  (this.rotation.order = t);
              },
            },
            useQuaternion: {
              get: function () {
                console.warn(
                  'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
                );
              },
              set: function () {
                console.warn(
                  'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
                );
              },
            },
          }),
          (da.prototype.setDrawMode = function () {
            console.error(
              'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
            );
          }),
          Object.defineProperties(da.prototype, {
            drawMode: {
              get: function () {
                return (
                  console.error(
                    'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.',
                  ),
                  Xe
                );
              },
              set: function () {
                console.error(
                  'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
                );
              },
            },
          }),
          (bl.prototype.initBones = function () {
            console.error('THREE.SkinnedMesh: initBones() has been removed.');
          }),
          Object.defineProperty(Ou.prototype, '__arcLengthDivisions', {
            get: function () {
              return (
                console.warn(
                  'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.',
                ),
                this.arcLengthDivisions
              );
            },
            set: function (t) {
              console.warn(
                'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.',
              ),
                (this.arcLengthDivisions = t);
            },
          }),
          (ba.prototype.setLens = function (t, e) {
            console.warn(
              'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.',
            ),
              void 0 !== e && (this.filmGauge = e),
              this.setFocalLength(t);
          }),
          Object.defineProperties(ah.prototype, {
            onlyShadow: {
              set: function () {
                console.warn('THREE.Light: .onlyShadow has been removed.');
              },
            },
            shadowCameraFov: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.',
                ),
                  (this.shadow.camera.fov = t);
              },
            },
            shadowCameraLeft: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.',
                ),
                  (this.shadow.camera.left = t);
              },
            },
            shadowCameraRight: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowCameraRight is now .shadow.camera.right.',
                ),
                  (this.shadow.camera.right = t);
              },
            },
            shadowCameraTop: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowCameraTop is now .shadow.camera.top.',
                ),
                  (this.shadow.camera.top = t);
              },
            },
            shadowCameraBottom: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.',
                ),
                  (this.shadow.camera.bottom = t);
              },
            },
            shadowCameraNear: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowCameraNear is now .shadow.camera.near.',
                ),
                  (this.shadow.camera.near = t);
              },
            },
            shadowCameraFar: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowCameraFar is now .shadow.camera.far.',
                ),
                  (this.shadow.camera.far = t);
              },
            },
            shadowCameraVisible: {
              set: function () {
                console.warn(
                  'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.',
                );
              },
            },
            shadowBias: {
              set: function (t) {
                console.warn('THREE.Light: .shadowBias is now .shadow.bias.'),
                  (this.shadow.bias = t);
              },
            },
            shadowDarkness: {
              set: function () {
                console.warn('THREE.Light: .shadowDarkness has been removed.');
              },
            },
            shadowMapWidth: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.',
                ),
                  (this.shadow.mapSize.width = t);
              },
            },
            shadowMapHeight: {
              set: function (t) {
                console.warn(
                  'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.',
                ),
                  (this.shadow.mapSize.height = t);
              },
            },
          }),
          Object.defineProperties(Er.prototype, {
            length: {
              get: function () {
                return (
                  console.warn(
                    'THREE.BufferAttribute: .length has been deprecated. Use .count instead.',
                  ),
                  this.array.length
                );
              },
            },
            dynamic: {
              get: function () {
                return (
                  console.warn(
                    'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
                  ),
                  this.usage === Tn
                );
              },
              set: function () {
                console.warn(
                  'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
                ),
                  this.setUsage(Tn);
              },
            },
          }),
          (Er.prototype.setDynamic = function (t) {
            return (
              console.warn(
                'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.',
              ),
              this.setUsage(!0 === t ? Tn : Sn),
              this
            );
          }),
          (Er.prototype.copyIndicesArray = function () {
            console.error(
              'THREE.BufferAttribute: .copyIndicesArray() has been removed.',
            );
          }),
          (Er.prototype.setArray = function () {
            console.error(
              'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
            );
          }),
          (Yr.prototype.addIndex = function (t) {
            console.warn(
              'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().',
            ),
              this.setIndex(t);
          }),
          (Yr.prototype.addAttribute = function (t, e) {
            return (
              console.warn(
                'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().',
              ),
              (e && e.isBufferAttribute) ||
              (e && e.isInterleavedBufferAttribute)
                ? 'index' === t
                  ? (console.warn(
                      'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.',
                    ),
                    this.setIndex(e),
                    this)
                  : this.setAttribute(t, e)
                : (console.warn(
                    'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).',
                  ),
                  this.setAttribute(t, new Er(arguments[1], arguments[2])))
            );
          }),
          (Yr.prototype.addDrawCall = function (t, e, n) {
            void 0 !== n &&
              console.warn(
                'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.',
              ),
              console.warn(
                'THREE.BufferGeometry: .addDrawCall() is now .addGroup().',
              ),
              this.addGroup(t, e);
          }),
          (Yr.prototype.clearDrawCalls = function () {
            console.warn(
              'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().',
            ),
              this.clearGroups();
          }),
          (Yr.prototype.computeOffsets = function () {
            console.warn(
              'THREE.BufferGeometry: .computeOffsets() has been removed.',
            );
          }),
          (Yr.prototype.removeAttribute = function (t) {
            return (
              console.warn(
                'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().',
              ),
              this.deleteAttribute(t)
            );
          }),
          (Yr.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().',
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(Yr.prototype, {
            drawcalls: {
              get: function () {
                return (
                  console.error(
                    'THREE.BufferGeometry: .drawcalls has been renamed to .groups.',
                  ),
                  this.groups
                );
              },
            },
            offsets: {
              get: function () {
                return (
                  console.warn(
                    'THREE.BufferGeometry: .offsets has been renamed to .groups.',
                  ),
                  this.groups
                );
              },
            },
          }),
          Object.defineProperties(Eh.prototype, {
            maxInstancedCount: {
              get: function () {
                return (
                  console.warn(
                    'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.',
                  ),
                  this.instanceCount
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.',
                ),
                  (this.instanceCount = t);
              },
            },
          }),
          Object.defineProperties(qd.prototype, {
            linePrecision: {
              get: function () {
                return (
                  console.warn(
                    'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.',
                  ),
                  this.params.Line.threshold
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.',
                ),
                  (this.params.Line.threshold = t);
              },
            },
          }),
          Object.defineProperties(Xs.prototype, {
            dynamic: {
              get: function () {
                return (
                  console.warn(
                    'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.',
                  ),
                  this.usage === Tn
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.',
                ),
                  this.setUsage(t);
              },
            },
          }),
          (Xs.prototype.setDynamic = function (t) {
            return (
              console.warn(
                'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.',
              ),
              this.setUsage(!0 === t ? Tn : Sn),
              this
            );
          }),
          (Xs.prototype.setArray = function () {
            console.error(
              'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
            );
          }),
          (Oc.prototype.getArrays = function () {
            console.error(
              'THREE.ExtrudeGeometry: .getArrays() has been removed.',
            );
          }),
          (Oc.prototype.addShapeList = function () {
            console.error(
              'THREE.ExtrudeGeometry: .addShapeList() has been removed.',
            );
          }),
          (Oc.prototype.addShape = function () {
            console.error(
              'THREE.ExtrudeGeometry: .addShape() has been removed.',
            );
          }),
          (Ws.prototype.dispose = function () {
            console.error('THREE.Scene: .dispose() has been removed.');
          }),
          (_d.prototype.onUpdate = function () {
            return (
              console.warn(
                'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.',
              ),
              this
            );
          }),
          Object.defineProperties(gr.prototype, {
            wrapAround: {
              get: function () {
                console.warn('THREE.Material: .wrapAround has been removed.');
              },
              set: function () {
                console.warn('THREE.Material: .wrapAround has been removed.');
              },
            },
            overdraw: {
              get: function () {
                console.warn('THREE.Material: .overdraw has been removed.');
              },
              set: function () {
                console.warn('THREE.Material: .overdraw has been removed.');
              },
            },
            wrapRGB: {
              get: function () {
                return (
                  console.warn('THREE.Material: .wrapRGB has been removed.'),
                  new Mr()
                );
              },
            },
            shading: {
              get: function () {
                console.error(
                  'THREE.' +
                    this.type +
                    ': .shading has been removed. Use the boolean .flatShading instead.',
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.' +
                    this.type +
                    ': .shading has been removed. Use the boolean .flatShading instead.',
                ),
                  (this.flatShading = t === y);
              },
            },
            stencilMask: {
              get: function () {
                return (
                  console.warn(
                    'THREE.' +
                      this.type +
                      ': .stencilMask has been removed. Use .stencilFuncMask instead.',
                  ),
                  this.stencilFuncMask
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.' +
                    this.type +
                    ': .stencilMask has been removed. Use .stencilFuncMask instead.',
                ),
                  (this.stencilFuncMask = t);
              },
            },
          }),
          Object.defineProperties(eu.prototype, {
            transparency: {
              get: function () {
                return (
                  console.warn(
                    'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.',
                  ),
                  this.transmission
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.',
                ),
                  (this.transmission = t);
              },
            },
          }),
          Object.defineProperties(va.prototype, {
            derivatives: {
              get: function () {
                return (
                  console.warn(
                    'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                  ),
                  this.extensions.derivatives
                );
              },
              set: function (t) {
                console.warn(
                  'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                ),
                  (this.extensions.derivatives = t);
              },
            },
          }),
          (js.prototype.clearTarget = function (t, e, n, i) {
            console.warn(
              'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.',
            ),
              this.setRenderTarget(t),
              this.clear(e, n, i);
          }),
          (js.prototype.animate = function (t) {
            console.warn(
              'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().',
            ),
              this.setAnimationLoop(t);
          }),
          (js.prototype.getCurrentRenderTarget = function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().',
              ),
              this.getRenderTarget()
            );
          }),
          (js.prototype.getMaxAnisotropy = function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().',
              ),
              this.capabilities.getMaxAnisotropy()
            );
          }),
          (js.prototype.getPrecision = function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.',
              ),
              this.capabilities.precision
            );
          }),
          (js.prototype.resetGLState = function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .resetGLState() is now .state.reset().',
              ),
              this.state.reset()
            );
          }),
          (js.prototype.supportsFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).",
              ),
              this.extensions.get('OES_texture_float')
            );
          }),
          (js.prototype.supportsHalfFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).",
              ),
              this.extensions.get('OES_texture_half_float')
            );
          }),
          (js.prototype.supportsStandardDerivatives = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).",
              ),
              this.extensions.get('OES_standard_derivatives')
            );
          }),
          (js.prototype.supportsCompressedTextureS3TC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).",
              ),
              this.extensions.get('WEBGL_compressed_texture_s3tc')
            );
          }),
          (js.prototype.supportsCompressedTexturePVRTC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).",
              ),
              this.extensions.get('WEBGL_compressed_texture_pvrtc')
            );
          }),
          (js.prototype.supportsBlendMinMax = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).",
              ),
              this.extensions.get('EXT_blend_minmax')
            );
          }),
          (js.prototype.supportsVertexTextures = function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.',
              ),
              this.capabilities.vertexTextures
            );
          }),
          (js.prototype.supportsInstancedArrays = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).",
              ),
              this.extensions.get('ANGLE_instanced_arrays')
            );
          }),
          (js.prototype.enableScissorTest = function (t) {
            console.warn(
              'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().',
            ),
              this.setScissorTest(t);
          }),
          (js.prototype.initMaterial = function () {
            console.warn(
              'THREE.WebGLRenderer: .initMaterial() has been removed.',
            );
          }),
          (js.prototype.addPrePlugin = function () {
            console.warn(
              'THREE.WebGLRenderer: .addPrePlugin() has been removed.',
            );
          }),
          (js.prototype.addPostPlugin = function () {
            console.warn(
              'THREE.WebGLRenderer: .addPostPlugin() has been removed.',
            );
          }),
          (js.prototype.updateShadowMap = function () {
            console.warn(
              'THREE.WebGLRenderer: .updateShadowMap() has been removed.',
            );
          }),
          (js.prototype.setFaceCulling = function () {
            console.warn(
              'THREE.WebGLRenderer: .setFaceCulling() has been removed.',
            );
          }),
          (js.prototype.allocTextureUnit = function () {
            console.warn(
              'THREE.WebGLRenderer: .allocTextureUnit() has been removed.',
            );
          }),
          (js.prototype.setTexture = function () {
            console.warn(
              'THREE.WebGLRenderer: .setTexture() has been removed.',
            );
          }),
          (js.prototype.setTexture2D = function () {
            console.warn(
              'THREE.WebGLRenderer: .setTexture2D() has been removed.',
            );
          }),
          (js.prototype.setTextureCube = function () {
            console.warn(
              'THREE.WebGLRenderer: .setTextureCube() has been removed.',
            );
          }),
          (js.prototype.getActiveMipMapLevel = function () {
            return (
              console.warn(
                'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().',
              ),
              this.getActiveMipmapLevel()
            );
          }),
          Object.defineProperties(js.prototype, {
            shadowMapEnabled: {
              get: function () {
                return this.shadowMap.enabled;
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.',
                ),
                  (this.shadowMap.enabled = t);
              },
            },
            shadowMapType: {
              get: function () {
                return this.shadowMap.type;
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.',
                ),
                  (this.shadowMap.type = t);
              },
            },
            shadowMapCullFace: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
                );
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
                );
              },
            },
            context: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.',
                  ),
                  this.getContext()
                );
              },
            },
            vr: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderer: .vr has been renamed to .xr',
                  ),
                  this.xr
                );
              },
            },
            gammaInput: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
                  ),
                  !1
                );
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
                );
              },
            },
            gammaOutput: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
                  ),
                  !1
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
                ),
                  (this.outputEncoding = !0 === t ? Ze : Je);
              },
            },
            toneMappingWhitePoint: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',
                  ),
                  1
                );
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',
                );
              },
            },
          }),
          Object.defineProperties(ks.prototype, {
            cullFace: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
                );
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
                );
              },
            },
            renderReverseSided: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
                );
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
                );
              },
            },
            renderSingleSided: {
              get: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
                );
              },
              set: function () {
                console.warn(
                  'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
                );
              },
            },
          }),
          Object.defineProperties(Yn.prototype, {
            wrapS: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
                  ),
                  this.texture.wrapS
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
                ),
                  (this.texture.wrapS = t);
              },
            },
            wrapT: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
                  ),
                  this.texture.wrapT
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
                ),
                  (this.texture.wrapT = t);
              },
            },
            magFilter: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
                  ),
                  this.texture.magFilter
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
                ),
                  (this.texture.magFilter = t);
              },
            },
            minFilter: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
                  ),
                  this.texture.minFilter
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
                ),
                  (this.texture.minFilter = t);
              },
            },
            anisotropy: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
                  ),
                  this.texture.anisotropy
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
                ),
                  (this.texture.anisotropy = t);
              },
            },
            offset: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
                  ),
                  this.texture.offset
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
                ),
                  (this.texture.offset = t);
              },
            },
            repeat: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
                  ),
                  this.texture.repeat
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
                ),
                  (this.texture.repeat = t);
              },
            },
            format: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .format is now .texture.format.',
                  ),
                  this.texture.format
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .format is now .texture.format.',
                ),
                  (this.texture.format = t);
              },
            },
            type: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .type is now .texture.type.',
                  ),
                  this.texture.type
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .type is now .texture.type.',
                ),
                  (this.texture.type = t);
              },
            },
            generateMipmaps: {
              get: function () {
                return (
                  console.warn(
                    'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
                  ),
                  this.texture.generateMipmaps
                );
              },
              set: function (t) {
                console.warn(
                  'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
                ),
                  (this.texture.generateMipmaps = t);
              },
            },
          }),
          (td.prototype.load = function (t) {
            console.warn(
              'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.',
            );
            const e = this;
            return (
              new Uh().load(t, function (t) {
                e.setBuffer(t);
              }),
              this
            );
          }),
          (od.prototype.getData = function () {
            return (
              console.warn(
                'THREE.AudioAnalyser: .getData() is now .getFrequencyData().',
              ),
              this.getFrequencyData()
            );
          }),
          (_a.prototype.updateCubeMap = function (t, e) {
            return (
              console.warn(
                'THREE.CubeCamera: .updateCubeMap() is now .update().',
              ),
              this.update(t, e)
            );
          }),
          (_a.prototype.clear = function (t, e, n, i) {
            return (
              console.warn(
                'THREE.CubeCamera: .clear() is now .renderTarget.clear().',
              ),
              this.renderTarget.clear(t, e, n, i)
            );
          }),
          (Gn.crossOrigin = void 0),
          (Gn.loadTexture = function (t, e, n, i) {
            console.warn(
              'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.',
            );
            const r = new Du();
            r.setCrossOrigin(this.crossOrigin);
            const a = r.load(t, n, void 0, i);
            return e && (a.mapping = e), a;
          }),
          (Gn.loadTextureCube = function (t, e, n, i) {
            console.warn(
              'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.',
            );
            const r = new ku();
            r.setCrossOrigin(this.crossOrigin);
            const a = r.load(t, n, void 0, i);
            return e && (a.mapping = e), a;
          }),
          (Gn.loadCompressedTexture = function () {
            console.error(
              'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.',
            );
          }),
          (Gn.loadCompressedTextureCube = function () {
            console.error(
              'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.',
            );
          });
        const xf = {
          createMultiMaterialObject: function () {
            console.error(
              'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js',
            );
          },
          detach: function () {
            console.error(
              'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js',
            );
          },
          attach: function () {
            console.error(
              'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js',
            );
          },
        };
        function bf() {
          console.error(
            'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js',
          );
        }
        'undefined' != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent('register', { detail: { revision: i } }),
          ),
          'undefined' != typeof window &&
            (window.__THREE__
              ? console.warn(
                  'WARNING: Multiple instances of Three.js being imported.',
                )
              : (window.__THREE__ = i));
      },
      10: function (t, e, n) {
        'use strict';
        var i = n(30);
        function r(t) {
          return t.startsWith('TMS');
        }
        function a(t) {
          return t.startsWith('EPSG');
        }
        function o(t) {
          return a(t) ? t : 'EPSG:'.concat(t.match(/\d+/)[0]);
        }
        i.default.defs(
          'EPSG:4978',
          '+proj=geocent +datum=WGS84 +units=m +no_defs',
        );
        var s = { DEGREE: 1, METER: 2 };
        function l(t) {
          return 'EPSG:4326' === t;
        }
        function c(t) {
          switch (t) {
            case 'EPSG:4326':
              return s.DEGREE;
            case 'EPSG:4978':
              return s.METER;
            default:
              var e = i.default.defs(o(t));
              if (!e) return;
              return 'degrees' === (n = e.units)
                ? s.DEGREE
                : 'm' === n
                ? s.METER
                : void 0;
          }
          var n;
        }
        function u(t) {
          var e = c(t);
          if (void 0 === t || void 0 === e)
            throw new Error("Invalid crs parameter value '".concat(t, "'"));
          return e;
        }
        e.a = {
          UNIT: s,
          isValid: function (t) {
            u(t);
          },
          isGeographic: function (t) {
            return u(t) == s.DEGREE;
          },
          isMetricUnit: function (t) {
            return c(t) == s.METER;
          },
          toUnit: c,
          is4326: l,
          reasonnableEpsilon: function (t) {
            return l(t) ? 0.01 : 0.001;
          },
          formatToEPSG: o,
          formatToTms: function (t) {
            return r(t) ? t : 'TMS:'.concat(t.match(/\d+/)[0]);
          },
          isTms: r,
          isEpsg: a,
          tms_3857: 'TMS:3857',
          tms_4326: 'TMS:4326',
          defs: function (t, e) {
            return i.default.defs(t, e);
          },
        };
      },
      105: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return u;
        });
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(0),
          l = n(8),
          c = n(37),
          u = { PERSPECTIVE: 0, ORTHOGRAPHIC: 1 },
          h = {
            frustum: new s.Frustum(),
            matrix: new s.Matrix4(),
            box3: new s.Box3(),
          },
          d = new s.Box3(new s.Vector3(-1, -1, -1), new s.Vector3(1, 1, 1));
        function p(t, e, n) {
          if (t.camera3D.isOrthographicCamera) t._preSSE = e;
          else {
            var i = s.MathUtils.degToRad(n);
            t._preSSE = e / (2 * Math.tan(0.5 * i));
          }
        }
        var f = (function () {
            function t(e, n, i) {
              var a = this,
                o =
                  arguments.length > 3 && void 0 !== arguments[3]
                    ? arguments[3]
                    : {};
              if ((r()(this, t), (this.crs = e), o.isCamera))
                console.warn(
                  'options.camera parameter is deprecated. Use options.camera.cameraThree to place a custom camera as a parameter. See the documentation of Camera.',
                ),
                  (this.camera3D = o);
              else if (o.cameraThree) this.camera3D = o.cameraThree;
              else
                switch (o.type) {
                  case u.ORTHOGRAPHIC:
                    this.camera3D = new s.OrthographicCamera();
                    break;
                  case u.PERSPECTIVE:
                  default:
                    this.camera3D = new s.PerspectiveCamera(30);
                }
              if (
                ((this.camera3D.aspect =
                  void 0 !== this.camera3D.aspect ? this.camera3D.aspect : 1),
                (this._viewMatrix = new s.Matrix4()),
                (this.width = n),
                (this.height = i),
                (this._viewMatrixNeedsUpdate = !0),
                this.resize(n, i),
                (this._preSSE = 1 / 0),
                this.camera3D.isPerspectiveCamera)
              ) {
                var l = this.camera3D.fov;
                Object.defineProperty(this.camera3D, 'fov', {
                  get: function () {
                    return l;
                  },
                  set: function (t) {
                    (l = t), p(a, a.height, l);
                  },
                });
              }
            }
            return (
              o()(t, [
                {
                  key: 'resize',
                  value: function (t, e) {
                    var n = t / e;
                    if (this.camera3D.aspect !== n) {
                      if (this.camera3D.isOrthographicCamera) {
                        this.camera3D.zoom *= this.width / t;
                        var i = (this.camera3D.top * this.camera3D.aspect) / n;
                        (this.camera3D.bottom = -i), (this.camera3D.top = i);
                      } else
                        this.camera3D.isPerspectiveCamera &&
                          (this.camera3D.fov =
                            2 *
                            s.Math.radToDeg(
                              Math.atan(
                                (e / this.height) *
                                  Math.tan(
                                    s.Math.degToRad(this.camera3D.fov) / 2,
                                  ),
                              ),
                            ));
                      this.camera3D.aspect = n;
                    }
                    (this.width = t),
                      (this.height = e),
                      p(this, this.height, this.camera3D.fov),
                      this.camera3D.updateProjectionMatrix &&
                        (this.camera3D.updateProjectionMatrix(),
                        (this._viewMatrixNeedsUpdate = !0));
                  },
                },
                {
                  key: 'update',
                  value: function () {
                    this.camera3D.updateMatrixWorld(),
                      (this._viewMatrixNeedsUpdate = !0);
                  },
                },
                {
                  key: 'position',
                  value: function (t) {
                    return new l.a(this.crs, this.camera3D.position).as(
                      t || this.crs,
                    );
                  },
                },
                {
                  key: 'setPosition',
                  value: function (t) {
                    this.camera3D.position.copy(t.as(this.crs));
                  },
                },
                {
                  key: 'isBox3Visible',
                  value: function (t, e) {
                    return this.box3SizeOnScreen(t, e).intersectsBox(d);
                  },
                },
                {
                  key: 'isSphereVisible',
                  value: function (t, e) {
                    return (
                      this._viewMatrixNeedsUpdate &&
                        (this._viewMatrix.multiplyMatrices(
                          this.camera3D.projectionMatrix,
                          this.camera3D.matrixWorldInverse,
                        ),
                        (this._viewMatrixNeedsUpdate = !1)),
                      e
                        ? (h.matrix.multiplyMatrices(this._viewMatrix, e),
                          h.frustum.setFromProjectionMatrix(h.matrix))
                        : h.frustum.setFromProjectionMatrix(this._viewMatrix),
                      h.frustum.intersectsSphere(t)
                    );
                  },
                },
                {
                  key: 'box3SizeOnScreen',
                  value: function (t, e) {
                    var n = (function (t, e, n) {
                      var i = t.camera3D.matrixWorldInverse;
                      n &&
                        (i = h.matrix.multiplyMatrices(
                          t.camera3D.matrixWorldInverse,
                          n,
                        ));
                      m[0].set(e.min.x, e.min.y, e.min.z).applyMatrix4(i),
                        m[1].set(e.min.x, e.min.y, e.max.z).applyMatrix4(i),
                        m[2].set(e.min.x, e.max.y, e.min.z).applyMatrix4(i),
                        m[3].set(e.min.x, e.max.y, e.max.z).applyMatrix4(i),
                        m[4].set(e.max.x, e.min.y, e.min.z).applyMatrix4(i),
                        m[5].set(e.max.x, e.min.y, e.max.z).applyMatrix4(i),
                        m[6].set(e.max.x, e.max.y, e.min.z).applyMatrix4(i),
                        m[7].set(e.max.x, e.max.y, e.max.z).applyMatrix4(i);
                      for (var r = !1, a = 0; a < 8; a++)
                        m[a].z <= -t.camera3D.near
                          ? (r = !0)
                          : (m[a].z = -t.camera3D.near);
                      return r ? m : void 0;
                    })(this, t, e);
                    if (!n) return h.box3.makeEmpty();
                    for (var i = 0; i < 8; i++)
                      n[i].applyMatrix4(this.camera3D.projectionMatrix);
                    return h.box3.setFromPoints(n);
                  },
                },
                {
                  key: 'adjustAltitudeToAvoidCollisionWithLayer',
                  value: function (t, e, n) {
                    var i = t.camera.position().as('EPSG:4326');
                    if (void 0 !== e) {
                      var r = c.a.getElevationValueAt(e, i);
                      if (void 0 !== r)
                        i.altitude - (r + n) < 0 &&
                          ((i.altitude = r + n),
                          t.camera.camera3D.position.copy(i.as(t.referenceCrs)),
                          t.notifyChange(this.camera3D));
                    }
                  },
                },
              ]),
              t
            );
          })(),
          m = [
            new s.Vector3(),
            new s.Vector3(),
            new s.Vector3(),
            new s.Vector3(),
            new s.Vector3(),
            new s.Vector3(),
            new s.Vector3(),
            new s.Vector3(),
          ];
        e.b = f;
      },
      106: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return s;
        });
        var i = n(24);
        function r(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return a(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return a(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var o,
            s = !0,
            l = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (s = t.done), t;
            },
            e: function (t) {
              (l = !0), (o = t);
            },
            f: function () {
              try {
                s || null == n.return || n.return();
              } finally {
                if (l) throw o;
              }
            },
          };
        }
        function a(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function o(t, e) {
          var n,
            a = i.a.getColorLayersIdOrderedBySequence(e),
            o = function (t) {
              t.material && t.material.setSequence && t.material.setSequence(a);
            },
            s = r(t.level0Nodes);
          try {
            for (s.s(); !(n = s.n()).done; ) {
              n.value.traverse(o);
            }
          } catch (t) {
            s.e(t);
          } finally {
            s.f();
          }
        }
        var s = 'layers-order-changed';
        e.b = {
          moveLayerUp: function (t, e) {
            var n = t.getLayers(function (t) {
                return t.isColorLayer;
              }),
              r = t.getLayerById(e);
            if (!r) throw new Error(''.concat(e, " isn't color layer"));
            var a = i.a.getColorLayersIdOrderedBySequence(n);
            i.a.moveLayerUp(r, n),
              o(t.tileLayer, n),
              t.dispatchEvent({
                type: s,
                previous: { sequence: a },
                new: { sequence: i.a.getColorLayersIdOrderedBySequence(n) },
              }),
              t.notifyChange(t.tileLayer);
          },
          moveLayerDown: function (t, e) {
            var n = t.getLayers(function (t) {
                return t.isColorLayer;
              }),
              r = t.getLayerById(e);
            if (!r) throw new Error(''.concat(e, " isn't color layer"));
            var a = i.a.getColorLayersIdOrderedBySequence(n);
            i.a.moveLayerDown(r, n),
              o(t.tileLayer, n),
              t.dispatchEvent({
                type: s,
                previous: { sequence: a },
                new: { sequence: i.a.getColorLayersIdOrderedBySequence(n) },
              }),
              t.notifyChange(t.tileLayer);
          },
          moveLayerToIndex: function (t, e, n) {
            var r = t.getLayers(function (t) {
                return t.isColorLayer;
              }),
              a = t.getLayerById(e);
            if (!a) throw new Error(''.concat(e, " isn't color layer"));
            var l = i.a.getColorLayersIdOrderedBySequence(r);
            i.a.moveLayerToIndex(a, n, r),
              o(t.tileLayer, r),
              t.dispatchEvent({
                type: s,
                previous: { sequence: l },
                new: { sequence: i.a.getColorLayersIdOrderedBySequence(r) },
              }),
              t.notifyChange(t.tileLayer);
          },
        };
      },
      107: function (t, e, n) {
        'use strict';
        var i = n(85),
          r = n(45),
          a = n(41);
        e.a = {
          parse: function (t, e) {
            return (e = Object(a.c)(e)), r.a.parse(Object(i.kml)(t), e);
          },
        };
      },
      108: function (t, e, n) {
        'use strict';
        var i = n(85),
          r = n(45),
          a = n(41);
        e.a = {
          parse: function (t, e) {
            return (e = Object(a.c)(e)), r.a.parse(Object(i.gpx)(t), e);
          },
        };
      },
      109: function (t, e, n) {
        'use strict';
        var i = n(16);
        function r(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return a(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return a(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var o,
            s = !0,
            l = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (s = t.done), t;
            },
            e: function (t) {
              (l = !0), (o = t);
            },
            f: function () {
              try {
                s || null == n.return || n.return();
              } finally {
                if (l) throw o;
              }
            },
          };
        }
        function a(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function o(t, e, n, r, a, o, s) {
          if (
            e == i.a.LINE &&
            (function (t, e, n, i, r, a) {
              for (
                var o = t.x, s = t.y, l = i + a, c = i;
                l < i + r;
                c = l, l += a
              ) {
                var u = e[l],
                  h = e[l + 1],
                  d = e[c],
                  p = e[c + 1],
                  f = d - u,
                  m = p - h,
                  g = Math.sqrt(f * f + m * m),
                  y = ((o - u) * f + (s - h) * m) / g;
                if (y >= -n && y <= g + n)
                  if (Math.abs(m * o - f * s + d * h - p * u) / g <= n)
                    return !0;
              }
              return !1;
            })(t, n, r, a, o, s)
          )
            return !0;
          if (
            e == i.a.POLYGON &&
            (function (t, e, n, i, r) {
              for (
                var a = t.x, o = t.y, s = !1, l = n, c = n + i - r;
                l < n + i;
                c = l, l += r
              ) {
                var u = e[l],
                  h = e[l + 1],
                  d = e[c],
                  p = e[c + 1];
                h > o != p > o &&
                  a < ((d - u) * (o - h)) / (p - h) + u &&
                  (s = !s);
              }
              return s;
            })(t, n, a, o, s)
          )
            return !0;
          if (e == i.a.POINT) {
            var l = (function (t, e, n, i, r, a) {
              for (
                var o, s = t.x, l = t.y, c = n * n, u = i;
                u < i + r;
                u += a
              ) {
                var h = s - e[u],
                  d = l - e[u + 1],
                  p = h * h + d * d;
                p < c && ((o = [e[u], e[u + 1]]), (c = p));
              }
              return o;
            })(t, n, r, a, o, s);
            if (l) return { coordinates: l };
          }
        }
        function s(t, e, n, i) {
          var a,
            s = t.as(e.crs),
            l = r(e.geometries);
          try {
            for (l.s(); !(a = l.n()).done; ) {
              var c = a.value;
              if (null == c.extent || c.extent.isPointInside(s, n)) {
                var u = c.indices[0].offset * e.size,
                  h = c.indices[0].count * e.size,
                  d = o(s, e.type, e.vertices, n, u, h, e.size);
                d &&
                  i.push({
                    type: e.type,
                    geometry: c,
                    coordinates: d.coordinates,
                    style: e.style,
                  });
              }
            }
          } catch (t) {
            l.e(t);
          } finally {
            l.f();
          }
        }
        var l = new (n(8).a)('EPSG:4326', 0, 0, 0);
        e.a = {
          filterFeaturesUnderCoordinate: function (t, e) {
            var n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0.1,
              i = [];
            if (
              (t.as(e.crs, l),
              l.applyMatrix4(e.matrixWorldInverse),
              e.extent.isPointInside(l, n))
            )
              if (e.isFeatureCollection) {
                n *= Math.sqrt(Math.pow(e.scale.x, 2) + Math.pow(e.scale.y, 2));
                var a,
                  o = r(e.features);
                try {
                  for (o.s(); !(a = o.n()).done; ) {
                    var c = a.value;
                    (c.extent && !c.extent.isPointInside(l, n)) ||
                      s(l, c, n, i);
                  }
                } catch (t) {
                  o.e(t);
                } finally {
                  o.f();
                }
              } else e.geometries && s(l, e, n, i);
            return i;
          },
        };
      },
      11: function (t, e, n) {
        'use strict';
        n.d(e, 'b', function () {
          return S;
        }),
          n.d(e, 'c', function () {
            return T;
          });
        var i,
          r,
          a = n(3),
          o = n.n(a),
          s = n(4),
          l = n.n(s),
          c = n(0),
          u = n(8),
          h = n(10),
          d = new c.Vector2(),
          p = new c.Vector2(),
          f = new c.Vector2(),
          m = new c.Vector2(),
          g = new c.Vector2(),
          y = new c.Vector2(2, 2),
          v = { row: 0, col: 0, invDiff: 0 },
          x = new c.Vector3(),
          b = new c.Vector3();
        function _(t, e) {
          var n = t.zoom - e,
            i = Math.pow(2, n);
          return (
            (v.invDiff = 1 / i),
            (v.row = (t.row - (t.row % i)) * v.invDiff),
            (v.col = (t.col - (t.col % i)) * v.invDiff),
            v
          );
        }
        for (var w = new Array(8), M = w.length - 1; M >= 0; M--)
          w[M] = new u.a('EPSG:4326', 0, 0, 0, 0);
        var q = new u.a('EPSG:4326', 0, 0),
          S = new Map(),
          T = new Map();
        function E(t) {
          var e = h.a.formatToEPSG(t),
            n = S.get(e),
            i = n.dimensions(p),
            r = h.a.formatToTms(t);
          return {
            epsg: e,
            globalExtent: n,
            globalDimension: i,
            sTs: T.get(r) || T.get('default'),
            isInverted: !r.includes(':NI'),
          };
        }
        function A(t, e) {
          var n = T.get(h.a.formatToTms(t)) || T.get('default'),
            i = Math.pow(2, e);
          return f.set(i, i).multiply(n), f;
        }
        var L = (function () {
          function t(e, n, i, r, a) {
            o()(this, t),
              (this.isExtent = !0),
              (this.crs = e),
              (this.zoom = 0),
              h.a.isTms(this.crs)
                ? ((this.row = 0), (this.col = 0))
                : ((this.west = 0),
                  (this.east = 0),
                  (this.south = 0),
                  (this.north = 0)),
              this.set(n, i, r, a);
          }
          return (
            l()(
              t,
              [
                {
                  key: 'clone',
                  value: function () {
                    return h.a.isTms(this.crs)
                      ? new t(this.crs, this.zoom, this.row, this.col)
                      : new t(
                          this.crs,
                          this.west,
                          this.east,
                          this.south,
                          this.north,
                        );
                  },
                },
                {
                  key: 'tiledCovering',
                  value: function (e) {
                    if ('EPSG:4326' == this.crs && e == h.a.tms_3857) {
                      var n = [],
                        a = i.copy(this).as(h.a.formatToEPSG(e), r),
                        o = E(h.a.formatToEPSG(e)),
                        s = o.globalExtent,
                        l = o.globalDimension,
                        c = o.sTs;
                      a.clampByExtent(s), a.dimensions(g);
                      var u =
                          this.zoom + 1 ||
                          Math.floor(Math.log2(Math.round(l.x / (g.x * c.x)))),
                        d = A(e, u),
                        p = a.center(q);
                      (m.x = p.x - s.west),
                        (m.y = s.north - a.north),
                        m.divide(l).multiply(d).floor();
                      for (
                        var f =
                          Math.ceil(((s.north - a.south) / l.x) * d.y) - 1;
                        f >= m.y;
                        f--
                      )
                        n.push(new t(e, u, f, m.x));
                      return n;
                    }
                    var y = new t(e, 0, 0, 0),
                      v = E(this.crs),
                      x = v.globalExtent,
                      b = v.globalDimension,
                      _ = v.sTs,
                      w = v.isInverted,
                      M = this.center(q);
                    this.dimensions(g);
                    var S = Math.floor(
                        Math.log2(Math.round(b.x / (g.x * _.x))),
                      ),
                      T = A(e, S);
                    return (
                      (m.x = M.x - x.west),
                      (m.y = w ? x.north - M.y : M.y - x.south),
                      m.divide(b).multiply(T).floor(),
                      y.set(S, m.y, m.x),
                      [y]
                    );
                  },
                },
                {
                  key: 'as',
                  value: function (e, n) {
                    if (
                      (h.a.isValid(e),
                      (n = n || new t('EPSG:4326', [0, 0, 0, 0])),
                      h.a.isTms(this.crs))
                    ) {
                      var i = E(this.crs),
                        r = i.epsg,
                        a = i.globalExtent,
                        o = i.globalDimension,
                        s = A(this.crs, this.zoom);
                      return (
                        g.set(1, 1).divide(s).multiply(o),
                        (n.west = a.west + (o.x - g.x * (s.x - this.col))),
                        (n.east = n.west + g.x),
                        (n.south = a.south + g.y * (s.y - this.row - 1)),
                        (n.north = n.south + g.y),
                        (n.crs = r),
                        (n.zoom = this.zoom),
                        e == r ? n : n.as(e, n)
                      );
                    }
                    if (h.a.isEpsg(e)) {
                      if (this.crs != e) {
                        var l = this.center(q);
                        w[0].setFromValues(this.west, this.north),
                          w[1].setFromValues(l.x, this.north),
                          w[2].setFromValues(this.east, this.north),
                          w[3].setFromValues(this.east, l.y),
                          w[4].setFromValues(this.east, this.south),
                          w[5].setFromValues(l.x, this.south),
                          w[6].setFromValues(this.west, this.south),
                          w[7].setFromValues(this.west, l.y),
                          n.set(1 / 0, -1 / 0, 1 / 0, -1 / 0);
                        for (var c = 0; c < w.length; c++)
                          (w[c].crs = this.crs),
                            w[c].as(e, q),
                            (n.north = Math.max(n.north, q.y)),
                            (n.south = Math.min(n.south, q.y)),
                            (n.east = Math.max(n.east, q.x)),
                            (n.west = Math.min(n.west, q.x));
                        return (n.zoom = this.zoom), (n.crs = e), n;
                      }
                      return (
                        (n.crs = e),
                        (n.zoom = this.zoom),
                        n.set(this.west, this.east, this.south, this.north),
                        n
                      );
                    }
                  },
                },
                {
                  key: 'center',
                  value: function () {
                    var t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : new u.a(this.crs);
                    if (h.a.isTms(this.crs))
                      throw new Error('Invalid operation for WMTS bbox');
                    return (
                      this.dimensions(d),
                      (t.crs = this.crs),
                      t.setFromValues(
                        this.west + 0.5 * d.x,
                        this.south + 0.5 * d.y,
                      ),
                      t
                    );
                  },
                },
                {
                  key: 'dimensions',
                  value: function () {
                    var t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : new c.Vector2();
                    return (
                      (t.x = Math.abs(this.east - this.west)),
                      (t.y = Math.abs(this.north - this.south)),
                      t
                    );
                  },
                },
                {
                  key: 'isPointInside',
                  value: function (t) {
                    var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                    return (
                      this.crs == t.crs ? q.copy(t) : t.as(this.crs, q),
                      q.x <= this.east + e &&
                        q.x >= this.west - e &&
                        q.y <= this.north + e &&
                        q.y >= this.south - e
                    );
                  },
                },
                {
                  key: 'isInside',
                  value: function (t, e) {
                    return h.a.isTms(this.crs)
                      ? this.zoom == t.zoom
                        ? this.row == t.row && this.col == t.col
                        : !(this.zoom < t.zoom) &&
                          (_(this, t.zoom), v.row == t.row && v.col == t.col)
                      : (t.as(this.crs, i),
                        (e = null == e ? h.a.reasonnableEpsilon(this.crs) : e),
                        this.east - i.east <= e &&
                          i.west - this.west <= e &&
                          this.north - i.north <= e &&
                          i.south - this.south <= e);
                  },
                },
                {
                  key: 'offsetToParent',
                  value: function (t) {
                    var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new c.Vector4();
                    if (this.crs != t.crs) throw new Error('unsupported mix');
                    if (h.a.isTms(this.crs))
                      return (
                        _(this, t.zoom),
                        e.set(
                          this.col * v.invDiff - v.col,
                          this.row * v.invDiff - v.row,
                          v.invDiff,
                          v.invDiff,
                        )
                      );
                    t.dimensions(d), this.dimensions(p);
                    var n = (this.west - t.west) / d.x,
                      i = (t.north - this.north) / d.y,
                      r = p.x / d.x,
                      a = p.y / d.y;
                    return e.set(n, i, r, a);
                  },
                },
                {
                  key: 'tiledExtentParent',
                  value: function (e) {
                    return e && e < this.zoom
                      ? (_(this, e), new t(this.crs, e, v.row, v.col))
                      : this;
                  },
                },
                {
                  key: 'intersectsExtent',
                  value: function (t) {
                    var e = t.crs == this.crs ? t : t.as(this.crs, i);
                    return !(
                      this.west >= e.east ||
                      this.east <= e.west ||
                      this.south >= e.north ||
                      this.north <= e.south
                    );
                  },
                },
                {
                  key: 'intersect',
                  value: function (e) {
                    return this.intersectsExtent(e)
                      ? (e.crs != this.crs && (e = e.as(this.crs, i)),
                        new t(
                          this.crs,
                          Math.max(this.west, e.west),
                          Math.min(this.east, e.east),
                          Math.max(this.south, e.south),
                          Math.min(this.north, e.north),
                        ))
                      : new t(this.crs, 0, 0, 0, 0);
                  },
                },
                {
                  key: 'set',
                  value: function (t, e, n, i) {
                    if (null == t)
                      throw new Error('No values to set in the extent');
                    return (
                      t.isExtent &&
                        (h.a.isTms(t.crs)
                          ? ((e = t.row), (n = t.col), (t = t.zoom))
                          : ((e = t.east),
                            (n = t.south),
                            (i = t.north),
                            (t = t.west))),
                      h.a.isTms(this.crs)
                        ? ((this.zoom = t), (this.row = e), (this.col = n))
                        : t.isCoordinates
                        ? ((this.west = t.x),
                          (this.east = e.x),
                          (this.south = t.y),
                          (this.north = e.y))
                        : void 0 !== t.west
                        ? ((this.west = t.west),
                          (this.east = t.east),
                          (this.south = t.south),
                          (this.north = t.north))
                        : 4 == t.length
                        ? ((this.west = t[0]),
                          (this.east = t[1]),
                          (this.south = t[2]),
                          (this.north = t[3]))
                        : void 0 !== i &&
                          ((this.west = t),
                          (this.east = e),
                          (this.south = n),
                          (this.north = i)),
                      this
                    );
                  },
                },
                {
                  key: 'copy',
                  value: function (t) {
                    return (this.crs = t.crs), this.set(t);
                  },
                },
                {
                  key: 'union',
                  value: function (t) {
                    if (t.crs != this.crs)
                      throw new Error('unsupported union between 2 diff crs');
                    if (this.west === 1 / 0) this.copy(t);
                    else {
                      var e = t.west;
                      e < this.west && (this.west = e);
                      var n = t.east;
                      n > this.east && (this.east = n);
                      var i = t.south;
                      i < this.south && (this.south = i);
                      var r = t.north;
                      r > this.north && (this.north = r);
                    }
                  },
                },
                {
                  key: 'expandByCoordinates',
                  value: function (t) {
                    var e = t.crs == this.crs ? t : t.as(this.crs, q);
                    this.expandByValuesCoordinates(e.x, e.y);
                  },
                },
                {
                  key: 'expandByValuesCoordinates',
                  value: function (t, e) {
                    t < this.west && (this.west = t),
                      t > this.east && (this.east = t),
                      e < this.south && (this.south = e),
                      e > this.north && (this.north = e);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : '';
                    return h.a.isTms(this.crs)
                      ? ''
                          .concat(this.zoom)
                          .concat(t)
                          .concat(this.row)
                          .concat(t)
                          .concat(this.col)
                      : ''
                          .concat(this.east)
                          .concat(t)
                          .concat(this.north)
                          .concat(t)
                          .concat(this.west)
                          .concat(t)
                          .concat(this.south);
                  },
                },
                {
                  key: 'subdivision',
                  value: function () {
                    return this.subdivisionByScheme();
                  },
                },
                {
                  key: 'subdivisionByScheme',
                  value: function () {
                    for (
                      var e =
                          arguments.length > 0 && void 0 !== arguments[0]
                            ? arguments[0]
                            : y,
                        n = [],
                        i = this.dimensions(d).divide(e),
                        r = e.x - 1;
                      r >= 0;
                      r--
                    )
                      for (var a = e.y - 1; a >= 0; a--) {
                        var o = this.west + r * i.x,
                          s = this.south + a * i.y;
                        n.push(new t(this.crs, o, o + i.x, s, s + i.y));
                      }
                    return n;
                  },
                },
                {
                  key: 'applyMatrix4',
                  value: function (t) {
                    if (!h.a.isTms(this.crs)) {
                      if (
                        (x.set(this.west, this.south).applyMatrix4(t),
                        b.set(this.east, this.north).applyMatrix4(t),
                        (this.west = x.x),
                        (this.east = b.x),
                        (this.south = x.y),
                        (this.north = b.y),
                        this.west > this.east)
                      ) {
                        var e = this.west;
                        (this.west = this.east), (this.east = e);
                      }
                      if (this.south > this.north) {
                        var n = this.south;
                        (this.south = this.north), (this.north = n);
                      }
                      return this;
                    }
                  },
                },
                {
                  key: 'clampSouthNorth',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : this.south,
                      e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : this.north;
                    return (
                      (this.south = Math.max(this.south, t)),
                      (this.north = Math.min(this.north, e)),
                      this
                    );
                  },
                },
                {
                  key: 'clampWestEast',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : this.west,
                      e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : this.east;
                    return (
                      (this.west = Math.max(this.west, t)),
                      (this.east = Math.min(this.east, e)),
                      this
                    );
                  },
                },
                {
                  key: 'clampByExtent',
                  value: function (t) {
                    return (
                      this.clampSouthNorth(t.south, t.north),
                      this.clampWestEast(t.west, t.east)
                    );
                  },
                },
              ],
              [
                {
                  key: 'fromBox3',
                  value: function (e, n) {
                    return new t(e, {
                      west: n.min.x,
                      east: n.max.x,
                      south: n.min.y,
                      north: n.max.y,
                    });
                  },
                },
              ],
            ),
            t
          );
        })();
        (i = new L('EPSG:4326', [0, 0, 0, 0])),
          (r = new L('EPSG:4326', [0, 0, 0, 0])),
          S.set('EPSG:4326', new L('EPSG:4326', -180, 180, -90, 90));
        var R = S.get('EPSG:4326').as('EPSG:3857');
        R.clampSouthNorth(R.west, R.east),
          S.set('EPSG:3857', R),
          T.set('default', new c.Vector2(1, 1)),
          T.set(h.a.tms_3857, T.get('default')),
          T.set(h.a.tms_4326, new c.Vector2(2, 1)),
          (e.a = L);
      },
      110: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(6),
          l = n.n(s),
          c = n(7),
          u = n.n(c),
          h = n(2),
          d = n.n(h),
          p = n(0),
          f = n(77),
          m = n(59),
          g = n(24),
          y = n(8),
          v = n(11),
          x = n(111),
          b = n(16);
        function _(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = d()(t);
            if (e) {
              var r = d()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return u()(this, n);
          };
        }
        var w = new y.a('EPSG:4326', 0, 0, 0),
          M = new v.a('EPSG:4326', 0, 0, 0, 0),
          q = (function (t) {
            l()(n, t);
            var e = _(n);
            function n(t) {
              var i,
                a =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {};
              return (
                r()(this, n),
                ((i = e.call(this, t, a)).isLabelLayer = !0),
                (i.domElement = document.createElement('div')),
                (i.domElement.id = 'itowns-label-'.concat(i.id)),
                i.defineLayerProperty('visible', !0, function () {
                  i.domElement.style.display = i.visible ? 'block' : 'none';
                }),
                (i.buildExtent = !0),
                i
              );
            }
            return (
              o()(n, [
                {
                  key: 'convert',
                  value: function (t, e) {
                    var n = this,
                      i = [],
                      r =
                        this.style && this.style.text && this.style.text.field;
                    e.as(t.crs, M), (w.crs = t.crs);
                    var a = { zoom: e.zoom };
                    return (
                      t.features.forEach(function (e) {
                        if (e.type === b.a.POINT) {
                          var o = e.style && e.style.text.field;
                          e.geometries.forEach(function (s) {
                            if (
                              (w.setFromArray(
                                e.vertices,
                                s.size * s.indices[0].offset,
                              ),
                              w.applyMatrix4(t.matrixWorld),
                              2 == e.size && (w.z = 0),
                              M.isPointInside(w))
                            ) {
                              var l,
                                c =
                                  s.properties.style &&
                                  s.properties.style.text.field,
                                u = {
                                  globals: a,
                                  properties: function () {
                                    return s.properties;
                                  },
                                };
                              if (c || o || r)
                                c
                                  ? (l =
                                      s.properties.style.getTextFromProperties(
                                        u,
                                      ))
                                  : o
                                  ? (l = e.style.getTextFromProperties(u))
                                  : r && (l = n.style.getTextFromProperties(u));
                              else if (
                                !(
                                  (s.properties.style &&
                                    s.properties.style.icon) ||
                                  (e.style && e.style.icon) ||
                                  (n.style && n.style.icon)
                                )
                              )
                                return;
                              var h = (
                                  s.properties.style ||
                                  e.style ||
                                  n.style
                                ).symbolStylefromContext(u),
                                d = new x.a(l, w.clone(), h, n.source.sprites);
                              (d.layerId = n.id),
                                2 == e.size && (d.needsAltitude = !0),
                                i.push(d);
                            }
                          });
                        }
                      }),
                      i
                    );
                  },
                },
                { key: 'preUpdate', value: function () {} },
                {
                  key: 'update',
                  value: function (t, e, n, i) {
                    var r = this;
                    if (i || !n.children.length) {
                      if (!this.frozen && n.visible && this.visible) {
                        var a = n.getExtentsByProjection(this.source.crs) || [
                            n.extent,
                          ],
                          o = a[0].zoom;
                        if (!(o < e.zoom.min || o > e.zoom.max)) {
                          void 0 === n.layerUpdateState[this.id] &&
                            (n.layerUpdateState[this.id] = new f.a());
                          var s = n.material.getElevationLayer();
                          if (
                            (s &&
                              n.layerUpdateState[s.id].canTryUpdate() &&
                              n.children.forEach(function (e) {
                                e.isLabel &&
                                  e.needsAltitude &&
                                  e.updateElevationFromLayer(r.parent) &&
                                  e.update3dPosition(t.view.referenceCrs);
                              }),
                            n.layerUpdateState[this.id].canTryUpdate())
                          ) {
                            if (this.source.extentInsideLimit(n.extent, o)) {
                              n.layerUpdateState[this.id].newTry();
                              var l = {
                                layer: this,
                                extentsSource: a,
                                view: t.view,
                                threejsLayer: this.threejsLayer,
                                requester: n,
                              };
                              return t.scheduler.execute(l).then(function (e) {
                                if (e) {
                                  var i =
                                      t.view.mainLoop.gfxEngine.label2dRenderer,
                                    a = [];
                                  if (
                                    (e.forEach(function (e) {
                                      n.parent
                                        ? e.forEach(function (e) {
                                            e.needsAltitude &&
                                              e.updateElevationFromLayer(
                                                r.parent,
                                              ),
                                              n.children.find(function (t) {
                                                return (
                                                  t.isLabel &&
                                                  t.baseContent == e.baseContent
                                                );
                                              }) ||
                                                (n.add(e),
                                                e.update3dPosition(
                                                  t.view.referenceCrs,
                                                ),
                                                n.level < 4 &&
                                                  ((e.horizonCullingPoint =
                                                    new p.Vector3()),
                                                  e.updateHorizonCullingPoint()),
                                                a.push(e.content));
                                          })
                                        : e.forEach(function (t) {
                                            m.a.removeChildrenAndCleanupRecursively(
                                              r,
                                              t,
                                            ),
                                              i.removeLabelDOM(t);
                                          });
                                    }),
                                    a.length > 0)
                                  ) {
                                    var o,
                                      s = n.domElements[r.id];
                                    s ||
                                      ((s = {
                                        dom: document.createElement('div'),
                                        visible: !0,
                                      }),
                                      (n.domElements[r.id] = s)),
                                      (o = s.dom).append.apply(o, a);
                                    var l = n.findClosestDomElement(r.id);
                                    ((l && l.dom) || r.domElement).appendChild(
                                      s.dom,
                                    ),
                                      (s.visible = !0),
                                      e.forEach(function (t) {
                                        return t.forEach(function (t) {
                                          return t.initDimensions();
                                        });
                                      }),
                                      e.forEach(function (t) {
                                        return t.forEach(function (t) {
                                          t.visible = !1;
                                        });
                                      }),
                                      n.children.sort(function (t) {
                                        return t.isLabel ? -t.order : 1;
                                      }),
                                      n.addEventListener(
                                        'removed',
                                        function () {
                                          e.forEach(function (t) {
                                            return t.forEach(function (t) {
                                              return n.remove(t);
                                            });
                                          }),
                                            r.removeNodeDomElement(n);
                                        },
                                      );
                                  }
                                  n.layerUpdateState[
                                    r.id
                                  ].noMoreUpdatePossible();
                                }
                              });
                            }
                            n.layerUpdateState[this.id].noMoreUpdatePossible();
                          }
                        }
                      }
                    } else m.a.removeChildrenAndCleanupRecursively(this, n);
                  },
                },
                {
                  key: 'removeLabelsFromNodeRecursive',
                  value: function (t) {
                    var e = this;
                    t.children.forEach(function (n) {
                      n.isLabel && n.layerId === e.id
                        ? t.remove(n)
                        : n.isTileMesh && e.removeLabelsFromNodeRecursive(n);
                    }),
                      this.removeNodeDomElement(t);
                  },
                },
                {
                  key: 'removeNodeDomElement',
                  value: function (t) {
                    if (t.domElements[this.id]) {
                      var e = t.domElements[this.id].dom;
                      e.parentElement.removeChild(e),
                        delete t.domElements[this.id];
                    }
                  },
                },
                {
                  key: 'delete',
                  value: function () {
                    var t = this;
                    this.domElement.parentElement.removeChild(this.domElement),
                      this.parent.level0Nodes.forEach(function (e) {
                        return t.removeLabelsFromNodeRecursive(e);
                      });
                  },
                },
              ]),
              n
            );
          })(g.b);
        e.a = q;
      },
      111: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(5),
          l = n.n(s),
          c = n(6),
          u = n.n(c),
          h = n(7),
          d = n.n(h),
          p = n(2),
          f = n.n(p),
          m = n(0),
          g = n(37);
        function y(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = f()(t);
            if (e) {
              var r = f()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return d()(this, n);
          };
        }
        var v,
          x = new (n(8).a)('EPSG:4326'),
          b = '';
        b =
          void 0 !== document.documentElement.style.transform
            ? 'transform'
            : void 0 !== document.documentElement.style.webkitTransform
            ? 'webkitTransform'
            : void 0 !== document.documentElement.style.mozTransform
            ? 'mozTransform'
            : void 0 !== document.documentElement.style.oTransform
            ? 'oTransform'
            : 'transform';
        var _ = (function (t) {
          u()(n, t);
          var e = y(n);
          function n() {
            var t,
              i =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : '',
              a = arguments.length > 1 ? arguments[1] : void 0,
              o =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {},
              s = arguments.length > 3 ? arguments[3] : void 0;
            if ((r()(this, n), null == a))
              throw new Error('coordinates are mandatory to add a Label');
            var c = (t = e.call(this)).visible;
            return (
              Object.defineProperty(l()(t), 'visible', {
                set: function (t) {
                  t != c &&
                    ((c = t),
                    (this.content.style.display = t ? 'block' : 'none'));
                },
                get: function () {
                  return c;
                },
              }),
              (t.isLabel = !0),
              (t.coordinates = a),
              (t.projectedPosition = { x: 0, y: 0 }),
              (t.boundaries = { left: 0, right: 0, top: 0, bottom: 0 }),
              (t.content = document.createElement('div')),
              t.content.classList.add('itowns-label'),
              (t.content.style.userSelect = 'none'),
              (t.content.style.position = 'absolute'),
              'string' == typeof i
                ? (t.content.textContent = i)
                : t.content.appendChild(i),
              (t.baseContent = i),
              o.isStyle
                ? ((t.anchor = o.getTextAnchorPosition()),
                  o.text.haloWidth > 0 &&
                    t.content.classList.add('itowns-stroke-single'),
                  o.applyToHTML(t.content, s))
                : (t.anchor = [0, 0]),
              (t.zoom = {
                min: o.zoom && null != o.zoom.min ? o.zoom.min : 2,
                max: o.zoom && null != o.zoom.max ? o.zoom.max : 24,
              }),
              (t.order = o.order || 0),
              (t.padding = 2),
              t
            );
          }
          return (
            o()(n, [
              {
                key: 'updateProjectedPosition',
                value: function (t, e) {
                  var n = Math.round(t),
                    i = Math.round(e);
                  (n == this.projectedPosition.x &&
                    i == this.projectedPosition.y) ||
                    ((this.projectedPosition.x = n),
                    (this.projectedPosition.y = i),
                    (this.boundaries.left =
                      t + this.offset.left - this.padding),
                    (this.boundaries.right =
                      t + this.offset.right + this.padding),
                    (this.boundaries.top = e + this.offset.top - this.padding),
                    (this.boundaries.bottom =
                      e + this.offset.bottom + this.padding));
                },
              },
              {
                key: 'updateCSSPosition',
                value: function () {
                  this.content.style[b] = 'translate('
                    .concat(this.boundaries.left + this.padding, 'px, ')
                    .concat(this.boundaries.top + this.padding, 'px)');
                },
              },
              {
                key: 'initDimensions',
                value: function () {
                  if (!this.offset) {
                    v = this.content.getBoundingClientRect();
                    var t = Math.round(v.width),
                      e = Math.round(v.height);
                    (this.offset = {
                      left: t * this.anchor[0],
                      top: e * this.anchor[1],
                    }),
                      (this.offset.right = this.offset.left + t),
                      (this.offset.bottom = this.offset.top + e);
                  }
                },
              },
              {
                key: 'update3dPosition',
                value: function (t) {
                  this.coordinates.as(t, x),
                    x.toVector3(this.position),
                    this.parent.worldToLocal(this.position),
                    this.updateMatrixWorld();
                },
              },
              {
                key: 'updateElevationFromLayer',
                value: function (t) {
                  var e = g.a.getElevationValueAt(
                    t,
                    this.coordinates,
                    g.a.FAST_READ_Z,
                  );
                  if (e && e != this.coordinates.z)
                    return (
                      (this.coordinates.z = e),
                      this.updateHorizonCullingPoint(),
                      !0
                    );
                },
              },
              {
                key: 'updateHorizonCullingPoint',
                value: function () {
                  this.horizonCullingPoint &&
                    this.getWorldPosition(this.horizonCullingPoint);
                },
              },
            ]),
            n
          );
        })(m.Object3D);
        e.a = _;
      },
      112: function (t, e, n) {
        'use strict';
        n.d(e, 'b', function () {
          return y;
        }),
          n.d(e, 'a', function () {
            return v;
          });
        var i = n(22),
          r = n.n(i),
          a = n(6),
          o = n.n(a),
          s = n(7),
          l = n.n(s),
          c = n(2),
          u = n.n(c),
          h = n(3),
          d = n.n(h),
          p = n(4),
          f = n.n(p),
          m = n(11);
        function g(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = u()(t);
            if (e) {
              var r = u()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return l()(this, n);
          };
        }
        var y = (function () {
            function t(e) {
              d()(this, t), (this.layer = e);
            }
            return (
              f()(t, [
                { key: 'clear', value: function () {} },
                { key: 'update', value: function () {} },
              ]),
              t
            );
          })(),
          v = (function (t) {
            o()(n, t);
            var e = g(n);
            function n(t) {
              var i;
              return (
                d()(this, n),
                ((i = e.call(this, t)).displayed = { tiles: new Set() }),
                Object.defineProperty(i.displayed, 'layers', {
                  get: function () {
                    var t = [];
                    return (
                      i.displayed.tiles.forEach(function (e) {
                        var n = e.material;
                        t = r()(
                          new Set(
                            [].concat(
                              r()(t),
                              r()(
                                n.colorLayerIds.filter(function (t) {
                                  return n.getLayer(t);
                                }),
                              ),
                              r()(n.elevationLayerIds),
                            ),
                          ),
                        );
                      }),
                      i.layer.attachedLayers.filter(function (e) {
                        return t.includes(e.id);
                      })
                    );
                  },
                }),
                Object.defineProperty(i.displayed, 'extent', {
                  get: function () {
                    var t = new m.a(
                      i.layer.extent.crs,
                      1 / 0,
                      -1 / 0,
                      1 / 0,
                      -1 / 0,
                    );
                    return (
                      (t.min = 1 / 0),
                      (t.max = -1 / 0),
                      i.displayed.tiles.forEach(function (e) {
                        t.union(e.extent),
                          (t.min = Math.min(e.obb.z.min, t.min)),
                          (t.max = Math.max(e.obb.z.max, t.max));
                      }),
                      t
                    );
                  },
                }),
                i
              );
            }
            return (
              f()(n, [
                {
                  key: 'clear',
                  value: function () {
                    this.displayed.tiles.clear();
                  },
                },
                {
                  key: 'update',
                  value: function (t) {
                    t.material.visible
                      ? this.displayed.tiles.add(t)
                      : this.displayed.tiles.delete(t);
                  },
                },
              ]),
              n
            );
          })(y);
      },
      113: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(6),
          o = n.n(a),
          s = n(7),
          l = n.n(s),
          c = n(2),
          u = n.n(c),
          h = n(0),
          d = n(114);
        function p(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = u()(t);
            if (e) {
              var r = u()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return l()(this, n);
          };
        }
        function f(t) {
          (t.buildIndexAndUv_0 = !0),
            (t.center = t.builder.center(t.extent).clone());
          var e = Object(d.a)(t);
          (e.index = new h.BufferAttribute(e.index, 1)),
            (e.uvs[0] = new h.BufferAttribute(e.uvs[0], 2)),
            (e.position = new h.BufferAttribute(e.position, 3)),
            (e.normal = new h.BufferAttribute(e.normal, 3));
          for (var n = 1; n < t.builder.uvCount; n++)
            e.uvs[1] = new h.BufferAttribute(e.uvs[1], 1);
          return e;
        }
        var m = (function (t) {
          o()(n, t);
          var e = p(n);
          function n(t) {
            var i,
              a =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : f(t);
            r()(this, n),
              ((i = e.call(this)).center = t.center),
              (i.extent = t.extent),
              i.setIndex(a.index),
              i.setAttribute('position', a.position),
              i.setAttribute('normal', a.normal);
            for (var o = 0; o < a.uvs.length; o++)
              i.setAttribute('uv_'.concat(o), a.uvs[o]);
            return i.computeBoundingBox(), (i.OBB = {}), i;
          }
          return n;
        })(h.BufferGeometry);
        e.a = m;
      },
      114: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return o;
        });
        var i = n(0);
        function r(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return a(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return a(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var o,
            s = !0,
            l = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (s = t.done), t;
            },
            e: function (t) {
              (l = !0), (o = t);
            },
            f: function () {
              try {
                s || null == n.return || n.return();
              } finally {
                if (l) throw o;
              }
            },
          };
        }
        function a(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function o(t) {
          var e = { index: null, position: null, normal: null, uvs: [] },
            n = [],
            a = t.builder,
            o = t.segment || 8,
            s = (o + 1) * (o + 1) + (t.disableSkirt ? 0 : 4 * o);
          if (s > Math.pow(2, 32))
            throw new Error('Tile segments count is too big');
          var l = o * o * 2 + (t.disableSkirt ? 0 : 4 * o * 2);
          (e.position = new Float32Array(3 * s)),
            (e.normal = new Float32Array(3 * s));
          var c = t.builder.uvCount;
          c > 1 && (e.uvs[1] = new Float32Array(s)),
            (n[0] = function () {}),
            t.buildIndexAndUv_0 &&
              (s < Math.pow(2, 8)
                ? (e.index = new Uint8Array(3 * l))
                : s < Math.pow(2, 16)
                ? (e.index = new Uint16Array(3 * l))
                : s < Math.pow(2, 32) && (e.index = new Uint32Array(3 * l)),
              (e.uvs[0] = new Float32Array(2 * s)),
              (n[0] = function (t, n, i) {
                (e.uvs[0][2 * t + 0] = n), (e.uvs[0][2 * t + 1] = i);
              }));
          var u = Math.max(2, Math.floor(o) || 2),
            h = Math.max(2, Math.floor(o) || 2),
            d = 0,
            p = [],
            f = [],
            m = [];
          a.prepare(t);
          for (var g = 0; g <= h; g++) {
            var y = [],
              v = g / h;
            a.vProjecte(v, t),
              c > 1 &&
                (function () {
                  var i = a.computeUvs[1](t);
                  n[1] = function (t) {
                    e.uvs[1][t] = i;
                  };
                })();
            for (var x = 0; x <= u; x++) {
              var b = x / u,
                _ = 3 * d;
              a.uProjecte(b, t);
              var w = a.vertexPosition(t, t.projected),
                M = a.vertexNormal(t);
              w.sub(t.center),
                t.quatNormalToZ &&
                  (w.applyQuaternion(t.quatNormalToZ),
                  M.applyQuaternion(t.quatNormalToZ)),
                w.toArray(e.position, _),
                M.toArray(e.normal, _);
              var q,
                S = r(n);
              try {
                for (S.s(); !(q = S.n()).done; ) {
                  (0, q.value)(d, b, v);
                }
              } catch (t) {
                S.e(t);
              } finally {
                S.f();
              }
              t.disableSkirt ||
                (0 !== g &&
                  g !== h &&
                  (x === u ? f.push(d) : 0 === x && m.push(d))),
                y.push(d),
                d++;
            }
            p.push(y),
              0 === g
                ? (f = f.concat(y))
                : g === h && (f = f.concat(y.slice().reverse()));
          }
          function T(t, n, i, r) {
            return (
              (e.index[r + 0] = t),
              (e.index[r + 1] = n),
              (e.index[r + 2] = i),
              r + 3
            );
          }
          t.disableSkirt || (f = f.concat(m.reverse()));
          var E = 0;
          if (t.buildIndexAndUv_0)
            for (var A = 0; A < h; A++)
              for (var L = 0; L < u; L++) {
                var R = p[A][L + 1],
                  C = p[A][L],
                  P = p[A + 1][L],
                  k = p[A + 1][L + 1];
                (E = T(k, C, R, E)), (E = T(k, P, C, E));
              }
          var I = d;
          if (!t.disableSkirt) {
            var D = new i.Vector3()
                .fromArray(e.position)
                .distanceTo(new i.Vector3().fromArray(e.position, 3)),
              O = function () {},
              N = function () {};
            t.buildIndexAndUv_0 &&
              ((O = function (t, e, n, i, r) {
                return (t = T(e, n, i, t)), (t = T(e, i, r, t));
              }),
              (N = function (t) {
                (e.uvs[0][2 * d + 0] = e.uvs[0][2 * t + 0]),
                  (e.uvs[0][2 * d + 1] = e.uvs[0][2 * t + 1]);
              }));
            for (var z = 0; z < f.length; z++) {
              var F = f[z],
                B = 3 * d,
                U = 3 * F;
              (e.position[B + 0] = e.position[U + 0] - e.normal[U + 0] * D),
                (e.position[B + 1] = e.position[U + 1] - e.normal[U + 1] * D),
                (e.position[B + 2] = e.position[U + 2] - e.normal[U + 2] * D),
                (e.normal[B + 0] = e.normal[U + 0]),
                (e.normal[B + 1] = e.normal[U + 1]),
                (e.normal[B + 2] = e.normal[U + 2]),
                N(F),
                c > 1 && (e.uvs[1][d] = e.uvs[1][F]);
              var j = (z + 1) % f.length;
              (E = O(E, F, d, 0 === j ? I : d + 1, f[j])), d++;
            }
          }
          return e;
        }
      },
      115: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(0),
          l = n(8),
          c = n(11),
          u = Math.PI / 4,
          h = 1 / (2 * Math.PI),
          d = new s.Vector3(0, 0, 1),
          p = new s.Vector3(0, 1, 0),
          f = new s.Quaternion(),
          m = new s.Quaternion(),
          g = new s.Quaternion();
        function y(t) {
          return (
            1 -
            (0.5 - Math.log(Math.tan(u + 0.5 * s.MathUtils.degToRad(t))) * h)
          );
        }
        var v = (function () {
          function t() {
            var e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            r()(this, t),
              (this.tmp = {
                coords: [
                  new l.a('EPSG:4326', 0, 0),
                  new l.a('EPSG:4326', 0, 0),
                ],
                position: new s.Vector3(),
                dimension: new s.Vector2(),
              }),
              (this.crs = e.crs),
              (this.uvCount = e.uvCount),
              (this.computeUvs = [
                function () {},
                function (t) {
                  var e = y(t.projected.latitude) * t.nbRow;
                  return (isFinite(e) ? e : 0) - t.deltaUV1;
                },
              ]);
          }
          return (
            o()(t, [
              {
                key: 'prepare',
                value: function (t) {
                  t.nbRow = Math.pow(2, t.level + 1);
                  var e = y(t.extent.south);
                  isFinite(e) || (e = 0);
                  var n = e % (1 / t.nbRow);
                  (t.deltaUV1 = (e - n) * t.nbRow),
                    (t.quatNormalToZ = g.setFromAxisAngle(
                      p,
                      -(
                        0.5 * Math.PI -
                        s.MathUtils.degToRad(t.extent.center().latitude)
                      ),
                    )),
                    (t.projected = { longitude: 0, latitude: 0 }),
                    t.extent.dimensions(this.tmp.dimension);
                },
              },
              {
                key: 'center',
                value: function (t) {
                  return t
                    .center(this.tmp.coords[0])
                    .as(this.crs, this.tmp.coords[1])
                    .toVector3();
                },
              },
              {
                key: 'vertexPosition',
                value: function (t) {
                  return (
                    this.tmp.coords[0].setFromValues(
                      t.projected.longitude,
                      t.projected.latitude,
                    ),
                    this.tmp.coords[0]
                      .as(this.crs, this.tmp.coords[1])
                      .toVector3(this.tmp.position),
                    this.tmp.position
                  );
                },
              },
              {
                key: 'vertexNormal',
                value: function () {
                  return this.tmp.coords[1].geodesicNormal;
                },
              },
              {
                key: 'uProjecte',
                value: function (t, e) {
                  e.projected.longitude =
                    e.extent.west + t * this.tmp.dimension.x;
                },
              },
              {
                key: 'vProjecte',
                value: function (t, e) {
                  e.projected.latitude =
                    e.extent.south + t * this.tmp.dimension.y;
                },
              },
              {
                key: 'computeSharableExtent',
                value: function (t) {
                  var e = Math.abs(t.west - t.east) / 2,
                    n = new c.a(t.crs, -e, e, t.south, t.north),
                    i = s.MathUtils.degToRad(t.west - n.west),
                    r = s.MathUtils.degToRad(
                      90 - t.center(this.tmp.coords[0]).latitude,
                    );
                  return (
                    f.setFromAxisAngle(d, i),
                    m.setFromAxisAngle(p, r),
                    f.multiply(m),
                    {
                      sharableExtent: n,
                      quaternion: f.clone(),
                      position: this.center(t),
                    }
                  );
                },
              },
            ]),
            t
          );
        })();
        e.a = v;
      },
      140: function (t, e) {
        (t.exports = function (t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      141: function (t, e, n) {
        var i = n(140);
        (t.exports = function (t, e) {
          if (t) {
            if ('string' == typeof t) return i(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            return (
              'Object' === n && t.constructor && (n = t.constructor.name),
              'Map' === n || 'Set' === n
                ? Array.from(t)
                : 'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                ? i(t, e)
                : void 0
            );
          }
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      142: function (t, e, n) {
        'use strict';
        var i = n(143);
        function r(t, e) {
          (this.version = 1),
            (this.name = null),
            (this.extent = 4096),
            (this.length = 0),
            (this._pbf = t),
            (this._keys = []),
            (this._values = []),
            (this._features = []),
            t.readFields(a, this, e),
            (this.length = this._features.length);
        }
        function a(t, e, n) {
          15 === t
            ? (e.version = n.readVarint())
            : 1 === t
            ? (e.name = n.readString())
            : 5 === t
            ? (e.extent = n.readVarint())
            : 2 === t
            ? e._features.push(n.pos)
            : 3 === t
            ? e._keys.push(n.readString())
            : 4 === t &&
              e._values.push(
                (function (t) {
                  var e = null,
                    n = t.readVarint() + t.pos;
                  for (; t.pos < n; ) {
                    var i = t.readVarint() >> 3;
                    e =
                      1 === i
                        ? t.readString()
                        : 2 === i
                        ? t.readFloat()
                        : 3 === i
                        ? t.readDouble()
                        : 4 === i
                        ? t.readVarint64()
                        : 5 === i
                        ? t.readVarint()
                        : 6 === i
                        ? t.readSVarint()
                        : 7 === i
                        ? t.readBoolean()
                        : null;
                  }
                  return e;
                })(n),
              );
        }
        (t.exports = r),
          (r.prototype.feature = function (t) {
            if (t < 0 || t >= this._features.length)
              throw new Error('feature index out of bounds');
            this._pbf.pos = this._features[t];
            var e = this._pbf.readVarint() + this._pbf.pos;
            return new i(this._pbf, e, this.extent, this._keys, this._values);
          });
      },
      143: function (t, e, n) {
        'use strict';
        var i = n(216);
        function r(t, e, n, i, r) {
          (this.properties = {}),
            (this.extent = n),
            (this.type = 0),
            (this._pbf = t),
            (this._geometry = -1),
            (this._keys = i),
            (this._values = r),
            t.readFields(a, this, e);
        }
        function a(t, e, n) {
          1 == t
            ? (e.id = n.readVarint())
            : 2 == t
            ? (function (t, e) {
                var n = t.readVarint() + t.pos;
                for (; t.pos < n; ) {
                  var i = e._keys[t.readVarint()],
                    r = e._values[t.readVarint()];
                  e.properties[i] = r;
                }
              })(n, e)
            : 3 == t
            ? (e.type = n.readVarint())
            : 4 == t && (e._geometry = n.pos);
        }
        function o(t) {
          for (var e, n, i = 0, r = 0, a = t.length, o = a - 1; r < a; o = r++)
            (e = t[r]), (i += ((n = t[o]).x - e.x) * (e.y + n.y));
          return i;
        }
        (t.exports = r),
          (r.types = ['Unknown', 'Point', 'LineString', 'Polygon']),
          (r.prototype.loadGeometry = function () {
            var t = this._pbf;
            t.pos = this._geometry;
            for (
              var e,
                n = t.readVarint() + t.pos,
                r = 1,
                a = 0,
                o = 0,
                s = 0,
                l = [];
              t.pos < n;

            ) {
              if (a <= 0) {
                var c = t.readVarint();
                (r = 7 & c), (a = c >> 3);
              }
              if ((a--, 1 === r || 2 === r))
                (o += t.readSVarint()),
                  (s += t.readSVarint()),
                  1 === r && (e && l.push(e), (e = [])),
                  e.push(new i(o, s));
              else {
                if (7 !== r) throw new Error('unknown command ' + r);
                e && e.push(e[0].clone());
              }
            }
            return e && l.push(e), l;
          }),
          (r.prototype.bbox = function () {
            var t = this._pbf;
            t.pos = this._geometry;
            for (
              var e = t.readVarint() + t.pos,
                n = 1,
                i = 0,
                r = 0,
                a = 0,
                o = 1 / 0,
                s = -1 / 0,
                l = 1 / 0,
                c = -1 / 0;
              t.pos < e;

            ) {
              if (i <= 0) {
                var u = t.readVarint();
                (n = 7 & u), (i = u >> 3);
              }
              if ((i--, 1 === n || 2 === n))
                (r += t.readSVarint()) < o && (o = r),
                  r > s && (s = r),
                  (a += t.readSVarint()) < l && (l = a),
                  a > c && (c = a);
              else if (7 !== n) throw new Error('unknown command ' + n);
            }
            return [o, l, s, c];
          }),
          (r.prototype.toGeoJSON = function (t, e, n) {
            var i,
              a,
              s = this.extent * Math.pow(2, n),
              l = this.extent * t,
              c = this.extent * e,
              u = this.loadGeometry(),
              h = r.types[this.type];
            function d(t) {
              for (var e = 0; e < t.length; e++) {
                var n = t[e],
                  i = 180 - (360 * (n.y + c)) / s;
                t[e] = [
                  (360 * (n.x + l)) / s - 180,
                  (360 / Math.PI) * Math.atan(Math.exp((i * Math.PI) / 180)) -
                    90,
                ];
              }
            }
            switch (this.type) {
              case 1:
                var p = [];
                for (i = 0; i < u.length; i++) p[i] = u[i][0];
                d((u = p));
                break;
              case 2:
                for (i = 0; i < u.length; i++) d(u[i]);
                break;
              case 3:
                for (
                  u = (function (t) {
                    var e = t.length;
                    if (e <= 1) return [t];
                    for (var n, i, r = [], a = 0; a < e; a++) {
                      var s = o(t[a]);
                      0 !== s &&
                        (void 0 === i && (i = s < 0),
                        i === s < 0
                          ? (n && r.push(n), (n = [t[a]]))
                          : n.push(t[a]));
                    }
                    n && r.push(n);
                    return r;
                  })(u),
                    i = 0;
                  i < u.length;
                  i++
                )
                  for (a = 0; a < u[i].length; a++) d(u[i][a]);
            }
            1 === u.length ? (u = u[0]) : (h = 'Multi' + h);
            var f = {
              type: 'Feature',
              geometry: { type: h, coordinates: u },
              properties: this.properties,
            };
            return 'id' in this && (f.id = this.id), f;
          });
      },
      144: function (t, e, n) {
        var i = n(212),
          r = n(213),
          a = n(141),
          o = n(214);
        (t.exports = function (t, e) {
          return i(t) || r(t, e) || a(t, e) || o();
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      145: function (t, e, n) {
        'use strict';
        t.exports = r;
        var i = n(174);
        function r(t) {
          (this.buf =
            ArrayBuffer.isView && ArrayBuffer.isView(t)
              ? t
              : new Uint8Array(t || 0)),
            (this.pos = 0),
            (this.type = 0),
            (this.length = this.buf.length);
        }
        (r.Varint = 0), (r.Fixed64 = 1), (r.Bytes = 2), (r.Fixed32 = 5);
        var a =
          'undefined' == typeof TextDecoder ? null : new TextDecoder('utf8');
        function o(t) {
          return t.type === r.Bytes ? t.readVarint() + t.pos : t.pos + 1;
        }
        function s(t, e, n) {
          return n
            ? 4294967296 * e + (t >>> 0)
            : 4294967296 * (e >>> 0) + (t >>> 0);
        }
        function l(t, e, n) {
          var i =
            e <= 16383
              ? 1
              : e <= 2097151
              ? 2
              : e <= 268435455
              ? 3
              : Math.floor(Math.log(e) / (7 * Math.LN2));
          n.realloc(i);
          for (var r = n.pos - 1; r >= t; r--) n.buf[r + i] = n.buf[r];
        }
        function c(t, e) {
          for (var n = 0; n < t.length; n++) e.writeVarint(t[n]);
        }
        function u(t, e) {
          for (var n = 0; n < t.length; n++) e.writeSVarint(t[n]);
        }
        function h(t, e) {
          for (var n = 0; n < t.length; n++) e.writeFloat(t[n]);
        }
        function d(t, e) {
          for (var n = 0; n < t.length; n++) e.writeDouble(t[n]);
        }
        function p(t, e) {
          for (var n = 0; n < t.length; n++) e.writeBoolean(t[n]);
        }
        function f(t, e) {
          for (var n = 0; n < t.length; n++) e.writeFixed32(t[n]);
        }
        function m(t, e) {
          for (var n = 0; n < t.length; n++) e.writeSFixed32(t[n]);
        }
        function g(t, e) {
          for (var n = 0; n < t.length; n++) e.writeFixed64(t[n]);
        }
        function y(t, e) {
          for (var n = 0; n < t.length; n++) e.writeSFixed64(t[n]);
        }
        function v(t, e) {
          return (
            (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + 16777216 * t[e + 3]
          );
        }
        function x(t, e, n) {
          (t[n] = e),
            (t[n + 1] = e >>> 8),
            (t[n + 2] = e >>> 16),
            (t[n + 3] = e >>> 24);
        }
        function b(t, e) {
          return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + (t[e + 3] << 24);
        }
        r.prototype = {
          destroy: function () {
            this.buf = null;
          },
          readFields: function (t, e, n) {
            for (n = n || this.length; this.pos < n; ) {
              var i = this.readVarint(),
                r = i >> 3,
                a = this.pos;
              (this.type = 7 & i),
                t(r, e, this),
                this.pos === a && this.skip(i);
            }
            return e;
          },
          readMessage: function (t, e) {
            return this.readFields(t, e, this.readVarint() + this.pos);
          },
          readFixed32: function () {
            var t = v(this.buf, this.pos);
            return (this.pos += 4), t;
          },
          readSFixed32: function () {
            var t = b(this.buf, this.pos);
            return (this.pos += 4), t;
          },
          readFixed64: function () {
            var t =
              v(this.buf, this.pos) + 4294967296 * v(this.buf, this.pos + 4);
            return (this.pos += 8), t;
          },
          readSFixed64: function () {
            var t =
              v(this.buf, this.pos) + 4294967296 * b(this.buf, this.pos + 4);
            return (this.pos += 8), t;
          },
          readFloat: function () {
            var t = i.read(this.buf, this.pos, !0, 23, 4);
            return (this.pos += 4), t;
          },
          readDouble: function () {
            var t = i.read(this.buf, this.pos, !0, 52, 8);
            return (this.pos += 8), t;
          },
          readVarint: function (t) {
            var e,
              n,
              i = this.buf;
            return (
              (e = 127 & (n = i[this.pos++])),
              n < 128
                ? e
                : ((e |= (127 & (n = i[this.pos++])) << 7),
                  n < 128
                    ? e
                    : ((e |= (127 & (n = i[this.pos++])) << 14),
                      n < 128
                        ? e
                        : ((e |= (127 & (n = i[this.pos++])) << 21),
                          n < 128
                            ? e
                            : (function (t, e, n) {
                                var i,
                                  r,
                                  a = n.buf;
                                if (
                                  ((r = a[n.pos++]),
                                  (i = (112 & r) >> 4),
                                  r < 128)
                                )
                                  return s(t, i, e);
                                if (
                                  ((r = a[n.pos++]),
                                  (i |= (127 & r) << 3),
                                  r < 128)
                                )
                                  return s(t, i, e);
                                if (
                                  ((r = a[n.pos++]),
                                  (i |= (127 & r) << 10),
                                  r < 128)
                                )
                                  return s(t, i, e);
                                if (
                                  ((r = a[n.pos++]),
                                  (i |= (127 & r) << 17),
                                  r < 128)
                                )
                                  return s(t, i, e);
                                if (
                                  ((r = a[n.pos++]),
                                  (i |= (127 & r) << 24),
                                  r < 128)
                                )
                                  return s(t, i, e);
                                if (
                                  ((r = a[n.pos++]),
                                  (i |= (1 & r) << 31),
                                  r < 128)
                                )
                                  return s(t, i, e);
                                throw new Error(
                                  'Expected varint not more than 10 bytes',
                                );
                              })(
                                (e |= (15 & (n = i[this.pos])) << 28),
                                t,
                                this,
                              ))))
            );
          },
          readVarint64: function () {
            return this.readVarint(!0);
          },
          readSVarint: function () {
            var t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          },
          readBoolean: function () {
            return Boolean(this.readVarint());
          },
          readString: function () {
            var t = this.readVarint() + this.pos,
              e = this.pos;
            return (
              (this.pos = t),
              t - e >= 12 && a
                ? (function (t, e, n) {
                    return a.decode(t.subarray(e, n));
                  })(this.buf, e, t)
                : (function (t, e, n) {
                    var i = '',
                      r = e;
                    for (; r < n; ) {
                      var a,
                        o,
                        s,
                        l = t[r],
                        c = null,
                        u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                      if (r + u > n) break;
                      1 === u
                        ? l < 128 && (c = l)
                        : 2 === u
                        ? 128 == (192 & (a = t[r + 1])) &&
                          (c = ((31 & l) << 6) | (63 & a)) <= 127 &&
                          (c = null)
                        : 3 === u
                        ? ((a = t[r + 1]),
                          (o = t[r + 2]),
                          128 == (192 & a) &&
                            128 == (192 & o) &&
                            ((c =
                              ((15 & l) << 12) | ((63 & a) << 6) | (63 & o)) <=
                              2047 ||
                              (c >= 55296 && c <= 57343)) &&
                            (c = null))
                        : 4 === u &&
                          ((a = t[r + 1]),
                          (o = t[r + 2]),
                          (s = t[r + 3]),
                          128 == (192 & a) &&
                            128 == (192 & o) &&
                            128 == (192 & s) &&
                            ((c =
                              ((15 & l) << 18) |
                              ((63 & a) << 12) |
                              ((63 & o) << 6) |
                              (63 & s)) <= 65535 ||
                              c >= 1114112) &&
                            (c = null)),
                        null === c
                          ? ((c = 65533), (u = 1))
                          : c > 65535 &&
                            ((c -= 65536),
                            (i += String.fromCharCode(
                              ((c >>> 10) & 1023) | 55296,
                            )),
                            (c = 56320 | (1023 & c))),
                        (i += String.fromCharCode(c)),
                        (r += u);
                    }
                    return i;
                  })(this.buf, e, t)
            );
          },
          readBytes: function () {
            var t = this.readVarint() + this.pos,
              e = this.buf.subarray(this.pos, t);
            return (this.pos = t), e;
          },
          readPackedVarint: function (t, e) {
            if (this.type !== r.Bytes) return t.push(this.readVarint(e));
            var n = o(this);
            for (t = t || []; this.pos < n; ) t.push(this.readVarint(e));
            return t;
          },
          readPackedSVarint: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readSVarint());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readSVarint());
            return t;
          },
          readPackedBoolean: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readBoolean());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readBoolean());
            return t;
          },
          readPackedFloat: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readFloat());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readFloat());
            return t;
          },
          readPackedDouble: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readDouble());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readDouble());
            return t;
          },
          readPackedFixed32: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readFixed32());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readFixed32());
            return t;
          },
          readPackedSFixed32: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readSFixed32());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readSFixed32());
            return t;
          },
          readPackedFixed64: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readFixed64());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readFixed64());
            return t;
          },
          readPackedSFixed64: function (t) {
            if (this.type !== r.Bytes) return t.push(this.readSFixed64());
            var e = o(this);
            for (t = t || []; this.pos < e; ) t.push(this.readSFixed64());
            return t;
          },
          skip: function (t) {
            var e = 7 & t;
            if (e === r.Varint) for (; this.buf[this.pos++] > 127; );
            else if (e === r.Bytes) this.pos = this.readVarint() + this.pos;
            else if (e === r.Fixed32) this.pos += 4;
            else {
              if (e !== r.Fixed64) throw new Error('Unimplemented type: ' + e);
              this.pos += 8;
            }
          },
          writeTag: function (t, e) {
            this.writeVarint((t << 3) | e);
          },
          realloc: function (t) {
            for (var e = this.length || 16; e < this.pos + t; ) e *= 2;
            if (e !== this.length) {
              var n = new Uint8Array(e);
              n.set(this.buf), (this.buf = n), (this.length = e);
            }
          },
          finish: function () {
            return (
              (this.length = this.pos),
              (this.pos = 0),
              this.buf.subarray(0, this.length)
            );
          },
          writeFixed32: function (t) {
            this.realloc(4), x(this.buf, t, this.pos), (this.pos += 4);
          },
          writeSFixed32: function (t) {
            this.realloc(4), x(this.buf, t, this.pos), (this.pos += 4);
          },
          writeFixed64: function (t) {
            this.realloc(8),
              x(this.buf, -1 & t, this.pos),
              x(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4),
              (this.pos += 8);
          },
          writeSFixed64: function (t) {
            this.realloc(8),
              x(this.buf, -1 & t, this.pos),
              x(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4),
              (this.pos += 8);
          },
          writeVarint: function (t) {
            (t = +t || 0) > 268435455 || t < 0
              ? (function (t, e) {
                  var n, i;
                  t >= 0
                    ? ((n = t % 4294967296 | 0), (i = (t / 4294967296) | 0))
                    : ((i = ~(-t / 4294967296)),
                      4294967295 ^ (n = ~(-t % 4294967296))
                        ? (n = (n + 1) | 0)
                        : ((n = 0), (i = (i + 1) | 0)));
                  if (t >= 0x10000000000000000 || t < -0x10000000000000000)
                    throw new Error("Given varint doesn't fit into 10 bytes");
                  e.realloc(10),
                    (function (t, e, n) {
                      (n.buf[n.pos++] = (127 & t) | 128),
                        (t >>>= 7),
                        (n.buf[n.pos++] = (127 & t) | 128),
                        (t >>>= 7),
                        (n.buf[n.pos++] = (127 & t) | 128),
                        (t >>>= 7),
                        (n.buf[n.pos++] = (127 & t) | 128),
                        (t >>>= 7),
                        (n.buf[n.pos] = 127 & t);
                    })(n, 0, e),
                    (function (t, e) {
                      var n = (7 & t) << 4;
                      if (((e.buf[e.pos++] |= n | ((t >>>= 3) ? 128 : 0)), !t))
                        return;
                      if (
                        ((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)),
                        !t)
                      )
                        return;
                      if (
                        ((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)),
                        !t)
                      )
                        return;
                      if (
                        ((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)),
                        !t)
                      )
                        return;
                      if (
                        ((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)),
                        !t)
                      )
                        return;
                      e.buf[e.pos++] = 127 & t;
                    })(i, e);
                })(t, this)
              : (this.realloc(4),
                (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
                t <= 127 ||
                  ((this.buf[this.pos++] =
                    (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                  t <= 127 ||
                    ((this.buf[this.pos++] =
                      (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
                    t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
          },
          writeSVarint: function (t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          },
          writeBoolean: function (t) {
            this.writeVarint(Boolean(t));
          },
          writeString: function (t) {
            (t = String(t)), this.realloc(4 * t.length), this.pos++;
            var e = this.pos;
            this.pos = (function (t, e, n) {
              for (var i, r, a = 0; a < e.length; a++) {
                if ((i = e.charCodeAt(a)) > 55295 && i < 57344) {
                  if (!r) {
                    i > 56319 || a + 1 === e.length
                      ? ((t[n++] = 239), (t[n++] = 191), (t[n++] = 189))
                      : (r = i);
                    continue;
                  }
                  if (i < 56320) {
                    (t[n++] = 239), (t[n++] = 191), (t[n++] = 189), (r = i);
                    continue;
                  }
                  (i = ((r - 55296) << 10) | (i - 56320) | 65536), (r = null);
                } else
                  r &&
                    ((t[n++] = 239),
                    (t[n++] = 191),
                    (t[n++] = 189),
                    (r = null));
                i < 128
                  ? (t[n++] = i)
                  : (i < 2048
                      ? (t[n++] = (i >> 6) | 192)
                      : (i < 65536
                          ? (t[n++] = (i >> 12) | 224)
                          : ((t[n++] = (i >> 18) | 240),
                            (t[n++] = ((i >> 12) & 63) | 128)),
                        (t[n++] = ((i >> 6) & 63) | 128)),
                    (t[n++] = (63 & i) | 128));
              }
              return n;
            })(this.buf, t, this.pos);
            var n = this.pos - e;
            n >= 128 && l(e, n, this),
              (this.pos = e - 1),
              this.writeVarint(n),
              (this.pos += n);
          },
          writeFloat: function (t) {
            this.realloc(4),
              i.write(this.buf, t, this.pos, !0, 23, 4),
              (this.pos += 4);
          },
          writeDouble: function (t) {
            this.realloc(8),
              i.write(this.buf, t, this.pos, !0, 52, 8),
              (this.pos += 8);
          },
          writeBytes: function (t) {
            var e = t.length;
            this.writeVarint(e), this.realloc(e);
            for (var n = 0; n < e; n++) this.buf[this.pos++] = t[n];
          },
          writeRawMessage: function (t, e) {
            this.pos++;
            var n = this.pos;
            t(e, this);
            var i = this.pos - n;
            i >= 128 && l(n, i, this),
              (this.pos = n - 1),
              this.writeVarint(i),
              (this.pos += i);
          },
          writeMessage: function (t, e, n) {
            this.writeTag(t, r.Bytes), this.writeRawMessage(e, n);
          },
          writePackedVarint: function (t, e) {
            e.length && this.writeMessage(t, c, e);
          },
          writePackedSVarint: function (t, e) {
            e.length && this.writeMessage(t, u, e);
          },
          writePackedBoolean: function (t, e) {
            e.length && this.writeMessage(t, p, e);
          },
          writePackedFloat: function (t, e) {
            e.length && this.writeMessage(t, h, e);
          },
          writePackedDouble: function (t, e) {
            e.length && this.writeMessage(t, d, e);
          },
          writePackedFixed32: function (t, e) {
            e.length && this.writeMessage(t, f, e);
          },
          writePackedSFixed32: function (t, e) {
            e.length && this.writeMessage(t, m, e);
          },
          writePackedFixed64: function (t, e) {
            e.length && this.writeMessage(t, g, e);
          },
          writePackedSFixed64: function (t, e) {
            e.length && this.writeMessage(t, y, e);
          },
          writeBytesField: function (t, e) {
            this.writeTag(t, r.Bytes), this.writeBytes(e);
          },
          writeFixed32Field: function (t, e) {
            this.writeTag(t, r.Fixed32), this.writeFixed32(e);
          },
          writeSFixed32Field: function (t, e) {
            this.writeTag(t, r.Fixed32), this.writeSFixed32(e);
          },
          writeFixed64Field: function (t, e) {
            this.writeTag(t, r.Fixed64), this.writeFixed64(e);
          },
          writeSFixed64Field: function (t, e) {
            this.writeTag(t, r.Fixed64), this.writeSFixed64(e);
          },
          writeVarintField: function (t, e) {
            this.writeTag(t, r.Varint), this.writeVarint(e);
          },
          writeSVarintField: function (t, e) {
            this.writeTag(t, r.Varint), this.writeSVarint(e);
          },
          writeStringField: function (t, e) {
            this.writeTag(t, r.Bytes), this.writeString(e);
          },
          writeFloatField: function (t, e) {
            this.writeTag(t, r.Fixed32), this.writeFloat(e);
          },
          writeDoubleField: function (t, e) {
            this.writeTag(t, r.Fixed64), this.writeDouble(e);
          },
          writeBooleanField: function (t, e) {
            this.writeVarintField(t, Boolean(e));
          },
        };
      },
      146: function (t, e, n) {
        (t.exports.VectorTile = n(215)),
          (t.exports.VectorTileFeature = n(143)),
          (t.exports.VectorTileLayer = n(142));
      },
      147: function (t, e, n) {
        t.exports = (function t(e, n, i) {
          function r(o, s) {
            if (!n[o]) {
              if (!e[o]) {
                if (a) return a(o, !0);
                var l = new Error("Cannot find module '" + o + "'");
                throw ((l.code = 'MODULE_NOT_FOUND'), l);
              }
              var c = (n[o] = { exports: {} });
              e[o][0].call(
                c.exports,
                function (t) {
                  var n = e[o][1][t];
                  return r(n || t);
                },
                c,
                c.exports,
                t,
                e,
                n,
                i,
              );
            }
            return n[o].exports;
          }
          for (var a = !1, o = 0; o < i.length; o++) r(i[o]);
          return r;
        })(
          {
            1: [
              function (t, e, n) {
                var i,
                  r,
                  a,
                  o,
                  s,
                  l = {}.hasOwnProperty;
                (i = t('./PriorityQueue/AbstractPriorityQueue')),
                  (r = t('./PriorityQueue/ArrayStrategy')),
                  (o = t('./PriorityQueue/BinaryHeapStrategy')),
                  (a = t('./PriorityQueue/BHeapStrategy')),
                  ((s = (function (t) {
                    function e(t) {
                      t || (t = {}),
                        t.strategy || (t.strategy = o),
                        t.comparator ||
                          (t.comparator = function (t, e) {
                            return (t || 0) - (e || 0);
                          }),
                        e.__super__.constructor.call(this, t);
                    }
                    return (
                      (function (t, e) {
                        for (var n in e) l.call(e, n) && (t[n] = e[n]);
                        function i() {
                          this.constructor = t;
                        }
                        (i.prototype = e.prototype),
                          (t.prototype = new i()),
                          (t.__super__ = e.prototype);
                      })(e, t),
                      e
                    );
                  })(i)).ArrayStrategy = r),
                  (s.BinaryHeapStrategy = o),
                  (s.BHeapStrategy = a),
                  (e.exports = s);
              },
              {
                './PriorityQueue/AbstractPriorityQueue': 2,
                './PriorityQueue/ArrayStrategy': 3,
                './PriorityQueue/BHeapStrategy': 4,
                './PriorityQueue/BinaryHeapStrategy': 5,
              },
            ],
            2: [
              function (t, e, n) {
                e.exports = (function () {
                  function t(t) {
                    var e;
                    if (null == (null != t ? t.strategy : void 0))
                      throw 'Must pass options.strategy, a strategy';
                    if (null == (null != t ? t.comparator : void 0))
                      throw 'Must pass options.comparator, a comparator';
                    (this.priv = new t.strategy(t)),
                      (this.length =
                        (null != t && null != (e = t.initialValues)
                          ? e.length
                          : void 0) || 0);
                  }
                  return (
                    (t.prototype.queue = function (t) {
                      this.length++, this.priv.queue(t);
                    }),
                    (t.prototype.dequeue = function (t) {
                      if (!this.length) throw 'Empty queue';
                      return this.length--, this.priv.dequeue();
                    }),
                    (t.prototype.peek = function (t) {
                      if (!this.length) throw 'Empty queue';
                      return this.priv.peek();
                    }),
                    (t.prototype.clear = function () {
                      return (this.length = 0), this.priv.clear();
                    }),
                    t
                  );
                })();
              },
              {},
            ],
            3: [
              function (t, e, n) {
                var i;
                (i = function (t, e, n) {
                  var i, r, a;
                  for (r = 0, i = t.length; r < i; )
                    n(t[(a = (r + i) >>> 1)], e) >= 0 ? (r = a + 1) : (i = a);
                  return r;
                }),
                  (e.exports = (function () {
                    function t(t) {
                      var e;
                      (this.options = t),
                        (this.comparator = this.options.comparator),
                        (this.data =
                          (null != (e = this.options.initialValues)
                            ? e.slice(0)
                            : void 0) || []),
                        this.data.sort(this.comparator).reverse();
                    }
                    return (
                      (t.prototype.queue = function (t) {
                        var e;
                        (e = i(this.data, t, this.comparator)),
                          this.data.splice(e, 0, t);
                      }),
                      (t.prototype.dequeue = function () {
                        return this.data.pop();
                      }),
                      (t.prototype.peek = function () {
                        return this.data[this.data.length - 1];
                      }),
                      (t.prototype.clear = function () {
                        this.data.length = 0;
                      }),
                      t
                    );
                  })());
              },
              {},
            ],
            4: [
              function (t, e, n) {
                e.exports = (function () {
                  function t(t) {
                    var e, n, i, r, a, o, s, l;
                    for (
                      this.comparator =
                        (null != t ? t.comparator : void 0) ||
                        function (t, e) {
                          return t - e;
                        },
                        this.pageSize =
                          (null != t ? t.pageSize : void 0) || 512,
                        this.length = 0,
                        s = 0;
                      1 << s < this.pageSize;

                    )
                      s += 1;
                    if (1 << s !== this.pageSize)
                      throw 'pageSize must be a power of two';
                    for (
                      this._shift = s,
                        this._emptyMemoryPageTemplate = e = [],
                        n = 0,
                        a = this.pageSize;
                      0 <= a ? n < a : n > a;
                      0 <= a ? ++n : --n
                    )
                      e.push(null);
                    if (
                      ((this._memory = []),
                      (this._mask = this.pageSize - 1),
                      t.initialValues)
                    )
                      for (i = 0, r = (o = t.initialValues).length; i < r; i++)
                        (l = o[i]), this.queue(l);
                  }
                  return (
                    (t.prototype.queue = function (t) {
                      (this.length += 1),
                        this._write(this.length, t),
                        this._bubbleUp(this.length, t);
                    }),
                    (t.prototype.dequeue = function () {
                      var t, e;
                      return (
                        (t = this._read(1)),
                        (e = this._read(this.length)),
                        (this.length -= 1),
                        this.length > 0 &&
                          (this._write(1, e), this._bubbleDown(1, e)),
                        t
                      );
                    }),
                    (t.prototype.peek = function () {
                      return this._read(1);
                    }),
                    (t.prototype.clear = function () {
                      (this.length = 0), (this._memory.length = 0);
                    }),
                    (t.prototype._write = function (t, e) {
                      var n;
                      for (n = t >> this._shift; n >= this._memory.length; )
                        this._memory.push(
                          this._emptyMemoryPageTemplate.slice(0),
                        );
                      return (this._memory[n][t & this._mask] = e);
                    }),
                    (t.prototype._read = function (t) {
                      return this._memory[t >> this._shift][t & this._mask];
                    }),
                    (t.prototype._bubbleUp = function (t, e) {
                      var n, i, r, a;
                      for (
                        n = this.comparator;
                        t > 1 &&
                        ((i = t & this._mask),
                        t < this.pageSize || i > 3
                          ? (r = (t & ~this._mask) | (i >> 1))
                          : i < 2
                          ? ((r = (t - this.pageSize) >> this._shift),
                            (r += r & ~(this._mask >> 1)),
                            (r |= this.pageSize >> 1))
                          : (r = t - 2),
                        !(n((a = this._read(r)), e) < 0));

                      )
                        this._write(r, e), this._write(t, a), (t = r);
                    }),
                    (t.prototype._bubbleDown = function (t, e) {
                      var n, i, r, a, o;
                      for (o = this.comparator; t < this.length; )
                        if (
                          (t > this._mask && !(t & (this._mask - 1))
                            ? (n = i = t + 2)
                            : t & (this.pageSize >> 1)
                            ? ((n = (t & ~this._mask) >> 1),
                              (i =
                                1 +
                                (n =
                                  (1 + (n |= t & (this._mask >> 1))) <<
                                  this._shift)))
                            : (i = (n = t + (t & this._mask)) + 1),
                          n !== i && i <= this.length)
                        )
                          if (
                            ((r = this._read(n)),
                            (a = this._read(i)),
                            o(r, e) < 0 && o(r, a) <= 0)
                          )
                            this._write(n, e), this._write(t, r), (t = n);
                          else {
                            if (!(o(a, e) < 0)) break;
                            this._write(i, e), this._write(t, a), (t = i);
                          }
                        else {
                          if (!(n <= this.length)) break;
                          if (!(o((r = this._read(n)), e) < 0)) break;
                          this._write(n, e), this._write(t, r), (t = n);
                        }
                    }),
                    t
                  );
                })();
              },
              {},
            ],
            5: [
              function (t, e, n) {
                e.exports = (function () {
                  function t(t) {
                    var e;
                    (this.comparator =
                      (null != t ? t.comparator : void 0) ||
                      function (t, e) {
                        return t - e;
                      }),
                      (this.length = 0),
                      (this.data =
                        (null != (e = t.initialValues) ? e.slice(0) : void 0) ||
                        []),
                      this._heapify();
                  }
                  return (
                    (t.prototype._heapify = function () {
                      var t, e, n;
                      if (this.data.length > 0)
                        for (
                          t = e = 1, n = this.data.length;
                          1 <= n ? e < n : e > n;
                          t = 1 <= n ? ++e : --e
                        )
                          this._bubbleUp(t);
                    }),
                    (t.prototype.queue = function (t) {
                      this.data.push(t), this._bubbleUp(this.data.length - 1);
                    }),
                    (t.prototype.dequeue = function () {
                      var t, e;
                      return (
                        (e = this.data[0]),
                        (t = this.data.pop()),
                        this.data.length > 0 &&
                          ((this.data[0] = t), this._bubbleDown(0)),
                        e
                      );
                    }),
                    (t.prototype.peek = function () {
                      return this.data[0];
                    }),
                    (t.prototype.clear = function () {
                      (this.length = 0), (this.data.length = 0);
                    }),
                    (t.prototype._bubbleUp = function (t) {
                      for (
                        var e, n;
                        t > 0 &&
                        ((e = (t - 1) >>> 1),
                        this.comparator(this.data[t], this.data[e]) < 0);

                      )
                        (n = this.data[e]),
                          (this.data[e] = this.data[t]),
                          (this.data[t] = n),
                          (t = e);
                    }),
                    (t.prototype._bubbleDown = function (t) {
                      var e, n, i, r, a;
                      for (
                        e = this.data.length - 1;
                        (r = 1 + (n = 1 + (t << 1))),
                          (i = t),
                          n <= e &&
                            this.comparator(this.data[n], this.data[i]) < 0 &&
                            (i = n),
                          r <= e &&
                            this.comparator(this.data[r], this.data[i]) < 0 &&
                            (i = r),
                          i !== t;

                      )
                        (a = this.data[i]),
                          (this.data[i] = this.data[t]),
                          (this.data[t] = a),
                          (t = i);
                    }),
                    t
                  );
                })();
              },
              {},
            ],
          },
          {},
          [1],
        )(1);
      },
      148: function (t, e, n) {
        'use strict';
        function i(t, e, n) {
          return e <= t && t <= n;
        }
        function r(t) {
          if (void 0 === t) return {};
          if (t === Object(t)) return t;
          throw TypeError('Could not convert argument to dictionary');
        }
        n.d(e, 'a', function () {
          return s;
        });
        function a(t) {
          this.tokens = [].slice.call(t);
        }
        a.prototype = {
          endOfStream: function () {
            return !this.tokens.length;
          },
          read: function () {
            return this.tokens.length ? this.tokens.shift() : -1;
          },
          prepend: function (t) {
            if (Array.isArray(t))
              for (var e = t; e.length; ) this.tokens.unshift(e.pop());
            else this.tokens.unshift(t);
          },
          push: function (t) {
            if (Array.isArray(t))
              for (var e = t; e.length; ) this.tokens.push(e.shift());
            else this.tokens.push(t);
          },
        };
        function o(t, e) {
          if (t) throw TypeError('Decoder error');
          return e || 65533;
        }
        function s(t, e) {
          if (!(this instanceof s)) return new s(t, e);
          if (
            'utf-8' !== (t = void 0 !== t ? String(t).toLowerCase() : 'utf-8')
          )
            throw new Error('Encoding not supported. Only utf-8 is supported');
          (e = r(e)),
            (this._streaming = !1),
            (this._BOMseen = !1),
            (this._decoder = null),
            (this._fatal = Boolean(e.fatal)),
            (this._ignoreBOM = Boolean(e.ignoreBOM)),
            Object.defineProperty(this, 'encoding', { value: 'utf-8' }),
            Object.defineProperty(this, 'fatal', { value: this._fatal }),
            Object.defineProperty(this, 'ignoreBOM', {
              value: this._ignoreBOM,
            });
        }
        function l(t) {
          var e = t.fatal,
            n = 0,
            r = 0,
            a = 0,
            s = 128,
            l = 191;
          this.handler = function (t, c) {
            if (-1 === c && 0 !== a) return (a = 0), o(e);
            if (-1 === c) return -1;
            if (0 === a) {
              if (i(c, 0, 127)) return c;
              if (i(c, 194, 223)) (a = 1), (n = c - 192);
              else if (i(c, 224, 239))
                224 === c && (s = 160),
                  237 === c && (l = 159),
                  (a = 2),
                  (n = c - 224);
              else {
                if (!i(c, 240, 244)) return o(e);
                240 === c && (s = 144),
                  244 === c && (l = 143),
                  (a = 3),
                  (n = c - 240);
              }
              return (n <<= 6 * a), null;
            }
            if (!i(c, s, l))
              return (n = a = r = 0), (s = 128), (l = 191), t.prepend(c), o(e);
            if (
              ((s = 128),
              (l = 191),
              (n += (c - 128) << (6 * (a - (r += 1)))),
              r !== a)
            )
              return null;
            var u = n;
            return (n = a = r = 0), u;
          };
        }
        s.prototype = {
          decode: function (t, e) {
            var n;
            (n =
              'object' == typeof t && t instanceof ArrayBuffer
                ? new Uint8Array(t)
                : 'object' == typeof t &&
                  'buffer' in t &&
                  t.buffer instanceof ArrayBuffer
                ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
                : new Uint8Array(0)),
              (e = r(e)),
              this._streaming ||
                ((this._decoder = new l({ fatal: this._fatal })),
                (this._BOMseen = !1)),
              (this._streaming = Boolean(e.stream));
            for (
              var i, o = new a(n), s = [];
              !o.endOfStream() &&
              -1 !== (i = this._decoder.handler(o, o.read()));

            )
              null !== i && (Array.isArray(i) ? s.push.apply(s, i) : s.push(i));
            if (!this._streaming) {
              do {
                if (-1 === (i = this._decoder.handler(o, o.read()))) break;
                null !== i &&
                  (Array.isArray(i) ? s.push.apply(s, i) : s.push(i));
              } while (!o.endOfStream());
              this._decoder = null;
            }
            return (
              s.length &&
                (-1 === ['utf-8'].indexOf(this.encoding) ||
                  this._ignoreBOM ||
                  this._BOMseen ||
                  (65279 === s[0]
                    ? ((this._BOMseen = !0), s.shift())
                    : (this._BOMseen = !0))),
              (function (t) {
                for (var e = '', n = 0; n < t.length; ++n) {
                  var i = t[n];
                  i <= 65535
                    ? (e += String.fromCharCode(i))
                    : ((i -= 65536),
                      (e += String.fromCharCode(
                        55296 + (i >> 10),
                        56320 + (1023 & i),
                      )));
                }
                return e;
              })(s)
            );
          },
        };
      },
      15: function (t, e, n) {
        'use strict';
        var i = n(0);
        e.a = {
          setDefineMapping: function (t, e, n) {
            Object.keys(n).forEach(function (i) {
              t.defines[''.concat(e, '_').concat(i)] = n[i];
            });
          },
          setDefineProperty: function (t, e, n, i) {
            (t.defines[n] = i),
              Object.defineProperty(t, e, {
                get: function () {
                  return t.defines[n];
                },
                set: function (e) {
                  t.defines[n] != e &&
                    ((t.defines[n] = e), (t.needsUpdate = !0));
                },
              });
          },
          setUniformProperty: function (t, e, n) {
            (t.uniforms[e] = new i.Uniform(n)),
              Object.defineProperty(t, e, {
                get: function () {
                  return t.uniforms[e].value;
                },
                set: function (n) {
                  t.uniforms[e].value != n && (t.uniforms[e].value = n);
                },
              });
          },
        };
      },
      16: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return T;
        }),
          n.d(e, 'c', function () {
            return A;
          }),
          n.d(e, 'b', function () {
            return N;
          });
        var i = n(18),
          r = n.n(i),
          a = n(6),
          o = n.n(a),
          s = n(7),
          l = n.n(s),
          c = n(2),
          u = n.n(c),
          h = n(4),
          d = n.n(h),
          p = n(3),
          f = n.n(p),
          m = n(0),
          g = n(11),
          y = n(8),
          v = n(10),
          x = n(55);
        function b(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return _(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return _(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function _(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function w(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = u()(t);
            if (e) {
              var r = u()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return l()(this, n);
          };
        }
        function M(t) {
          return new g.a(t, 1 / 0, -1 / 0, 1 / 0, -1 / 0);
        }
        var q = new y.a('EPSG:4326', 0, 0, 0),
          S = new m.Vector3(0, 0, 1),
          T = { POINT: 0, LINE: 1, POLYGON: 2 },
          E = ['point', 'stroke', 'fill'],
          A = (function () {
            function t(e) {
              f()(this, t),
                (this.indices = []),
                (this.properties = {}),
                (this.size = e.size),
                e.extent &&
                  ((this.extent = M(e.extent.crs)),
                  (this._currentExtent = M(e.extent.crs))),
                (this.altitude = { min: 1 / 0, max: -1 / 0 });
            }
            return (
              d()(t, [
                {
                  key: 'startSubGeometry',
                  value: function (t, e) {
                    var n = this.indices.length - 1,
                      i = this.extent ? M(this.extent.crs) : void 0,
                      r =
                        n > -1
                          ? this.indices[n].offset + this.indices[n].count
                          : e.vertices.length / this.size;
                    this.indices.push({ offset: r, count: t, extent: i }),
                      (this._currentExtent = i),
                      (function (t, e) {
                        (t.vertices.length += e * t.size),
                          t.normals && (t.normals.length = t.vertices.length);
                      })(e, t);
                  },
                },
                {
                  key: 'closeSubGeometry',
                  value: function (t, e) {
                    var n = this.indices.length - 1,
                      i =
                        n > -1
                          ? this.indices[n].offset + this.indices[n].count
                          : e.vertices.length / this.size - t;
                    this.indices.push({
                      offset: i,
                      count: t,
                      extent: this._currentExtent,
                    }),
                      this.extent &&
                        (this.extent.union(this._currentExtent),
                        (this._currentExtent = M(this.extent.crs)));
                  },
                },
                {
                  key: 'getLastSubGeometry',
                  value: function () {
                    var t = this.indices.length - 1;
                    return this.indices[t];
                  },
                },
                {
                  key: 'pushCoordinates',
                  value: function (t, e) {
                    if (3 == this.size) {
                      var n = e.style[E[e.type]].base_altitude;
                      t.z = isNaN(n) ? n(this.properties, t) : n;
                    }
                    t.as(e.crs, q),
                      e.transformToLocalSystem(q),
                      e.normals && q.geodesicNormal.toArray(e.normals, e._pos),
                      e._pushValues(q.x, q.y, q.z),
                      this._currentExtent &&
                        this._currentExtent.expandByCoordinates(
                          e.useCrsOut ? q : t,
                        ),
                      3 == this.size &&
                        ((this.altitude.min = Math.min(this.altitude.min, t.z)),
                        (this.altitude.max = Math.max(this.altitude.max, t.z)));
                  },
                },
                {
                  key: 'pushCoordinatesValues',
                  value: function (t, e, n) {
                    var i =
                        arguments.length > 3 && void 0 !== arguments[3]
                          ? arguments[3]
                          : 0,
                      r =
                        arguments.length > 4 && void 0 !== arguments[4]
                          ? arguments[4]
                          : S;
                    t.normals && r.toArray(t.normals, t._pos),
                      t._pushValues(e, n, i),
                      this._currentExtent &&
                        this._currentExtent.expandByValuesCoordinates(e, n),
                      3 == this.size &&
                        ((this.altitude.min = Math.min(this.altitude.min, i)),
                        (this.altitude.max = Math.max(this.altitude.max, i)));
                  },
                },
                {
                  key: 'updateExtent',
                  value: function () {
                    if (this.extent) {
                      var t = this.indices[this.indices.length - 1];
                      t && this.extent.union(t.extent);
                    }
                  },
                },
              ]),
              t
            );
          })();
        function L(t, e) {
          (this.vertices[this._pos++] = t), (this.vertices[this._pos++] = e);
        }
        function R(t, e) {
          var n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          (this.vertices[this._pos++] = t),
            (this.vertices[this._pos++] = e),
            (this.vertices[this._pos++] = n);
        }
        var C = (function () {
          function t(e, n) {
            if (
              (f()(this, t),
              !Object.keys(T).find(function (t) {
                return T[t] === e;
              }))
            )
              throw new Error('Unsupported Feature type: '.concat(e));
            (this.type = e),
              (this.geometries = []),
              (this.vertices = []),
              (this.crs = n.crs),
              (this.size = n.size),
              (this.normals = 3 == n.size ? [] : void 0),
              (this.transformToLocalSystem = n.transformToLocalSystem.bind(n)),
              n.extent &&
                ((this.extent = M(n.extent.crs)),
                (this.useCrsOut = this.extent.crs == this.crs)),
              (this._pos = 0),
              (this._pushValues = (3 === this.size ? R : L).bind(this)),
              (this.style = new x.a({}, n.style)),
              (this.altitude = { min: 1 / 0, max: -1 / 0 });
          }
          return (
            d()(t, [
              {
                key: 'bindNewGeometry',
                value: function () {
                  var t = new A(this);
                  return this.geometries.push(t), t;
                },
              },
              {
                key: 'updateExtent',
                value: function (t) {
                  this.extent && this.extent.union(t.extent),
                    3 == this.size &&
                      ((this.altitude.min = Math.min(
                        this.altitude.min,
                        t.altitude.min,
                      )),
                      (this.altitude.max = Math.max(
                        this.altitude.max,
                        t.altitude.max,
                      )));
                },
              },
              {
                key: 'geometryCount',
                get: function () {
                  return this.geometries.length;
                },
              },
            ]),
            t
          );
        })();
        e.d = C;
        var P = function () {},
          k = function (t, e) {
            return (
              t.geodesicNormal.applyNormalMatrix(e.normalMatrixInverse),
              t.applyMatrix4(e.matrixWorldInverse)
            );
          },
          I = function (t, e) {
            return t.applyMatrix4(e.matrixWorldInverse);
          },
          D = new m.Vector3(0, 0, 1),
          O = new m.Quaternion(),
          N = (function (t) {
            o()(n, t);
            var e = w(n);
            function n(t) {
              var i;
              return (
                f()(this, n),
                ((i = e.call(this)).isFeatureCollection = !0),
                (i.crs = v.a.formatToEPSG(t.crs)),
                (i.features = []),
                (i.mergeFeatures =
                  void 0 === t.mergeFeatures || t.mergeFeatures),
                (i.extent = t.buildExtent
                  ? M(t.forcedExtentCrs || i.crs)
                  : void 0),
                (i.size = '3d' == t.structure ? 3 : 2),
                (i.filterExtent = t.filterExtent),
                (i.style = t.style),
                (i.isInverted = !1),
                (i.matrixWorldInverse = new m.Matrix4()),
                (i.center = new y.a('EPSG:4326', 0, 0)),
                2 == i.size
                  ? ((i._setLocalSystem = function (t) {
                      t.as('EPSG:4326', i.center),
                        i.position.copy(t),
                        i.updateMatrixWorld(),
                        (i._setLocalSystem = P);
                    }),
                    (i._transformToLocalSystem = I))
                  : ((i._setLocalSystem = function (t) {
                      t.as('EPSG:4326', i.center),
                        'EPSG:4978' == i.crs &&
                          (i.quaternion.setFromUnitVectors(D, t.geodesicNormal),
                          O.setFromAxisAngle(
                            D,
                            m.MathUtils.degToRad(90 + i.center.longitude),
                          ),
                          i.quaternion.multiply(O)),
                        i.position.copy(t),
                        i.updateMatrixWorld(),
                        i.normalMatrix.getNormalMatrix(i.matrix),
                        (i.normalMatrixInverse = new m.Matrix3()
                          .copy(i.normalMatrix)
                          .invert()),
                        (i._setLocalSystem = P);
                    }),
                    (i._transformToLocalSystem = k)),
                (i.altitude = { min: 1 / 0, max: -1 / 0 }),
                i
              );
            }
            return (
              d()(n, [
                {
                  key: 'transformToLocalSystem',
                  value: function (t) {
                    return (
                      this._setLocalSystem(t),
                      this._transformToLocalSystem(t, this)
                    );
                  },
                },
                {
                  key: 'updateExtent',
                  value: function (t) {
                    if (this.extent) {
                      var e,
                        n = b(
                          t
                            ? [t]
                            : this.features.map(function (t) {
                                return t.extent;
                              }),
                        );
                      try {
                        for (n.s(); !(e = n.n()).done; ) {
                          var i = e.value;
                          this.extent.union(i);
                        }
                      } catch (t) {
                        n.e(t);
                      } finally {
                        n.f();
                      }
                    }
                    if (3 == this.size) {
                      var r,
                        a = b(this.features);
                      try {
                        for (a.s(); !(r = a.n()).done; ) {
                          var o = r.value;
                          (this.altitude.min = Math.min(
                            this.altitude.min,
                            o.altitude.min,
                          )),
                            (this.altitude.max = Math.max(
                              this.altitude.max,
                              o.altitude.max,
                            ));
                        }
                      } catch (t) {
                        a.e(t);
                      } finally {
                        a.f();
                      }
                    }
                    (this.altitude.min =
                      this.altitude.min == 1 / 0 ? 0 : this.altitude.min),
                      (this.altitude.max =
                        this.altitude.max == -1 / 0 ? 0 : this.altitude.max);
                  },
                },
                {
                  key: 'updateMatrixWorld',
                  value: function (t) {
                    r()(u()(n.prototype), 'updateMatrixWorld', this).call(
                      this,
                      t,
                    ),
                      this.matrixWorldInverse.copy(this.matrixWorld).invert();
                  },
                },
                {
                  key: 'removeEmptyFeature',
                  value: function () {
                    this.features = this.features.filter(function (t) {
                      return t.geometries.length;
                    });
                  },
                },
                {
                  key: 'pushFeature',
                  value: function (t) {
                    this.features.push(t), this.updateExtent(t.extent);
                  },
                },
                {
                  key: 'requestFeature',
                  value: function (t, e) {
                    var n = this.features.find(e);
                    if (n && this.mergeFeatures) return n;
                    var i = new C(t, this);
                    return this.features.push(i), i;
                  },
                },
                {
                  key: 'requestFeatureByType',
                  value: function (t) {
                    return this.requestFeature(t, function (e) {
                      return e.type === t;
                    });
                  },
                },
                {
                  key: 'requestFeatureById',
                  value: function (t, e) {
                    return this.requestFeature(e, function (e) {
                      return e.id === t;
                    });
                  },
                },
                {
                  key: 'newFeatureByReference',
                  value: function (t) {
                    var e = new C(t.type, this);
                    return (
                      (e.extent = t.extent),
                      (e.geometries = t.geometries),
                      (e.normals = t.normals),
                      (e.size = t.size),
                      (e.vertices = t.vertices),
                      (e._pos = t._pos),
                      this.features.push(e),
                      e
                    );
                  },
                },
                {
                  key: 'setParentStyle',
                  value: function (t) {
                    t &&
                      this.features.forEach(function (e) {
                        e.style.parent = t;
                      });
                  },
                },
              ]),
              n
            );
          })(m.Object3D);
      },
      174: function (t, e) {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        (e.read = function (t, e, n, i, r) {
          var a,
            o,
            s = 8 * r - i - 1,
            l = (1 << s) - 1,
            c = l >> 1,
            u = -7,
            h = n ? r - 1 : 0,
            d = n ? -1 : 1,
            p = t[e + h];
          for (
            h += d, a = p & ((1 << -u) - 1), p >>= -u, u += s;
            u > 0;
            a = 256 * a + t[e + h], h += d, u -= 8
          );
          for (
            o = a & ((1 << -u) - 1), a >>= -u, u += i;
            u > 0;
            o = 256 * o + t[e + h], h += d, u -= 8
          );
          if (0 === a) a = 1 - c;
          else {
            if (a === l) return o ? NaN : (1 / 0) * (p ? -1 : 1);
            (o += Math.pow(2, i)), (a -= c);
          }
          return (p ? -1 : 1) * o * Math.pow(2, a - i);
        }),
          (e.write = function (t, e, n, i, r, a) {
            var o,
              s,
              l,
              c = 8 * a - r - 1,
              u = (1 << c) - 1,
              h = u >> 1,
              d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              p = i ? 0 : a - 1,
              f = i ? 1 : -1,
              m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
            for (
              e = Math.abs(e),
                isNaN(e) || e === 1 / 0
                  ? ((s = isNaN(e) ? 1 : 0), (o = u))
                  : ((o = Math.floor(Math.log(e) / Math.LN2)),
                    e * (l = Math.pow(2, -o)) < 1 && (o--, (l *= 2)),
                    (e += o + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >=
                      2 && (o++, (l /= 2)),
                    o + h >= u
                      ? ((s = 0), (o = u))
                      : o + h >= 1
                      ? ((s = (e * l - 1) * Math.pow(2, r)), (o += h))
                      : ((s = e * Math.pow(2, h - 1) * Math.pow(2, r)),
                        (o = 0)));
              r >= 8;
              t[n + p] = 255 & s, p += f, s /= 256, r -= 8
            );
            for (
              o = (o << r) | s, c += r;
              c > 0;
              t[n + p] = 255 & o, p += f, o /= 256, c -= 8
            );
            t[n + p - f] |= 128 * m;
          });
      },
      18: function (t, e, n) {
        var i = n(207);
        function r(e, n, a) {
          return (
            'undefined' != typeof Reflect && Reflect.get
              ? ((t.exports = r = Reflect.get),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0))
              : ((t.exports = r =
                  function (t, e, n) {
                    var r = i(t, e);
                    if (r) {
                      var a = Object.getOwnPropertyDescriptor(r, e);
                      return a.get ? a.get.call(n) : a.value;
                    }
                  }),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0)),
            r(e, n, a || e)
          );
        }
        (t.exports = r),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      19: function (t, e, n) {
        'use strict';
        n.d(e, 'b', function () {
          return o;
        }),
          n.d(e, 'a', function () {
            return s;
          });
        var i = n(0);
        function r(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return a(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return a(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var o,
            s = !0,
            l = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (s = t.done), t;
            },
            e: function (t) {
              (l = !0), (o = t);
            },
            f: function () {
              try {
                s || null == n.return || n.return();
              } finally {
                if (l) throw o;
              }
            },
          };
        }
        function a(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        var o = 0,
          s = {
            UPDATE_START: 'update_start',
            BEFORE_CAMERA_UPDATE: 'before_camera_update',
            AFTER_CAMERA_UPDATE: 'after_camera_update',
            BEFORE_LAYER_UPDATE: 'before_layer_update',
            AFTER_LAYER_UPDATE: 'after_layer_update',
            BEFORE_RENDER: 'before_render',
            AFTER_RENDER: 'after_render',
            UPDATE_END: 'update_end',
          };
        function l(t, e) {
          (this.renderingState = o),
            (this.needsRedraw = !1),
            (this.scheduler = t),
            (this.gfxEngine = e),
            (this._updateLoopRestarted = !0);
        }
        function c(t, e, n) {
          if (n) {
            var i,
              a = r(n);
            try {
              for (a.s(); !(i = a.n()).done; ) {
                var o = i.value,
                  s = e.update(t, e, o),
                  l = e.getObjectToUpdateForAttachedLayers(o);
                if (l)
                  if (l.element) {
                    var u,
                      h = r(e.attachedLayers);
                    try {
                      for (h.s(); !(u = h.n()).done; ) {
                        var d = u.value;
                        d.ready &&
                          (d.update(t, d, l.element, l.parent),
                          d.cache.flush());
                      }
                    } catch (t) {
                      h.e(t);
                    } finally {
                      h.f();
                    }
                  } else if (l.elements)
                    for (var p = 0; p < l.elements.length; p++) {
                      if (!l.elements[p].isObject3D)
                        throw new Error(
                          '\n                            Invalid object for attached layer to update.\n                            Must be a THREE.Object and have a THREE.Material',
                        );
                      var f,
                        m = r(e.attachedLayers);
                      try {
                        for (m.s(); !(f = m.n()).done; ) {
                          var g = f.value;
                          g.ready &&
                            (g.update(t, g, l.elements[p], l.parent),
                            g.cache.flush());
                        }
                      } catch (t) {
                        m.e(t);
                      } finally {
                        m.f();
                      }
                    }
                c(t, e, s);
              }
            } catch (t) {
              a.e(t);
            } finally {
              a.f();
            }
          }
        }
        function u(t, e) {
          var n = !1,
            i = new Set();
          return (
            t.forEach(function (t) {
              t === e || t.isCamera
                ? (e.info.clear(), (n = !0))
                : t.layer === e && i.add(t);
            }),
            n ? new Set([e]) : i
          );
        }
        (l.prototype = Object.create(i.EventDispatcher.prototype)),
          (l.prototype.constructor = l),
          (l.prototype.scheduleViewUpdate = function (t, e) {
            var n = this;
            (this.needsRedraw |= e),
              1 !== this.renderingState &&
                ((this.renderingState = 1),
                requestAnimationFrame(function (e) {
                  n._step(t, e);
                }));
          }),
          (l.prototype._update = function (t, e, n) {
            var i = {
              camera: t.camera,
              engine: this.gfxEngine,
              scheduler: this.scheduler,
              view: t,
            };
            e.forEach(function (t) {
              var n = t.layer || t;
              n.isLayer && n.parent && e.add(n.parent);
            });
            var a,
              o = r(
                t.getLayers(function (t, e) {
                  return !e;
                }),
              );
            try {
              for (o.s(); !(a = o.n()).done; ) {
                var l = a.value;
                if (
                  ((i.geometryLayer = l), l.ready && l.visible && !l.frozen)
                ) {
                  t.execFrameRequesters(
                    s.BEFORE_LAYER_UPDATE,
                    n,
                    this._updateLoopRestarted,
                    l,
                  );
                  var h = u(e, l);
                  if (h.size > 0) {
                    var d,
                      p = r(l.attachedLayers);
                    try {
                      for (p.s(); !(d = p.n()).done; ) {
                        var f = d.value;
                        f.ready && f.preUpdate && f.preUpdate(i, h);
                      }
                    } catch (t) {
                      p.e(t);
                    } finally {
                      p.f();
                    }
                    var m = l.preUpdate(i, h);
                    c(i, l, m), l.postUpdate(i, l, e);
                  }
                  l.cache.flush(),
                    t.execFrameRequesters(
                      s.AFTER_LAYER_UPDATE,
                      n,
                      this._updateLoopRestarted,
                      l,
                    );
                }
              }
            } catch (t) {
              o.e(t);
            } finally {
              o.f();
            }
          }),
          (l.prototype._step = function (t, e) {
            var n = e - this._lastTimestamp;
            t._executeFrameRequestersRemovals(),
              t.execFrameRequesters(
                s.UPDATE_START,
                n,
                this._updateLoopRestarted,
              );
            var i = this.needsRedraw;
            (this._lastTimestamp = e),
              (this.needsRedraw = !1),
              (this.renderingState = o);
            var r = new Set(t._changeSources);
            t._changeSources.clear();
            var a = this.gfxEngine.getWindowSize();
            t.execFrameRequesters(
              s.BEFORE_CAMERA_UPDATE,
              n,
              this._updateLoopRestarted,
            ),
              t.camera.update(a.x, a.y),
              t.execFrameRequesters(
                s.AFTER_CAMERA_UPDATE,
                n,
                this._updateLoopRestarted,
              );
            var l = t.camera.camera3D.matrixAutoUpdate;
            (t.camera.camera3D.matrixAutoUpdate = !1),
              this._update(t, r, n),
              0 == this.scheduler.commandsWaitingExecutionCount() &&
                this.dispatchEvent({ type: 'command-queue-empty' }),
              i && this._renderView(t, n),
              (this._updateLoopRestarted = this.renderingState === o),
              (t.camera.camera3D.matrixAutoUpdate = l),
              t.execFrameRequesters(s.UPDATE_END, n, this._updateLoopRestarted);
          }),
          (l.prototype._renderView = function (t, e) {
            t.execFrameRequesters(
              s.BEFORE_RENDER,
              e,
              this._updateLoopRestarted,
            ),
              t.render ? t.render() : this.gfxEngine.renderView(t),
              t.execFrameRequesters(
                s.AFTER_RENDER,
                e,
                this._updateLoopRestarted,
              );
          }),
          (e.c = l);
      },
      2: function (t, e) {
        function n(e) {
          return (
            (t.exports = n =
              Object.setPrototypeOf
                ? Object.getPrototypeOf
                : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t);
                  }),
            (t.exports.default = t.exports),
            (t.exports.__esModule = !0),
            n(e)
          );
        }
        (t.exports = n),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      20: function (t, e, n) {
        'use strict';
        var i = n(0);
        function r(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return a(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return a(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var o,
            s = !0,
            l = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (s = t.done), t;
            },
            e: function (t) {
              (l = !0), (o = t);
            },
            f: function () {
              try {
                s || null == n.return || n.return();
              } finally {
                if (l) throw o;
              }
            },
          };
        }
        function a(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        var o = new i.TextureLoader();
        function s(t) {
          if (!t.ok) {
            var e = new Error(
              'Error loading '.concat(t.url, ': status ').concat(t.status),
            );
            throw ((e.response = t), e);
          }
        }
        var l = function (t) {
          var e =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return fetch(t, e).then(function (t) {
            return s(t), t.arrayBuffer();
          });
        };
        function c(t) {
          var e =
            !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (e) {
            var n = new i.DataTexture(t, 256, 256, i.RedFormat, i.FloatType);
            return (n.internalFormat = 'R32F'), n;
          }
          return new i.DataTexture(t, 256, 256, i.AlphaFormat, i.FloatType);
        }
        e.a = {
          text: function (t) {
            var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            return fetch(t, e).then(function (t) {
              return s(t), t.text();
            });
          },
          json: function (t) {
            var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            return fetch(t, e).then(function (t) {
              return s(t), t.json();
            });
          },
          xml: function (t) {
            var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            return fetch(t, e)
              .then(function (t) {
                return s(t), t.text();
              })
              .then(function (t) {
                return new window.DOMParser().parseFromString(t, 'text/xml');
              });
          },
          texture: function (t) {
            var e,
              n,
              i =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
            o.crossOrigin = i.crossOrigin;
            var r = new Promise(function (t, i) {
              (e = t), (n = i);
            });
            return o.load(t, e, function () {}, n), r;
          },
          arrayBuffer: l,
          textureFloat: function (t) {
            var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            return l(t, e).then(function (t) {
              return c(new Float32Array(t), e.isWebGL2);
            });
          },
          multiple: function (t, e) {
            var n,
              i = this,
              a =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {},
              o = [];
            for (var s in e) {
              if (!this[s])
                throw new Error(
                  ''.concat(s, ' is not a valid Fetcher method.'),
                );
              var l,
                c = r(e[s]);
              try {
                var u = function () {
                  var e = l.value;
                  (n = ''.concat(t, '.').concat(e)),
                    o.push(
                      i[s](n, a).then(function (t) {
                        return { type: e, result: t };
                      }),
                    );
                };
                for (c.s(); !(l = c.n()).done; ) u();
              } catch (t) {
                c.e(t);
              } finally {
                c.f();
              }
            }
            return Promise.all(o).then(function (t) {
              var e,
                n = {},
                i = r(t);
              try {
                for (i.s(); !(e = i.n()).done; ) {
                  var a = e.value;
                  n[a.type] = a.result;
                }
              } catch (t) {
                i.e(t);
              } finally {
                i.f();
              }
              return Promise.resolve(n);
            });
          },
        };
      },
      207: function (t, e, n) {
        var i = n(2);
        (t.exports = function (t, e) {
          for (
            ;
            !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = i(t));

          );
          return t;
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      208: function (t, e) {
        function n(e, i) {
          return (
            (t.exports = n =
              Object.setPrototypeOf ||
              function (t, e) {
                return (t.__proto__ = e), t;
              }),
            (t.exports.default = t.exports),
            (t.exports.__esModule = !0),
            n(e, i)
          );
        }
        (t.exports = n),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      209: function (t, e, n) {
        var i = n(140);
        (t.exports = function (t) {
          if (Array.isArray(t)) return i(t);
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      210: function (t, e) {
        (t.exports = function (t) {
          if ('undefined' != typeof Symbol && Symbol.iterator in Object(t))
            return Array.from(t);
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      211: function (t, e) {
        (t.exports = function () {
          throw new TypeError(
            'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
          );
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      212: function (t, e) {
        (t.exports = function (t) {
          if (Array.isArray(t)) return t;
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      213: function (t, e) {
        (t.exports = function (t, e) {
          if ('undefined' != typeof Symbol && Symbol.iterator in Object(t)) {
            var n = [],
              i = !0,
              r = !1,
              a = void 0;
            try {
              for (
                var o, s = t[Symbol.iterator]();
                !(i = (o = s.next()).done) &&
                (n.push(o.value), !e || n.length !== e);
                i = !0
              );
            } catch (t) {
              (r = !0), (a = t);
            } finally {
              try {
                i || null == s.return || s.return();
              } finally {
                if (r) throw a;
              }
            }
            return n;
          }
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      214: function (t, e) {
        (t.exports = function () {
          throw new TypeError(
            'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
          );
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      215: function (t, e, n) {
        'use strict';
        var i = n(142);
        function r(t, e, n) {
          if (3 === t) {
            var r = new i(n, n.readVarint() + n.pos);
            r.length && (e[r.name] = r);
          }
        }
        t.exports = function (t, e) {
          this.layers = t.readFields(r, {}, e);
        };
      },
      216: function (t, e, n) {
        'use strict';
        function i(t, e) {
          (this.x = t), (this.y = e);
        }
        (t.exports = i),
          (i.prototype = {
            clone: function () {
              return new i(this.x, this.y);
            },
            add: function (t) {
              return this.clone()._add(t);
            },
            sub: function (t) {
              return this.clone()._sub(t);
            },
            multByPoint: function (t) {
              return this.clone()._multByPoint(t);
            },
            divByPoint: function (t) {
              return this.clone()._divByPoint(t);
            },
            mult: function (t) {
              return this.clone()._mult(t);
            },
            div: function (t) {
              return this.clone()._div(t);
            },
            rotate: function (t) {
              return this.clone()._rotate(t);
            },
            rotateAround: function (t, e) {
              return this.clone()._rotateAround(t, e);
            },
            matMult: function (t) {
              return this.clone()._matMult(t);
            },
            unit: function () {
              return this.clone()._unit();
            },
            perp: function () {
              return this.clone()._perp();
            },
            round: function () {
              return this.clone()._round();
            },
            mag: function () {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals: function (t) {
              return this.x === t.x && this.y === t.y;
            },
            dist: function (t) {
              return Math.sqrt(this.distSqr(t));
            },
            distSqr: function (t) {
              var e = t.x - this.x,
                n = t.y - this.y;
              return e * e + n * n;
            },
            angle: function () {
              return Math.atan2(this.y, this.x);
            },
            angleTo: function (t) {
              return Math.atan2(this.y - t.y, this.x - t.x);
            },
            angleWith: function (t) {
              return this.angleWithSep(t.x, t.y);
            },
            angleWithSep: function (t, e) {
              return Math.atan2(
                this.x * e - this.y * t,
                this.x * t + this.y * e,
              );
            },
            _matMult: function (t) {
              var e = t[0] * this.x + t[1] * this.y,
                n = t[2] * this.x + t[3] * this.y;
              return (this.x = e), (this.y = n), this;
            },
            _add: function (t) {
              return (this.x += t.x), (this.y += t.y), this;
            },
            _sub: function (t) {
              return (this.x -= t.x), (this.y -= t.y), this;
            },
            _mult: function (t) {
              return (this.x *= t), (this.y *= t), this;
            },
            _div: function (t) {
              return (this.x /= t), (this.y /= t), this;
            },
            _multByPoint: function (t) {
              return (this.x *= t.x), (this.y *= t.y), this;
            },
            _divByPoint: function (t) {
              return (this.x /= t.x), (this.y /= t.y), this;
            },
            _unit: function () {
              return this._div(this.mag()), this;
            },
            _perp: function () {
              var t = this.y;
              return (this.y = this.x), (this.x = -t), this;
            },
            _rotate: function (t) {
              var e = Math.cos(t),
                n = Math.sin(t),
                i = e * this.x - n * this.y,
                r = n * this.x + e * this.y;
              return (this.x = i), (this.y = r), this;
            },
            _rotateAround: function (t, e) {
              var n = Math.cos(t),
                i = Math.sin(t),
                r = e.x + n * (this.x - e.x) - i * (this.y - e.y),
                a = e.y + i * (this.x - e.x) + n * (this.y - e.y);
              return (this.x = r), (this.y = a), this;
            },
            _round: function () {
              return (
                (this.x = Math.round(this.x)),
                (this.y = Math.round(this.y)),
                this
              );
            },
          }),
          (i.convert = function (t) {
            return t instanceof i
              ? t
              : Array.isArray(t)
              ? new i(t[0], t[1])
              : t;
          });
      },
      22: function (t, e, n) {
        var i = n(209),
          r = n(210),
          a = n(141),
          o = n(211);
        (t.exports = function (t) {
          return i(t) || r(t) || a(t) || o();
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      24: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return q;
        });
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(5),
          l = n.n(s),
          c = n(6),
          u = n.n(c),
          h = n(7),
          d = n.n(h),
          p = n(2),
          f = n.n(p),
          m = n(0),
          g = n(68),
          y = n(112),
          v = n(40),
          x = n(39);
        function b(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return _(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return _(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function _(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function w(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = f()(t);
            if (e) {
              var r = f()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return d()(this, n);
          };
        }
        var M = (function (t) {
          u()(n, t);
          var e = w(n);
          function n(t) {
            var i,
              a =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
            if (
              (r()(this, n),
              a.projection &&
                (console.warn(
                  'Layer projection parameter is deprecated, use crs instead.',
                ),
                (a.crs = a.crs || a.projection)),
              void 0 === a.source || !0 === a.source)
            )
              throw new Error('Layer '.concat(t, ' needs Source'));
            return (
              ((i = e.call(this)).isLayer = !0),
              Object.assign(l()(i), a),
              Object.defineProperty(l()(i), 'id', { value: t, writable: !1 }),
              (i.options = a.options || {}),
              i.updateStrategy ||
                (i.updateStrategy = { type: g.c, options: {} }),
              i.defineLayerProperty('frozen', !1),
              a.zoom
                ? ((i.zoom = { max: a.zoom.max, min: a.zoom.min || 0 }),
                  null == i.zoom.max && (i.zoom.max = 1 / 0))
                : (i.zoom = { max: 1 / 0, min: 0 }),
              (i.info = new y.b(l()(i))),
              (i.source = i.source || new v.a({ url: 'none' })),
              (i.ready = !1),
              (i._promises = []),
              (i.whenReady = new Promise(function (t, e) {
                (i._resolve = t), (i._reject = e);
              }).then(function () {
                return (
                  (i.ready = !0), i.source.onLayerAdded({ out: l()(i) }), l()(i)
                );
              })),
              i._promises.push(i.source.whenReady),
              (i.cache = new x.b(a.cacheLifeTime)),
              (i.mergeFeatures = void 0 === i.mergeFeatures || a.mergeFeatures),
              (i.filter = i.filter || i.source.filter),
              i
            );
          }
          return (
            o()(n, [
              {
                key: 'addInitializationStep',
                value: function () {
                  var t;
                  return (
                    this._promises.push(
                      new Promise(function (e) {
                        t = e;
                      }),
                    ),
                    t
                  );
                },
              },
              {
                key: 'defineLayerProperty',
                value: function (t, e, n) {
                  var i = this,
                    r = Object.getOwnPropertyDescriptor(this, t);
                  if (!r || !r.set) {
                    var a = null == this[t] ? e : this[t];
                    Object.defineProperty(this, t, {
                      get: function () {
                        return a;
                      },
                      set: function (e) {
                        if (a !== e) {
                          var r = {
                            type: ''.concat(t, '-property-changed'),
                            previous: {},
                            new: {},
                          };
                          (r.previous[t] = a),
                            (r.new[t] = e),
                            (a = e),
                            n && n(i, t),
                            i.dispatchEvent(r);
                        }
                      },
                    });
                  }
                },
              },
              {
                key: 'convert',
                value: function (t) {
                  return t;
                },
              },
              {
                key: 'getData',
                value: function (t, e) {
                  var n = this,
                    i = this.source.requestToKey(
                      this.source.isVectorSource ? e : t,
                    ),
                    r = this.cache.getByArray(i);
                  return (
                    r ||
                      ((r = this.source.loadData(t, this).then(
                        function (t) {
                          return n.convert(t, e);
                        },
                        function (t) {
                          throw t;
                        },
                      )),
                      this.cache.setByArray(r, i)),
                    r
                  );
                },
              },
              { key: 'isValidData', value: function () {} },
              {
                key: 'delete',
                value: function () {
                  console.warn("Function delete doesn't exist for this layer");
                },
              },
            ]),
            n
          );
        })(m.EventDispatcher);
        e.b = M;
        var q = {
          moveLayerToIndex: function (t, e, n) {
            (e = Math.min(e, n.length - 1)), (e = Math.max(e, 0));
            var i,
              r = t.sequence,
              a = b(n);
            try {
              for (a.s(); !(i = a.n()).done; ) {
                var o = i.value;
                o.id === t.id
                  ? (o.sequence = e)
                  : o.sequence > r && o.sequence <= e
                  ? o.sequence--
                  : o.sequence >= e && o.sequence < r && o.sequence++;
              }
            } catch (t) {
              a.e(t);
            } finally {
              a.f();
            }
          },
          moveLayerDown: function (t, e) {
            t.sequence > 0 && this.moveLayerToIndex(t, t.sequence - 1, e);
          },
          moveLayerUp: function (t, e) {
            var n = e.length - 1;
            t.sequence < n && this.moveLayerToIndex(t, t.sequence + 1, e);
          },
          getColorLayersIdOrderedBySequence: function (t) {
            var e = Array.from(t);
            return (
              e.sort(function (t, e) {
                return t.sequence - e.sequence;
              }),
              e.map(function (t) {
                return t.id;
              })
            );
          },
        };
      },
      29: function (t, e, n) {
        'use strict';
        n.d(e, 'e', function () {
          return A;
        }),
          n.d(e, 'd', function () {
            return L;
          }),
          n.d(e, 'b', function () {
            return R;
          }),
          n.d(e, 'a', function () {
            return I;
          });
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(5),
          l = n.n(s),
          c = n(6),
          u = n.n(c),
          h = n(7),
          d = n.n(h),
          p = n(2),
          f = n.n(p),
          m = n(0),
          g = n(62),
          y = n(31),
          v = n(49),
          x = n(15);
        function b(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = f()(t);
            if (e) {
              var r = f()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return d()(this, n);
          };
        }
        function _(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return w(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return w(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function w(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        var M =
            '#include <itowns/WebGL2_pars_vertex>\n#include <itowns/precision_qualifier>\n#include <common>\n#include <itowns/project_pars_vertex>\n#include <itowns/elevation_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nattribute vec2      uv_0;\n#if NUM_CRS > 1\nattribute float     uv_1;\n#endif\nattribute vec3      normal;\n\nuniform mat4 modelMatrix;\nuniform bool lightingEnabled;\nvarying vec2 vHighPrecisionZW;\n\n#if MODE == MODE_FINAL\n#include <fog_pars_vertex>\nvarying vec3        vUv;\nvarying vec3        vNormal;\n#endif\nvoid main() {\n        vec2 uv = vec2(uv_0.x, 1.0 - uv_0.y);\n\n        #include <begin_vertex>\n        #include <itowns/elevation_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        vHighPrecisionZW = gl_Position.zw;\n#if MODE == MODE_FINAL\n        #include <fog_vertex>\n        #if NUM_CRS > 1\n        vUv = vec3(uv_0, (uv_1 > 0.) ? uv_1 : uv_0.y); // set uv_1 = uv_0 if uv_1 is undefined\n        #else\n        vUv = vec3(uv_0, 0.0);\n        #endif\n        vNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n#endif\n}\n',
          q =
            '#include <itowns/WebGL2_pars_fragment>\n#include <itowns/precision_qualifier>\n#include <logdepthbuf_pars_fragment>\n#include <itowns/pitUV>\n#include <itowns/color_layers_pars_fragment>\n#if MODE == MODE_FINAL\n#include <itowns/fog_pars_fragment>\n#include <itowns/overlay_pars_fragment>\n#include <itowns/lighting_pars_fragment>\n#endif\n#include <itowns/mode_pars_fragment>\n\nuniform vec3        diffuse;\nuniform float       opacity;\nvarying vec3        vUv; // uv_0.x/uv_1.x, uv_0.y, uv_1.y\nvarying vec2        vHighPrecisionZW;\n\nvoid main() {\n    #include <logdepthbuf_fragment>\n\n#if MODE == MODE_ID\n\n    #include <itowns/mode_id_fragment>\n\n#elif MODE == MODE_DEPTH\n\n    #include <itowns/mode_depth_fragment>\n\n#else\n\n    gl_FragColor = vec4(diffuse, opacity);\n\n    uvs[0] = vec3(vUv.xy, 0.);\n\n#if NUM_CRS > 1\n    uvs[1] = vec3(vUv.x, fract(vUv.z), floor(vUv.z));\n#endif\n\n    vec4 color;\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_FS_TEXTURES; i ++ ) {\n        color = getLayerColor( i , colorTextures[ i ], colorOffsetScales[ i ], colorLayers[ i ]);\n        gl_FragColor.rgb = mix(gl_FragColor.rgb, color.rgb, color.a);\n    }\n\n  #if defined(DEBUG)\n    if (showOutline) {\n        #pragma unroll_loop\n        for ( int i = 0; i < NUM_CRS; i ++) {\n            color = getOutlineColor( outlineColors[ i ], uvs[ i ].xy);\n            gl_FragColor.rgb = mix(gl_FragColor.rgb, color.rgb, color.a);\n        }\n    }\n  #endif\n\n    #include <itowns/fog_fragment>\n    #include <itowns/lighting_fragment>\n    #include <itowns/overlay_fragment>\n\n#endif\n}\n',
          S = new m.Vector4(0, 0, 1, 1),
          T = new m.Texture(),
          E = new m.Vector4(
            255 / 256 / 16777216,
            255 / 256 / 65536,
            255 / 256 / 256,
            255 / 256,
          );
        function A(t, e) {
          return e ? E.dot(t) * e : E.dot(t);
        }
        function L() {
          var t = y.a.getMaxTextureUnitsCount();
          return Math.min(t - 1, 15);
        }
        var R = {
            noEffect: 0,
            removeLightColor: 1,
            removeWhiteColor: 2,
            customEffect: 3,
          },
          C = {
            bias: 0,
            zmin: 0,
            zmax: 0,
            scale: 0,
            mode: 0,
            textureOffset: 0,
            opacity: 0,
            crs: 0,
            effect_parameter: 0,
            effect_type: R.noEffect,
          };
        function P(t, e, n) {
          var i,
            r = t.layers.value,
            a = t.textures.value,
            o = t.offsetScales.value,
            s = t.textureCount,
            l = 0,
            c = _(e);
          try {
            for (c.s(); !(i = c.n()).done; ) {
              var u = i.value;
              u.textureOffset = l;
              for (var h = 0, d = u.textures.length; h < d; ++h, ++l)
                l < n &&
                  ((o[l] = u.offsetScales[h]),
                  (a[l] = u.textures[h]),
                  (r[l] = u));
            }
          } catch (t) {
            c.e(t);
          } finally {
            c.f();
          }
          l > n &&
            console.warn(
              'LayeredMaterial: Not enough texture units ('
                .concat(n, ' < ')
                .concat(l, '), excess textures have been discarded.'),
            ),
            (s.value = l);
          for (var p = l; p < a.length; p++) (a[p] = T), (o[p] = S), (r[p] = C);
        }
        var k,
          I = { RGBA: 0, COLOR: 1, DATA: 2 },
          D = [],
          O = (function (t) {
            u()(n, t);
            var e = b(n);
            function n() {
              var t,
                i =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : {},
                a = arguments.length > 1 ? arguments[1] : void 0;
              r()(this, n),
                (t = e.call(this, i)),
                (k = k || [1, L()]),
                (t.defines.NUM_VS_TEXTURES = k[0]),
                (t.defines.NUM_FS_TEXTURES = k[1]),
                (t.defines.USE_FOG = 1),
                (t.defines.NUM_CRS = a),
                x.a.setDefineMapping(l()(t), 'ELEVATION', I),
                x.a.setDefineMapping(l()(t), 'MODE', v.a.MODES),
                x.a.setDefineProperty(l()(t), 'mode', 'MODE', v.a.MODES.FINAL),
                y.a.isLogDepthBufferSupported() &&
                  ((t.defines.USE_LOGDEPTHBUF = 1),
                  (t.defines.USE_LOGDEPTHBUF_EXT = 1)),
                (t.vertexShader = M),
                (D[a] = D[a] || g.a.unrollLoops(q, t.defines)),
                (t.fragmentShader = D[a]),
                x.a.setUniformProperty(
                  l()(t),
                  'diffuse',
                  new m.Color(0.04, 0.23, 0.35),
                ),
                x.a.setUniformProperty(l()(t), 'opacity', t.opacity),
                x.a.setUniformProperty(l()(t), 'lightingEnabled', !1),
                x.a.setUniformProperty(
                  l()(t),
                  'lightPosition',
                  new m.Vector3(-0.5, 0, 1),
                ),
                x.a.setUniformProperty(l()(t), 'fogDistance', 1e9),
                x.a.setUniformProperty(
                  l()(t),
                  'fogColor',
                  new m.Color(0.76, 0.85, 1),
                ),
                x.a.setUniformProperty(l()(t), 'overlayAlpha', 0),
                x.a.setUniformProperty(
                  l()(t),
                  'overlayColor',
                  new m.Color(1, 0.3, 0),
                ),
                x.a.setUniformProperty(l()(t), 'objectId', 0),
                x.a.setUniformProperty(l()(t), 'minBorderDistance', -0.01),
                (t.layers = []),
                (t.elevationLayerIds = []),
                (t.colorLayerIds = []),
                (t.uniforms.elevationLayers = new m.Uniform(
                  new Array(k[0]).fill(C),
                )),
                (t.uniforms.elevationTextures = new m.Uniform(
                  new Array(k[0]).fill(T),
                )),
                (t.uniforms.elevationOffsetScales = new m.Uniform(
                  new Array(k[0]).fill(S),
                )),
                (t.uniforms.elevationTextureCount = new m.Uniform(0)),
                (t.uniforms.colorLayers = new m.Uniform(
                  new Array(k[1]).fill(C),
                )),
                (t.uniforms.colorTextures = new m.Uniform(
                  new Array(k[1]).fill(T),
                )),
                (t.uniforms.colorOffsetScales = new m.Uniform(
                  new Array(k[1]).fill(S),
                )),
                (t.uniforms.colorTextureCount = new m.Uniform(0));
              var o = t.visible;
              return (
                Object.defineProperty(l()(t), 'visible', {
                  get: function () {
                    return o;
                  },
                  set: function (t) {
                    o != t &&
                      ((o = t),
                      this.dispatchEvent({ type: t ? 'shown' : 'hidden' }));
                  },
                }),
                t
              );
            }
            return (
              o()(n, [
                {
                  key: 'onBeforeCompile',
                  value: function (t, e) {
                    e.capabilities.isWebGL2 &&
                      ((this.defines.WEBGL2 = !0), (t.glslVersion = '300 es'));
                  },
                },
                {
                  key: 'getUniformByType',
                  value: function (t) {
                    return {
                      layers: this.uniforms[''.concat(t, 'Layers')],
                      textures: this.uniforms[''.concat(t, 'Textures')],
                      offsetScales: this.uniforms[''.concat(t, 'OffsetScales')],
                      textureCount: this.uniforms[''.concat(t, 'TextureCount')],
                    };
                  },
                },
                {
                  key: 'updateLayersUniforms',
                  value: function () {
                    var t = this,
                      e = this.layers.filter(function (e) {
                        return (
                          t.colorLayerIds.includes(e.id) &&
                          e.visible &&
                          e.opacity > 0
                        );
                      });
                    if (
                      (e.sort(function (e, n) {
                        return (
                          t.colorLayerIds.indexOf(e.id) -
                          t.colorLayerIds.indexOf(n.id)
                        );
                      }),
                      P(
                        this.getUniformByType('color'),
                        e,
                        this.defines.NUM_FS_TEXTURES,
                      ),
                      this.elevationLayerIds.some(function (e) {
                        return t.getLayer(e);
                      }) ||
                        (this.uniforms.elevationTextureCount.value &&
                          !this.elevationLayerIds.length))
                    ) {
                      var n = this.getElevationLayer()
                        ? [this.getElevationLayer()]
                        : [];
                      P(
                        this.getUniformByType('elevation'),
                        n,
                        this.defines.NUM_VS_TEXTURES,
                      );
                    }
                    this.layersNeedUpdate = !1;
                  },
                },
                {
                  key: 'dispose',
                  value: function () {
                    this.dispatchEvent({ type: 'dispose' }),
                      this.layers.forEach(function (t) {
                        return t.dispose(!0);
                      }),
                      (this.layers.length = 0),
                      (this.layersNeedUpdate = !0);
                  },
                },
                {
                  key: 'setSequence',
                  value: function (t) {
                    (this.colorLayerIds = t), (this.layersNeedUpdate = !0);
                  },
                },
                {
                  key: 'setSequenceElevation',
                  value: function (t) {
                    (this.elevationLayerIds[0] = t),
                      (this.layersNeedUpdate = !0);
                  },
                },
                {
                  key: 'removeLayer',
                  value: function (t) {
                    var e = this.layers.findIndex(function (e) {
                      return e.id === t;
                    });
                    if (e > -1) {
                      this.layers[e].dispose(), this.layers.splice(e, 1);
                      var n = this.colorLayerIds.indexOf(t);
                      n > -1
                        ? this.colorLayerIds.splice(n, 1)
                        : (this.elevationLayerIds = []);
                    }
                  },
                },
                {
                  key: 'addLayer',
                  value: function (t) {
                    t.layer.id in this.layers &&
                      console.warn(
                        'The "{layer.id}" layer was already present in the material, overwritting.',
                      ),
                      this.layers.push(t);
                  },
                },
                {
                  key: 'getLayer',
                  value: function (t) {
                    return this.layers.find(function (e) {
                      return e.id === t;
                    });
                  },
                },
                {
                  key: 'getLayers',
                  value: function (t) {
                    return this.layers.filter(function (e) {
                      return t.includes(e.id);
                    });
                  },
                },
                {
                  key: 'getElevationLayer',
                  value: function () {
                    var t = this;
                    return this.layers.find(function (e) {
                      return e.id === t.elevationLayerIds[0];
                    });
                  },
                },
                {
                  key: 'setElevationScale',
                  value: function (t) {
                    this.elevationLayerIds.length &&
                      (this.getElevationLayer().scale = t);
                  },
                },
              ]),
              n
            );
          })(m.RawShaderMaterial);
        e.c = O;
      },
      3: function (t, e) {
        (t.exports = function (t, e) {
          if (!(t instanceof e))
            throw new TypeError('Cannot call a class as a function');
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      30: function (t, e, n) {
        'use strict';
        n.r(e);
        var i = 484813681109536e-20,
          r = Math.PI / 2,
          a = 0.017453292519943295,
          o = 57.29577951308232,
          s = Math.PI / 4,
          l = 2 * Math.PI,
          c = 3.14159265359,
          u = {
            greenwich: 0,
            lisbon: -9.131906111111,
            paris: 2.337229166667,
            bogota: -74.080916666667,
            madrid: -3.687938888889,
            rome: 12.452333333333,
            bern: 7.439583333333,
            jakarta: 106.807719444444,
            ferro: -17.666666666667,
            brussels: 4.367975,
            stockholm: 18.058277777778,
            athens: 23.7163375,
            oslo: 10.722916666667,
          },
          h = { ft: { to_meter: 0.3048 }, 'us-ft': { to_meter: 1200 / 3937 } },
          d = /[\s_\-\/\(\)]/g;
        function p(t, e) {
          if (t[e]) return t[e];
          for (
            var n,
              i = Object.keys(t),
              r = e.toLowerCase().replace(d, ''),
              a = -1;
            ++a < i.length;

          )
            if ((n = i[a]).toLowerCase().replace(d, '') === r) return t[n];
        }
        var f = function (t) {
            var e,
              n,
              i,
              r = {},
              o = t
                .split('+')
                .map(function (t) {
                  return t.trim();
                })
                .filter(function (t) {
                  return t;
                })
                .reduce(function (t, e) {
                  var n = e.split('=');
                  return n.push(!0), (t[n[0].toLowerCase()] = n[1]), t;
                }, {}),
              s = {
                proj: 'projName',
                datum: 'datumCode',
                rf: function (t) {
                  r.rf = parseFloat(t);
                },
                lat_0: function (t) {
                  r.lat0 = t * a;
                },
                lat_1: function (t) {
                  r.lat1 = t * a;
                },
                lat_2: function (t) {
                  r.lat2 = t * a;
                },
                lat_ts: function (t) {
                  r.lat_ts = t * a;
                },
                lon_0: function (t) {
                  r.long0 = t * a;
                },
                lon_1: function (t) {
                  r.long1 = t * a;
                },
                lon_2: function (t) {
                  r.long2 = t * a;
                },
                alpha: function (t) {
                  r.alpha = parseFloat(t) * a;
                },
                gamma: function (t) {
                  r.rectified_grid_angle = parseFloat(t);
                },
                lonc: function (t) {
                  r.longc = t * a;
                },
                x_0: function (t) {
                  r.x0 = parseFloat(t);
                },
                y_0: function (t) {
                  r.y0 = parseFloat(t);
                },
                k_0: function (t) {
                  r.k0 = parseFloat(t);
                },
                k: function (t) {
                  r.k0 = parseFloat(t);
                },
                a: function (t) {
                  r.a = parseFloat(t);
                },
                b: function (t) {
                  r.b = parseFloat(t);
                },
                r_a: function () {
                  r.R_A = !0;
                },
                zone: function (t) {
                  r.zone = parseInt(t, 10);
                },
                south: function () {
                  r.utmSouth = !0;
                },
                towgs84: function (t) {
                  r.datum_params = t.split(',').map(function (t) {
                    return parseFloat(t);
                  });
                },
                to_meter: function (t) {
                  r.to_meter = parseFloat(t);
                },
                units: function (t) {
                  r.units = t;
                  var e = p(h, t);
                  e && (r.to_meter = e.to_meter);
                },
                from_greenwich: function (t) {
                  r.from_greenwich = t * a;
                },
                pm: function (t) {
                  var e = p(u, t);
                  r.from_greenwich = (e || parseFloat(t)) * a;
                },
                nadgrids: function (t) {
                  '@null' === t ? (r.datumCode = 'none') : (r.nadgrids = t);
                },
                axis: function (t) {
                  3 === t.length &&
                    -1 !== 'ewnsud'.indexOf(t.substr(0, 1)) &&
                    -1 !== 'ewnsud'.indexOf(t.substr(1, 1)) &&
                    -1 !== 'ewnsud'.indexOf(t.substr(2, 1)) &&
                    (r.axis = t);
                },
                approx: function () {
                  r.approx = !0;
                },
              };
            for (e in o)
              (n = o[e]),
                e in s
                  ? 'function' == typeof (i = s[e])
                    ? i(n)
                    : (r[i] = n)
                  : (r[e] = n);
            return (
              'string' == typeof r.datumCode &&
                'WGS84' !== r.datumCode &&
                (r.datumCode = r.datumCode.toLowerCase()),
              r
            );
          },
          m = function (t) {
            return new _(t).output();
          },
          g = /\s/,
          y = /[A-Za-z]/,
          v = /[A-Za-z84]/,
          x = /[,\]]/,
          b = /[\d\.E\-\+]/;
        function _(t) {
          if ('string' != typeof t) throw new Error('not a string');
          (this.text = t.trim()),
            (this.level = 0),
            (this.place = 0),
            (this.root = null),
            (this.stack = []),
            (this.currentObject = null),
            (this.state = 1);
        }
        function w(t, e, n) {
          Array.isArray(e) && (n.unshift(e), (e = null));
          var i = e ? {} : t,
            r = n.reduce(function (t, e) {
              return M(e, t), t;
            }, i);
          e && (t[e] = r);
        }
        function M(t, e) {
          if (Array.isArray(t)) {
            var n = t.shift();
            if (('PARAMETER' === n && (n = t.shift()), 1 === t.length))
              return Array.isArray(t[0])
                ? ((e[n] = {}), void M(t[0], e[n]))
                : void (e[n] = t[0]);
            if (t.length)
              if ('TOWGS84' !== n) {
                if ('AXIS' === n)
                  return n in e || (e[n] = []), void e[n].push(t);
                var i;
                switch ((Array.isArray(n) || (e[n] = {}), n)) {
                  case 'UNIT':
                  case 'PRIMEM':
                  case 'VERT_DATUM':
                    return (
                      (e[n] = { name: t[0].toLowerCase(), convert: t[1] }),
                      void (3 === t.length && M(t[2], e[n]))
                    );
                  case 'SPHEROID':
                  case 'ELLIPSOID':
                    return (
                      (e[n] = { name: t[0], a: t[1], rf: t[2] }),
                      void (4 === t.length && M(t[3], e[n]))
                    );
                  case 'PROJECTEDCRS':
                  case 'PROJCRS':
                  case 'GEOGCS':
                  case 'GEOCCS':
                  case 'PROJCS':
                  case 'LOCAL_CS':
                  case 'GEODCRS':
                  case 'GEODETICCRS':
                  case 'GEODETICDATUM':
                  case 'EDATUM':
                  case 'ENGINEERINGDATUM':
                  case 'VERT_CS':
                  case 'VERTCRS':
                  case 'VERTICALCRS':
                  case 'COMPD_CS':
                  case 'COMPOUNDCRS':
                  case 'ENGINEERINGCRS':
                  case 'ENGCRS':
                  case 'FITTED_CS':
                  case 'LOCAL_DATUM':
                  case 'DATUM':
                    return (t[0] = ['name', t[0]]), void w(e, n, t);
                  default:
                    for (i = -1; ++i < t.length; )
                      if (!Array.isArray(t[i])) return M(t, e[n]);
                    return w(e, n, t);
                }
              } else e[n] = t;
            else e[n] = !0;
          } else e[t] = !0;
        }
        (_.prototype.readCharicter = function () {
          var t = this.text[this.place++];
          if (4 !== this.state)
            for (; g.test(t); ) {
              if (this.place >= this.text.length) return;
              t = this.text[this.place++];
            }
          switch (this.state) {
            case 1:
              return this.neutral(t);
            case 2:
              return this.keyword(t);
            case 4:
              return this.quoted(t);
            case 5:
              return this.afterquote(t);
            case 3:
              return this.number(t);
            case -1:
              return;
          }
        }),
          (_.prototype.afterquote = function (t) {
            if ('"' === t) return (this.word += '"'), void (this.state = 4);
            if (x.test(t))
              return (this.word = this.word.trim()), void this.afterItem(t);
            throw new Error(
              'havn\'t handled "' +
                t +
                '" in afterquote yet, index ' +
                this.place,
            );
          }),
          (_.prototype.afterItem = function (t) {
            return ',' === t
              ? (null !== this.word && this.currentObject.push(this.word),
                (this.word = null),
                void (this.state = 1))
              : ']' === t
              ? (this.level--,
                null !== this.word &&
                  (this.currentObject.push(this.word), (this.word = null)),
                (this.state = 1),
                (this.currentObject = this.stack.pop()),
                void (this.currentObject || (this.state = -1)))
              : void 0;
          }),
          (_.prototype.number = function (t) {
            if (!b.test(t)) {
              if (x.test(t))
                return (
                  (this.word = parseFloat(this.word)), void this.afterItem(t)
                );
              throw new Error(
                'havn\'t handled "' +
                  t +
                  '" in number yet, index ' +
                  this.place,
              );
            }
            this.word += t;
          }),
          (_.prototype.quoted = function (t) {
            '"' !== t ? (this.word += t) : (this.state = 5);
          }),
          (_.prototype.keyword = function (t) {
            if (v.test(t)) this.word += t;
            else {
              if ('[' === t) {
                var e = [];
                return (
                  e.push(this.word),
                  this.level++,
                  null === this.root
                    ? (this.root = e)
                    : this.currentObject.push(e),
                  this.stack.push(this.currentObject),
                  (this.currentObject = e),
                  void (this.state = 1)
                );
              }
              if (!x.test(t))
                throw new Error(
                  'havn\'t handled "' +
                    t +
                    '" in keyword yet, index ' +
                    this.place,
                );
              this.afterItem(t);
            }
          }),
          (_.prototype.neutral = function (t) {
            if (y.test(t)) return (this.word = t), void (this.state = 2);
            if ('"' === t) return (this.word = ''), void (this.state = 4);
            if (b.test(t)) return (this.word = t), void (this.state = 3);
            if (!x.test(t))
              throw new Error(
                'havn\'t handled "' +
                  t +
                  '" in neutral yet, index ' +
                  this.place,
              );
            this.afterItem(t);
          }),
          (_.prototype.output = function () {
            for (; this.place < this.text.length; ) this.readCharicter();
            if (-1 === this.state) return this.root;
            throw new Error(
              'unable to parse string "' +
                this.text +
                '". State is ' +
                this.state,
            );
          });
        function q(t) {
          return 0.017453292519943295 * t;
        }
        var S = function (t) {
          var e = m(t),
            n = e.shift(),
            i = e.shift();
          e.unshift(['name', i]), e.unshift(['type', n]);
          var r = {};
          return (
            M(e, r),
            (function (t) {
              if (
                ('GEOGCS' === t.type
                  ? (t.projName = 'longlat')
                  : 'LOCAL_CS' === t.type
                  ? ((t.projName = 'identity'), (t.local = !0))
                  : 'object' == typeof t.PROJECTION
                  ? (t.projName = Object.keys(t.PROJECTION)[0])
                  : (t.projName = t.PROJECTION),
                t.AXIS)
              ) {
                for (var e = '', n = 0, i = t.AXIS.length; n < i; ++n) {
                  var r = t.AXIS[n][0].toLowerCase();
                  -1 !== r.indexOf('north')
                    ? (e += 'n')
                    : -1 !== r.indexOf('south')
                    ? (e += 's')
                    : -1 !== r.indexOf('east')
                    ? (e += 'e')
                    : -1 !== r.indexOf('west') && (e += 'w');
                }
                2 === e.length && (e += 'u'), 3 === e.length && (t.axis = e);
              }
              t.UNIT &&
                ((t.units = t.UNIT.name.toLowerCase()),
                'metre' === t.units && (t.units = 'meter'),
                t.UNIT.convert &&
                  ('GEOGCS' === t.type
                    ? t.DATUM &&
                      t.DATUM.SPHEROID &&
                      (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a)
                    : (t.to_meter = t.UNIT.convert)));
              var a = t.GEOGCS;
              function o(e) {
                return e * (t.to_meter || 1);
              }
              'GEOGCS' === t.type && (a = t),
                a &&
                  (a.DATUM
                    ? (t.datumCode = a.DATUM.name.toLowerCase())
                    : (t.datumCode = a.name.toLowerCase()),
                  'd_' === t.datumCode.slice(0, 2) &&
                    (t.datumCode = t.datumCode.slice(2)),
                  ('new_zealand_geodetic_datum_1949' !== t.datumCode &&
                    'new_zealand_1949' !== t.datumCode) ||
                    (t.datumCode = 'nzgd49'),
                  ('wgs_1984' !== t.datumCode &&
                    'world_geodetic_system_1984' !== t.datumCode) ||
                    ('Mercator_Auxiliary_Sphere' === t.PROJECTION &&
                      (t.sphere = !0),
                    (t.datumCode = 'wgs84')),
                  '_ferro' === t.datumCode.slice(-6) &&
                    (t.datumCode = t.datumCode.slice(0, -6)),
                  '_jakarta' === t.datumCode.slice(-8) &&
                    (t.datumCode = t.datumCode.slice(0, -8)),
                  ~t.datumCode.indexOf('belge') && (t.datumCode = 'rnb72'),
                  a.DATUM &&
                    a.DATUM.SPHEROID &&
                    ((t.ellps = a.DATUM.SPHEROID.name
                      .replace('_19', '')
                      .replace(/[Cc]larke\_18/, 'clrk')),
                    'international' === t.ellps.toLowerCase().slice(0, 13) &&
                      (t.ellps = 'intl'),
                    (t.a = a.DATUM.SPHEROID.a),
                    (t.rf = parseFloat(a.DATUM.SPHEROID.rf, 10))),
                  a.DATUM &&
                    a.DATUM.TOWGS84 &&
                    (t.datum_params = a.DATUM.TOWGS84),
                  ~t.datumCode.indexOf('osgb_1936') && (t.datumCode = 'osgb36'),
                  ~t.datumCode.indexOf('osni_1952') && (t.datumCode = 'osni52'),
                  (~t.datumCode.indexOf('tm65') ||
                    ~t.datumCode.indexOf('geodetic_datum_of_1965')) &&
                    (t.datumCode = 'ire65'),
                  'ch1903+' === t.datumCode && (t.datumCode = 'ch1903'),
                  ~t.datumCode.indexOf('israel') && (t.datumCode = 'isr93')),
                t.b && !isFinite(t.b) && (t.b = t.a),
                [
                  ['standard_parallel_1', 'Standard_Parallel_1'],
                  ['standard_parallel_2', 'Standard_Parallel_2'],
                  ['false_easting', 'False_Easting'],
                  ['false_northing', 'False_Northing'],
                  ['central_meridian', 'Central_Meridian'],
                  ['latitude_of_origin', 'Latitude_Of_Origin'],
                  ['latitude_of_origin', 'Central_Parallel'],
                  ['scale_factor', 'Scale_Factor'],
                  ['k0', 'scale_factor'],
                  ['latitude_of_center', 'Latitude_Of_Center'],
                  ['latitude_of_center', 'Latitude_of_center'],
                  ['lat0', 'latitude_of_center', q],
                  ['longitude_of_center', 'Longitude_Of_Center'],
                  ['longitude_of_center', 'Longitude_of_center'],
                  ['longc', 'longitude_of_center', q],
                  ['x0', 'false_easting', o],
                  ['y0', 'false_northing', o],
                  ['long0', 'central_meridian', q],
                  ['lat0', 'latitude_of_origin', q],
                  ['lat0', 'standard_parallel_1', q],
                  ['lat1', 'standard_parallel_1', q],
                  ['lat2', 'standard_parallel_2', q],
                  ['azimuth', 'Azimuth'],
                  ['alpha', 'azimuth', q],
                  ['srsCode', 'name'],
                ].forEach(function (e) {
                  return (
                    (n = t),
                    (r = (i = e)[0]),
                    (a = i[1]),
                    void (
                      !(r in n) &&
                      a in n &&
                      ((n[r] = n[a]), 3 === i.length && (n[r] = i[2](n[r])))
                    )
                  );
                  var n, i, r, a;
                }),
                t.long0 ||
                  !t.longc ||
                  ('Albers_Conic_Equal_Area' !== t.projName &&
                    'Lambert_Azimuthal_Equal_Area' !== t.projName) ||
                  (t.long0 = t.longc),
                t.lat_ts ||
                  !t.lat1 ||
                  ('Stereographic_South_Pole' !== t.projName &&
                    'Polar Stereographic (variant B)' !== t.projName) ||
                  ((t.lat0 = q(t.lat1 > 0 ? 90 : -90)), (t.lat_ts = t.lat1));
            })(r),
            r
          );
        };
        function T(t) {
          var e = this;
          if (2 === arguments.length) {
            var n = arguments[1];
            'string' == typeof n
              ? '+' === n.charAt(0)
                ? (T[t] = f(arguments[1]))
                : (T[t] = S(arguments[1]))
              : (T[t] = n);
          } else if (1 === arguments.length) {
            if (Array.isArray(t))
              return t.map(function (t) {
                Array.isArray(t) ? T.apply(e, t) : T(t);
              });
            if ('string' == typeof t) {
              if (t in T) return T[t];
            } else
              'EPSG' in t
                ? (T['EPSG:' + t.EPSG] = t)
                : 'ESRI' in t
                ? (T['ESRI:' + t.ESRI] = t)
                : 'IAU2000' in t
                ? (T['IAU2000:' + t.IAU2000] = t)
                : console.log(t);
            return;
          }
        }
        !(function (t) {
          t(
            'EPSG:4326',
            '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees',
          ),
            t(
              'EPSG:4269',
              '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees',
            ),
            t(
              'EPSG:3857',
              '+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs',
            ),
            (t.WGS84 = t['EPSG:4326']),
            (t['EPSG:3785'] = t['EPSG:3857']),
            (t.GOOGLE = t['EPSG:3857']),
            (t['EPSG:900913'] = t['EPSG:3857']),
            (t['EPSG:102113'] = t['EPSG:3857']);
        })(T);
        var E = T;
        var A = [
          'PROJECTEDCRS',
          'PROJCRS',
          'GEOGCS',
          'GEOCCS',
          'PROJCS',
          'LOCAL_CS',
          'GEODCRS',
          'GEODETICCRS',
          'GEODETICDATUM',
          'ENGCRS',
          'ENGINEERINGCRS',
        ];
        var L = ['3857', '900913', '3785', '102113'];
        var R = function (t) {
            if (
              !(function (t) {
                return 'string' == typeof t;
              })(t)
            )
              return t;
            if (
              (function (t) {
                return t in E;
              })(t)
            )
              return E[t];
            if (
              (function (t) {
                return A.some(function (e) {
                  return t.indexOf(e) > -1;
                });
              })(t)
            ) {
              var e = S(t);
              if (
                (function (t) {
                  var e = p(t, 'authority');
                  if (e) {
                    var n = p(e, 'epsg');
                    return n && L.indexOf(n) > -1;
                  }
                })(e)
              )
                return E['EPSG:3857'];
              var n = (function (t) {
                var e = p(t, 'extension');
                if (e) return p(e, 'proj4');
              })(e);
              return n ? f(n) : e;
            }
            return (function (t) {
              return '+' === t[0];
            })(t)
              ? f(t)
              : void 0;
          },
          C = function (t, e) {
            var n, i;
            if (((t = t || {}), !e)) return t;
            for (i in e) void 0 !== (n = e[i]) && (t[i] = n);
            return t;
          },
          P = function (t, e, n) {
            var i = t * e;
            return n / Math.sqrt(1 - i * i);
          },
          k = function (t) {
            return t < 0 ? -1 : 1;
          },
          I = function (t) {
            return Math.abs(t) <= c ? t : t - k(t) * l;
          },
          D = function (t, e, n) {
            var i = t * n,
              a = 0.5 * t;
            return (
              (i = Math.pow((1 - i) / (1 + i), a)), Math.tan(0.5 * (r - e)) / i
            );
          },
          O = function (t, e) {
            for (
              var n, i, a = 0.5 * t, o = r - 2 * Math.atan(e), s = 0;
              s <= 15;
              s++
            )
              if (
                ((n = t * Math.sin(o)),
                (o += i =
                  r - 2 * Math.atan(e * Math.pow((1 - n) / (1 + n), a)) - o),
                Math.abs(i) <= 1e-10)
              )
                return o;
            return -9999;
          };
        function N(t) {
          return t;
        }
        var z = [
            {
              init: function () {
                var t = this.b / this.a;
                (this.es = 1 - t * t),
                  'x0' in this || (this.x0 = 0),
                  'y0' in this || (this.y0 = 0),
                  (this.e = Math.sqrt(this.es)),
                  this.lat_ts
                    ? this.sphere
                      ? (this.k0 = Math.cos(this.lat_ts))
                      : (this.k0 = P(
                          this.e,
                          Math.sin(this.lat_ts),
                          Math.cos(this.lat_ts),
                        ))
                    : this.k0 || (this.k ? (this.k0 = this.k) : (this.k0 = 1));
              },
              forward: function (t) {
                var e,
                  n,
                  i = t.x,
                  a = t.y;
                if (a * o > 90 && a * o < -90 && i * o > 180 && i * o < -180)
                  return null;
                if (Math.abs(Math.abs(a) - r) <= 1e-10) return null;
                if (this.sphere)
                  (e = this.x0 + this.a * this.k0 * I(i - this.long0)),
                    (n =
                      this.y0 +
                      this.a * this.k0 * Math.log(Math.tan(s + 0.5 * a)));
                else {
                  var l = Math.sin(a),
                    c = D(this.e, a, l);
                  (e = this.x0 + this.a * this.k0 * I(i - this.long0)),
                    (n = this.y0 - this.a * this.k0 * Math.log(c));
                }
                return (t.x = e), (t.y = n), t;
              },
              inverse: function (t) {
                var e,
                  n,
                  i = t.x - this.x0,
                  a = t.y - this.y0;
                if (this.sphere)
                  n = r - 2 * Math.atan(Math.exp(-a / (this.a * this.k0)));
                else {
                  var o = Math.exp(-a / (this.a * this.k0));
                  if (-9999 === (n = O(this.e, o))) return null;
                }
                return (
                  (e = I(this.long0 + i / (this.a * this.k0))),
                  (t.x = e),
                  (t.y = n),
                  t
                );
              },
              names: [
                'Mercator',
                'Popular Visualisation Pseudo Mercator',
                'Mercator_1SP',
                'Mercator_Auxiliary_Sphere',
                'merc',
              ],
            },
            {
              init: function () {},
              forward: N,
              inverse: N,
              names: ['longlat', 'identity'],
            },
          ],
          F = {},
          B = [];
        function U(t, e) {
          var n = B.length;
          return t.names
            ? ((B[n] = t),
              t.names.forEach(function (t) {
                F[t.toLowerCase()] = n;
              }),
              this)
            : (console.log(e), !0);
        }
        var j = {
            start: function () {
              z.forEach(U);
            },
            add: U,
            get: function (t) {
              if (!t) return !1;
              var e = t.toLowerCase();
              return void 0 !== F[e] && B[F[e]] ? B[F[e]] : void 0;
            },
          },
          G = {
            MERIT: { a: 6378137, rf: 298.257, ellipseName: 'MERIT 1983' },
            SGS85: {
              a: 6378136,
              rf: 298.257,
              ellipseName: 'Soviet Geodetic System 85',
            },
            GRS80: {
              a: 6378137,
              rf: 298.257222101,
              ellipseName: 'GRS 1980(IUGG, 1980)',
            },
            IAU76: { a: 6378140, rf: 298.257, ellipseName: 'IAU 1976' },
            airy: { a: 6377563.396, b: 6356256.91, ellipseName: 'Airy 1830' },
            APL4: {
              a: 6378137,
              rf: 298.25,
              ellipseName: 'Appl. Physics. 1965',
            },
            NWL9D: {
              a: 6378145,
              rf: 298.25,
              ellipseName: 'Naval Weapons Lab., 1965',
            },
            mod_airy: {
              a: 6377340.189,
              b: 6356034.446,
              ellipseName: 'Modified Airy',
            },
            andrae: {
              a: 6377104.43,
              rf: 300,
              ellipseName: 'Andrae 1876 (Den., Iclnd.)',
            },
            aust_SA: {
              a: 6378160,
              rf: 298.25,
              ellipseName: 'Australian Natl & S. Amer. 1969',
            },
            GRS67: {
              a: 6378160,
              rf: 298.247167427,
              ellipseName: 'GRS 67(IUGG 1967)',
            },
            bessel: {
              a: 6377397.155,
              rf: 299.1528128,
              ellipseName: 'Bessel 1841',
            },
            bess_nam: {
              a: 6377483.865,
              rf: 299.1528128,
              ellipseName: 'Bessel 1841 (Namibia)',
            },
            clrk66: { a: 6378206.4, b: 6356583.8, ellipseName: 'Clarke 1866' },
            clrk80: {
              a: 6378249.145,
              rf: 293.4663,
              ellipseName: 'Clarke 1880 mod.',
            },
            clrk58: {
              a: 6378293.645208759,
              rf: 294.2606763692654,
              ellipseName: 'Clarke 1858',
            },
            CPM: {
              a: 6375738.7,
              rf: 334.29,
              ellipseName: 'Comm. des Poids et Mesures 1799',
            },
            delmbr: {
              a: 6376428,
              rf: 311.5,
              ellipseName: 'Delambre 1810 (Belgium)',
            },
            engelis: {
              a: 6378136.05,
              rf: 298.2566,
              ellipseName: 'Engelis 1985',
            },
            evrst30: {
              a: 6377276.345,
              rf: 300.8017,
              ellipseName: 'Everest 1830',
            },
            evrst48: {
              a: 6377304.063,
              rf: 300.8017,
              ellipseName: 'Everest 1948',
            },
            evrst56: {
              a: 6377301.243,
              rf: 300.8017,
              ellipseName: 'Everest 1956',
            },
            evrst69: {
              a: 6377295.664,
              rf: 300.8017,
              ellipseName: 'Everest 1969',
            },
            evrstSS: {
              a: 6377298.556,
              rf: 300.8017,
              ellipseName: 'Everest (Sabah & Sarawak)',
            },
            fschr60: {
              a: 6378166,
              rf: 298.3,
              ellipseName: 'Fischer (Mercury Datum) 1960',
            },
            fschr60m: { a: 6378155, rf: 298.3, ellipseName: 'Fischer 1960' },
            fschr68: { a: 6378150, rf: 298.3, ellipseName: 'Fischer 1968' },
            helmert: { a: 6378200, rf: 298.3, ellipseName: 'Helmert 1906' },
            hough: { a: 6378270, rf: 297, ellipseName: 'Hough' },
            intl: {
              a: 6378388,
              rf: 297,
              ellipseName: 'International 1909 (Hayford)',
            },
            kaula: { a: 6378163, rf: 298.24, ellipseName: 'Kaula 1961' },
            lerch: { a: 6378139, rf: 298.257, ellipseName: 'Lerch 1979' },
            mprts: { a: 6397300, rf: 191, ellipseName: 'Maupertius 1738' },
            new_intl: {
              a: 6378157.5,
              b: 6356772.2,
              ellipseName: 'New International 1967',
            },
            plessis: {
              a: 6376523,
              rf: 6355863,
              ellipseName: 'Plessis 1817 (France)',
            },
            krass: { a: 6378245, rf: 298.3, ellipseName: 'Krassovsky, 1942' },
            SEasia: {
              a: 6378155,
              b: 6356773.3205,
              ellipseName: 'Southeast Asia',
            },
            walbeck: { a: 6376896, b: 6355834.8467, ellipseName: 'Walbeck' },
            WGS60: { a: 6378165, rf: 298.3, ellipseName: 'WGS 60' },
            WGS66: { a: 6378145, rf: 298.25, ellipseName: 'WGS 66' },
            WGS7: { a: 6378135, rf: 298.26, ellipseName: 'WGS 72' },
          },
          H = (G.WGS84 = {
            a: 6378137,
            rf: 298.257223563,
            ellipseName: 'WGS 84',
          });
        G.sphere = {
          a: 6370997,
          b: 6370997,
          ellipseName: 'Normal Sphere (r=6370997)',
        };
        var V = {};
        (V.wgs84 = { towgs84: '0,0,0', ellipse: 'WGS84', datumName: 'WGS84' }),
          (V.ch1903 = {
            towgs84: '674.374,15.056,405.346',
            ellipse: 'bessel',
            datumName: 'swiss',
          }),
          (V.ggrs87 = {
            towgs84: '-199.87,74.79,246.62',
            ellipse: 'GRS80',
            datumName: 'Greek_Geodetic_Reference_System_1987',
          }),
          (V.nad83 = {
            towgs84: '0,0,0',
            ellipse: 'GRS80',
            datumName: 'North_American_Datum_1983',
          }),
          (V.nad27 = {
            nadgrids: '@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat',
            ellipse: 'clrk66',
            datumName: 'North_American_Datum_1927',
          }),
          (V.potsdam = {
            towgs84: '606.0,23.0,413.0',
            ellipse: 'bessel',
            datumName: 'Potsdam Rauenberg 1950 DHDN',
          }),
          (V.carthage = {
            towgs84: '-263.0,6.0,431.0',
            ellipse: 'clark80',
            datumName: 'Carthage 1934 Tunisia',
          }),
          (V.hermannskogel = {
            towgs84: '653.0,-212.0,449.0',
            ellipse: 'bessel',
            datumName: 'Hermannskogel',
          }),
          (V.osni52 = {
            towgs84: '482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15',
            ellipse: 'airy',
            datumName: 'Irish National',
          }),
          (V.ire65 = {
            towgs84: '482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15',
            ellipse: 'mod_airy',
            datumName: 'Ireland 1965',
          }),
          (V.rassadiran = {
            towgs84: '-133.63,-157.5,-158.62',
            ellipse: 'intl',
            datumName: 'Rassadiran',
          }),
          (V.nzgd49 = {
            towgs84: '59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993',
            ellipse: 'intl',
            datumName: 'New Zealand Geodetic Datum 1949',
          }),
          (V.osgb36 = {
            towgs84: '446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894',
            ellipse: 'airy',
            datumName: 'Airy 1830',
          }),
          (V.s_jtsk = {
            towgs84: '589,76,480',
            ellipse: 'bessel',
            datumName: 'S-JTSK (Ferro)',
          }),
          (V.beduaram = {
            towgs84: '-106,-87,188',
            ellipse: 'clrk80',
            datumName: 'Beduaram',
          }),
          (V.gunung_segara = {
            towgs84: '-403,684,41',
            ellipse: 'bessel',
            datumName: 'Gunung Segara Jakarta',
          }),
          (V.rnb72 = {
            towgs84: '106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1',
            ellipse: 'intl',
            datumName: 'Reseau National Belge 1972',
          });
        var W = function (t, e, n, r, a, o, s) {
            var l = {};
            return (
              (l.datum_type = void 0 === t || 'none' === t ? 5 : 4),
              e &&
                ((l.datum_params = e.map(parseFloat)),
                (0 === l.datum_params[0] &&
                  0 === l.datum_params[1] &&
                  0 === l.datum_params[2]) ||
                  (l.datum_type = 1),
                l.datum_params.length > 3 &&
                  ((0 === l.datum_params[3] &&
                    0 === l.datum_params[4] &&
                    0 === l.datum_params[5] &&
                    0 === l.datum_params[6]) ||
                    ((l.datum_type = 2),
                    (l.datum_params[3] *= i),
                    (l.datum_params[4] *= i),
                    (l.datum_params[5] *= i),
                    (l.datum_params[6] = l.datum_params[6] / 1e6 + 1)))),
              s && ((l.datum_type = 3), (l.grids = s)),
              (l.a = n),
              (l.b = r),
              (l.es = a),
              (l.ep2 = o),
              l
            );
          },
          X = {};
        function Y(t) {
          if (0 === t.length) return null;
          var e = '@' === t[0];
          return (
            e && (t = t.slice(1)),
            'null' === t
              ? { name: 'null', mandatory: !e, grid: null, isNull: !0 }
              : { name: t, mandatory: !e, grid: X[t] || null, isNull: !1 }
          );
        }
        function $(t) {
          return ((t / 3600) * Math.PI) / 180;
        }
        function J(t, e, n) {
          return String.fromCharCode.apply(
            null,
            new Uint8Array(t.buffer.slice(e, n)),
          );
        }
        function Z(t) {
          return t.map(function (t) {
            return [$(t.longitudeShift), $(t.latitudeShift)];
          });
        }
        function K(t, e, n) {
          return {
            name: J(t, e + 8, e + 16).trim(),
            parent: J(t, e + 24, e + 24 + 8).trim(),
            lowerLatitude: t.getFloat64(e + 72, n),
            upperLatitude: t.getFloat64(e + 88, n),
            lowerLongitude: t.getFloat64(e + 104, n),
            upperLongitude: t.getFloat64(e + 120, n),
            latitudeInterval: t.getFloat64(e + 136, n),
            longitudeInterval: t.getFloat64(e + 152, n),
            gridNodeCount: t.getInt32(e + 168, n),
          };
        }
        function Q(t, e, n, i) {
          for (var r = e + 176, a = [], o = 0; o < n.gridNodeCount; o++) {
            var s = {
              latitudeShift: t.getFloat32(r + 16 * o, i),
              longitudeShift: t.getFloat32(r + 16 * o + 4, i),
              latitudeAccuracy: t.getFloat32(r + 16 * o + 8, i),
              longitudeAccuracy: t.getFloat32(r + 16 * o + 12, i),
            };
            a.push(s);
          }
          return a;
        }
        function tt(t, e) {
          if (!(this instanceof tt)) return new tt(t);
          e =
            e ||
            function (t) {
              if (t) throw t;
            };
          var n = R(t);
          if ('object' == typeof n) {
            var i = tt.projections.get(n.projName);
            if (i) {
              if (n.datumCode && 'none' !== n.datumCode) {
                var r = p(V, n.datumCode);
                r &&
                  ((n.datum_params =
                    n.datum_params ||
                    (r.towgs84 ? r.towgs84.split(',') : null)),
                  (n.ellps = r.ellipse),
                  (n.datumName = r.datumName ? r.datumName : n.datumCode));
              }
              (n.k0 = n.k0 || 1),
                (n.axis = n.axis || 'enu'),
                (n.ellps = n.ellps || 'wgs84'),
                (n.lat1 = n.lat1 || n.lat0);
              var a,
                o,
                s,
                l,
                c,
                u,
                h,
                d = (function (t, e, n, i, r) {
                  if (!t) {
                    var a = p(G, i);
                    a || (a = H), (t = a.a), (e = a.b), (n = a.rf);
                  }
                  return (
                    n && !e && (e = (1 - 1 / n) * t),
                    (0 === n || Math.abs(t - e) < 1e-10) && ((r = !0), (e = t)),
                    { a: t, b: e, rf: n, sphere: r }
                  );
                })(n.a, n.b, n.rf, n.ellps, n.sphere),
                f =
                  ((a = d.a),
                  (o = d.b),
                  d.rf,
                  (s = n.R_A),
                  (u = ((l = a * a) - (c = o * o)) / l),
                  (h = 0),
                  s
                    ? ((l =
                        (a *=
                          1 -
                          u *
                            (0.16666666666666666 +
                              u *
                                (0.04722222222222222 +
                                  0.022156084656084655 * u))) * a),
                      (u = 0))
                    : (h = Math.sqrt(u)),
                  { es: u, e: h, ep2: (l - c) / c }),
                m = (function (t) {
                  return void 0 === t ? null : t.split(',').map(Y);
                })(n.nadgrids),
                g =
                  n.datum ||
                  W(n.datumCode, n.datum_params, d.a, d.b, f.es, f.ep2, m);
              C(this, n),
                C(this, i),
                (this.a = d.a),
                (this.b = d.b),
                (this.rf = d.rf),
                (this.sphere = d.sphere),
                (this.es = f.es),
                (this.e = f.e),
                (this.ep2 = f.ep2),
                (this.datum = g),
                this.init(),
                e(null, this);
            } else e(t);
          } else e(t);
        }
        (tt.projections = j), tt.projections.start();
        var et = tt;
        function nt(t, e, n) {
          var i,
            a,
            o,
            s,
            l = t.x,
            c = t.y,
            u = t.z ? t.z : 0;
          if (c < -r && c > -1.001 * r) c = -r;
          else if (c > r && c < 1.001 * r) c = r;
          else {
            if (c < -r) return { x: -1 / 0, y: -1 / 0, z: t.z };
            if (c > r) return { x: 1 / 0, y: 1 / 0, z: t.z };
          }
          return (
            l > Math.PI && (l -= 2 * Math.PI),
            (a = Math.sin(c)),
            (s = Math.cos(c)),
            (o = a * a),
            {
              x: ((i = n / Math.sqrt(1 - e * o)) + u) * s * Math.cos(l),
              y: (i + u) * s * Math.sin(l),
              z: (i * (1 - e) + u) * a,
            }
          );
        }
        function it(t, e, n, i) {
          var a,
            o,
            s,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g,
            y,
            v,
            x,
            b = t.x,
            _ = t.y,
            w = t.z ? t.z : 0;
          if (
            ((a = Math.sqrt(b * b + _ * _)),
            (o = Math.sqrt(b * b + _ * _ + w * w)),
            a / n < 1e-12)
          ) {
            if (((v = 0), o / n < 1e-12))
              return r, (x = -i), { x: t.x, y: t.y, z: t.z };
          } else v = Math.atan2(_, b);
          (s = w / o),
            (d =
              (l = a / o) *
              (1 - e) *
              (c = 1 / Math.sqrt(1 - e * (2 - e) * l * l))),
            (p = s * c),
            (y = 0);
          do {
            y++,
              (u =
                (e * (h = n / Math.sqrt(1 - e * p * p))) /
                (h + (x = a * d + w * p - h * (1 - e * p * p)))),
              (g =
                (m = s * (c = 1 / Math.sqrt(1 - u * (2 - u) * l * l))) * d -
                (f = l * (1 - u) * c) * p),
              (d = f),
              (p = m);
          } while (g * g > 1e-24 && y < 30);
          return { x: v, y: Math.atan(m / Math.abs(f)), z: x };
        }
        function rt(t) {
          return 1 === t || 2 === t;
        }
        var at = function (t, e, n) {
          if (
            (function (t, e) {
              return (
                t.datum_type === e.datum_type &&
                !(t.a !== e.a || Math.abs(t.es - e.es) > 5e-11) &&
                (1 === t.datum_type
                  ? t.datum_params[0] === e.datum_params[0] &&
                    t.datum_params[1] === e.datum_params[1] &&
                    t.datum_params[2] === e.datum_params[2]
                  : 2 !== t.datum_type ||
                    (t.datum_params[0] === e.datum_params[0] &&
                      t.datum_params[1] === e.datum_params[1] &&
                      t.datum_params[2] === e.datum_params[2] &&
                      t.datum_params[3] === e.datum_params[3] &&
                      t.datum_params[4] === e.datum_params[4] &&
                      t.datum_params[5] === e.datum_params[5] &&
                      t.datum_params[6] === e.datum_params[6]))
              );
            })(t, e)
          )
            return n;
          if (5 === t.datum_type || 5 === e.datum_type) return n;
          var i = t.a,
            r = t.es;
          if (3 === t.datum_type) {
            if (0 !== ot(t, !1, n)) return;
            (i = 6378137), (r = 0.0066943799901413165);
          }
          var a = e.a,
            o = e.b,
            s = e.es;
          if (
            (3 === e.datum_type &&
              ((a = 6378137), (o = 6356752.314), (s = 0.0066943799901413165)),
            r === s && i === a && !rt(t.datum_type) && !rt(e.datum_type))
          )
            return n;
          if (
            ((n = nt(n, r, i)),
            rt(t.datum_type) &&
              (n = (function (t, e, n) {
                if (1 === e)
                  return { x: t.x + n[0], y: t.y + n[1], z: t.z + n[2] };
                if (2 === e) {
                  var i = n[0],
                    r = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    l = n[5],
                    c = n[6];
                  return {
                    x: c * (t.x - l * t.y + s * t.z) + i,
                    y: c * (l * t.x + t.y - o * t.z) + r,
                    z: c * (-s * t.x + o * t.y + t.z) + a,
                  };
                }
              })(n, t.datum_type, t.datum_params)),
            rt(e.datum_type) &&
              (n = (function (t, e, n) {
                if (1 === e)
                  return { x: t.x - n[0], y: t.y - n[1], z: t.z - n[2] };
                if (2 === e) {
                  var i = n[0],
                    r = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    l = n[5],
                    c = n[6],
                    u = (t.x - i) / c,
                    h = (t.y - r) / c,
                    d = (t.z - a) / c;
                  return {
                    x: u + l * h - s * d,
                    y: -l * u + h + o * d,
                    z: s * u - o * h + d,
                  };
                }
              })(n, e.datum_type, e.datum_params)),
            (n = it(n, s, a, o)),
            3 === e.datum_type) &&
            0 !== ot(e, !0, n)
          )
            return;
          return n;
        };
        function ot(t, e, n) {
          if (null === t.grids || 0 === t.grids.length)
            return console.log('Grid shift grids not found'), -1;
          for (
            var i = { x: -n.x, y: n.y },
              r = { x: Number.NaN, y: Number.NaN },
              a = [],
              s = 0;
            s < t.grids.length;
            s++
          ) {
            var l = t.grids[s];
            if ((a.push(l.name), l.isNull)) {
              r = i;
              break;
            }
            if ((l.mandatory, null !== l.grid)) {
              var c = l.grid.subgrids[0],
                u = (Math.abs(c.del[1]) + Math.abs(c.del[0])) / 1e4,
                h = c.ll[0] - u,
                d = c.ll[1] - u,
                p = c.ll[0] + (c.lim[0] - 1) * c.del[0] + u,
                f = c.ll[1] + (c.lim[1] - 1) * c.del[1] + u;
              if (
                !(
                  d > i.y ||
                  h > i.x ||
                  f < i.y ||
                  p < i.x ||
                  ((r = st(i, e, c)), isNaN(r.x))
                )
              )
                break;
            } else if (l.mandatory)
              return (
                console.log("Unable to find mandatory grid '" + l.name + "'"),
                -1
              );
          }
          return isNaN(r.x)
            ? (console.log(
                "Failed to find a grid shift table for location '" +
                  -i.x * o +
                  ' ' +
                  i.y * o +
                  " tried: '" +
                  a +
                  "'",
              ),
              -1)
            : ((n.x = -r.x), (n.y = r.y), 0);
        }
        function st(t, e, n) {
          var i = { x: Number.NaN, y: Number.NaN };
          if (isNaN(t.x)) return i;
          var r = { x: t.x, y: t.y };
          (r.x -= n.ll[0]),
            (r.y -= n.ll[1]),
            (r.x = I(r.x - Math.PI) + Math.PI);
          var a = lt(r, n);
          if (e) {
            if (isNaN(a.x)) return i;
            (a.x = r.x - a.x), (a.y = r.y - a.y);
            var o,
              s,
              l = 9;
            do {
              if (((s = lt(a, n)), isNaN(s.x))) {
                console.log(
                  'Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.',
                );
                break;
              }
              (o = { x: r.x - (s.x + a.x), y: r.y - (s.y + a.y) }),
                (a.x += o.x),
                (a.y += o.y);
            } while (l-- && Math.abs(o.x) > 1e-12 && Math.abs(o.y) > 1e-12);
            if (l < 0)
              return (
                console.log('Inverse grid shift iterator failed to converge.'),
                i
              );
            (i.x = I(a.x + n.ll[0])), (i.y = a.y + n.ll[1]);
          } else isNaN(a.x) || ((i.x = t.x + a.x), (i.y = t.y + a.y));
          return i;
        }
        function lt(t, e) {
          var n,
            i = { x: t.x / e.del[0], y: t.y / e.del[1] },
            r = Math.floor(i.x),
            a = Math.floor(i.y),
            o = i.x - 1 * r,
            s = i.y - 1 * a,
            l = { x: Number.NaN, y: Number.NaN };
          if (r < 0 || r >= e.lim[0]) return l;
          if (a < 0 || a >= e.lim[1]) return l;
          n = a * e.lim[0] + r;
          var c = e.cvs[n][0],
            u = e.cvs[n][1];
          n++;
          var h = e.cvs[n][0],
            d = e.cvs[n][1];
          n += e.lim[0];
          var p = e.cvs[n][0],
            f = e.cvs[n][1];
          n--;
          var m = e.cvs[n][0],
            g = e.cvs[n][1],
            y = o * s,
            v = o * (1 - s),
            x = (1 - o) * (1 - s),
            b = (1 - o) * s;
          return (
            (l.x = x * c + v * h + b * m + y * p),
            (l.y = x * u + v * d + b * g + y * f),
            l
          );
        }
        var ct = function (t, e, n) {
            var i,
              r,
              a,
              o = n.x,
              s = n.y,
              l = n.z || 0,
              c = {};
            for (a = 0; a < 3; a++)
              if (!e || 2 !== a || void 0 !== n.z)
                switch (
                  (0 === a
                    ? ((i = o),
                      (r = -1 !== 'ew'.indexOf(t.axis[a]) ? 'x' : 'y'))
                    : 1 === a
                    ? ((i = s),
                      (r = -1 !== 'ns'.indexOf(t.axis[a]) ? 'y' : 'x'))
                    : ((i = l), (r = 'z')),
                  t.axis[a])
                ) {
                  case 'e':
                    c[r] = i;
                    break;
                  case 'w':
                    c[r] = -i;
                    break;
                  case 'n':
                    c[r] = i;
                    break;
                  case 's':
                    c[r] = -i;
                    break;
                  case 'u':
                    void 0 !== n[r] && (c.z = i);
                    break;
                  case 'd':
                    void 0 !== n[r] && (c.z = -i);
                    break;
                  default:
                    return null;
                }
            return c;
          },
          ut = function (t) {
            var e = { x: t[0], y: t[1] };
            return (
              t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e
            );
          };
        function ht(t) {
          if ('function' == typeof Number.isFinite) {
            if (Number.isFinite(t)) return;
            throw new TypeError('coordinates must be finite numbers');
          }
          if ('number' != typeof t || t != t || !isFinite(t))
            throw new TypeError('coordinates must be finite numbers');
        }
        function dt(t, e, n) {
          var i;
          if (
            (Array.isArray(n) && (n = ut(n)),
            (function (t) {
              ht(t.x), ht(t.y);
            })(n),
            t.datum &&
              e.datum &&
              (function (t, e) {
                return (
                  ((1 === t.datum.datum_type || 2 === t.datum.datum_type) &&
                    'WGS84' !== e.datumCode) ||
                  ((1 === e.datum.datum_type || 2 === e.datum.datum_type) &&
                    'WGS84' !== t.datumCode)
                );
              })(t, e) &&
              ((n = dt(t, (i = new et('WGS84')), n)), (t = i)),
            'enu' !== t.axis && (n = ct(t, !1, n)),
            'longlat' === t.projName)
          )
            n = { x: n.x * a, y: n.y * a, z: n.z || 0 };
          else if (
            (t.to_meter &&
              (n = { x: n.x * t.to_meter, y: n.y * t.to_meter, z: n.z || 0 }),
            !(n = t.inverse(n)))
          )
            return;
          if (
            (t.from_greenwich && (n.x += t.from_greenwich),
            (n = at(t.datum, e.datum, n)))
          )
            return (
              e.from_greenwich &&
                (n = { x: n.x - e.from_greenwich, y: n.y, z: n.z || 0 }),
              'longlat' === e.projName
                ? (n = { x: n.x * o, y: n.y * o, z: n.z || 0 })
                : ((n = e.forward(n)),
                  e.to_meter &&
                    (n = {
                      x: n.x / e.to_meter,
                      y: n.y / e.to_meter,
                      z: n.z || 0,
                    })),
              'enu' !== e.axis ? ct(e, !0, n) : n
            );
        }
        var pt = et('WGS84');
        function ft(t, e, n) {
          var i, r, a;
          return Array.isArray(n)
            ? ((i = dt(t, e, n) || { x: NaN, y: NaN }),
              n.length > 2
                ? (void 0 !== t.name && 'geocent' === t.name) ||
                  (void 0 !== e.name && 'geocent' === e.name)
                  ? 'number' == typeof i.z
                    ? [i.x, i.y, i.z].concat(n.splice(3))
                    : [i.x, i.y, n[2]].concat(n.splice(3))
                  : [i.x, i.y].concat(n.splice(2))
                : [i.x, i.y])
            : ((r = dt(t, e, n)),
              2 === (a = Object.keys(n)).length ||
                a.forEach(function (i) {
                  if (
                    (void 0 !== t.name && 'geocent' === t.name) ||
                    (void 0 !== e.name && 'geocent' === e.name)
                  ) {
                    if ('x' === i || 'y' === i || 'z' === i) return;
                  } else if ('x' === i || 'y' === i) return;
                  r[i] = n[i];
                }),
              r);
        }
        function mt(t) {
          return t instanceof et ? t : t.oProj ? t.oProj : et(t);
        }
        var gt = function (t, e, n) {
            t = mt(t);
            var i,
              r = !1;
            return (
              void 0 === e
                ? ((e = t), (t = pt), (r = !0))
                : (void 0 !== e.x || Array.isArray(e)) &&
                  ((n = e), (e = t), (t = pt), (r = !0)),
              (e = mt(e)),
              n
                ? ft(t, e, n)
                : ((i = {
                    forward: function (n) {
                      return ft(t, e, n);
                    },
                    inverse: function (n) {
                      return ft(e, t, n);
                    },
                  }),
                  r && (i.oProj = e),
                  i)
            );
          },
          yt = 73,
          vt = 79,
          xt = {
            forward: bt,
            inverse: function (t) {
              var e = qt(Et(t.toUpperCase()));
              if (e.lat && e.lon) return [e.lon, e.lat, e.lon, e.lat];
              return [e.left, e.bottom, e.right, e.top];
            },
            toPoint: _t,
          };
        function bt(t, e) {
          return (
            (e = e || 5),
            (function (t, e) {
              var n = '00000' + t.easting,
                i = '00000' + t.northing;
              return (
                t.zoneNumber +
                t.zoneLetter +
                ((p = t.easting),
                (f = t.northing),
                (m = t.zoneNumber),
                (g = Tt(m)),
                (y = Math.floor(p / 1e5)),
                (v = Math.floor(f / 1e5) % 20),
                (r = y),
                (a = v),
                (o = g),
                (s = o - 1),
                (l = 'AJSAJS'.charCodeAt(s)),
                (c = 'AFAFAF'.charCodeAt(s)),
                (u = l + r - 1),
                (h = c + a),
                (d = !1),
                u > 90 && ((u = u - 90 + 65 - 1), (d = !0)),
                (u === yt || (l < yt && u > yt) || ((u > yt || l < yt) && d)) &&
                  u++,
                (u === vt || (l < vt && u > vt) || ((u > vt || l < vt) && d)) &&
                  ++u === yt &&
                  u++,
                u > 90 && (u = u - 90 + 65 - 1),
                h > 86 ? ((h = h - 86 + 65 - 1), (d = !0)) : (d = !1),
                (h === yt || (c < yt && h > yt) || ((h > yt || c < yt) && d)) &&
                  h++,
                (h === vt || (c < vt && h > vt) || ((h > vt || c < vt) && d)) &&
                  ++h === yt &&
                  h++,
                h > 86 && (h = h - 86 + 65 - 1),
                String.fromCharCode(u) + String.fromCharCode(h)) +
                n.substr(n.length - 5, e) +
                i.substr(i.length - 5, e)
              );
              var r, a, o, s, l, c, u, h, d;
              var p, f, m, g, y, v;
            })(
              (function (t) {
                var e,
                  n,
                  i,
                  r,
                  a,
                  o,
                  s,
                  l = t.lat,
                  c = t.lon,
                  u = 6378137,
                  h = wt(l),
                  d = wt(c);
                (s = Math.floor((c + 180) / 6) + 1), 180 === c && (s = 60);
                l >= 56 && l < 64 && c >= 3 && c < 12 && (s = 32);
                l >= 72 &&
                  l < 84 &&
                  (c >= 0 && c < 9
                    ? (s = 31)
                    : c >= 9 && c < 21
                    ? (s = 33)
                    : c >= 21 && c < 33
                    ? (s = 35)
                    : c >= 33 && c < 42 && (s = 37));
                (o = wt(6 * (s - 1) - 180 + 3)),
                  0.006739496752268451,
                  (e =
                    u / Math.sqrt(1 - 0.00669438 * Math.sin(h) * Math.sin(h))),
                  (n = Math.tan(h) * Math.tan(h)),
                  (i = 0.006739496752268451 * Math.cos(h) * Math.cos(h)),
                  (r = Math.cos(h) * (d - o)),
                  (a =
                    u *
                    (0.9983242984503243 * h -
                      0.002514607064228144 * Math.sin(2 * h) +
                      2639046602129982e-21 * Math.sin(4 * h) -
                      3.418046101696858e-9 * Math.sin(6 * h)));
                var p =
                    0.9996 *
                      e *
                      (r +
                        ((1 - n + i) * r * r * r) / 6 +
                        ((5 - 18 * n + n * n + 72 * i - 0.39089081163157013) *
                          r *
                          r *
                          r *
                          r *
                          r) /
                          120) +
                    5e5,
                  f =
                    0.9996 *
                    (a +
                      e *
                        Math.tan(h) *
                        ((r * r) / 2 +
                          ((5 - n + 9 * i + 4 * i * i) * r * r * r * r) / 24 +
                          ((61 -
                            58 * n +
                            n * n +
                            600 * i -
                            2.2240339282485886) *
                            r *
                            r *
                            r *
                            r *
                            r *
                            r) /
                            720));
                l < 0 && (f += 1e7);
                return {
                  northing: Math.round(f),
                  easting: Math.round(p),
                  zoneNumber: s,
                  zoneLetter: St(l),
                };
              })({ lat: t[1], lon: t[0] }),
              e,
            )
          );
        }
        function _t(t) {
          var e = qt(Et(t.toUpperCase()));
          return e.lat && e.lon
            ? [e.lon, e.lat]
            : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
        }
        function wt(t) {
          return t * (Math.PI / 180);
        }
        function Mt(t) {
          return (t / Math.PI) * 180;
        }
        function qt(t) {
          var e = t.northing,
            n = t.easting,
            i = t.zoneLetter,
            r = t.zoneNumber;
          if (r < 0 || r > 60) return null;
          var a,
            o,
            s,
            l,
            c,
            u,
            h,
            d,
            p = 6378137,
            f = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)),
            m = n - 5e5,
            g = e;
          i < 'N' && (g -= 1e7),
            (u = 6 * (r - 1) - 180 + 3),
            (d =
              (h = g / 0.9996 / 6367449.145945056) +
              ((3 * f) / 2 - (27 * f * f * f) / 32) * Math.sin(2 * h) +
              ((21 * f * f) / 16 - (55 * f * f * f * f) / 32) *
                Math.sin(4 * h) +
              ((151 * f * f * f) / 96) * Math.sin(6 * h)),
            (a = p / Math.sqrt(1 - 0.00669438 * Math.sin(d) * Math.sin(d))),
            (o = Math.tan(d) * Math.tan(d)),
            (s = 0.006739496752268451 * Math.cos(d) * Math.cos(d)),
            (l =
              (0.99330562 * p) /
              Math.pow(1 - 0.00669438 * Math.sin(d) * Math.sin(d), 1.5)),
            (c = m / (0.9996 * a));
          var y =
            d -
            ((a * Math.tan(d)) / l) *
              ((c * c) / 2 -
                ((5 + 3 * o + 10 * s - 4 * s * s - 0.06065547077041606) *
                  c *
                  c *
                  c *
                  c) /
                  24 +
                ((61 +
                  90 * o +
                  298 * s +
                  45 * o * o -
                  1.6983531815716497 -
                  3 * s * s) *
                  c *
                  c *
                  c *
                  c *
                  c *
                  c) /
                  720);
          y = Mt(y);
          var v,
            x =
              (c -
                ((1 + 2 * o + s) * c * c * c) / 6 +
                ((5 -
                  2 * s +
                  28 * o -
                  3 * s * s +
                  0.05391597401814761 +
                  24 * o * o) *
                  c *
                  c *
                  c *
                  c *
                  c) /
                  120) /
              Math.cos(d);
          if (((x = u + Mt(x)), t.accuracy)) {
            var b = qt({
              northing: t.northing + t.accuracy,
              easting: t.easting + t.accuracy,
              zoneLetter: t.zoneLetter,
              zoneNumber: t.zoneNumber,
            });
            v = { top: b.lat, right: b.lon, bottom: y, left: x };
          } else v = { lat: y, lon: x };
          return v;
        }
        function St(t) {
          var e = 'Z';
          return (
            84 >= t && t >= 72
              ? (e = 'X')
              : 72 > t && t >= 64
              ? (e = 'W')
              : 64 > t && t >= 56
              ? (e = 'V')
              : 56 > t && t >= 48
              ? (e = 'U')
              : 48 > t && t >= 40
              ? (e = 'T')
              : 40 > t && t >= 32
              ? (e = 'S')
              : 32 > t && t >= 24
              ? (e = 'R')
              : 24 > t && t >= 16
              ? (e = 'Q')
              : 16 > t && t >= 8
              ? (e = 'P')
              : 8 > t && t >= 0
              ? (e = 'N')
              : 0 > t && t >= -8
              ? (e = 'M')
              : -8 > t && t >= -16
              ? (e = 'L')
              : -16 > t && t >= -24
              ? (e = 'K')
              : -24 > t && t >= -32
              ? (e = 'J')
              : -32 > t && t >= -40
              ? (e = 'H')
              : -40 > t && t >= -48
              ? (e = 'G')
              : -48 > t && t >= -56
              ? (e = 'F')
              : -56 > t && t >= -64
              ? (e = 'E')
              : -64 > t && t >= -72
              ? (e = 'D')
              : -72 > t && t >= -80 && (e = 'C'),
            e
          );
        }
        function Tt(t) {
          var e = t % 6;
          return 0 === e && (e = 6), e;
        }
        function Et(t) {
          if (t && 0 === t.length) throw 'MGRSPoint coverting from nothing';
          for (
            var e, n = t.length, i = null, r = '', a = 0;
            !/[A-Z]/.test((e = t.charAt(a)));

          ) {
            if (a >= 2) throw 'MGRSPoint bad conversion from: ' + t;
            (r += e), a++;
          }
          var o = parseInt(r, 10);
          if (0 === a || a + 3 > n) throw 'MGRSPoint bad conversion from: ' + t;
          var s = t.charAt(a++);
          if (
            s <= 'A' ||
            'B' === s ||
            'Y' === s ||
            s >= 'Z' ||
            'I' === s ||
            'O' === s
          )
            throw 'MGRSPoint zone letter ' + s + ' not handled: ' + t;
          i = t.substring(a, (a += 2));
          for (
            var l = Tt(o),
              c = (function (t, e) {
                var n = 'AJSAJS'.charCodeAt(e - 1),
                  i = 1e5,
                  r = !1;
                for (; n !== t.charCodeAt(0); ) {
                  if ((++n === yt && n++, n === vt && n++, n > 90)) {
                    if (r) throw 'Bad character: ' + t;
                    (n = 65), (r = !0);
                  }
                  i += 1e5;
                }
                return i;
              })(i.charAt(0), l),
              u = (function (t, e) {
                if (t > 'V') throw 'MGRSPoint given invalid Northing ' + t;
                var n = 'AFAFAF'.charCodeAt(e - 1),
                  i = 0,
                  r = !1;
                for (; n !== t.charCodeAt(0); ) {
                  if ((++n === yt && n++, n === vt && n++, n > 86)) {
                    if (r) throw 'Bad character: ' + t;
                    (n = 65), (r = !0);
                  }
                  i += 1e5;
                }
                return i;
              })(i.charAt(1), l);
            u < At(s);

          )
            u += 2e6;
          var h = n - a;
          if (h % 2 != 0)
            throw (
              'MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters' +
              t
            );
          var d,
            p,
            f,
            m = h / 2,
            g = 0,
            y = 0;
          return (
            m > 0 &&
              ((d = 1e5 / Math.pow(10, m)),
              (p = t.substring(a, a + m)),
              (g = parseFloat(p) * d),
              (f = t.substring(a + m)),
              (y = parseFloat(f) * d)),
            {
              easting: g + c,
              northing: y + u,
              zoneLetter: s,
              zoneNumber: o,
              accuracy: d,
            }
          );
        }
        function At(t) {
          var e;
          switch (t) {
            case 'C':
              e = 11e5;
              break;
            case 'D':
              e = 2e6;
              break;
            case 'E':
              e = 28e5;
              break;
            case 'F':
              e = 37e5;
              break;
            case 'G':
              e = 46e5;
              break;
            case 'H':
              e = 55e5;
              break;
            case 'J':
              e = 64e5;
              break;
            case 'K':
              e = 73e5;
              break;
            case 'L':
              e = 82e5;
              break;
            case 'M':
              e = 91e5;
              break;
            case 'N':
              e = 0;
              break;
            case 'P':
              e = 8e5;
              break;
            case 'Q':
              e = 17e5;
              break;
            case 'R':
              e = 26e5;
              break;
            case 'S':
              e = 35e5;
              break;
            case 'T':
              e = 44e5;
              break;
            case 'U':
              e = 53e5;
              break;
            case 'V':
              e = 62e5;
              break;
            case 'W':
              e = 7e6;
              break;
            case 'X':
              e = 79e5;
              break;
            default:
              e = -1;
          }
          if (e >= 0) return e;
          throw 'Invalid zone letter: ' + t;
        }
        function Lt(t, e, n) {
          if (!(this instanceof Lt)) return new Lt(t, e, n);
          if (Array.isArray(t))
            (this.x = t[0]), (this.y = t[1]), (this.z = t[2] || 0);
          else if ('object' == typeof t)
            (this.x = t.x), (this.y = t.y), (this.z = t.z || 0);
          else if ('string' == typeof t && void 0 === e) {
            var i = t.split(',');
            (this.x = parseFloat(i[0], 10)),
              (this.y = parseFloat(i[1], 10)),
              (this.z = parseFloat(i[2], 10) || 0);
          } else (this.x = t), (this.y = e), (this.z = n || 0);
          console.warn(
            'proj4.Point will be removed in version 3, use proj4.toPoint',
          );
        }
        (Lt.fromMGRS = function (t) {
          return new Lt(_t(t));
        }),
          (Lt.prototype.toMGRS = function (t) {
            return bt([this.x, this.y], t);
          });
        var Rt = Lt,
          Ct = 0.01068115234375,
          Pt = function (t) {
            var e = [];
            (e[0] =
              1 - t * (0.25 + t * (0.046875 + t * (0.01953125 + t * Ct)))),
              (e[1] = t * (0.75 - t * (0.046875 + t * (0.01953125 + t * Ct))));
            var n = t * t;
            return (
              (e[2] =
                n *
                (0.46875 -
                  t * (0.013020833333333334 + 0.007120768229166667 * t))),
              (n *= t),
              (e[3] = n * (0.3645833333333333 - 0.005696614583333333 * t)),
              (e[4] = n * t * 0.3076171875),
              e
            );
          },
          kt = function (t, e, n, i) {
            return (
              (n *= e),
              (e *= e),
              i[0] * t - n * (i[1] + e * (i[2] + e * (i[3] + e * i[4])))
            );
          },
          It = function (t, e, n) {
            for (var i = 1 / (1 - e), r = t, a = 20; a; --a) {
              var o = Math.sin(r),
                s = 1 - e * o * o;
              if (
                ((r -= s =
                  (kt(r, o, Math.cos(r), n) - t) * (s * Math.sqrt(s)) * i),
                Math.abs(s) < 1e-10)
              )
                return r;
            }
            return r;
          };
        var Dt = {
            init: function () {
              (this.x0 = void 0 !== this.x0 ? this.x0 : 0),
                (this.y0 = void 0 !== this.y0 ? this.y0 : 0),
                (this.long0 = void 0 !== this.long0 ? this.long0 : 0),
                (this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0),
                this.es &&
                  ((this.en = Pt(this.es)),
                  (this.ml0 = kt(
                    this.lat0,
                    Math.sin(this.lat0),
                    Math.cos(this.lat0),
                    this.en,
                  )));
            },
            forward: function (t) {
              var e,
                n,
                i,
                r = t.x,
                a = t.y,
                o = I(r - this.long0),
                s = Math.sin(a),
                l = Math.cos(a);
              if (this.es) {
                var c = l * o,
                  u = Math.pow(c, 2),
                  h = this.ep2 * Math.pow(l, 2),
                  d = Math.pow(h, 2),
                  p = Math.abs(l) > 1e-10 ? Math.tan(a) : 0,
                  f = Math.pow(p, 2),
                  m = Math.pow(f, 2);
                (e = 1 - this.es * Math.pow(s, 2)), (c /= Math.sqrt(e));
                var g = kt(a, s, l, this.en);
                (n =
                  this.a *
                    (this.k0 *
                      c *
                      (1 +
                        (u / 6) *
                          (1 -
                            f +
                            h +
                            (u / 20) *
                              (5 -
                                18 * f +
                                m +
                                14 * h -
                                58 * f * h +
                                (u / 42) *
                                  (61 + 179 * m - m * f - 479 * f))))) +
                  this.x0),
                  (i =
                    this.a *
                      (this.k0 *
                        (g -
                          this.ml0 +
                          ((s * o * c) / 2) *
                            (1 +
                              (u / 12) *
                                (5 -
                                  f +
                                  9 * h +
                                  4 * d +
                                  (u / 30) *
                                    (61 +
                                      m -
                                      58 * f +
                                      270 * h -
                                      330 * f * h +
                                      (u / 56) *
                                        (1385 +
                                          543 * m -
                                          m * f -
                                          3111 * f)))))) +
                    this.y0);
              } else {
                var y = l * Math.sin(o);
                if (Math.abs(Math.abs(y) - 1) < 1e-10) return 93;
                if (
                  ((n =
                    0.5 * this.a * this.k0 * Math.log((1 + y) / (1 - y)) +
                    this.x0),
                  (i = (l * Math.cos(o)) / Math.sqrt(1 - Math.pow(y, 2))),
                  (y = Math.abs(i)) >= 1)
                ) {
                  if (y - 1 > 1e-10) return 93;
                  i = 0;
                } else i = Math.acos(i);
                a < 0 && (i = -i),
                  (i = this.a * this.k0 * (i - this.lat0) + this.y0);
              }
              return (t.x = n), (t.y = i), t;
            },
            inverse: function (t) {
              var e,
                n,
                i,
                a,
                o = (t.x - this.x0) * (1 / this.a),
                s = (t.y - this.y0) * (1 / this.a);
              if (this.es)
                if (
                  ((e = this.ml0 + s / this.k0),
                  (n = It(e, this.es, this.en)),
                  Math.abs(n) < r)
                ) {
                  var l = Math.sin(n),
                    c = Math.cos(n),
                    u = Math.abs(c) > 1e-10 ? Math.tan(n) : 0,
                    h = this.ep2 * Math.pow(c, 2),
                    d = Math.pow(h, 2),
                    p = Math.pow(u, 2),
                    f = Math.pow(p, 2);
                  e = 1 - this.es * Math.pow(l, 2);
                  var m = (o * Math.sqrt(e)) / this.k0,
                    g = Math.pow(m, 2);
                  (i =
                    n -
                    (((e *= u) * g) / (1 - this.es)) *
                      0.5 *
                      (1 -
                        (g / 12) *
                          (5 +
                            3 * p -
                            9 * h * p +
                            h -
                            4 * d -
                            (g / 30) *
                              (61 +
                                90 * p -
                                252 * h * p +
                                45 * f +
                                46 * h -
                                (g / 56) *
                                  (1385 +
                                    3633 * p +
                                    4095 * f +
                                    1574 * f * p))))),
                    (a = I(
                      this.long0 +
                        (m *
                          (1 -
                            (g / 6) *
                              (1 +
                                2 * p +
                                h -
                                (g / 20) *
                                  (5 +
                                    28 * p +
                                    24 * f +
                                    8 * h * p +
                                    6 * h -
                                    (g / 42) *
                                      (61 +
                                        662 * p +
                                        1320 * f +
                                        720 * f * p))))) /
                          c,
                    ));
                } else (i = r * k(s)), (a = 0);
              else {
                var y = Math.exp(o / this.k0),
                  v = 0.5 * (y - 1 / y),
                  x = this.lat0 + s / this.k0,
                  b = Math.cos(x);
                (e = Math.sqrt((1 - Math.pow(b, 2)) / (1 + Math.pow(v, 2)))),
                  (i = Math.asin(e)),
                  s < 0 && (i = -i),
                  (a =
                    0 === v && 0 === b ? 0 : I(Math.atan2(v, b) + this.long0));
              }
              return (t.x = a), (t.y = i), t;
            },
            names: ['Fast_Transverse_Mercator', 'Fast Transverse Mercator'],
          },
          Ot = function (t) {
            var e = Math.exp(t);
            return (e = (e - 1 / e) / 2);
          },
          Nt = function (t, e) {
            (t = Math.abs(t)), (e = Math.abs(e));
            var n = Math.max(t, e),
              i = Math.min(t, e) / (n || 1);
            return n * Math.sqrt(1 + Math.pow(i, 2));
          },
          zt = function (t) {
            var e = Math.abs(t);
            return (
              (e = (function (t) {
                var e = 1 + t,
                  n = e - 1;
                return 0 === n ? t : (t * Math.log(e)) / n;
              })(e * (1 + e / (Nt(1, e) + 1)))),
              t < 0 ? -e : e
            );
          },
          Ft = function (t, e) {
            for (
              var n, i = 2 * Math.cos(2 * e), r = t.length - 1, a = t[r], o = 0;
              --r >= 0;

            )
              (n = i * a - o + t[r]), (o = a), (a = n);
            return e + n * Math.sin(2 * e);
          },
          Bt = function (t, e, n) {
            for (
              var i,
                r,
                a = Math.sin(e),
                o = Math.cos(e),
                s = Ot(n),
                l = (function (t) {
                  var e = Math.exp(t);
                  return (e = (e + 1 / e) / 2);
                })(n),
                c = 2 * o * l,
                u = -2 * a * s,
                h = t.length - 1,
                d = t[h],
                p = 0,
                f = 0,
                m = 0;
              --h >= 0;

            )
              (i = f),
                (r = p),
                (d = c * (f = d) - i - u * (p = m) + t[h]),
                (m = u * f - r + c * p);
            return [(c = a * l) * d - (u = o * s) * m, c * m + u * d];
          };
        var Ut = {
          init: function () {
            if (!this.approx && (isNaN(this.es) || this.es <= 0))
              throw new Error(
                'Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.',
              );
            this.approx &&
              (Dt.init.apply(this),
              (this.forward = Dt.forward),
              (this.inverse = Dt.inverse)),
              (this.x0 = void 0 !== this.x0 ? this.x0 : 0),
              (this.y0 = void 0 !== this.y0 ? this.y0 : 0),
              (this.long0 = void 0 !== this.long0 ? this.long0 : 0),
              (this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0),
              (this.cgb = []),
              (this.cbg = []),
              (this.utg = []),
              (this.gtu = []);
            var t = this.es / (1 + Math.sqrt(1 - this.es)),
              e = t / (2 - t),
              n = e;
            (this.cgb[0] =
              e *
              (2 +
                e *
                  (-2 / 3 +
                    e *
                      (e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675))) -
                        2)))),
              (this.cbg[0] =
                e *
                (e *
                  (2 / 3 +
                    e *
                      (4 / 3 +
                        e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725))))) -
                  2)),
              (n *= e),
              (this.cgb[1] =
                n *
                (7 / 3 +
                  e *
                    (e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))) -
                      1.6))),
              (this.cbg[1] =
                n *
                (5 / 3 +
                  e *
                    (-16 / 15 +
                      e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945)))))),
              (n *= e),
              (this.cgb[2] =
                n *
                (56 / 15 +
                  e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835))))),
              (this.cbg[2] =
                n *
                (-26 / 15 + e * (34 / 21 + e * (1.6 + e * (-12686 / 2835))))),
              (n *= e),
              (this.cgb[3] =
                n * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175)))),
              (this.cbg[3] =
                n * (1237 / 630 + e * (e * (-24832 / 14175) - 2.4))),
              (n *= e),
              (this.cgb[4] = n * (4174 / 315 + e * (-144838 / 6237))),
              (this.cbg[4] = n * (-734 / 315 + e * (109598 / 31185))),
              (n *= e),
              (this.cgb[5] = n * (601676 / 22275)),
              (this.cbg[5] = n * (444337 / 155925)),
              (n = Math.pow(e, 2)),
              (this.Qn =
                (this.k0 / (1 + e)) *
                (1 + n * (1 / 4 + n * (1 / 64 + n / 256)))),
              (this.utg[0] =
                e *
                (e *
                  (2 / 3 +
                    e *
                      (-37 / 96 +
                        e *
                          (1 / 360 + e * (81 / 512 + e * (-96199 / 604800))))) -
                  0.5)),
              (this.gtu[0] =
                e *
                (0.5 +
                  e *
                    (-2 / 3 +
                      e *
                        (5 / 16 +
                          e *
                            (41 / 180 +
                              e * (-127 / 288 + e * (7891 / 37800))))))),
              (this.utg[1] =
                n *
                (-1 / 48 +
                  e *
                    (-1 / 15 +
                      e *
                        (437 / 1440 +
                          e * (-46 / 105 + e * (1118711 / 3870720)))))),
              (this.gtu[1] =
                n *
                (13 / 48 +
                  e *
                    (e *
                      (557 / 1440 +
                        e * (281 / 630 + e * (-1983433 / 1935360))) -
                      0.6))),
              (n *= e),
              (this.utg[2] =
                n *
                (-17 / 480 +
                  e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720))))),
              (this.gtu[2] =
                n *
                (61 / 240 +
                  e *
                    (-103 / 140 +
                      e * (15061 / 26880 + e * (167603 / 181440))))),
              (n *= e),
              (this.utg[3] =
                n * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600)))),
              (this.gtu[3] =
                n *
                (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600)))),
              (n *= e),
              (this.utg[4] = n * (-4583 / 161280 + e * (108847 / 3991680))),
              (this.gtu[4] = n * (34729 / 80640 + e * (-3418889 / 1995840))),
              (n *= e),
              (this.utg[5] = n * (-20648693 / 638668800)),
              (this.gtu[5] = 0.6650675310896665 * n);
            var i = Ft(this.cbg, this.lat0);
            this.Zb =
              -this.Qn *
              (i +
                (function (t, e) {
                  for (
                    var n,
                      i = 2 * Math.cos(e),
                      r = t.length - 1,
                      a = t[r],
                      o = 0;
                    --r >= 0;

                  )
                    (n = i * a - o + t[r]), (o = a), (a = n);
                  return Math.sin(e) * n;
                })(this.gtu, 2 * i));
          },
          forward: function (t) {
            var e = I(t.x - this.long0),
              n = t.y;
            n = Ft(this.cbg, n);
            var i = Math.sin(n),
              r = Math.cos(n),
              a = Math.sin(e),
              o = Math.cos(e);
            (n = Math.atan2(i, o * r)),
              (e = Math.atan2(a * r, Nt(i, r * o))),
              (e = zt(Math.tan(e)));
            var s,
              l,
              c = Bt(this.gtu, 2 * n, 2 * e);
            return (
              (n += c[0]),
              (e += c[1]),
              Math.abs(e) <= 2.623395162778
                ? ((s = this.a * (this.Qn * e) + this.x0),
                  (l = this.a * (this.Qn * n + this.Zb) + this.y0))
                : ((s = 1 / 0), (l = 1 / 0)),
              (t.x = s),
              (t.y = l),
              t
            );
          },
          inverse: function (t) {
            var e,
              n,
              i = (t.x - this.x0) * (1 / this.a),
              r = (t.y - this.y0) * (1 / this.a);
            if (
              ((r = (r - this.Zb) / this.Qn),
              (i /= this.Qn),
              Math.abs(i) <= 2.623395162778)
            ) {
              var a = Bt(this.utg, 2 * r, 2 * i);
              (r += a[0]), (i += a[1]), (i = Math.atan(Ot(i)));
              var o = Math.sin(r),
                s = Math.cos(r),
                l = Math.sin(i),
                c = Math.cos(i);
              (r = Math.atan2(o * c, Nt(l, c * s))),
                (i = Math.atan2(l, c * s)),
                (e = I(i + this.long0)),
                (n = Ft(this.cgb, r));
            } else (e = 1 / 0), (n = 1 / 0);
            return (t.x = e), (t.y = n), t;
          },
          names: [
            'Extended_Transverse_Mercator',
            'Extended Transverse Mercator',
            'etmerc',
            'Transverse_Mercator',
            'Transverse Mercator',
            'tmerc',
          ],
        };
        var jt = {
            init: function () {
              var t = (function (t, e) {
                if (void 0 === t) {
                  if (
                    (t = Math.floor((30 * (I(e) + Math.PI)) / Math.PI) + 1) < 0
                  )
                    return 0;
                  if (t > 60) return 60;
                }
                return t;
              })(this.zone, this.long0);
              if (void 0 === t) throw new Error('unknown utm zone');
              (this.lat0 = 0),
                (this.long0 = (6 * Math.abs(t) - 183) * a),
                (this.x0 = 5e5),
                (this.y0 = this.utmSouth ? 1e7 : 0),
                (this.k0 = 0.9996),
                Ut.init.apply(this),
                (this.forward = Ut.forward),
                (this.inverse = Ut.inverse);
            },
            names: ['Universal Transverse Mercator System', 'utm'],
            dependsOn: 'etmerc',
          },
          Gt = function (t, e) {
            return Math.pow((1 - t) / (1 + t), e);
          };
        var Ht = {
          init: function () {
            var t = Math.sin(this.lat0),
              e = Math.cos(this.lat0);
            (e *= e),
              (this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t)),
              (this.C = Math.sqrt(1 + (this.es * e * e) / (1 - this.es))),
              (this.phic0 = Math.asin(t / this.C)),
              (this.ratexp = 0.5 * this.C * this.e),
              (this.K =
                Math.tan(0.5 * this.phic0 + s) /
                (Math.pow(Math.tan(0.5 * this.lat0 + s), this.C) *
                  Gt(this.e * t, this.ratexp)));
          },
          forward: function (t) {
            var e = t.x,
              n = t.y;
            return (
              (t.y =
                2 *
                  Math.atan(
                    this.K *
                      Math.pow(Math.tan(0.5 * n + s), this.C) *
                      Gt(this.e * Math.sin(n), this.ratexp),
                  ) -
                r),
              (t.x = this.C * e),
              t
            );
          },
          inverse: function (t) {
            for (
              var e = t.x / this.C,
                n = t.y,
                i = Math.pow(Math.tan(0.5 * n + s) / this.K, 1 / this.C),
                a = 20;
              a > 0 &&
              ((n =
                2 * Math.atan(i * Gt(this.e * Math.sin(t.y), -0.5 * this.e)) -
                r),
              !(Math.abs(n - t.y) < 1e-14));
              --a
            )
              t.y = n;
            return a ? ((t.x = e), (t.y = n), t) : null;
          },
          names: ['gauss'],
        };
        var Vt = {
          init: function () {
            Ht.init.apply(this),
              this.rc &&
                ((this.sinc0 = Math.sin(this.phic0)),
                (this.cosc0 = Math.cos(this.phic0)),
                (this.R2 = 2 * this.rc),
                this.title ||
                  (this.title = 'Oblique Stereographic Alternative'));
          },
          forward: function (t) {
            var e, n, i, r;
            return (
              (t.x = I(t.x - this.long0)),
              Ht.forward.apply(this, [t]),
              (e = Math.sin(t.y)),
              (n = Math.cos(t.y)),
              (i = Math.cos(t.x)),
              (r =
                (this.k0 * this.R2) /
                (1 + this.sinc0 * e + this.cosc0 * n * i)),
              (t.x = r * n * Math.sin(t.x)),
              (t.y = r * (this.cosc0 * e - this.sinc0 * n * i)),
              (t.x = this.a * t.x + this.x0),
              (t.y = this.a * t.y + this.y0),
              t
            );
          },
          inverse: function (t) {
            var e, n, i, r, a;
            if (
              ((t.x = (t.x - this.x0) / this.a),
              (t.y = (t.y - this.y0) / this.a),
              (t.x /= this.k0),
              (t.y /= this.k0),
              (a = Math.sqrt(t.x * t.x + t.y * t.y)))
            ) {
              var o = 2 * Math.atan2(a, this.R2);
              (e = Math.sin(o)),
                (n = Math.cos(o)),
                (r = Math.asin(n * this.sinc0 + (t.y * e * this.cosc0) / a)),
                (i = Math.atan2(
                  t.x * e,
                  a * this.cosc0 * n - t.y * this.sinc0 * e,
                ));
            } else (r = this.phic0), (i = 0);
            return (
              (t.x = i),
              (t.y = r),
              Ht.inverse.apply(this, [t]),
              (t.x = I(t.x + this.long0)),
              t
            );
          },
          names: [
            'Stereographic_North_Pole',
            'Oblique_Stereographic',
            'Polar_Stereographic',
            'sterea',
            'Oblique Stereographic Alternative',
            'Double_Stereographic',
          ],
        };
        var Wt = {
          init: function () {
            (this.coslat0 = Math.cos(this.lat0)),
              (this.sinlat0 = Math.sin(this.lat0)),
              this.sphere
                ? 1 === this.k0 &&
                  !isNaN(this.lat_ts) &&
                  Math.abs(this.coslat0) <= 1e-10 &&
                  (this.k0 = 0.5 * (1 + k(this.lat0) * Math.sin(this.lat_ts)))
                : (Math.abs(this.coslat0) <= 1e-10 &&
                    (this.lat0 > 0 ? (this.con = 1) : (this.con = -1)),
                  (this.cons = Math.sqrt(
                    Math.pow(1 + this.e, 1 + this.e) *
                      Math.pow(1 - this.e, 1 - this.e),
                  )),
                  1 === this.k0 &&
                    !isNaN(this.lat_ts) &&
                    Math.abs(this.coslat0) <= 1e-10 &&
                    (this.k0 =
                      (0.5 *
                        this.cons *
                        P(
                          this.e,
                          Math.sin(this.lat_ts),
                          Math.cos(this.lat_ts),
                        )) /
                      D(
                        this.e,
                        this.con * this.lat_ts,
                        this.con * Math.sin(this.lat_ts),
                      )),
                  (this.ms1 = P(this.e, this.sinlat0, this.coslat0)),
                  (this.X0 =
                    2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) -
                    r),
                  (this.cosX0 = Math.cos(this.X0)),
                  (this.sinX0 = Math.sin(this.X0)));
          },
          forward: function (t) {
            var e,
              n,
              i,
              a,
              o,
              s,
              l = t.x,
              c = t.y,
              u = Math.sin(c),
              h = Math.cos(c),
              d = I(l - this.long0);
            return Math.abs(Math.abs(l - this.long0) - Math.PI) <= 1e-10 &&
              Math.abs(c + this.lat0) <= 1e-10
              ? ((t.x = NaN), (t.y = NaN), t)
              : this.sphere
              ? ((e =
                  (2 * this.k0) /
                  (1 + this.sinlat0 * u + this.coslat0 * h * Math.cos(d))),
                (t.x = this.a * e * h * Math.sin(d) + this.x0),
                (t.y =
                  this.a *
                    e *
                    (this.coslat0 * u - this.sinlat0 * h * Math.cos(d)) +
                  this.y0),
                t)
              : ((n = 2 * Math.atan(this.ssfn_(c, u, this.e)) - r),
                (a = Math.cos(n)),
                (i = Math.sin(n)),
                Math.abs(this.coslat0) <= 1e-10
                  ? ((o = D(this.e, c * this.con, this.con * u)),
                    (s = (2 * this.a * this.k0 * o) / this.cons),
                    (t.x = this.x0 + s * Math.sin(l - this.long0)),
                    (t.y = this.y0 - this.con * s * Math.cos(l - this.long0)),
                    t)
                  : (Math.abs(this.sinlat0) < 1e-10
                      ? ((e = (2 * this.a * this.k0) / (1 + a * Math.cos(d))),
                        (t.y = e * i))
                      : ((e =
                          (2 * this.a * this.k0 * this.ms1) /
                          (this.cosX0 *
                            (1 +
                              this.sinX0 * i +
                              this.cosX0 * a * Math.cos(d)))),
                        (t.y =
                          e * (this.cosX0 * i - this.sinX0 * a * Math.cos(d)) +
                          this.y0)),
                    (t.x = e * a * Math.sin(d) + this.x0),
                    t));
          },
          inverse: function (t) {
            var e, n, i, a, o;
            (t.x -= this.x0), (t.y -= this.y0);
            var s = Math.sqrt(t.x * t.x + t.y * t.y);
            if (this.sphere) {
              var l = 2 * Math.atan(s / (2 * this.a * this.k0));
              return (
                (e = this.long0),
                (n = this.lat0),
                s <= 1e-10
                  ? ((t.x = e), (t.y = n), t)
                  : ((n = Math.asin(
                      Math.cos(l) * this.sinlat0 +
                        (t.y * Math.sin(l) * this.coslat0) / s,
                    )),
                    (e =
                      Math.abs(this.coslat0) < 1e-10
                        ? this.lat0 > 0
                          ? I(this.long0 + Math.atan2(t.x, -1 * t.y))
                          : I(this.long0 + Math.atan2(t.x, t.y))
                        : I(
                            this.long0 +
                              Math.atan2(
                                t.x * Math.sin(l),
                                s * this.coslat0 * Math.cos(l) -
                                  t.y * this.sinlat0 * Math.sin(l),
                              ),
                          )),
                    (t.x = e),
                    (t.y = n),
                    t)
              );
            }
            if (Math.abs(this.coslat0) <= 1e-10) {
              if (s <= 1e-10)
                return (
                  (n = this.lat0), (e = this.long0), (t.x = e), (t.y = n), t
                );
              (t.x *= this.con),
                (t.y *= this.con),
                (i = (s * this.cons) / (2 * this.a * this.k0)),
                (n = this.con * O(this.e, i)),
                (e =
                  this.con *
                  I(this.con * this.long0 + Math.atan2(t.x, -1 * t.y)));
            } else
              (a =
                2 *
                Math.atan(
                  (s * this.cosX0) / (2 * this.a * this.k0 * this.ms1),
                )),
                (e = this.long0),
                s <= 1e-10
                  ? (o = this.X0)
                  : ((o = Math.asin(
                      Math.cos(a) * this.sinX0 +
                        (t.y * Math.sin(a) * this.cosX0) / s,
                    )),
                    (e = I(
                      this.long0 +
                        Math.atan2(
                          t.x * Math.sin(a),
                          s * this.cosX0 * Math.cos(a) -
                            t.y * this.sinX0 * Math.sin(a),
                        ),
                    ))),
                (n = -1 * O(this.e, Math.tan(0.5 * (r + o))));
            return (t.x = e), (t.y = n), t;
          },
          names: [
            'stere',
            'Stereographic_South_Pole',
            'Polar Stereographic (variant B)',
          ],
          ssfn_: function (t, e, n) {
            return (
              (e *= n),
              Math.tan(0.5 * (r + t)) * Math.pow((1 - e) / (1 + e), 0.5 * n)
            );
          },
        };
        var Xt = {
          init: function () {
            var t = this.lat0;
            this.lambda0 = this.long0;
            var e = Math.sin(t),
              n = this.a,
              i = 1 / this.rf,
              r = 2 * i - Math.pow(i, 2),
              a = (this.e = Math.sqrt(r));
            (this.R =
              (this.k0 * n * Math.sqrt(1 - r)) / (1 - r * Math.pow(e, 2))),
              (this.alpha = Math.sqrt(
                1 + (r / (1 - r)) * Math.pow(Math.cos(t), 4),
              )),
              (this.b0 = Math.asin(e / this.alpha));
            var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
              s = Math.log(Math.tan(Math.PI / 4 + t / 2)),
              l = Math.log((1 + a * e) / (1 - a * e));
            this.K = o - this.alpha * s + ((this.alpha * a) / 2) * l;
          },
          forward: function (t) {
            var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)),
              n =
                (this.e / 2) *
                Math.log(
                  (1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y)),
                ),
              i = -this.alpha * (e + n) + this.K,
              r = 2 * (Math.atan(Math.exp(i)) - Math.PI / 4),
              a = this.alpha * (t.x - this.lambda0),
              o = Math.atan(
                Math.sin(a) /
                  (Math.sin(this.b0) * Math.tan(r) +
                    Math.cos(this.b0) * Math.cos(a)),
              ),
              s = Math.asin(
                Math.cos(this.b0) * Math.sin(r) -
                  Math.sin(this.b0) * Math.cos(r) * Math.cos(a),
              );
            return (
              (t.y =
                (this.R / 2) * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) +
                this.y0),
              (t.x = this.R * o + this.x0),
              t
            );
          },
          inverse: function (t) {
            for (
              var e = t.x - this.x0,
                n = t.y - this.y0,
                i = e / this.R,
                r = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4),
                a = Math.asin(
                  Math.cos(this.b0) * Math.sin(r) +
                    Math.sin(this.b0) * Math.cos(r) * Math.cos(i),
                ),
                o = Math.atan(
                  Math.sin(i) /
                    (Math.cos(this.b0) * Math.cos(i) -
                      Math.sin(this.b0) * Math.tan(r)),
                ),
                s = this.lambda0 + o / this.alpha,
                l = 0,
                c = a,
                u = -1e3,
                h = 0;
              Math.abs(c - u) > 1e-7;

            ) {
              if (++h > 20) return;
              (l =
                (1 / this.alpha) *
                  (Math.log(Math.tan(Math.PI / 4 + a / 2)) - this.K) +
                this.e *
                  Math.log(
                    Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(c)) / 2),
                  )),
                (u = c),
                (c = 2 * Math.atan(Math.exp(l)) - Math.PI / 2);
            }
            return (t.x = s), (t.y = c), t;
          },
          names: ['somerc'],
        };
        var Yt = {
          init: function () {
            var t,
              e,
              n,
              i,
              o,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              y = 0,
              v = 0,
              x = 0,
              b = 0,
              _ = 0,
              w = 0,
              M = 0;
            (this.no_off =
              ((g =
                'object' == typeof (m = this).PROJECTION
                  ? Object.keys(m.PROJECTION)[0]
                  : m.PROJECTION),
              'no_uoff' in m ||
                'no_off' in m ||
                -1 !==
                  [
                    'Hotine_Oblique_Mercator',
                    'Hotine_Oblique_Mercator_Azimuth_Natural_Origin',
                  ].indexOf(g))),
              (this.no_rot = 'no_rot' in this);
            var q = !1;
            'alpha' in this && (q = !0);
            var S = !1;
            if (
              ('rectified_grid_angle' in this && (S = !0),
              q && (M = this.alpha),
              S && (y = this.rectified_grid_angle * a),
              q || S)
            )
              v = this.longc;
            else if (
              ((x = this.long1),
              (_ = this.lat1),
              (b = this.long2),
              (w = this.lat2),
              Math.abs(_ - w) <= 1e-7 ||
                (t = Math.abs(_)) <= 1e-7 ||
                Math.abs(t - r) <= 1e-7 ||
                Math.abs(Math.abs(this.lat0) - r) <= 1e-7 ||
                Math.abs(Math.abs(w) - r) <= 1e-7)
            )
              throw new Error();
            var T = 1 - this.es;
            (e = Math.sqrt(T)),
              Math.abs(this.lat0) > 1e-10
                ? ((h = Math.sin(this.lat0)),
                  (n = Math.cos(this.lat0)),
                  (t = 1 - this.es * h * h),
                  (this.B = n * n),
                  (this.B = Math.sqrt(1 + (this.es * this.B * this.B) / T)),
                  (this.A = (this.B * this.k0 * e) / t),
                  (o = (i = (this.B * e) / (n * Math.sqrt(t))) * i - 1) <= 0
                    ? (o = 0)
                    : ((o = Math.sqrt(o)), this.lat0 < 0 && (o = -o)),
                  (this.E = o += i),
                  (this.E *= Math.pow(D(this.e, this.lat0, h), this.B)))
                : ((this.B = 1 / e), (this.A = this.k0), (this.E = i = o = 1)),
              q || S
                ? (q
                    ? ((f = Math.asin(Math.sin(M) / i)), S || (y = M))
                    : ((f = y), (M = Math.asin(i * Math.sin(f)))),
                  (this.lam0 =
                    v - Math.asin(0.5 * (o - 1 / o) * Math.tan(f)) / this.B))
                : ((c = Math.pow(D(this.e, _, Math.sin(_)), this.B)),
                  (u = Math.pow(D(this.e, w, Math.sin(w)), this.B)),
                  (o = this.E / c),
                  (d = (u - c) / (u + c)),
                  (p = ((p = this.E * this.E) - u * c) / (p + u * c)),
                  (t = x - b) < -Math.pi ? (b -= l) : t > Math.pi && (b += l),
                  (this.lam0 = I(
                    0.5 * (x + b) -
                      Math.atan((p * Math.tan(0.5 * this.B * (x - b))) / d) /
                        this.B,
                  )),
                  (f = Math.atan(
                    (2 * Math.sin(this.B * I(x - this.lam0))) / (o - 1 / o),
                  )),
                  (y = M = Math.asin(i * Math.sin(f)))),
              (this.singam = Math.sin(f)),
              (this.cosgam = Math.cos(f)),
              (this.sinrot = Math.sin(y)),
              (this.cosrot = Math.cos(y)),
              (this.rB = 1 / this.B),
              (this.ArB = this.A * this.rB),
              (this.BrA = 1 / this.ArB),
              this.A,
              this.B,
              this.no_off
                ? (this.u_0 = 0)
                : ((this.u_0 = Math.abs(
                    this.ArB * Math.atan(Math.sqrt(i * i - 1) / Math.cos(M)),
                  )),
                  this.lat0 < 0 && (this.u_0 = -this.u_0)),
              (o = 0.5 * f),
              (this.v_pole_n = this.ArB * Math.log(Math.tan(s - o))),
              (this.v_pole_s = this.ArB * Math.log(Math.tan(s + o)));
          },
          forward: function (t) {
            var e,
              n,
              i,
              a,
              o,
              s,
              l,
              c,
              u = {};
            if (
              ((t.x = t.x - this.lam0), Math.abs(Math.abs(t.y) - r) > 1e-10)
            ) {
              if (
                ((e =
                  0.5 *
                  ((o =
                    this.E / Math.pow(D(this.e, t.y, Math.sin(t.y)), this.B)) -
                    (s = 1 / o))),
                (n = 0.5 * (o + s)),
                (a = Math.sin(this.B * t.x)),
                (i = (e * this.singam - a * this.cosgam) / n),
                Math.abs(Math.abs(i) - 1) < 1e-10)
              )
                throw new Error();
              (c = 0.5 * this.ArB * Math.log((1 - i) / (1 + i))),
                (s = Math.cos(this.B * t.x)),
                (l =
                  Math.abs(s) < 1e-7
                    ? this.A * t.x
                    : this.ArB *
                      Math.atan2(e * this.cosgam + a * this.singam, s));
            } else
              (c = t.y > 0 ? this.v_pole_n : this.v_pole_s),
                (l = this.ArB * t.y);
            return (
              this.no_rot
                ? ((u.x = l), (u.y = c))
                : ((l -= this.u_0),
                  (u.x = c * this.cosrot + l * this.sinrot),
                  (u.y = l * this.cosrot - c * this.sinrot)),
              (u.x = this.a * u.x + this.x0),
              (u.y = this.a * u.y + this.y0),
              u
            );
          },
          inverse: function (t) {
            var e,
              n,
              i,
              a,
              o,
              s,
              l,
              c = {};
            if (
              ((t.x = (t.x - this.x0) * (1 / this.a)),
              (t.y = (t.y - this.y0) * (1 / this.a)),
              this.no_rot
                ? ((n = t.y), (e = t.x))
                : ((n = t.x * this.cosrot - t.y * this.sinrot),
                  (e = t.y * this.cosrot + t.x * this.sinrot + this.u_0)),
              (a = 0.5 * ((i = Math.exp(-this.BrA * n)) - 1 / i)),
              (o = 0.5 * (i + 1 / i)),
              (l =
                ((s = Math.sin(this.BrA * e)) * this.cosgam + a * this.singam) /
                o),
              Math.abs(Math.abs(l) - 1) < 1e-10)
            )
              (c.x = 0), (c.y = l < 0 ? -r : r);
            else {
              if (
                ((c.y = this.E / Math.sqrt((1 + l) / (1 - l))),
                (c.y = O(this.e, Math.pow(c.y, 1 / this.B))),
                c.y === 1 / 0)
              )
                throw new Error();
              c.x =
                -this.rB *
                Math.atan2(
                  a * this.cosgam - s * this.singam,
                  Math.cos(this.BrA * e),
                );
            }
            return (c.x += this.lam0), c;
          },
          names: [
            'Hotine_Oblique_Mercator',
            'Hotine Oblique Mercator',
            'Hotine_Oblique_Mercator_Azimuth_Natural_Origin',
            'Hotine_Oblique_Mercator_Two_Point_Natural_Origin',
            'Hotine_Oblique_Mercator_Azimuth_Center',
            'Oblique_Mercator',
            'omerc',
          ],
        };
        var $t = {
          init: function () {
            if (
              (this.lat2 || (this.lat2 = this.lat1),
              this.k0 || (this.k0 = 1),
              (this.x0 = this.x0 || 0),
              (this.y0 = this.y0 || 0),
              !(Math.abs(this.lat1 + this.lat2) < 1e-10))
            ) {
              var t = this.b / this.a;
              this.e = Math.sqrt(1 - t * t);
              var e = Math.sin(this.lat1),
                n = Math.cos(this.lat1),
                i = P(this.e, e, n),
                r = D(this.e, this.lat1, e),
                a = Math.sin(this.lat2),
                o = Math.cos(this.lat2),
                s = P(this.e, a, o),
                l = D(this.e, this.lat2, a),
                c = D(this.e, this.lat0, Math.sin(this.lat0));
              Math.abs(this.lat1 - this.lat2) > 1e-10
                ? (this.ns = Math.log(i / s) / Math.log(r / l))
                : (this.ns = e),
                isNaN(this.ns) && (this.ns = e),
                (this.f0 = i / (this.ns * Math.pow(r, this.ns))),
                (this.rh = this.a * this.f0 * Math.pow(c, this.ns)),
                this.title || (this.title = 'Lambert Conformal Conic');
            }
          },
          forward: function (t) {
            var e = t.x,
              n = t.y;
            Math.abs(2 * Math.abs(n) - Math.PI) <= 1e-10 &&
              (n = k(n) * (r - 2e-10));
            var i,
              a,
              o = Math.abs(Math.abs(n) - r);
            if (o > 1e-10)
              (i = D(this.e, n, Math.sin(n))),
                (a = this.a * this.f0 * Math.pow(i, this.ns));
            else {
              if ((o = n * this.ns) <= 0) return null;
              a = 0;
            }
            var s = this.ns * I(e - this.long0);
            return (
              (t.x = this.k0 * (a * Math.sin(s)) + this.x0),
              (t.y = this.k0 * (this.rh - a * Math.cos(s)) + this.y0),
              t
            );
          },
          inverse: function (t) {
            var e,
              n,
              i,
              a,
              o,
              s = (t.x - this.x0) / this.k0,
              l = this.rh - (t.y - this.y0) / this.k0;
            this.ns > 0
              ? ((e = Math.sqrt(s * s + l * l)), (n = 1))
              : ((e = -Math.sqrt(s * s + l * l)), (n = -1));
            var c = 0;
            if (
              (0 !== e && (c = Math.atan2(n * s, n * l)),
              0 !== e || this.ns > 0)
            ) {
              if (
                ((n = 1 / this.ns),
                (i = Math.pow(e / (this.a * this.f0), n)),
                -9999 === (a = O(this.e, i)))
              )
                return null;
            } else a = -r;
            return (o = I(c / this.ns + this.long0)), (t.x = o), (t.y = a), t;
          },
          names: [
            'Lambert Tangential Conformal Conic Projection',
            'Lambert_Conformal_Conic',
            'Lambert_Conformal_Conic_1SP',
            'Lambert_Conformal_Conic_2SP',
            'lcc',
          ],
        };
        var Jt = {
            init: function () {
              (this.a = 6377397.155),
                (this.es = 0.006674372230614),
                (this.e = Math.sqrt(this.es)),
                this.lat0 || (this.lat0 = 0.863937979737193),
                this.long0 || (this.long0 = 0.4334234309119251),
                this.k0 || (this.k0 = 0.9999),
                (this.s45 = 0.785398163397448),
                (this.s90 = 2 * this.s45),
                (this.fi0 = this.lat0),
                (this.e2 = this.es),
                (this.e = Math.sqrt(this.e2)),
                (this.alfa = Math.sqrt(
                  1 +
                    (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2),
                )),
                (this.uq = 1.04216856380474),
                (this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa)),
                (this.g = Math.pow(
                  (1 + this.e * Math.sin(this.fi0)) /
                    (1 - this.e * Math.sin(this.fi0)),
                  (this.alfa * this.e) / 2,
                )),
                (this.k =
                  (Math.tan(this.u0 / 2 + this.s45) /
                    Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa)) *
                  this.g),
                (this.k1 = this.k0),
                (this.n0 =
                  (this.a * Math.sqrt(1 - this.e2)) /
                  (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2))),
                (this.s0 = 1.37008346281555),
                (this.n = Math.sin(this.s0)),
                (this.ro0 = (this.k1 * this.n0) / Math.tan(this.s0)),
                (this.ad = this.s90 - this.uq);
            },
            forward: function (t) {
              var e,
                n,
                i,
                r,
                a,
                o,
                s,
                l = t.x,
                c = t.y,
                u = I(l - this.long0);
              return (
                (e = Math.pow(
                  (1 + this.e * Math.sin(c)) / (1 - this.e * Math.sin(c)),
                  (this.alfa * this.e) / 2,
                )),
                (n =
                  2 *
                  (Math.atan(
                    (this.k * Math.pow(Math.tan(c / 2 + this.s45), this.alfa)) /
                      e,
                  ) -
                    this.s45)),
                (i = -u * this.alfa),
                (r = Math.asin(
                  Math.cos(this.ad) * Math.sin(n) +
                    Math.sin(this.ad) * Math.cos(n) * Math.cos(i),
                )),
                (a = Math.asin((Math.cos(n) * Math.sin(i)) / Math.cos(r))),
                (o = this.n * a),
                (s =
                  (this.ro0 *
                    Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n)) /
                  Math.pow(Math.tan(r / 2 + this.s45), this.n)),
                (t.y = (s * Math.cos(o)) / 1),
                (t.x = (s * Math.sin(o)) / 1),
                this.czech || ((t.y *= -1), (t.x *= -1)),
                t
              );
            },
            inverse: function (t) {
              var e,
                n,
                i,
                r,
                a,
                o,
                s,
                l = t.x;
              (t.x = t.y),
                (t.y = l),
                this.czech || ((t.y *= -1), (t.x *= -1)),
                (a = Math.sqrt(t.x * t.x + t.y * t.y)),
                (r = Math.atan2(t.y, t.x) / Math.sin(this.s0)),
                (i =
                  2 *
                  (Math.atan(
                    Math.pow(this.ro0 / a, 1 / this.n) *
                      Math.tan(this.s0 / 2 + this.s45),
                  ) -
                    this.s45)),
                (e = Math.asin(
                  Math.cos(this.ad) * Math.sin(i) -
                    Math.sin(this.ad) * Math.cos(i) * Math.cos(r),
                )),
                (n = Math.asin((Math.cos(i) * Math.sin(r)) / Math.cos(e))),
                (t.x = this.long0 - n / this.alfa),
                (o = e),
                (s = 0);
              var c = 0;
              do {
                (t.y =
                  2 *
                  (Math.atan(
                    Math.pow(this.k, -1 / this.alfa) *
                      Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) *
                      Math.pow(
                        (1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)),
                        this.e / 2,
                      ),
                  ) -
                    this.s45)),
                  Math.abs(o - t.y) < 1e-10 && (s = 1),
                  (o = t.y),
                  (c += 1);
              } while (0 === s && c < 15);
              return c >= 15 ? null : t;
            },
            names: ['Krovak', 'krovak'],
          },
          Zt = function (t, e, n, i, r) {
            return (
              t * r -
              e * Math.sin(2 * r) +
              n * Math.sin(4 * r) -
              i * Math.sin(6 * r)
            );
          },
          Kt = function (t) {
            return 1 - 0.25 * t * (1 + (t / 16) * (3 + 1.25 * t));
          },
          Qt = function (t) {
            return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
          },
          te = function (t) {
            return 0.05859375 * t * t * (1 + 0.75 * t);
          },
          ee = function (t) {
            return t * t * t * (35 / 3072);
          },
          ne = function (t, e, n) {
            var i = e * n;
            return t / Math.sqrt(1 - i * i);
          },
          ie = function (t) {
            return Math.abs(t) < r ? t : t - k(t) * Math.PI;
          },
          re = function (t, e, n, i, r) {
            var a, o;
            a = t / e;
            for (var s = 0; s < 15; s++)
              if (
                ((a += o =
                  (t -
                    (e * a -
                      n * Math.sin(2 * a) +
                      i * Math.sin(4 * a) -
                      r * Math.sin(6 * a))) /
                  (e -
                    2 * n * Math.cos(2 * a) +
                    4 * i * Math.cos(4 * a) -
                    6 * r * Math.cos(6 * a))),
                Math.abs(o) <= 1e-10)
              )
                return a;
            return NaN;
          };
        var ae = {
            init: function () {
              this.sphere ||
                ((this.e0 = Kt(this.es)),
                (this.e1 = Qt(this.es)),
                (this.e2 = te(this.es)),
                (this.e3 = ee(this.es)),
                (this.ml0 =
                  this.a * Zt(this.e0, this.e1, this.e2, this.e3, this.lat0)));
            },
            forward: function (t) {
              var e,
                n,
                i = t.x,
                r = t.y;
              if (((i = I(i - this.long0)), this.sphere))
                (e = this.a * Math.asin(Math.cos(r) * Math.sin(i))),
                  (n =
                    this.a *
                    (Math.atan2(Math.tan(r), Math.cos(i)) - this.lat0));
              else {
                var a = Math.sin(r),
                  o = Math.cos(r),
                  s = ne(this.a, this.e, a),
                  l = Math.tan(r) * Math.tan(r),
                  c = i * Math.cos(r),
                  u = c * c,
                  h = (this.es * o * o) / (1 - this.es);
                (e =
                  s * c * (1 - u * l * (1 / 6 - ((8 - l + 8 * h) * u) / 120))),
                  (n =
                    this.a * Zt(this.e0, this.e1, this.e2, this.e3, r) -
                    this.ml0 +
                    ((s * a) / o) * u * (0.5 + ((5 - l + 6 * h) * u) / 24));
              }
              return (t.x = e + this.x0), (t.y = n + this.y0), t;
            },
            inverse: function (t) {
              (t.x -= this.x0), (t.y -= this.y0);
              var e,
                n,
                i = t.x / this.a,
                a = t.y / this.a;
              if (this.sphere) {
                var o = a + this.lat0;
                (e = Math.asin(Math.sin(o) * Math.cos(i))),
                  (n = Math.atan2(Math.tan(i), Math.cos(o)));
              } else {
                var s = this.ml0 / this.a + a,
                  l = re(s, this.e0, this.e1, this.e2, this.e3);
                if (Math.abs(Math.abs(l) - r) <= 1e-10)
                  return (t.x = this.long0), (t.y = r), a < 0 && (t.y *= -1), t;
                var c = ne(this.a, this.e, Math.sin(l)),
                  u = ((c * c * c) / this.a / this.a) * (1 - this.es),
                  h = Math.pow(Math.tan(l), 2),
                  d = (i * this.a) / c,
                  p = d * d;
                (e =
                  l -
                  ((c * Math.tan(l)) / u) *
                    d *
                    d *
                    (0.5 - ((1 + 3 * h) * d * d) / 24)),
                  (n =
                    (d * (1 - p * (h / 3 + ((1 + 3 * h) * h * p) / 15))) /
                    Math.cos(l));
              }
              return (t.x = I(n + this.long0)), (t.y = ie(e)), t;
            },
            names: ['Cassini', 'Cassini_Soldner', 'cass'],
          },
          oe = function (t, e) {
            var n;
            return t > 1e-7
              ? (1 - t * t) *
                  (e / (1 - (n = t * e) * n) -
                    (0.5 / t) * Math.log((1 - n) / (1 + n)))
              : 2 * e;
          };
        var se = {
            init: function () {
              var t,
                e = Math.abs(this.lat0);
              if (
                (Math.abs(e - r) < 1e-10
                  ? (this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE)
                  : Math.abs(e) < 1e-10
                  ? (this.mode = this.EQUIT)
                  : (this.mode = this.OBLIQ),
                this.es > 0)
              )
                switch (
                  ((this.qp = oe(this.e, 1)),
                  (this.mmf = 0.5 / (1 - this.es)),
                  (this.apa = (function (t) {
                    var e,
                      n = [];
                    return (
                      (n[0] = 0.3333333333333333 * t),
                      (e = t * t),
                      (n[0] += 0.17222222222222222 * e),
                      (n[1] = 0.06388888888888888 * e),
                      (e *= t),
                      (n[0] += 0.10257936507936508 * e),
                      (n[1] += 0.0664021164021164 * e),
                      (n[2] = 0.016415012942191543 * e),
                      n
                    );
                  })(this.es)),
                  this.mode)
                ) {
                  case this.N_POLE:
                  case this.S_POLE:
                    this.dd = 1;
                    break;
                  case this.EQUIT:
                    (this.rq = Math.sqrt(0.5 * this.qp)),
                      (this.dd = 1 / this.rq),
                      (this.xmf = 1),
                      (this.ymf = 0.5 * this.qp);
                    break;
                  case this.OBLIQ:
                    (this.rq = Math.sqrt(0.5 * this.qp)),
                      (t = Math.sin(this.lat0)),
                      (this.sinb1 = oe(this.e, t) / this.qp),
                      (this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1)),
                      (this.dd =
                        Math.cos(this.lat0) /
                        (Math.sqrt(1 - this.es * t * t) *
                          this.rq *
                          this.cosb1)),
                      (this.ymf = (this.xmf = this.rq) / this.dd),
                      (this.xmf *= this.dd);
                }
              else
                this.mode === this.OBLIQ &&
                  ((this.sinph0 = Math.sin(this.lat0)),
                  (this.cosph0 = Math.cos(this.lat0)));
            },
            forward: function (t) {
              var e,
                n,
                i,
                a,
                o,
                l,
                c,
                u,
                h,
                d,
                p = t.x,
                f = t.y;
              if (((p = I(p - this.long0)), this.sphere)) {
                if (
                  ((o = Math.sin(f)),
                  (d = Math.cos(f)),
                  (i = Math.cos(p)),
                  this.mode === this.OBLIQ || this.mode === this.EQUIT)
                ) {
                  if (
                    (n =
                      this.mode === this.EQUIT
                        ? 1 + d * i
                        : 1 + this.sinph0 * o + this.cosph0 * d * i) <= 1e-10
                  )
                    return null;
                  (e = (n = Math.sqrt(2 / n)) * d * Math.sin(p)),
                    (n *=
                      this.mode === this.EQUIT
                        ? o
                        : this.cosph0 * o - this.sinph0 * d * i);
                } else if (
                  this.mode === this.N_POLE ||
                  this.mode === this.S_POLE
                ) {
                  if (
                    (this.mode === this.N_POLE && (i = -i),
                    Math.abs(f + this.lat0) < 1e-10)
                  )
                    return null;
                  (n = s - 0.5 * f),
                    (e =
                      (n =
                        2 *
                        (this.mode === this.S_POLE
                          ? Math.cos(n)
                          : Math.sin(n))) * Math.sin(p)),
                    (n *= i);
                }
              } else {
                switch (
                  ((c = 0),
                  (u = 0),
                  (h = 0),
                  (i = Math.cos(p)),
                  (a = Math.sin(p)),
                  (o = Math.sin(f)),
                  (l = oe(this.e, o)),
                  (this.mode !== this.OBLIQ && this.mode !== this.EQUIT) ||
                    ((c = l / this.qp), (u = Math.sqrt(1 - c * c))),
                  this.mode)
                ) {
                  case this.OBLIQ:
                    h = 1 + this.sinb1 * c + this.cosb1 * u * i;
                    break;
                  case this.EQUIT:
                    h = 1 + u * i;
                    break;
                  case this.N_POLE:
                    (h = r + f), (l = this.qp - l);
                    break;
                  case this.S_POLE:
                    (h = f - r), (l = this.qp + l);
                }
                if (Math.abs(h) < 1e-10) return null;
                switch (this.mode) {
                  case this.OBLIQ:
                  case this.EQUIT:
                    (h = Math.sqrt(2 / h)),
                      (n =
                        this.mode === this.OBLIQ
                          ? this.ymf * h * (this.cosb1 * c - this.sinb1 * u * i)
                          : (h = Math.sqrt(2 / (1 + u * i))) * c * this.ymf),
                      (e = this.xmf * h * u * a);
                    break;
                  case this.N_POLE:
                  case this.S_POLE:
                    l >= 0
                      ? ((e = (h = Math.sqrt(l)) * a),
                        (n = i * (this.mode === this.S_POLE ? h : -h)))
                      : (e = n = 0);
                }
              }
              return (
                (t.x = this.a * e + this.x0), (t.y = this.a * n + this.y0), t
              );
            },
            inverse: function (t) {
              (t.x -= this.x0), (t.y -= this.y0);
              var e,
                n,
                i,
                a,
                o,
                s,
                l,
                c,
                u,
                h,
                d = t.x / this.a,
                p = t.y / this.a;
              if (this.sphere) {
                var f,
                  m = 0,
                  g = 0;
                if ((n = 0.5 * (f = Math.sqrt(d * d + p * p))) > 1) return null;
                switch (
                  ((n = 2 * Math.asin(n)),
                  (this.mode !== this.OBLIQ && this.mode !== this.EQUIT) ||
                    ((g = Math.sin(n)), (m = Math.cos(n))),
                  this.mode)
                ) {
                  case this.EQUIT:
                    (n = Math.abs(f) <= 1e-10 ? 0 : Math.asin((p * g) / f)),
                      (d *= g),
                      (p = m * f);
                    break;
                  case this.OBLIQ:
                    (n =
                      Math.abs(f) <= 1e-10
                        ? this.lat0
                        : Math.asin(
                            m * this.sinph0 + (p * g * this.cosph0) / f,
                          )),
                      (d *= g * this.cosph0),
                      (p = (m - Math.sin(n) * this.sinph0) * f);
                    break;
                  case this.N_POLE:
                    (p = -p), (n = r - n);
                    break;
                  case this.S_POLE:
                    n -= r;
                }
                e =
                  0 !== p ||
                  (this.mode !== this.EQUIT && this.mode !== this.OBLIQ)
                    ? Math.atan2(d, p)
                    : 0;
              } else {
                if (
                  ((l = 0),
                  this.mode === this.OBLIQ || this.mode === this.EQUIT)
                ) {
                  if (
                    ((d /= this.dd),
                    (p *= this.dd),
                    (s = Math.sqrt(d * d + p * p)) < 1e-10)
                  )
                    return (t.x = this.long0), (t.y = this.lat0), t;
                  (a = 2 * Math.asin((0.5 * s) / this.rq)),
                    (i = Math.cos(a)),
                    (d *= a = Math.sin(a)),
                    this.mode === this.OBLIQ
                      ? ((l = i * this.sinb1 + (p * a * this.cosb1) / s),
                        (o = this.qp * l),
                        (p = s * this.cosb1 * i - p * this.sinb1 * a))
                      : ((l = (p * a) / s), (o = this.qp * l), (p = s * i));
                } else if (
                  this.mode === this.N_POLE ||
                  this.mode === this.S_POLE
                ) {
                  if (
                    (this.mode === this.N_POLE && (p = -p),
                    !(o = d * d + p * p))
                  )
                    return (t.x = this.long0), (t.y = this.lat0), t;
                  (l = 1 - o / this.qp), this.mode === this.S_POLE && (l = -l);
                }
                (e = Math.atan2(d, p)),
                  (c = Math.asin(l)),
                  (u = this.apa),
                  (h = c + c),
                  (n =
                    c +
                    u[0] * Math.sin(h) +
                    u[1] * Math.sin(h + h) +
                    u[2] * Math.sin(h + h + h));
              }
              return (t.x = I(this.long0 + e)), (t.y = n), t;
            },
            names: [
              'Lambert Azimuthal Equal Area',
              'Lambert_Azimuthal_Equal_Area',
              'laea',
            ],
            S_POLE: 1,
            N_POLE: 2,
            EQUIT: 3,
            OBLIQ: 4,
          },
          le = function (t) {
            return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
          };
        var ce = {
          init: function () {
            Math.abs(this.lat1 + this.lat2) < 1e-10 ||
              ((this.temp = this.b / this.a),
              (this.es = 1 - Math.pow(this.temp, 2)),
              (this.e3 = Math.sqrt(this.es)),
              (this.sin_po = Math.sin(this.lat1)),
              (this.cos_po = Math.cos(this.lat1)),
              (this.t1 = this.sin_po),
              (this.con = this.sin_po),
              (this.ms1 = P(this.e3, this.sin_po, this.cos_po)),
              (this.qs1 = oe(this.e3, this.sin_po, this.cos_po)),
              (this.sin_po = Math.sin(this.lat2)),
              (this.cos_po = Math.cos(this.lat2)),
              (this.t2 = this.sin_po),
              (this.ms2 = P(this.e3, this.sin_po, this.cos_po)),
              (this.qs2 = oe(this.e3, this.sin_po, this.cos_po)),
              (this.sin_po = Math.sin(this.lat0)),
              (this.cos_po = Math.cos(this.lat0)),
              (this.t3 = this.sin_po),
              (this.qs0 = oe(this.e3, this.sin_po, this.cos_po)),
              Math.abs(this.lat1 - this.lat2) > 1e-10
                ? (this.ns0 =
                    (this.ms1 * this.ms1 - this.ms2 * this.ms2) /
                    (this.qs2 - this.qs1))
                : (this.ns0 = this.con),
              (this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1),
              (this.rh =
                (this.a * Math.sqrt(this.c - this.ns0 * this.qs0)) / this.ns0));
          },
          forward: function (t) {
            var e = t.x,
              n = t.y;
            (this.sin_phi = Math.sin(n)), (this.cos_phi = Math.cos(n));
            var i = oe(this.e3, this.sin_phi, this.cos_phi),
              r = (this.a * Math.sqrt(this.c - this.ns0 * i)) / this.ns0,
              a = this.ns0 * I(e - this.long0),
              o = r * Math.sin(a) + this.x0,
              s = this.rh - r * Math.cos(a) + this.y0;
            return (t.x = o), (t.y = s), t;
          },
          inverse: function (t) {
            var e, n, i, r, a, o;
            return (
              (t.x -= this.x0),
              (t.y = this.rh - t.y + this.y0),
              this.ns0 >= 0
                ? ((e = Math.sqrt(t.x * t.x + t.y * t.y)), (i = 1))
                : ((e = -Math.sqrt(t.x * t.x + t.y * t.y)), (i = -1)),
              (r = 0),
              0 !== e && (r = Math.atan2(i * t.x, i * t.y)),
              (i = (e * this.ns0) / this.a),
              this.sphere
                ? (o = Math.asin((this.c - i * i) / (2 * this.ns0)))
                : ((n = (this.c - i * i) / this.ns0),
                  (o = this.phi1z(this.e3, n))),
              (a = I(r / this.ns0 + this.long0)),
              (t.x = a),
              (t.y = o),
              t
            );
          },
          names: ['Albers_Conic_Equal_Area', 'Albers', 'aea'],
          phi1z: function (t, e) {
            var n,
              i,
              r,
              a,
              o = le(0.5 * e);
            if (t < 1e-10) return o;
            for (var s = t * t, l = 1; l <= 25; l++)
              if (
                ((o += a =
                  ((0.5 * (r = 1 - (i = t * (n = Math.sin(o))) * i) * r) /
                    Math.cos(o)) *
                  (e / (1 - s) -
                    n / r +
                    (0.5 / t) * Math.log((1 - i) / (1 + i)))),
                Math.abs(a) <= 1e-7)
              )
                return o;
            return null;
          },
        };
        var ue = {
          init: function () {
            (this.sin_p14 = Math.sin(this.lat0)),
              (this.cos_p14 = Math.cos(this.lat0)),
              (this.infinity_dist = 1e3 * this.a),
              (this.rc = 1);
          },
          forward: function (t) {
            var e,
              n,
              i,
              r,
              a,
              o,
              s,
              l = t.x,
              c = t.y;
            return (
              (i = I(l - this.long0)),
              (e = Math.sin(c)),
              (n = Math.cos(c)),
              (r = Math.cos(i)),
              1,
              (a = this.sin_p14 * e + this.cos_p14 * n * r) > 0 ||
              Math.abs(a) <= 1e-10
                ? ((o = this.x0 + (1 * this.a * n * Math.sin(i)) / a),
                  (s =
                    this.y0 +
                    (1 * this.a * (this.cos_p14 * e - this.sin_p14 * n * r)) /
                      a))
                : ((o = this.x0 + this.infinity_dist * n * Math.sin(i)),
                  (s =
                    this.y0 +
                    this.infinity_dist *
                      (this.cos_p14 * e - this.sin_p14 * n * r))),
              (t.x = o),
              (t.y = s),
              t
            );
          },
          inverse: function (t) {
            var e, n, i, r, a, o;
            return (
              (t.x = (t.x - this.x0) / this.a),
              (t.y = (t.y - this.y0) / this.a),
              (t.x /= this.k0),
              (t.y /= this.k0),
              (e = Math.sqrt(t.x * t.x + t.y * t.y))
                ? ((r = Math.atan2(e, this.rc)),
                  (n = Math.sin(r)),
                  (i = Math.cos(r)),
                  (o = le(i * this.sin_p14 + (t.y * n * this.cos_p14) / e)),
                  (a = Math.atan2(
                    t.x * n,
                    e * this.cos_p14 * i - t.y * this.sin_p14 * n,
                  )),
                  (a = I(this.long0 + a)))
                : ((o = this.phic0), (a = 0)),
              (t.x = a),
              (t.y = o),
              t
            );
          },
          names: ['gnom'],
        };
        var he = {
          init: function () {
            this.sphere ||
              (this.k0 = P(
                this.e,
                Math.sin(this.lat_ts),
                Math.cos(this.lat_ts),
              ));
          },
          forward: function (t) {
            var e,
              n,
              i = t.x,
              r = t.y,
              a = I(i - this.long0);
            if (this.sphere)
              (e = this.x0 + this.a * a * Math.cos(this.lat_ts)),
                (n = this.y0 + (this.a * Math.sin(r)) / Math.cos(this.lat_ts));
            else {
              var o = oe(this.e, Math.sin(r));
              (e = this.x0 + this.a * this.k0 * a),
                (n = this.y0 + (this.a * o * 0.5) / this.k0);
            }
            return (t.x = e), (t.y = n), t;
          },
          inverse: function (t) {
            var e, n;
            return (
              (t.x -= this.x0),
              (t.y -= this.y0),
              this.sphere
                ? ((e = I(this.long0 + t.x / this.a / Math.cos(this.lat_ts))),
                  (n = Math.asin((t.y / this.a) * Math.cos(this.lat_ts))))
                : ((n = (function (t, e) {
                    var n =
                      1 - ((1 - t * t) / (2 * t)) * Math.log((1 - t) / (1 + t));
                    if (Math.abs(Math.abs(e) - n) < 1e-6)
                      return e < 0 ? -1 * r : r;
                    for (
                      var i, a, o, s, l = Math.asin(0.5 * e), c = 0;
                      c < 30;
                      c++
                    )
                      if (
                        ((a = Math.sin(l)),
                        (o = Math.cos(l)),
                        (s = t * a),
                        (l += i =
                          (Math.pow(1 - s * s, 2) / (2 * o)) *
                          (e / (1 - t * t) -
                            a / (1 - s * s) +
                            (0.5 / t) * Math.log((1 - s) / (1 + s)))),
                        Math.abs(i) <= 1e-10)
                      )
                        return l;
                    return NaN;
                  })(this.e, (2 * t.y * this.k0) / this.a)),
                  (e = I(this.long0 + t.x / (this.a * this.k0)))),
              (t.x = e),
              (t.y = n),
              t
            );
          },
          names: ['cea'],
        };
        var de = {
          init: function () {
            (this.x0 = this.x0 || 0),
              (this.y0 = this.y0 || 0),
              (this.lat0 = this.lat0 || 0),
              (this.long0 = this.long0 || 0),
              (this.lat_ts = this.lat_ts || 0),
              (this.title =
                this.title || 'Equidistant Cylindrical (Plate Carre)'),
              (this.rc = Math.cos(this.lat_ts));
          },
          forward: function (t) {
            var e = t.x,
              n = t.y,
              i = I(e - this.long0),
              r = ie(n - this.lat0);
            return (
              (t.x = this.x0 + this.a * i * this.rc),
              (t.y = this.y0 + this.a * r),
              t
            );
          },
          inverse: function (t) {
            var e = t.x,
              n = t.y;
            return (
              (t.x = I(this.long0 + (e - this.x0) / (this.a * this.rc))),
              (t.y = ie(this.lat0 + (n - this.y0) / this.a)),
              t
            );
          },
          names: ['Equirectangular', 'Equidistant_Cylindrical', 'eqc'],
        };
        var pe = {
          init: function () {
            (this.temp = this.b / this.a),
              (this.es = 1 - Math.pow(this.temp, 2)),
              (this.e = Math.sqrt(this.es)),
              (this.e0 = Kt(this.es)),
              (this.e1 = Qt(this.es)),
              (this.e2 = te(this.es)),
              (this.e3 = ee(this.es)),
              (this.ml0 =
                this.a * Zt(this.e0, this.e1, this.e2, this.e3, this.lat0));
          },
          forward: function (t) {
            var e,
              n,
              i,
              r = t.x,
              a = t.y,
              o = I(r - this.long0);
            if (((i = o * Math.sin(a)), this.sphere))
              Math.abs(a) <= 1e-10
                ? ((e = this.a * o), (n = -1 * this.a * this.lat0))
                : ((e = (this.a * Math.sin(i)) / Math.tan(a)),
                  (n =
                    this.a *
                    (ie(a - this.lat0) + (1 - Math.cos(i)) / Math.tan(a))));
            else if (Math.abs(a) <= 1e-10)
              (e = this.a * o), (n = -1 * this.ml0);
            else {
              var s = ne(this.a, this.e, Math.sin(a)) / Math.tan(a);
              (e = s * Math.sin(i)),
                (n =
                  this.a * Zt(this.e0, this.e1, this.e2, this.e3, a) -
                  this.ml0 +
                  s * (1 - Math.cos(i)));
            }
            return (t.x = e + this.x0), (t.y = n + this.y0), t;
          },
          inverse: function (t) {
            var e, n, i, r, a, o, s, l, c;
            if (((i = t.x - this.x0), (r = t.y - this.y0), this.sphere))
              if (Math.abs(r + this.a * this.lat0) <= 1e-10)
                (e = I(i / this.a + this.long0)), (n = 0);
              else {
                var u;
                for (
                  o = this.lat0 + r / this.a,
                    s = (i * i) / this.a / this.a + o * o,
                    l = o,
                    a = 20;
                  a;
                  --a
                )
                  if (
                    ((l += c =
                      (-1 *
                        (o * (l * (u = Math.tan(l)) + 1) -
                          l -
                          0.5 * (l * l + s) * u)) /
                      ((l - o) / u - 1)),
                    Math.abs(c) <= 1e-10)
                  ) {
                    n = l;
                    break;
                  }
                e = I(
                  this.long0 +
                    Math.asin((i * Math.tan(l)) / this.a) / Math.sin(n),
                );
              }
            else if (Math.abs(r + this.ml0) <= 1e-10)
              (n = 0), (e = I(this.long0 + i / this.a));
            else {
              var h, d, p, f, m;
              for (
                o = (this.ml0 + r) / this.a,
                  s = (i * i) / this.a / this.a + o * o,
                  l = o,
                  a = 20;
                a;
                --a
              )
                if (
                  ((m = this.e * Math.sin(l)),
                  (h = Math.sqrt(1 - m * m) * Math.tan(l)),
                  (d = this.a * Zt(this.e0, this.e1, this.e2, this.e3, l)),
                  (p =
                    this.e0 -
                    2 * this.e1 * Math.cos(2 * l) +
                    4 * this.e2 * Math.cos(4 * l) -
                    6 * this.e3 * Math.cos(6 * l)),
                  (l -= c =
                    (o * (h * (f = d / this.a) + 1) -
                      f -
                      0.5 * h * (f * f + s)) /
                    ((this.es * Math.sin(2 * l) * (f * f + s - 2 * o * f)) /
                      (4 * h) +
                      (o - f) * (h * p - 2 / Math.sin(2 * l)) -
                      p)),
                  Math.abs(c) <= 1e-10)
                ) {
                  n = l;
                  break;
                }
              (h =
                Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) *
                Math.tan(n)),
                (e = I(this.long0 + Math.asin((i * h) / this.a) / Math.sin(n)));
            }
            return (t.x = e), (t.y = n), t;
          },
          names: ['Polyconic', 'poly'],
        };
        var fe = {
          init: function () {
            (this.A = []),
              (this.A[1] = 0.6399175073),
              (this.A[2] = -0.1358797613),
              (this.A[3] = 0.063294409),
              (this.A[4] = -0.02526853),
              (this.A[5] = 0.0117879),
              (this.A[6] = -0.0055161),
              (this.A[7] = 0.0026906),
              (this.A[8] = -0.001333),
              (this.A[9] = 67e-5),
              (this.A[10] = -34e-5),
              (this.B_re = []),
              (this.B_im = []),
              (this.B_re[1] = 0.7557853228),
              (this.B_im[1] = 0),
              (this.B_re[2] = 0.249204646),
              (this.B_im[2] = 0.003371507),
              (this.B_re[3] = -0.001541739),
              (this.B_im[3] = 0.04105856),
              (this.B_re[4] = -0.10162907),
              (this.B_im[4] = 0.01727609),
              (this.B_re[5] = -0.26623489),
              (this.B_im[5] = -0.36249218),
              (this.B_re[6] = -0.6870983),
              (this.B_im[6] = -1.1651967),
              (this.C_re = []),
              (this.C_im = []),
              (this.C_re[1] = 1.3231270439),
              (this.C_im[1] = 0),
              (this.C_re[2] = -0.577245789),
              (this.C_im[2] = -0.007809598),
              (this.C_re[3] = 0.508307513),
              (this.C_im[3] = -0.112208952),
              (this.C_re[4] = -0.15094762),
              (this.C_im[4] = 0.18200602),
              (this.C_re[5] = 1.01418179),
              (this.C_im[5] = 1.64497696),
              (this.C_re[6] = 1.9660549),
              (this.C_im[6] = 2.5127645),
              (this.D = []),
              (this.D[1] = 1.5627014243),
              (this.D[2] = 0.5185406398),
              (this.D[3] = -0.03333098),
              (this.D[4] = -0.1052906),
              (this.D[5] = -0.0368594),
              (this.D[6] = 0.007317),
              (this.D[7] = 0.0122),
              (this.D[8] = 0.00394),
              (this.D[9] = -0.0013);
          },
          forward: function (t) {
            var e,
              n = t.x,
              r = t.y - this.lat0,
              a = n - this.long0,
              o = (r / i) * 1e-5,
              s = a,
              l = 1,
              c = 0;
            for (e = 1; e <= 10; e++) (l *= o), (c += this.A[e] * l);
            var u,
              h = c,
              d = s,
              p = 1,
              f = 0,
              m = 0,
              g = 0;
            for (e = 1; e <= 6; e++)
              (u = f * h + p * d),
                (p = p * h - f * d),
                (f = u),
                (m = m + this.B_re[e] * p - this.B_im[e] * f),
                (g = g + this.B_im[e] * p + this.B_re[e] * f);
            return (
              (t.x = g * this.a + this.x0), (t.y = m * this.a + this.y0), t
            );
          },
          inverse: function (t) {
            var e,
              n,
              r = t.x,
              a = t.y,
              o = r - this.x0,
              s = (a - this.y0) / this.a,
              l = o / this.a,
              c = 1,
              u = 0,
              h = 0,
              d = 0;
            for (e = 1; e <= 6; e++)
              (n = u * s + c * l),
                (c = c * s - u * l),
                (u = n),
                (h = h + this.C_re[e] * c - this.C_im[e] * u),
                (d = d + this.C_im[e] * c + this.C_re[e] * u);
            for (var p = 0; p < this.iterations; p++) {
              var f,
                m = h,
                g = d,
                y = s,
                v = l;
              for (e = 2; e <= 6; e++)
                (f = g * h + m * d),
                  (m = m * h - g * d),
                  (g = f),
                  (y += (e - 1) * (this.B_re[e] * m - this.B_im[e] * g)),
                  (v += (e - 1) * (this.B_im[e] * m + this.B_re[e] * g));
              (m = 1), (g = 0);
              var x = this.B_re[1],
                b = this.B_im[1];
              for (e = 2; e <= 6; e++)
                (f = g * h + m * d),
                  (m = m * h - g * d),
                  (g = f),
                  (x += e * (this.B_re[e] * m - this.B_im[e] * g)),
                  (b += e * (this.B_im[e] * m + this.B_re[e] * g));
              var _ = x * x + b * b;
              (h = (y * x + v * b) / _), (d = (v * x - y * b) / _);
            }
            var w = h,
              M = d,
              q = 1,
              S = 0;
            for (e = 1; e <= 9; e++) (q *= w), (S += this.D[e] * q);
            var T = this.lat0 + S * i * 1e5,
              E = this.long0 + M;
            return (t.x = E), (t.y = T), t;
          },
          names: ['New_Zealand_Map_Grid', 'nzmg'],
        };
        var me = {
          init: function () {},
          forward: function (t) {
            var e = t.x,
              n = t.y,
              i = I(e - this.long0),
              r = this.x0 + this.a * i,
              a =
                this.y0 +
                this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
            return (t.x = r), (t.y = a), t;
          },
          inverse: function (t) {
            (t.x -= this.x0), (t.y -= this.y0);
            var e = I(this.long0 + t.x / this.a),
              n =
                2.5 * (Math.atan(Math.exp((0.8 * t.y) / this.a)) - Math.PI / 4);
            return (t.x = e), (t.y = n), t;
          },
          names: ['Miller_Cylindrical', 'mill'],
        };
        var ge = {
          init: function () {
            this.sphere
              ? ((this.n = 1),
                (this.m = 0),
                (this.es = 0),
                (this.C_y = Math.sqrt((this.m + 1) / this.n)),
                (this.C_x = this.C_y / (this.m + 1)))
              : (this.en = Pt(this.es));
          },
          forward: function (t) {
            var e,
              n,
              i = t.x,
              r = t.y;
            if (((i = I(i - this.long0)), this.sphere)) {
              if (this.m)
                for (var a = this.n * Math.sin(r), o = 20; o; --o) {
                  var s =
                    (this.m * r + Math.sin(r) - a) / (this.m + Math.cos(r));
                  if (((r -= s), Math.abs(s) < 1e-10)) break;
                }
              else r = 1 !== this.n ? Math.asin(this.n * Math.sin(r)) : r;
              (e = this.a * this.C_x * i * (this.m + Math.cos(r))),
                (n = this.a * this.C_y * r);
            } else {
              var l = Math.sin(r),
                c = Math.cos(r);
              (n = this.a * kt(r, l, c, this.en)),
                (e = (this.a * i * c) / Math.sqrt(1 - this.es * l * l));
            }
            return (t.x = e), (t.y = n), t;
          },
          inverse: function (t) {
            var e, n, i, a;
            return (
              (t.x -= this.x0),
              (i = t.x / this.a),
              (t.y -= this.y0),
              (e = t.y / this.a),
              this.sphere
                ? ((e /= this.C_y),
                  (i /= this.C_x * (this.m + Math.cos(e))),
                  this.m
                    ? (e = le((this.m * e + Math.sin(e)) / this.n))
                    : 1 !== this.n && (e = le(Math.sin(e) / this.n)),
                  (i = I(i + this.long0)),
                  (e = ie(e)))
                : ((e = It(t.y / this.a, this.es, this.en)),
                  (a = Math.abs(e)) < r
                    ? ((a = Math.sin(e)),
                      (n =
                        this.long0 +
                        (t.x * Math.sqrt(1 - this.es * a * a)) /
                          (this.a * Math.cos(e))),
                      (i = I(n)))
                    : a - 1e-10 < r && (i = this.long0)),
              (t.x = i),
              (t.y = e),
              t
            );
          },
          names: ['Sinusoidal', 'sinu'],
        };
        var ye = {
          init: function () {},
          forward: function (t) {
            for (
              var e = t.x,
                n = t.y,
                i = I(e - this.long0),
                r = n,
                a = Math.PI * Math.sin(n);
              ;

            ) {
              var o = -(r + Math.sin(r) - a) / (1 + Math.cos(r));
              if (((r += o), Math.abs(o) < 1e-10)) break;
            }
            (r /= 2), Math.PI / 2 - Math.abs(n) < 1e-10 && (i = 0);
            var s = 0.900316316158 * this.a * i * Math.cos(r) + this.x0,
              l = 1.4142135623731 * this.a * Math.sin(r) + this.y0;
            return (t.x = s), (t.y = l), t;
          },
          inverse: function (t) {
            var e, n;
            (t.x -= this.x0),
              (t.y -= this.y0),
              (n = t.y / (1.4142135623731 * this.a)),
              Math.abs(n) > 0.999999999999 && (n = 0.999999999999),
              (e = Math.asin(n));
            var i = I(
              this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)),
            );
            i < -Math.PI && (i = -Math.PI),
              i > Math.PI && (i = Math.PI),
              (n = (2 * e + Math.sin(2 * e)) / Math.PI),
              Math.abs(n) > 1 && (n = 1);
            var r = Math.asin(n);
            return (t.x = i), (t.y = r), t;
          },
          names: ['Mollweide', 'moll'],
        };
        var ve = {
          init: function () {
            Math.abs(this.lat1 + this.lat2) < 1e-10 ||
              ((this.lat2 = this.lat2 || this.lat1),
              (this.temp = this.b / this.a),
              (this.es = 1 - Math.pow(this.temp, 2)),
              (this.e = Math.sqrt(this.es)),
              (this.e0 = Kt(this.es)),
              (this.e1 = Qt(this.es)),
              (this.e2 = te(this.es)),
              (this.e3 = ee(this.es)),
              (this.sinphi = Math.sin(this.lat1)),
              (this.cosphi = Math.cos(this.lat1)),
              (this.ms1 = P(this.e, this.sinphi, this.cosphi)),
              (this.ml1 = Zt(this.e0, this.e1, this.e2, this.e3, this.lat1)),
              Math.abs(this.lat1 - this.lat2) < 1e-10
                ? (this.ns = this.sinphi)
                : ((this.sinphi = Math.sin(this.lat2)),
                  (this.cosphi = Math.cos(this.lat2)),
                  (this.ms2 = P(this.e, this.sinphi, this.cosphi)),
                  (this.ml2 = Zt(
                    this.e0,
                    this.e1,
                    this.e2,
                    this.e3,
                    this.lat2,
                  )),
                  (this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1))),
              (this.g = this.ml1 + this.ms1 / this.ns),
              (this.ml0 = Zt(this.e0, this.e1, this.e2, this.e3, this.lat0)),
              (this.rh = this.a * (this.g - this.ml0)));
          },
          forward: function (t) {
            var e,
              n = t.x,
              i = t.y;
            if (this.sphere) e = this.a * (this.g - i);
            else {
              var r = Zt(this.e0, this.e1, this.e2, this.e3, i);
              e = this.a * (this.g - r);
            }
            var a = this.ns * I(n - this.long0),
              o = this.x0 + e * Math.sin(a),
              s = this.y0 + this.rh - e * Math.cos(a);
            return (t.x = o), (t.y = s), t;
          },
          inverse: function (t) {
            var e, n, i, r;
            (t.x -= this.x0),
              (t.y = this.rh - t.y + this.y0),
              this.ns >= 0
                ? ((n = Math.sqrt(t.x * t.x + t.y * t.y)), (e = 1))
                : ((n = -Math.sqrt(t.x * t.x + t.y * t.y)), (e = -1));
            var a = 0;
            if ((0 !== n && (a = Math.atan2(e * t.x, e * t.y)), this.sphere))
              return (
                (r = I(this.long0 + a / this.ns)),
                (i = ie(this.g - n / this.a)),
                (t.x = r),
                (t.y = i),
                t
              );
            var o = this.g - n / this.a;
            return (
              (i = re(o, this.e0, this.e1, this.e2, this.e3)),
              (r = I(this.long0 + a / this.ns)),
              (t.x = r),
              (t.y = i),
              t
            );
          },
          names: ['Equidistant_Conic', 'eqdc'],
        };
        var xe = {
          init: function () {
            this.R = this.a;
          },
          forward: function (t) {
            var e,
              n,
              i = t.x,
              a = t.y,
              o = I(i - this.long0);
            Math.abs(a) <= 1e-10 && ((e = this.x0 + this.R * o), (n = this.y0));
            var s = le(2 * Math.abs(a / Math.PI));
            (Math.abs(o) <= 1e-10 || Math.abs(Math.abs(a) - r) <= 1e-10) &&
              ((e = this.x0),
              (n =
                a >= 0
                  ? this.y0 + Math.PI * this.R * Math.tan(0.5 * s)
                  : this.y0 + Math.PI * this.R * -Math.tan(0.5 * s)));
            var l = 0.5 * Math.abs(Math.PI / o - o / Math.PI),
              c = l * l,
              u = Math.sin(s),
              h = Math.cos(s),
              d = h / (u + h - 1),
              p = d * d,
              f = d * (2 / u - 1),
              m = f * f,
              g =
                (Math.PI *
                  this.R *
                  (l * (d - m) +
                    Math.sqrt(c * (d - m) * (d - m) - (m + c) * (p - m)))) /
                (m + c);
            o < 0 && (g = -g), (e = this.x0 + g);
            var y = c + d;
            return (
              (g =
                (Math.PI *
                  this.R *
                  (f * y - l * Math.sqrt((m + c) * (c + 1) - y * y))) /
                (m + c)),
              (n = a >= 0 ? this.y0 + g : this.y0 - g),
              (t.x = e),
              (t.y = n),
              t
            );
          },
          inverse: function (t) {
            var e, n, i, r, a, o, s, l, c, u, h, d;
            return (
              (t.x -= this.x0),
              (t.y -= this.y0),
              (h = Math.PI * this.R),
              (a = (i = t.x / h) * i + (r = t.y / h) * r),
              (h =
                (3 *
                  ((r * r) /
                    (l =
                      -2 * (o = -Math.abs(r) * (1 + a)) +
                      1 +
                      2 * r * r +
                      a * a) +
                    ((2 * (s = o - 2 * r * r + i * i) * s * s) / l / l / l -
                      (9 * o * s) / l / l) /
                      27)) /
                (c = (o - (s * s) / 3 / l) / l) /
                (u = 2 * Math.sqrt(-c / 3))),
              Math.abs(h) > 1 && (h = h >= 0 ? 1 : -1),
              (d = Math.acos(h) / 3),
              (n =
                t.y >= 0
                  ? (-u * Math.cos(d + Math.PI / 3) - s / 3 / l) * Math.PI
                  : -(-u * Math.cos(d + Math.PI / 3) - s / 3 / l) * Math.PI),
              (e =
                Math.abs(i) < 1e-10
                  ? this.long0
                  : I(
                      this.long0 +
                        (Math.PI *
                          (a -
                            1 +
                            Math.sqrt(1 + 2 * (i * i - r * r) + a * a))) /
                          2 /
                          i,
                    )),
              (t.x = e),
              (t.y = n),
              t
            );
          },
          names: ['Van_der_Grinten_I', 'VanDerGrinten', 'vandg'],
        };
        var be = {
          init: function () {
            (this.sin_p12 = Math.sin(this.lat0)),
              (this.cos_p12 = Math.cos(this.lat0));
          },
          forward: function (t) {
            var e,
              n,
              i,
              a,
              o,
              s,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              y,
              v,
              x,
              b,
              _,
              w,
              M,
              q = t.x,
              S = t.y,
              T = Math.sin(t.y),
              E = Math.cos(t.y),
              A = I(q - this.long0);
            return this.sphere
              ? Math.abs(this.sin_p12 - 1) <= 1e-10
                ? ((t.x = this.x0 + this.a * (r - S) * Math.sin(A)),
                  (t.y = this.y0 - this.a * (r - S) * Math.cos(A)),
                  t)
                : Math.abs(this.sin_p12 + 1) <= 1e-10
                ? ((t.x = this.x0 + this.a * (r + S) * Math.sin(A)),
                  (t.y = this.y0 + this.a * (r + S) * Math.cos(A)),
                  t)
                : ((x = this.sin_p12 * T + this.cos_p12 * E * Math.cos(A)),
                  (v = (y = Math.acos(x)) ? y / Math.sin(y) : 1),
                  (t.x = this.x0 + this.a * v * E * Math.sin(A)),
                  (t.y =
                    this.y0 +
                    this.a *
                      v *
                      (this.cos_p12 * T - this.sin_p12 * E * Math.cos(A))),
                  t)
              : ((e = Kt(this.es)),
                (n = Qt(this.es)),
                (i = te(this.es)),
                (a = ee(this.es)),
                Math.abs(this.sin_p12 - 1) <= 1e-10
                  ? ((o = this.a * Zt(e, n, i, a, r)),
                    (s = this.a * Zt(e, n, i, a, S)),
                    (t.x = this.x0 + (o - s) * Math.sin(A)),
                    (t.y = this.y0 - (o - s) * Math.cos(A)),
                    t)
                  : Math.abs(this.sin_p12 + 1) <= 1e-10
                  ? ((o = this.a * Zt(e, n, i, a, r)),
                    (s = this.a * Zt(e, n, i, a, S)),
                    (t.x = this.x0 + (o + s) * Math.sin(A)),
                    (t.y = this.y0 + (o + s) * Math.cos(A)),
                    t)
                  : ((l = T / E),
                    (c = ne(this.a, this.e, this.sin_p12)),
                    (u = ne(this.a, this.e, T)),
                    (h = Math.atan(
                      (1 - this.es) * l +
                        (this.es * c * this.sin_p12) / (u * E),
                    )),
                    (b =
                      0 ===
                      (d = Math.atan2(
                        Math.sin(A),
                        this.cos_p12 * Math.tan(h) - this.sin_p12 * Math.cos(A),
                      ))
                        ? Math.asin(
                            this.cos_p12 * Math.sin(h) -
                              this.sin_p12 * Math.cos(h),
                          )
                        : Math.abs(Math.abs(d) - Math.PI) <= 1e-10
                        ? -Math.asin(
                            this.cos_p12 * Math.sin(h) -
                              this.sin_p12 * Math.cos(h),
                          )
                        : Math.asin((Math.sin(A) * Math.cos(h)) / Math.sin(d))),
                    (p = (this.e * this.sin_p12) / Math.sqrt(1 - this.es)),
                    (y =
                      c *
                      b *
                      (1 -
                        ((_ = b * b) *
                          (g =
                            (f =
                              (this.e * this.cos_p12 * Math.cos(d)) /
                              Math.sqrt(1 - this.es)) * f) *
                          (1 - g)) /
                          6 +
                        ((w = _ * b) / 8) * (m = p * f) * (1 - 2 * g) +
                        ((M = w * b) / 120) *
                          (g * (4 - 7 * g) - 3 * p * p * (1 - 7 * g)) -
                        ((M * b) / 48) * m)),
                    (t.x = this.x0 + y * Math.sin(d)),
                    (t.y = this.y0 + y * Math.cos(d)),
                    t));
          },
          inverse: function (t) {
            var e,
              n,
              i,
              a,
              o,
              s,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              y,
              v,
              x,
              b,
              _,
              w,
              M,
              q;
            if (((t.x -= this.x0), (t.y -= this.y0), this.sphere)) {
              if ((e = Math.sqrt(t.x * t.x + t.y * t.y)) > 2 * r * this.a)
                return;
              return (
                (n = e / this.a),
                (i = Math.sin(n)),
                (a = Math.cos(n)),
                (o = this.long0),
                Math.abs(e) <= 1e-10
                  ? (s = this.lat0)
                  : ((s = le(a * this.sin_p12 + (t.y * i * this.cos_p12) / e)),
                    (l = Math.abs(this.lat0) - r),
                    (o =
                      Math.abs(l) <= 1e-10
                        ? this.lat0 >= 0
                          ? I(this.long0 + Math.atan2(t.x, -t.y))
                          : I(this.long0 - Math.atan2(-t.x, t.y))
                        : I(
                            this.long0 +
                              Math.atan2(
                                t.x * i,
                                e * this.cos_p12 * a - t.y * this.sin_p12 * i,
                              ),
                          ))),
                (t.x = o),
                (t.y = s),
                t
              );
            }
            return (
              (c = Kt(this.es)),
              (u = Qt(this.es)),
              (h = te(this.es)),
              (d = ee(this.es)),
              Math.abs(this.sin_p12 - 1) <= 1e-10
                ? ((p = this.a * Zt(c, u, h, d, r)),
                  (e = Math.sqrt(t.x * t.x + t.y * t.y)),
                  (s = re((p - e) / this.a, c, u, h, d)),
                  (o = I(this.long0 + Math.atan2(t.x, -1 * t.y))),
                  (t.x = o),
                  (t.y = s),
                  t)
                : Math.abs(this.sin_p12 + 1) <= 1e-10
                ? ((p = this.a * Zt(c, u, h, d, r)),
                  (e = Math.sqrt(t.x * t.x + t.y * t.y)),
                  (s = re((e - p) / this.a, c, u, h, d)),
                  (o = I(this.long0 + Math.atan2(t.x, t.y))),
                  (t.x = o),
                  (t.y = s),
                  t)
                : ((e = Math.sqrt(t.x * t.x + t.y * t.y)),
                  (g = Math.atan2(t.x, t.y)),
                  (f = ne(this.a, this.e, this.sin_p12)),
                  (y = Math.cos(g)),
                  (x = (-(v = this.e * this.cos_p12 * y) * v) / (1 - this.es)),
                  (b =
                    (3 * this.es * (1 - x) * this.sin_p12 * this.cos_p12 * y) /
                    (1 - this.es)),
                  (M =
                    1 -
                    (x *
                      (w =
                        (_ = e / f) -
                        (x * (1 + x) * Math.pow(_, 3)) / 6 -
                        (b * (1 + 3 * x) * Math.pow(_, 4)) / 24) *
                      w) /
                      2 -
                    (_ * w * w * w) / 6),
                  (m = Math.asin(
                    this.sin_p12 * Math.cos(w) + this.cos_p12 * Math.sin(w) * y,
                  )),
                  (o = I(
                    this.long0 +
                      Math.asin((Math.sin(g) * Math.sin(w)) / Math.cos(m)),
                  )),
                  (q = Math.sin(m)),
                  (s = Math.atan2(
                    (q - this.es * M * this.sin_p12) * Math.tan(m),
                    q * (1 - this.es),
                  )),
                  (t.x = o),
                  (t.y = s),
                  t)
            );
          },
          names: ['Azimuthal_Equidistant', 'aeqd'],
        };
        var _e = {
            init: function () {
              (this.sin_p14 = Math.sin(this.lat0)),
                (this.cos_p14 = Math.cos(this.lat0));
            },
            forward: function (t) {
              var e,
                n,
                i,
                r,
                a,
                o,
                s,
                l = t.x,
                c = t.y;
              return (
                (i = I(l - this.long0)),
                (e = Math.sin(c)),
                (n = Math.cos(c)),
                (r = Math.cos(i)),
                1,
                ((a = this.sin_p14 * e + this.cos_p14 * n * r) > 0 ||
                  Math.abs(a) <= 1e-10) &&
                  ((o = 1 * this.a * n * Math.sin(i)),
                  (s =
                    this.y0 +
                    1 * this.a * (this.cos_p14 * e - this.sin_p14 * n * r))),
                (t.x = o),
                (t.y = s),
                t
              );
            },
            inverse: function (t) {
              var e, n, i, a, o, s, l;
              return (
                (t.x -= this.x0),
                (t.y -= this.y0),
                (e = Math.sqrt(t.x * t.x + t.y * t.y)),
                (n = le(e / this.a)),
                (i = Math.sin(n)),
                (a = Math.cos(n)),
                (s = this.long0),
                Math.abs(e) <= 1e-10
                  ? ((l = this.lat0), (t.x = s), (t.y = l), t)
                  : ((l = le(a * this.sin_p14 + (t.y * i * this.cos_p14) / e)),
                    (o = Math.abs(this.lat0) - r),
                    Math.abs(o) <= 1e-10
                      ? ((s =
                          this.lat0 >= 0
                            ? I(this.long0 + Math.atan2(t.x, -t.y))
                            : I(this.long0 - Math.atan2(-t.x, t.y))),
                        (t.x = s),
                        (t.y = l),
                        t)
                      : ((s = I(
                          this.long0 +
                            Math.atan2(
                              t.x * i,
                              e * this.cos_p14 * a - t.y * this.sin_p14 * i,
                            ),
                        )),
                        (t.x = s),
                        (t.y = l),
                        t))
              );
            },
            names: ['ortho'],
          },
          we = 1,
          Me = 2,
          qe = 3,
          Se = 4,
          Te = 5,
          Ee = 6,
          Ae = 1,
          Le = 2,
          Re = 3,
          Ce = 4;
        function Pe(t, e, n, i) {
          var a;
          return (
            t < 1e-10
              ? ((i.value = Ae), (a = 0))
              : ((a = Math.atan2(e, n)),
                Math.abs(a) <= s
                  ? (i.value = Ae)
                  : a > s && a <= r + s
                  ? ((i.value = Le), (a -= r))
                  : a > r + s || a <= -(r + s)
                  ? ((i.value = Re), (a = a >= 0 ? a - c : a + c))
                  : ((i.value = Ce), (a += r))),
            a
          );
        }
        function ke(t, e) {
          var n = t + e;
          return n < -c ? (n += l) : n > +c && (n -= l), n;
        }
        var Ie = {
            init: function () {
              (this.x0 = this.x0 || 0),
                (this.y0 = this.y0 || 0),
                (this.lat0 = this.lat0 || 0),
                (this.long0 = this.long0 || 0),
                (this.lat_ts = this.lat_ts || 0),
                (this.title = this.title || 'Quadrilateralized Spherical Cube'),
                this.lat0 >= r - s / 2
                  ? (this.face = Te)
                  : this.lat0 <= -(r - s / 2)
                  ? (this.face = Ee)
                  : Math.abs(this.long0) <= s
                  ? (this.face = we)
                  : Math.abs(this.long0) <= r + s
                  ? (this.face = this.long0 > 0 ? Me : Se)
                  : (this.face = qe),
                0 !== this.es &&
                  ((this.one_minus_f = 1 - (this.a - this.b) / this.a),
                  (this.one_minus_f_squared =
                    this.one_minus_f * this.one_minus_f));
            },
            forward: function (t) {
              var e,
                n,
                i,
                a,
                o,
                l,
                u = { x: 0, y: 0 },
                h = { value: 0 };
              if (
                ((t.x -= this.long0),
                (e =
                  0 !== this.es
                    ? Math.atan(this.one_minus_f_squared * Math.tan(t.y))
                    : t.y),
                (n = t.x),
                this.face === Te)
              )
                (a = r - e),
                  n >= s && n <= r + s
                    ? ((h.value = Ae), (i = n - r))
                    : n > r + s || n <= -(r + s)
                    ? ((h.value = Le), (i = n > 0 ? n - c : n + c))
                    : n > -(r + s) && n <= -s
                    ? ((h.value = Re), (i = n + r))
                    : ((h.value = Ce), (i = n));
              else if (this.face === Ee)
                (a = r + e),
                  n >= s && n <= r + s
                    ? ((h.value = Ae), (i = -n + r))
                    : n < s && n >= -s
                    ? ((h.value = Le), (i = -n))
                    : n < -s && n >= -(r + s)
                    ? ((h.value = Re), (i = -n - r))
                    : ((h.value = Ce), (i = n > 0 ? -n + c : -n - c));
              else {
                var d, p, f, m, g, y;
                this.face === Me
                  ? (n = ke(n, +r))
                  : this.face === qe
                  ? (n = ke(n, +c))
                  : this.face === Se && (n = ke(n, -r)),
                  (m = Math.sin(e)),
                  (g = Math.cos(e)),
                  (y = Math.sin(n)),
                  (d = g * Math.cos(n)),
                  (p = g * y),
                  (f = m),
                  this.face === we
                    ? (i = Pe((a = Math.acos(d)), f, p, h))
                    : this.face === Me
                    ? (i = Pe((a = Math.acos(p)), f, -d, h))
                    : this.face === qe
                    ? (i = Pe((a = Math.acos(-d)), f, -p, h))
                    : this.face === Se
                    ? (i = Pe((a = Math.acos(-p)), f, d, h))
                    : ((a = i = 0), (h.value = Ae));
              }
              return (
                (l = Math.atan(
                  (12 / c) * (i + Math.acos(Math.sin(i) * Math.cos(s)) - r),
                )),
                (o = Math.sqrt(
                  (1 - Math.cos(a)) /
                    (Math.cos(l) * Math.cos(l)) /
                    (1 - Math.cos(Math.atan(1 / Math.cos(i)))),
                )),
                h.value === Le
                  ? (l += r)
                  : h.value === Re
                  ? (l += c)
                  : h.value === Ce && (l += 1.5 * c),
                (u.x = o * Math.cos(l)),
                (u.y = o * Math.sin(l)),
                (u.x = u.x * this.a + this.x0),
                (u.y = u.y * this.a + this.y0),
                (t.x = u.x),
                (t.y = u.y),
                t
              );
            },
            inverse: function (t) {
              var e,
                n,
                i,
                a,
                o,
                s,
                l,
                u,
                h,
                d,
                p,
                f,
                m = { lam: 0, phi: 0 },
                g = { value: 0 };
              if (
                ((t.x = (t.x - this.x0) / this.a),
                (t.y = (t.y - this.y0) / this.a),
                (n = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y))),
                (e = Math.atan2(t.y, t.x)),
                t.x >= 0 && t.x >= Math.abs(t.y)
                  ? (g.value = Ae)
                  : t.y >= 0 && t.y >= Math.abs(t.x)
                  ? ((g.value = Le), (e -= r))
                  : t.x < 0 && -t.x >= Math.abs(t.y)
                  ? ((g.value = Re), (e = e < 0 ? e + c : e - c))
                  : ((g.value = Ce), (e += r)),
                (h = (c / 12) * Math.tan(e)),
                (o = Math.sin(h) / (Math.cos(h) - 1 / Math.sqrt(2))),
                (s = Math.atan(o)),
                (l =
                  1 -
                  (i = Math.cos(e)) *
                    i *
                    (a = Math.tan(n)) *
                    a *
                    (1 - Math.cos(Math.atan(1 / Math.cos(s))))) < -1
                  ? (l = -1)
                  : l > 1 && (l = 1),
                this.face === Te)
              )
                (u = Math.acos(l)),
                  (m.phi = r - u),
                  g.value === Ae
                    ? (m.lam = s + r)
                    : g.value === Le
                    ? (m.lam = s < 0 ? s + c : s - c)
                    : g.value === Re
                    ? (m.lam = s - r)
                    : (m.lam = s);
              else if (this.face === Ee)
                (u = Math.acos(l)),
                  (m.phi = u - r),
                  g.value === Ae
                    ? (m.lam = -s + r)
                    : g.value === Le
                    ? (m.lam = -s)
                    : g.value === Re
                    ? (m.lam = -s - r)
                    : (m.lam = s < 0 ? -s - c : -s + c);
              else {
                var y, v, x;
                (h = (y = l) * y),
                  (v =
                    (h +=
                      (x = h >= 1 ? 0 : Math.sqrt(1 - h) * Math.sin(s)) * x) >=
                    1
                      ? 0
                      : Math.sqrt(1 - h)),
                  g.value === Le
                    ? ((h = v), (v = -x), (x = h))
                    : g.value === Re
                    ? ((v = -v), (x = -x))
                    : g.value === Ce && ((h = v), (v = x), (x = -h)),
                  this.face === Me
                    ? ((h = y), (y = -v), (v = h))
                    : this.face === qe
                    ? ((y = -y), (v = -v))
                    : this.face === Se && ((h = y), (y = v), (v = -h)),
                  (m.phi = Math.acos(-x) - r),
                  (m.lam = Math.atan2(v, y)),
                  this.face === Me
                    ? (m.lam = ke(m.lam, -r))
                    : this.face === qe
                    ? (m.lam = ke(m.lam, -c))
                    : this.face === Se && (m.lam = ke(m.lam, +r));
              }
              return (
                0 !== this.es &&
                  ((d = m.phi < 0 ? 1 : 0),
                  (p = Math.tan(m.phi)),
                  (f = this.b / Math.sqrt(p * p + this.one_minus_f_squared)),
                  (m.phi = Math.atan(
                    Math.sqrt(this.a * this.a - f * f) / (this.one_minus_f * f),
                  )),
                  d && (m.phi = -m.phi)),
                (m.lam += this.long0),
                (t.x = m.lam),
                (t.y = m.phi),
                t
              );
            },
            names: [
              'Quadrilateralized Spherical Cube',
              'Quadrilateralized_Spherical_Cube',
              'qsc',
            ],
          },
          De = [
            [1, 22199e-21, -715515e-10, 31103e-10],
            [0.9986, -482243e-9, -24897e-9, -13309e-10],
            [0.9954, -83103e-8, -448605e-10, -9.86701e-7],
            [0.99, -0.00135364, -59661e-9, 36777e-10],
            [0.9822, -0.00167442, -449547e-11, -572411e-11],
            [0.973, -0.00214868, -903571e-10, 1.8736e-8],
            [0.96, -0.00305085, -900761e-10, 164917e-11],
            [0.9427, -0.00382792, -653386e-10, -26154e-10],
            [0.9216, -0.00467746, -10457e-8, 481243e-11],
            [0.8962, -0.00536223, -323831e-10, -543432e-11],
            [0.8679, -0.00609363, -113898e-9, 332484e-11],
            [0.835, -0.00698325, -640253e-10, 9.34959e-7],
            [0.7986, -0.00755338, -500009e-10, 9.35324e-7],
            [0.7597, -0.00798324, -35971e-9, -227626e-11],
            [0.7186, -0.00851367, -701149e-10, -86303e-10],
            [0.6732, -0.00986209, -199569e-9, 191974e-10],
            [0.6213, -0.010418, 883923e-10, 624051e-11],
            [0.5722, -0.00906601, 182e-6, 624051e-11],
            [0.5322, -0.00677797, 275608e-9, 624051e-11],
          ],
          Oe = [
            [-520417e-23, 0.0124, 121431e-23, -845284e-16],
            [0.062, 0.0124, -1.26793e-9, 4.22642e-10],
            [0.124, 0.0124, 5.07171e-9, -1.60604e-9],
            [0.186, 0.0123999, -1.90189e-8, 6.00152e-9],
            [0.248, 0.0124002, 7.10039e-8, -2.24e-8],
            [0.31, 0.0123992, -2.64997e-7, 8.35986e-8],
            [0.372, 0.0124029, 9.88983e-7, -3.11994e-7],
            [0.434, 0.0123893, -369093e-11, -4.35621e-7],
            [0.4958, 0.0123198, -102252e-10, -3.45523e-7],
            [0.5571, 0.0121916, -154081e-10, -5.82288e-7],
            [0.6176, 0.0119938, -241424e-10, -5.25327e-7],
            [0.6769, 0.011713, -320223e-10, -5.16405e-7],
            [0.7346, 0.0113541, -397684e-10, -6.09052e-7],
            [0.7903, 0.0109107, -489042e-10, -104739e-11],
            [0.8435, 0.0103431, -64615e-9, -1.40374e-9],
            [0.8936, 0.00969686, -64636e-9, -8547e-9],
            [0.9394, 0.00840947, -192841e-9, -42106e-10],
            [0.9761, 0.00616527, -256e-6, -42106e-10],
            [1, 0.00328947, -319159e-9, -42106e-10],
          ],
          Ne = o / 5,
          ze = function (t, e) {
            return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
          };
        var Fe = {
          init: function () {
            (this.x0 = this.x0 || 0),
              (this.y0 = this.y0 || 0),
              (this.long0 = this.long0 || 0),
              (this.es = 0),
              (this.title = this.title || 'Robinson');
          },
          forward: function (t) {
            var e = I(t.x - this.long0),
              n = Math.abs(t.y),
              i = Math.floor(n * Ne);
            i < 0 ? (i = 0) : i >= 18 && (i = 17);
            var r = {
              x: ze(De[i], (n = o * (n - 0.08726646259971647 * i))) * e,
              y: ze(Oe[i], n),
            };
            return (
              t.y < 0 && (r.y = -r.y),
              (r.x = r.x * this.a * 0.8487 + this.x0),
              (r.y = r.y * this.a * 1.3523 + this.y0),
              r
            );
          },
          inverse: function (t) {
            var e = {
              x: (t.x - this.x0) / (0.8487 * this.a),
              y: Math.abs(t.y - this.y0) / (1.3523 * this.a),
            };
            if (e.y >= 1) (e.x /= De[18][0]), (e.y = t.y < 0 ? -r : r);
            else {
              var n = Math.floor(18 * e.y);
              for (n < 0 ? (n = 0) : n >= 18 && (n = 17); ; )
                if (Oe[n][0] > e.y) --n;
                else {
                  if (!(Oe[n + 1][0] <= e.y)) break;
                  ++n;
                }
              var i = Oe[n],
                o = (5 * (e.y - i[0])) / (Oe[n + 1][0] - i[0]);
              (o = (function (t, e, n, i) {
                for (var r = e; i; --i) {
                  var a = t(r);
                  if (((r -= a), Math.abs(a) < n)) break;
                }
                return r;
              })(
                function (t) {
                  return (
                    (ze(i, t) - e.y) /
                    (function (t, e) {
                      return t[1] + e * (2 * t[2] + 3 * e * t[3]);
                    })(i, t)
                  );
                },
                o,
                1e-10,
                100,
              )),
                (e.x /= ze(De[n], o)),
                (e.y = (5 * n + o) * a),
                t.y < 0 && (e.y = -e.y);
            }
            return (e.x = I(e.x + this.long0)), e;
          },
          names: ['Robinson', 'robin'],
        };
        var Be = {
            init: function () {
              this.name = 'geocent';
            },
            forward: function (t) {
              return nt(t, this.es, this.a);
            },
            inverse: function (t) {
              return it(t, this.es, this.a, this.b);
            },
            names: ['Geocentric', 'geocentric', 'geocent', 'Geocent'],
          },
          Ue = 0,
          je = 1,
          Ge = 2,
          He = 3,
          Ve = {
            h: { def: 1e5, num: !0 },
            azi: { def: 0, num: !0, degrees: !0 },
            tilt: { def: 0, num: !0, degrees: !0 },
            long0: { def: 0, num: !0 },
            lat0: { def: 0, num: !0 },
          };
        var We,
          Xe = {
            init: function () {
              if (
                (Object.keys(Ve).forEach(
                  function (t) {
                    if (void 0 === this[t]) this[t] = Ve[t].def;
                    else {
                      if (Ve[t].num && isNaN(this[t]))
                        throw new Error(
                          'Invalid parameter value, must be numeric ' +
                            t +
                            ' = ' +
                            this[t],
                        );
                      Ve[t].num && (this[t] = parseFloat(this[t]));
                    }
                    Ve[t].degrees && (this[t] = this[t] * a);
                  }.bind(this),
                ),
                Math.abs(Math.abs(this.lat0) - r) < 1e-10
                  ? (this.mode = this.lat0 < 0 ? je : Ue)
                  : Math.abs(this.lat0) < 1e-10
                  ? (this.mode = Ge)
                  : ((this.mode = He),
                    (this.sinph0 = Math.sin(this.lat0)),
                    (this.cosph0 = Math.cos(this.lat0))),
                (this.pn1 = this.h / this.a),
                this.pn1 <= 0 || this.pn1 > 1e10)
              )
                throw new Error('Invalid height');
              (this.p = 1 + this.pn1),
                (this.rp = 1 / this.p),
                (this.h1 = 1 / this.pn1),
                (this.pfact = (this.p + 1) * this.h1),
                (this.es = 0);
              var t = this.tilt,
                e = this.azi;
              (this.cg = Math.cos(e)),
                (this.sg = Math.sin(e)),
                (this.cw = Math.cos(t)),
                (this.sw = Math.sin(t));
            },
            forward: function (t) {
              t.x -= this.long0;
              var e,
                n,
                i,
                r,
                a = Math.sin(t.y),
                o = Math.cos(t.y),
                s = Math.cos(t.x);
              switch (this.mode) {
                case He:
                  n = this.sinph0 * a + this.cosph0 * o * s;
                  break;
                case Ge:
                  n = o * s;
                  break;
                case je:
                  n = -a;
                  break;
                case Ue:
                  n = a;
              }
              switch (
                ((e = (n = this.pn1 / (this.p - n)) * o * Math.sin(t.x)),
                this.mode)
              ) {
                case He:
                  n *= this.cosph0 * a - this.sinph0 * o * s;
                  break;
                case Ge:
                  n *= a;
                  break;
                case Ue:
                  n *= -o * s;
                  break;
                case je:
                  n *= o * s;
              }
              return (
                (r =
                  1 /
                  ((i = n * this.cg + e * this.sg) * this.sw * this.h1 +
                    this.cw)),
                (e = (e * this.cg - n * this.sg) * this.cw * r),
                (n = i * r),
                (t.x = e * this.a),
                (t.y = n * this.a),
                t
              );
            },
            inverse: function (t) {
              (t.x /= this.a), (t.y /= this.a);
              var e,
                n,
                i,
                r = { x: t.x, y: t.y };
              (i = 1 / (this.pn1 - t.y * this.sw)),
                (e = this.pn1 * t.x * i),
                (n = this.pn1 * t.y * this.cw * i),
                (t.x = e * this.cg + n * this.sg),
                (t.y = n * this.cg - e * this.sg);
              var a = Nt(t.x, t.y);
              if (Math.abs(a) < 1e-10) (r.x = 0), (r.y = t.y);
              else {
                var o, s;
                switch (
                  ((s = 1 - a * a * this.pfact),
                  (s = (this.p - Math.sqrt(s)) / (this.pn1 / a + a / this.pn1)),
                  (o = Math.sqrt(1 - s * s)),
                  this.mode)
                ) {
                  case He:
                    (r.y = Math.asin(
                      o * this.sinph0 + (t.y * s * this.cosph0) / a,
                    )),
                      (t.y = (o - this.sinph0 * Math.sin(r.y)) * a),
                      (t.x *= s * this.cosph0);
                    break;
                  case Ge:
                    (r.y = Math.asin((t.y * s) / a)), (t.y = o * a), (t.x *= s);
                    break;
                  case Ue:
                    (r.y = Math.asin(o)), (t.y = -t.y);
                    break;
                  case je:
                    r.y = -Math.asin(o);
                }
                r.x = Math.atan2(t.x, t.y);
              }
              return (t.x = r.x + this.long0), (t.y = r.y), t;
            },
            names: ['Tilted_Perspective', 'tpers'],
          };
        (gt.defaultDatum = 'WGS84'),
          (gt.Proj = et),
          (gt.WGS84 = new gt.Proj('WGS84')),
          (gt.Point = Rt),
          (gt.toPoint = ut),
          (gt.defs = E),
          (gt.nadgrid = function (t, e) {
            var n = new DataView(e),
              i = (function (t) {
                var e = t.getInt32(8, !1);
                if (11 === e) return !1;
                11 !== (e = t.getInt32(8, !0)) &&
                  console.warn(
                    'Failed to detect nadgrid endian-ness, defaulting to little-endian',
                  );
                return !0;
              })(n),
              r = (function (t, e) {
                return {
                  nFields: t.getInt32(8, e),
                  nSubgridFields: t.getInt32(24, e),
                  nSubgrids: t.getInt32(40, e),
                  shiftType: J(t, 56, 64).trim(),
                  fromSemiMajorAxis: t.getFloat64(120, e),
                  fromSemiMinorAxis: t.getFloat64(136, e),
                  toSemiMajorAxis: t.getFloat64(152, e),
                  toSemiMinorAxis: t.getFloat64(168, e),
                };
              })(n, i);
            r.nSubgrids > 1 &&
              console.log(
                'Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored',
              );
            var a = {
              header: r,
              subgrids: (function (t, e, n) {
                for (var i = [], r = 0; r < e.nSubgrids; r++) {
                  var a = K(t, 176, n),
                    o = Q(t, 176, a, n),
                    s = Math.round(
                      1 +
                        (a.upperLongitude - a.lowerLongitude) /
                          a.longitudeInterval,
                    ),
                    l = Math.round(
                      1 +
                        (a.upperLatitude - a.lowerLatitude) /
                          a.latitudeInterval,
                    );
                  i.push({
                    ll: [$(a.lowerLongitude), $(a.lowerLatitude)],
                    del: [$(a.longitudeInterval), $(a.latitudeInterval)],
                    lim: [s, l],
                    count: a.gridNodeCount,
                    cvs: Z(o),
                  });
                }
                return i;
              })(n, r, i),
            };
            return (X[t] = a), a;
          }),
          (gt.transform = dt),
          (gt.mgrs = xt),
          (gt.version = '__VERSION__'),
          (We = gt).Proj.projections.add(Dt),
          We.Proj.projections.add(Ut),
          We.Proj.projections.add(jt),
          We.Proj.projections.add(Vt),
          We.Proj.projections.add(Wt),
          We.Proj.projections.add(Xt),
          We.Proj.projections.add(Yt),
          We.Proj.projections.add($t),
          We.Proj.projections.add(Jt),
          We.Proj.projections.add(ae),
          We.Proj.projections.add(se),
          We.Proj.projections.add(ce),
          We.Proj.projections.add(ue),
          We.Proj.projections.add(he),
          We.Proj.projections.add(de),
          We.Proj.projections.add(pe),
          We.Proj.projections.add(fe),
          We.Proj.projections.add(me),
          We.Proj.projections.add(ge),
          We.Proj.projections.add(ye),
          We.Proj.projections.add(ve),
          We.Proj.projections.add(xe),
          We.Proj.projections.add(be),
          We.Proj.projections.add(_e),
          We.Proj.projections.add(Ie),
          We.Proj.projections.add(Fe),
          We.Proj.projections.add(Be),
          We.Proj.projections.add(Xe);
        e.default = gt;
      },
      31: function (t, e, n) {
        'use strict';
        var i = !1,
          r = 8,
          a = 4096;
        function o(t, e, n) {
          var i = t.getContext(),
            r = i.createShader(e);
          return i.shaderSource(r, n), i.compileShader(r), r;
        }
        function s() {
          return (
            navigator &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().includes('firefox')
          );
        }
        e.a = {
          isLogDepthBufferSupported: function () {
            return i;
          },
          isFirefox: s,
          isInternetExplorer: function () {
            return !!document.documentMode;
          },
          getMaxTextureUnitsCount: function () {
            return r;
          },
          getMaxTextureSize: function () {
            return a;
          },
          updateCapabilities: function (t) {
            var e = t.getContext();
            (r = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)),
              (a = e.getParameter(e.MAX_TEXTURE_SIZE));
            var n = e.createProgram(),
              l = o(
                t,
                e.VERTEX_SHADER,
                'void main() {\n    gl_Position = vec4( 0.0, 0.0, 0.0, 1.0 );\n}',
              ),
              c = '#define SAMPLE '.concat(r, '\n');
            c +=
              'uniform sampler2D uni[SAMPLE];\nvoid main() {\n    gl_FragColor += texture2D(uni[SAMPLE-1], vec2(0));\n}';
            var u = o(t, e.FRAGMENT_SHADER, c);
            if (
              (e.attachShader(n, l),
              e.attachShader(n, u),
              e.linkProgram(n),
              !1 === e.getProgramParameter(n, e.LINK_STATUS))
            ) {
              if (!(r > 16))
                throw new Error(
                  'The GPU capabilities could not be determined accurately.\n                    Impossible to link a shader with the Maximum texture units '.concat(
                    r,
                  ),
                );
              var h = e.getProgramInfoLog(n);
              console.warn(
                ''
                  .concat(
                    h,
                    ': using a maximum of 16 texture units instead of the reported value (',
                  )
                  .concat(r, ')'),
              ),
                s() &&
                  console.warn(
                    'It can come from a Mesa/Firefox bug;\n                        the shader compiles to an error when using more than 16 sampler uniforms,\n                        see https://bugzilla.mozilla.org/show_bug.cgi?id=777028',
                  ),
                (r = 16);
            }
            e.deleteProgram(n),
              e.deleteShader(l),
              e.deleteShader(u),
              (i = t.capabilities.logarithmicDepthBuffer);
          },
        };
      },
      33: function (t, e, n) {
        'use strict';
        n.d(e, 'b', function () {
          return u;
        });
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(0),
          l = n(30),
          c = n(8),
          u = new s.Vector3(
            l.default.WGS84.a,
            l.default.WGS84.a,
            l.default.WGS84.b,
          ),
          h = new s.Vector3(),
          d = (function () {
            function t() {
              var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : u;
              r()(this, t),
                (this.size = new s.Vector3()),
                (this._radiiSquared = new s.Vector3()),
                (this._invRadiiSquared = new s.Vector3()),
                this.setSize(e);
            }
            return (
              o()(t, [
                {
                  key: 'geodeticSurfaceNormal',
                  value: function (t) {
                    var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new s.Vector3();
                    return t
                      .toVector3(e)
                      .multiply(this._invRadiiSquared)
                      .normalize();
                  },
                },
                {
                  key: 'geodeticSurfaceNormalCartographic',
                  value: function (t) {
                    var e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : new s.Vector3(),
                      n = s.MathUtils.degToRad(t.longitude),
                      i = s.MathUtils.degToRad(t.latitude),
                      r = Math.cos(i);
                    return e.set(r * Math.cos(n), r * Math.sin(n), Math.sin(i));
                  },
                },
                {
                  key: 'setSize',
                  value: function (t) {
                    this.size.set(t.x, t.y, t.z),
                      this._radiiSquared.multiplyVectors(t, t),
                      (this._invRadiiSquared.x =
                        0 == t.x ? 0 : 1 / this._radiiSquared.x),
                      (this._invRadiiSquared.y =
                        0 == t.y ? 0 : 1 / this._radiiSquared.y),
                      (this._invRadiiSquared.z =
                        0 == t.z ? 0 : 1 / this._radiiSquared.z);
                  },
                },
                {
                  key: 'cartographicToCartesian',
                  value: function (t) {
                    var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new s.Vector3();
                    h.copy(t.geodesicNormal),
                      e.multiplyVectors(this._radiiSquared, h);
                    var n = Math.sqrt(h.dot(e));
                    return (
                      e.divideScalar(n), h.multiplyScalar(t.altitude), e.add(h)
                    );
                  },
                },
                {
                  key: 'cartesianToCartographic',
                  value: function (t) {
                    var e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : new c.a('EPSG:4326', 0, 0, 0),
                      n = Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z),
                      i = this.size.x,
                      r = this.size.z,
                      a = Math.abs((i * i - r * r) / (i * i)),
                      o = 1 - Math.sqrt(1 - a),
                      l = Math.sqrt(t.x * t.x + t.y * t.y),
                      u = Math.atan2(t.y, t.x),
                      h = Math.atan((t.z / l) * (1 - o + (a * i) / n)),
                      d = Math.sin(h),
                      p = Math.cos(h),
                      f = Math.atan(
                        (t.z * (1 - o) + a * i * d * d * d) /
                          ((1 - o) * (l - a * i * p * p * p)),
                      ),
                      m =
                        l * Math.cos(f) +
                        t.z * Math.sin(f) -
                        i * Math.sqrt(1 - a * Math.sin(f) * Math.sin(f));
                    return e.setFromValues(
                      s.MathUtils.radToDeg(u),
                      s.MathUtils.radToDeg(f),
                      m,
                    );
                  },
                },
                {
                  key: 'cartographicToCartesianArray',
                  value: function (t) {
                    for (var e = [], n = 0; n < t.length; n++)
                      e.push(this.cartographicToCartesian(t[n]));
                    return e;
                  },
                },
                {
                  key: 'intersection',
                  value: function (t) {
                    var e = t.origin,
                      n = t.direction,
                      i =
                        n.x * n.x * this._invRadiiSquared.x +
                        n.y * n.y * this._invRadiiSquared.y +
                        n.z * n.z * this._invRadiiSquared.z,
                      r =
                        2 * e.x * n.x * this._invRadiiSquared.x +
                        2 * e.y * n.y * this._invRadiiSquared.y +
                        2 * e.z * n.z * this._invRadiiSquared.z,
                      a =
                        e.x * e.x * this._invRadiiSquared.x +
                        e.y * e.y * this._invRadiiSquared.y +
                        e.z * e.z * this._invRadiiSquared.z -
                        1,
                      o = r * r - 4 * i * a;
                    if (o < 0 || 0 === i || 0 === r || 0 === a) return !1;
                    var l = (-r + (o = Math.sqrt(o))) / (2 * i),
                      c = (-r - o) / (2 * i);
                    if (l <= 1e-4 && c <= 1e-4) return !1;
                    var u = 0;
                    if ((u = l <= 1e-4 ? c : c <= 1e-4 || l < c ? l : c) < 1e-4)
                      return !1;
                    var h = new s.Vector3();
                    return h.addVectors(t.origin, n.clone().setLength(u)), h;
                  },
                },
                {
                  key: 'computeDistance',
                  value: function (t, e) {
                    var n = s.MathUtils.degToRad(t.longitude),
                      i = s.MathUtils.degToRad(t.latitude),
                      r = s.MathUtils.degToRad(e.longitude),
                      a = s.MathUtils.degToRad(e.latitude),
                      o = Math.acos(
                        Math.sin(i) * Math.sin(a) +
                          Math.cos(i) * Math.cos(a) * Math.cos(r - n),
                      ),
                      l = this.size.x,
                      c = this.size.z,
                      u = Math.sqrt((l * l - c * c) / (l * l)),
                      h = (i + a) / 2,
                      d =
                        (l * (1 - u * u)) /
                        Math.sqrt(1 - u * u * Math.sin(h) * Math.sin(h)),
                      p = l / Math.sqrt(1 - u * u * Math.sin(h) * Math.sin(h));
                    return o * Math.sqrt(d * p);
                  },
                },
              ]),
              t
            );
          })();
        e.a = d;
      },
      36: function (t, e, n) {
        'use strict';
        (function (t) {
          var i = n(148),
            r = 'function' == typeof t.TextDecoder ? t.TextDecoder : i.a;
          e.a = new r('utf-8');
        }.call(this, n(69)));
      },
      37: function (t, e, n) {
        'use strict';
        n.d(e, 'b', function () {
          return g;
        });
        var i = n(144),
          r = n.n(i),
          a = n(0),
          o = n(8),
          s = {
            v: new a.Vector3(),
            coord1: new o.a('EPSG:4978'),
            coord2: new o.a('EPSG:4978'),
            offset: new a.Vector2(),
          };
        function l(t, e, n, i, r, a) {
          var l =
              arguments.length > 6 && void 0 !== arguments[6]
                ? arguments[6]
                : {},
            c = arguments.length > 7 ? arguments[7] : void 0,
            u = arguments.length > 8 ? arguments[8] : void 0,
            d = c || new o.a(i);
          l.worldFromLocal
            ? d.setFromVector3(s.v.copy(r).applyMatrix4(l.worldFromLocal))
            : d.setFromVector3(r);
          var p = h.getTerrainObjectAt(t, d, e, n, u);
          if (p)
            return (
              (p.coord.z += a),
              p.coord.as(i, s.coord2).toVector3(r),
              l.localFromWorld && r.applyMatrix4(l.localFromWorld),
              { id: p.texture.id, version: p.texture.version, tile: p.tile }
            );
        }
        var c,
          u = function (t, e, n) {
            var i,
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : {},
              s = arguments.length > 4 ? arguments[4] : void 0;
            if (
              (console.warn(
                'placeObjectOnGround has been deprecated because it needs review and test',
              ),
              (i = s ? s.concat(t.level0Nodes) : t.level0Nodes),
              r.modifyGeometry)
            ) {
              var c = {
                  worldFromLocal: n.matrixWorld,
                  localFromWorld: new a.Matrix4().copy(n.matrixWorld).invert(),
                },
                u = n.geometry;
              if (u.vertices) {
                r.cache && (r.cache.length = u.vertices.length);
                for (
                  var d = !0, p = new o.a(e), f = 0;
                  f < u.vertices.length;
                  f++
                ) {
                  var m = r.cache ? r.cache[f] : void 0,
                    g = l(
                      t,
                      r.method || h.FAST_READ_Z,
                      i,
                      e,
                      u.vertices[f],
                      r.offset || 0,
                      c,
                      p,
                      m,
                    );
                  r.cache && (r.cache[f] = g), g || (d = !1);
                }
                return (u.verticesNeedUpdate = !0), d;
              }
              if (u.isBufferGeometry) {
                r.cache && (r.cache.length = u.attributes.position.count);
                for (
                  var y = !0, v = new a.Vector3(), x = new o.a(e), b = 0;
                  b < u.attributes.position.count;
                  b++
                ) {
                  var _ = r.cache ? r.cache[b] : void 0;
                  v.fromBufferAttribute(u.attributes.position, b);
                  var w = v.z,
                    M = l(
                      t,
                      r.method || h.FAST_READ_Z,
                      i,
                      e,
                      v,
                      r.offset || 0,
                      c,
                      x,
                      _,
                    );
                  r.cache && (r.cache[b] = M),
                    M || (y = !1),
                    w != v.z && (u.attributes.position.needsUpdate = !0),
                    u.attributes.position.setXYZ(b, v.x, v.y, v.z);
                }
                return y;
              }
            } else {
              r.cache && (r.cache.length = 1);
              var q = {
                  worldFromLocal: n.parent ? n.parent.matrixWorld : void 0,
                  localFromWorld: n.parent
                    ? new a.Matrix4().copy(n.parent.matrixWorld).invert()
                    : void 0,
                },
                S = l(
                  t,
                  r.method || h.FAST_READ_Z,
                  i,
                  e,
                  n.position,
                  r.offset || 0,
                  q,
                  void 0,
                  r.cache ? r.cache[0] : void 0,
                );
              if (S)
                return (
                  r.cache && (r.cache[0] = S),
                  n.updateMatrix(),
                  n.updateMatrixWorld(),
                  !0
                );
            }
          },
          h = (e.a = {
            getElevationValueAt: function (t, e) {
              var n =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : 0,
                i = arguments.length > 3 ? arguments[3] : void 0,
                r = _(t, n, e, i || t.level0Nodes);
              if (r) return r.coord.z;
            },
            getTerrainObjectAt: function (t, e) {
              var n =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : 0,
                i = arguments.length > 3 ? arguments[3] : void 0,
                r = arguments.length > 4 ? arguments[4] : void 0;
              return _(t, n, e, i || t.level0Nodes, r);
            },
            FAST_READ_Z: 0,
            PRECISE_READ_Z: 1,
            placeObjectOnGround: u,
          });
        function d(t, e) {
          if (e.extent) {
            if (!e.extent.isPointInside(t)) return;
            for (var n = 0; n < e.children.length; n++) {
              var i = d(t, e.children[n]);
              if (i) return i;
            }
            var r = e.material.getElevationLayer();
            return r && r.level >= 0 ? e : void 0;
          }
        }
        function p(t, e) {
          for (
            var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2;
            r < n;
            r++
          )
            i[r - 2] = arguments[r];
          for (var o = 0; o < i.length; o += 2)
            (i[o] = a.MathUtils.clamp(i[o], 0, e.image.width - 1)),
              (i[o + 1] = a.MathUtils.clamp(i[o + 1], 0, e.image.height - 1));
          if (e.image.data) {
            if (2 === i.length) {
              var s = e.image.data[i[1] * e.image.width + i[0]];
              return s != t.noDataValue ? s : void 0;
            }
            for (var l = [], u = 0; u < i.length; u += 2) {
              var h = e.image.data[i[u + 1] * e.image.width + i[u]];
              l.push(h != t.noDataValue ? h : void 0);
            }
            return l;
          }
          c ||
            (((c = document.createElement('canvas')).width = 2),
            (c.height = 2));
          for (
            var d = 1 / 0, p = 1 / 0, f = -1 / 0, m = -1 / 0, g = 0;
            g < i.length;
            g += 2
          )
            (d = Math.min(i[g], d)),
              (p = Math.min(i[g + 1], p)),
              (f = Math.max(i[g], f)),
              (m = Math.max(i[g + 1], m));
          var y = f - d + 1,
            v = m - p + 1;
          (c.width = Math.max(c.width, y)), (c.height = Math.max(c.height, v));
          var x = c.getContext('2d');
          x.drawImage(e.image, d, p, y, v, 0, 0, y, v);
          for (
            var b = x.getImageData(0, 0, y, v), _ = [], w = 0;
            w < i.length;
            w += 2
          ) {
            var M = i[w] - d,
              q = i[w + 1] - p,
              S = a.MathUtils.lerp(
                t.colorTextureElevationMinZ,
                t.colorTextureElevationMaxZ,
                b.data[4 * q * y + 4 * M] / 255,
              );
            _.push(S != t.noDataValue ? S : void 0);
          }
          return 2 === i.length ? _[0] : _;
        }
        function f(t, e, n) {
          var i = t.image.width,
            r = t.image.height,
            a = Math.max(0, e * i - 0.5),
            o = Math.max(0, n * r - 0.5),
            s = Math.floor(a),
            l = Math.ceil(a),
            c = Math.floor(o);
          return {
            u1: s,
            u2: l,
            v1: c,
            v2: Math.ceil(o),
            wu: a - s,
            wv: o - c,
          };
        }
        function m(t, e, n) {
          return null == t ? e : null == e ? t : a.MathUtils.lerp(t, e, n);
        }
        function g(t, e, n, i) {
          var a = f(e, n, i),
            o = p(t, e, a.u1, a.v1, a.u2, a.v1, a.u1, a.v2, a.u2, a.v2),
            s = r()(o, 4),
            l = s[0],
            c = s[1],
            u = s[2],
            h = s[3],
            d = m(l, c, a.wu),
            g = m(u, h, a.wu);
          return m(d, g, a.wv);
        }
        function y(t, e, n) {
          return (function (t, e, n, i) {
            var r = f(e, n, i);
            return p(t, e, r.wu <= 0 ? r.u1 : r.u2, r.wv <= 0 ? r.v1 : r.v2);
          })(
            t.attachedLayers.filter(function (t) {
              return t.isElevationLayer;
            })[0],
            e,
            n.x,
            n.y,
          );
        }
        var v = new a.Vector3();
        var x = {
            v: new a.Vector3(),
            coord1: new o.a('EPSG:4978'),
            coord2: new o.a('EPSG:4978'),
            offset: new a.Vector2(),
          },
          b = new a.Vector2();
        function _(t, e, n, i, r) {
          var o = n.as(t.extent.crs, x.coord1),
            s = null;
          r && r.tile && r.tile.material && (s = d(o, r.tile));
          for (var l = 0; !s && l < i.length; l++) s = d(o, i[l]);
          if (s) {
            var c = s,
              u = c.material.getElevationLayer(),
              h = u.textures[0];
            if (r && r.id === h.id && r.version === h.version)
              return { coord: o, texture: h, tile: c };
            for (
              var p = Math.round(Math.log2(1 / u.offsetScales[0].z)), f = 0;
              f < p;
              f++
            )
              s = s.parent;
            return (
              (function (t, e) {
                var n =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : new a.Vector2();
                if (t.crs != e.crs)
                  throw new Error(
                    'Unsupported mix: '.concat(t.crs, ' and ').concat(e.crs),
                  );
                e.dimensions(b);
                var i = (t.x - e.west) / b.x,
                  r = (e.north - t.y) / b.y;
                n.set(i, r);
              })(o, s.extent, x.offset),
              (o.z =
                1 == e
                  ? (function (t, e, n, i, r) {
                      var o = i.x / r.x / 16,
                        s = Math.floor(n.x / o) * o,
                        l = Math.floor(n.y / o) * o;
                      1 == s && (s -= o), 1 == l && (l -= o);
                      var c = s,
                        u = s + o,
                        h = l,
                        d = l + o,
                        p = (n.x - s) / o,
                        f = (n.y - l) / o,
                        m = new a.Triangle(
                          new a.Vector3(c, d),
                          new a.Vector3(u, h),
                          1 == f || p / (1 - f) >= 1
                            ? new a.Vector3(u, d)
                            : new a.Vector3(c, h),
                        );
                      m.getBarycoord(new a.Vector3(n.x, n.y), v);
                      var y = t.attachedLayers.filter(function (t) {
                          return t.isElevationLayer;
                        })[0],
                        x = g(y, e, m.a.x, m.a.y),
                        b = g(y, e, m.b.x, m.b.y),
                        _ = g(y, e, m.c.x, m.c.y);
                      return x * v.x + b * v.y + _ * v.z;
                    })(
                      t,
                      h,
                      x.offset,
                      c.extent.dimensions(),
                      s.extent.dimensions(),
                    )
                  : y(t, h, x.offset)),
              null != o.z ? { coord: o, texture: h, tile: c } : void 0
            );
          }
        }
      },
      39: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return l;
        });
        var i,
          r = n(3),
          a = n.n(r),
          o = n(4),
          s = n.n(o),
          l = { INFINITE: 1 / 0, TEXTURE: 9e5, GEOMETRY: 9e5 },
          c = (function () {
            function t() {
              var e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : l.INFINITE;
              a()(this, t),
                (this.lifeTime = e),
                (this.lastTimeFlush = Date.now()),
                (this.data = new Map());
            }
            return (
              s()(t, [
                {
                  key: 'getByArray',
                  value: function (t) {
                    return this.get(t[0], t[1], t[2]);
                  },
                },
                {
                  key: 'setByArray',
                  value: function (t, e) {
                    return this.set(t, e[0], e[1], e[2]);
                  },
                },
                {
                  key: 'get',
                  value: function (t, e, n) {
                    var r = this.data.get(t);
                    if (null != r) {
                      if (null != r.lastTimeUsed) i = r;
                      else {
                        var a = r.get(e);
                        if (null == a) return;
                        if (null != a.lastTimeUsed) i = a;
                        else {
                          var o = a.get(n);
                          if (null == o) return;
                          i = o;
                        }
                      }
                      return i.value
                        ? ((i.lastTimeUsed = Date.now()), i.value)
                        : void 0;
                    }
                  },
                },
                {
                  key: 'set',
                  value: function (t, e, n, r) {
                    if (
                      ((i = { value: t, lastTimeUsed: Date.now() }), null == n)
                    )
                      return this.data.set(e, i), t;
                    this.data.get(e) || this.data.set(e, new Map());
                    var a = this.data.get(e);
                    return null == r
                      ? (a.set(n, i), t)
                      : (a.get(n) || a.set(n, new Map()),
                        a.get(n).set(r, i),
                        t);
                  },
                },
                {
                  key: 'delete',
                  value: function (t, e, n) {
                    var i = this.data.get(t);
                    if (void 0 !== i)
                      if (null != i.lastTimeUsed)
                        this.data.get(t), this.data.delete(t);
                      else {
                        var r = i.get(e);
                        if (void 0 === r) return;
                        if (null != r.lastTimeUsed)
                          i.get(e),
                            i.delete(e),
                            0 == i.size && this.data.delete(t);
                        else {
                          if (void 0 === r.get(n)) return;
                          r.get(n),
                            r.delete(n),
                            0 == r.size &&
                              (i.delete(e), 0 == i.size && this.data.delete(t));
                        }
                      }
                  },
                },
                {
                  key: 'clear',
                  value: function () {
                    this.data.clear();
                  },
                },
                {
                  key: 'flush',
                  value: function () {
                    var t = this,
                      e =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : Date.now();
                    this.lifeTime == l.INFINITE ||
                      this.lifeTime > e - this.lastTimeFlush ||
                      !this.data.size ||
                      ((this.lastTimeFlush = 1 / 0),
                      this.data.forEach(function (n, i) {
                        t.lifeTime < e - n.lastTimeUsed
                          ? (t.data.get(i), t.data.delete(i))
                          : (n.forEach(function (i, r) {
                              t.lifeTime < e - i.lastTimeUsed
                                ? (n.get(r), n.delete(r))
                                : (i.forEach(function (n, r) {
                                    t.lifeTime < e - n.lastTimeUsed
                                      ? (i.get(r), i.delete(r))
                                      : (t.lastTimeFlush = Math.min(
                                          t.lastTimeFlush,
                                          n.lastTimeUsed,
                                        ));
                                  }),
                                  i.size || (n.get(r), n.delete(r)));
                            }),
                            n.size || (t.data.get(i), t.data.delete(i)));
                      }),
                      0 == this.data.size && (this.lastTimeFlush = Date.now()));
                  },
                },
              ]),
              t
            );
          })();
        e.b = c;
      },
      4: function (t, e) {
        function n(t, e) {
          for (var n = 0; n < e.length; n++) {
            var i = e[n];
            (i.enumerable = i.enumerable || !1),
              (i.configurable = !0),
              'value' in i && (i.writable = !0),
              Object.defineProperty(t, i.key, i);
          }
        }
        (t.exports = function (t, e, i) {
          return e && n(t.prototype, e), i && n(t, i), t;
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      40: function (t, e, n) {
        'use strict';
        var i = n(4),
          r = n.n(i),
          a = n(6),
          o = n.n(a),
          s = n(7),
          l = n.n(s),
          c = n(2),
          u = n.n(c),
          h = n(3),
          d = n.n(h),
          p = n(11),
          f = n(45),
          m = n(107),
          g = n(108),
          y = n(0),
          v = n(145),
          x = n.n(v),
          b = n(146),
          _ = n(16),
          w = n(41);
        function M(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return q(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return q(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function q(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        var S = p.b.get('EPSG:3857').dimensions(),
          T = new y.Vector3(S.x, S.y, 1),
          E = new y.Vector2(),
          A = new y.Vector2();
        function L(t, e) {
          e.out = e.out || {};
          var n = new b.VectorTile(new x.a(t)),
            i = Object.keys(n.layers);
          if (!(i.length < 1)) {
            var r = t.extent.col,
              a = t.extent.zoom,
              o = e.in.isInverted ? t.extent.row : (1 << a) - t.extent.row - 1,
              s = new _.b(e.out),
              l = n.layers[i[0]],
              c = l.extent * Math.pow(2, a),
              u = -0.5 * c;
            return (
              s.scale.set(T.x / c, -T.y / c, 1),
              s.position
                .set(l.extent * r + u, l.extent * o + u, 0)
                .multiply(s.scale),
              s.updateMatrixWorld(),
              i.forEach(function (t) {
                if (e.in.layers[t])
                  for (
                    var i = n.layers[t],
                      r = function (n) {
                        var r,
                          o = i.feature(n),
                          l = e.in.layers[t].filter(function (t) {
                            return (
                              t.filterExpression.filter({ zoom: a }, o) &&
                              a >= t.zoom.min &&
                              a < t.zoom.max
                            );
                          }),
                          c = void 0,
                          u = M(l);
                        try {
                          var h = function () {
                            var t = r.value;
                            c
                              ? s.features.find(function (e) {
                                  return e.id === t.id;
                                }) ||
                                (((c = s.newFeatureByReference(c)).id = t.id),
                                (c.order = t.order),
                                (c.style = e.in.styles[c.id]))
                              : (((c = s.requestFeatureById(
                                  t.id,
                                  o.type - 1,
                                )).id = t.id),
                                (c.order = t.order),
                                (c.style = e.in.styles[c.id]),
                                (function (t, e) {
                                  var n =
                                      arguments.length > 2 &&
                                      void 0 !== arguments[2] &&
                                      arguments[2],
                                    i = e.bindNewGeometry();
                                  (n = n && e.type === _.a.POLYGON),
                                    (i.properties = t.properties);
                                  var r = t._pbf;
                                  r.pos = t._geometry;
                                  for (
                                    var a = r.readVarint() + r.pos,
                                      o = 1,
                                      s = 0,
                                      l = 0,
                                      c = 0,
                                      u = 0,
                                      h = 0;
                                    r.pos < a;

                                  ) {
                                    if (s <= 0) {
                                      var d = r.readVarint();
                                      (o = 7 & d), (s = d >> 3);
                                    }
                                    if ((s--, 1 === o || 2 === o))
                                      (l += r.readSVarint()),
                                        (c += r.readSVarint()),
                                        1 === o &&
                                          (u &&
                                            (n &&
                                              h > 0 &&
                                              i.indices.length > 0 &&
                                              (e.updateExtent(i),
                                              ((i =
                                                e.bindNewGeometry()).properties =
                                                t.properties)),
                                            i.closeSubGeometry(u, e),
                                            (i.getLastSubGeometry().ccw =
                                              h < 0)),
                                          (u = 0),
                                          (h = 0)),
                                        u++,
                                        i.pushCoordinatesValues(e, l, c),
                                        1 == u
                                          ? (A.set(l, c), E.set(l, c))
                                          : n &&
                                            u > 1 &&
                                            ((h += (E.x - l) * (E.y + c)),
                                            E.set(l, c));
                                    else {
                                      if (7 !== o)
                                        throw new Error(
                                          'unknown command '.concat(o),
                                        );
                                      u &&
                                        (u++,
                                        i.pushCoordinatesValues(e, A.x, A.y),
                                        n && (h += (E.x - A.x) * (E.y + A.y)));
                                    }
                                  }
                                  u &&
                                    (n &&
                                      h > 0 &&
                                      i.indices.length > 0 &&
                                      (e.updateExtent(i),
                                      ((i = e.bindNewGeometry()).properties =
                                        t.properties)),
                                    i.closeSubGeometry(u, e),
                                    (i.getLastSubGeometry().ccw = h < 0)),
                                    e.updateExtent(i);
                                })(o, c));
                          };
                          for (u.s(); !(r = u.n()).done; ) h();
                        } catch (t) {
                          u.e(t);
                        } finally {
                          u.f();
                        }
                      },
                      o = i.length - 1;
                    o >= 0;
                    o--
                  )
                    r(o);
              }),
              s.removeEmptyFeature(),
              s.features.sort(function (t, e) {
                return t.order - e.order;
              }),
              s.updateExtent(),
              (s.extent = t.extent),
              (s.isInverted = e.in.isInverted),
              Promise.resolve(s)
            );
          }
        }
        var R = {
            parse: function (t, e) {
              return (e = Object(w.c)(e)), Promise.resolve(L(t, e));
            },
          },
          C = n(20),
          P = n(39);
        function k(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = u()(t);
            if (e) {
              var r = u()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return l()(this, n);
          };
        }
        var I = new Map([
            ['image/x-bil;bits=32', C.a.textureFloat],
            ['geojson', C.a.json],
            ['application/json', C.a.json],
            ['application/kml', C.a.xml],
            ['application/gpx', C.a.xml],
            ['application/x-protobuf;type=mapbox-vector', C.a.arrayBuffer],
          ]),
          D = new Map([
            ['geojson', f.a.parse],
            ['application/json', f.a.parse],
            ['application/kml', m.a.parse],
            ['application/gpx', g.a.parse],
            ['application/x-protobuf;type=mapbox-vector', R.parse],
          ]),
          O = {
            getByArray: function () {},
            setByArray: function (t) {
              return t;
            },
            clear: function () {},
          };
        var N = 0,
          z = (function (t) {
            o()(n, t);
            var e = k(n);
            function n(t) {
              var i;
              if ((d()(this, n), ((i = e.call(this, t)).isSource = !0), !t.url))
                throw new Error('New Source: url is required');
              return (
                (i.uid = N++),
                (i.url = t.url),
                (i.format = t.format),
                (i.fetcher = t.fetcher || I.get(t.format) || C.a.texture),
                (i.parser =
                  t.parser ||
                  D.get(t.format) ||
                  function (t) {
                    return t;
                  }),
                (i.isVectorSource = null != (t.parser || D.get(t.format))),
                (i.networkOptions = t.networkOptions || {
                  crossOrigin: 'anonymous',
                }),
                (i.attribution = t.attribution),
                (i.whenReady = Promise.resolve()),
                (i._featuresCaches = {}),
                t.extent && !t.extent.isExtent
                  ? (i.extent = new p.a(i.crs, t.extent))
                  : (i.extent = t.extent),
                i
              );
            }
            return (
              r()(n, [
                {
                  key: 'handlingError',
                  value: function (t) {
                    throw new Error(t);
                  },
                },
                {
                  key: 'urlFromExtent',
                  value: function () {
                    throw new Error(
                      'In extended Source, you have to implement the method urlFromExtent!',
                    );
                  },
                },
                {
                  key: 'requestToKey',
                  value: function (t) {
                    return [t.zoom, t.row, t.col];
                  },
                },
                {
                  key: 'loadData',
                  value: function (t, e) {
                    var n = this,
                      i = this._featuresCaches[e.crs],
                      r = this.requestToKey(t),
                      a = i.getByArray(r);
                    return (
                      a ||
                        ((a = i.setByArray(
                          (function (t, e) {
                            var n = t.urlFromExtent(e);
                            return t.fetcher(n, t.networkOptions).then(
                              function (t) {
                                return (t.extent = e), t;
                              },
                              function (e) {
                                return t.handlingError(e);
                              },
                            );
                          })(this, t).then(
                            function (t) {
                              return n.parser(t, { out: e, in: n });
                            },
                            function (t) {
                              return n.handlingError(t);
                            },
                          ),
                          r,
                        )),
                        this.onParsedFile &&
                          a.then(function (t) {
                            return (
                              n.onParsedFile(t),
                              console.warn(
                                'Source.onParsedFile was deprecated',
                              ),
                              t
                            );
                          })),
                      a
                    );
                  },
                },
                {
                  key: 'onLayerAdded',
                  value: function (t) {
                    this._featuresCaches[t.out.crs] ||
                      (this._featuresCaches[t.out.crs] = this.isVectorSource
                        ? new P.b()
                        : O);
                  },
                },
                {
                  key: 'onLayerRemoved',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : {},
                      e = this._featuresCaches[t.unusedCrs];
                    e && (e.clear(), delete this._featuresCaches[t.unusedCrs]);
                  },
                },
                {
                  key: 'extentInsideLimit',
                  value: function () {
                    throw new Error(
                      'In extented Source, you have to implement the method extentInsideLimit!',
                    );
                  },
                },
              ]),
              n
            );
          })(function t(e) {
            d()(this, t),
              e.projection &&
                (console.warn(
                  'Source projection parameter is deprecated, use crs instead.',
                ),
                (e.crs = e.crs || e.projection)),
              (this.crs = e.crs);
          });
        e.a = z;
      },
      41: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return r;
        }),
          n.d(e, 'c', function () {
            return a;
          }),
          n.d(e, 'b', function () {
            return o;
          });
        var i = n(29),
          r = function (t) {
            return (
              t.fx &&
                (console.warn(
                  'ColorLayer fx is deprecated, use ColorLayer.effect_type and ColorLayer.effect_parameter instead.',
                ),
                t.fx > 2
                  ? ((t.effect_parameter = t.fx),
                    (t.effect_type = i.b.removeLightColor))
                  : t.fx > 0 &&
                    ((t.effect_parameter = t.fx),
                    (t.effect_type = i.b.removeWhiteColor))),
              t
            );
          },
          a = function (t) {
            if (t.crsOut || t.crsIn) {
              console.warn(
                'Parsing options with crsIn and crsOut are deprecated, use { in, out } structure.',
              );
              var e = { in: {}, out: {} };
              return (
                (e.in.crs = t.crsIn),
                (e.in.isInverted = t.isInverted),
                (e.in.styles = t.styles),
                (e.in.layers = t.layers),
                (e.in.filter = t.filter),
                (e.out.crs = t.crsOut),
                (e.out.mergeFeatures = t.mergeFeatures),
                t.withAltitude && t.withNormal
                  ? (console.warn(
                      'Parsing options withAltitude and withNormal is deprecated, use out.structure: 2d or 3d.',
                    ),
                    (e.out.structure = '3d'))
                  : (e.out.structure = '2d'),
                (e.out.filteringExtent = t.filteringExtent),
                (e.out.style = t.style),
                void 0 !== t.crsOut.overrideAltitudeInToZero &&
                  console.error(
                    'Parsing options out.overrideAltitudeInToZero is removed, use Style.xxx.base_altitude instead',
                  ),
                (e.out.filter = t.filter),
                e
              );
            }
            return (
              t.out &&
                ((void 0 === t.out.withAltitude &&
                  void 0 === t.out.withNormal) ||
                  (console.warn(
                    'Parsing options out.withAltitude and out.withNormal is deprecated, use out.structure: 2d or 3d.',
                  ),
                  t.out.withAltitude && t.out.withNormal
                    ? (t.out.structure = '3d')
                    : (t.out.structure = '2d')),
                void 0 !== t.out.overrideAltitudeInToZero &&
                  console.error(
                    'Parsing options out.overrideAltitudeInToZero is removed, use Style.xxx.base_altitude instead',
                  )),
              t
            );
          },
          o = function (t) {
            t.color &&
              console.error(
                'Color convert option is removed, use Style.xxx.color',
              ),
              t.extrude &&
                console.error(
                  'extrude convert option is removed, use Style.fill.extrusion_height instead',
                ),
              t.altitude &&
                console.error(
                  'altitude convert option is removed, use Style.xxx.base_altitude instead',
                );
          };
      },
      45: function (t, e, n) {
        'use strict';
        var i = n(8),
          r = n(16),
          a = n(55),
          o = n(41);
        function s(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return l(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return l(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function l(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function c(t) {
          if (t.crs) {
            if ('epsg' == t.crs.type.toLowerCase())
              return 'EPSG:'.concat(t.crs.properties.code);
            if ('name' == t.crs.type.toLowerCase()) {
              var e = t.crs.properties.name.toLowerCase().indexOf('epsg:');
              if (e >= 0) {
                var n = t.crs.properties.name.indexOf(':', e + 5);
                if (n > 0)
                  return 'EPSG:'.concat(t.crs.properties.name.substr(n + 1));
              }
            }
            throw new Error("Unsupported CRS type '".concat(t.crs, "'"));
          }
          return 'EPSG:4326';
        }
        var u = new i.a('EPSG:4978', 0, 0, 0),
          h = function (t, e, n) {
            return (u.crs = n), u.setFromArray(e[0]), !t.isPointInside(u);
          },
          d = {
            populateGeometry: function (t, e, n, i) {
              n.startSubGeometry(e.length, i), (u.crs = t);
              var r,
                a = s(e);
              try {
                for (a.s(); !(r = a.n()).done; ) {
                  var o = r.value;
                  u.setFromValues(o[0], o[1], o[2]), n.pushCoordinates(u, i);
                }
              } catch (t) {
                a.e(t);
              } finally {
                a.f();
              }
              n.updateExtent();
            },
            point: function (t, e, n, i, r) {
              this.default(t, e, [n], i, r);
            },
            default: function (t, e, n, i, r) {
              if (!i.filterExtent || !h(i.filterExtent, n, e)) {
                var o = t.bindNewGeometry();
                (o.properties = r),
                  (o.properties.style = new a.a(
                    {},
                    t.style,
                  ).setFromGeojsonProperties(r, t.type)),
                  this.populateGeometry(e, n, o, t),
                  t.updateExtent(o);
              }
            },
            polygon: function (t, e, n, i, r) {
              if (!i.filterExtent || !h(i.filterExtent, n[0], e)) {
                var o = t.bindNewGeometry();
                (o.properties = r),
                  (o.properties.style = new a.a(
                    {},
                    t.style,
                  ).setFromGeojsonProperties(r, t.type));
                for (var s = 0; s < n.length; s++)
                  this.populateGeometry(e, n[s], o, t);
                t.updateExtent(o);
              }
            },
            multi: function (t, e, n, i, r, a) {
              var o,
                l = s(i);
              try {
                for (l.s(); !(o = l.n()).done; ) {
                  var c = o.value;
                  this[t](e, n, c, r, a);
                }
              } catch (t) {
                l.e(t);
              } finally {
                l.f();
              }
            },
          };
        var p = ['type', 'geometry', 'properties'];
        function f(t, e, n) {
          for (
            var i = e.geometry.type.toLowerCase(),
              a = (function (t) {
                switch (t) {
                  case 'point':
                  case 'multipoint':
                    return r.a.POINT;
                  case 'linestring':
                  case 'multilinestring':
                    return r.a.LINE;
                  case 'polygon':
                  case 'multipolygon':
                    return r.a.POLYGON;
                  case 'geometrycollection':
                  default:
                    throw new Error('Unhandled geometry type '.concat(t));
                }
              })(i),
              o = n.requestFeatureByType(a),
              s =
                'point' != i
                  ? e.geometry.coordinates
                  : [e.geometry.coordinates],
              l = e.properties || {},
              c = 0,
              u = Object.keys(e);
            c < u.length;
            c++
          ) {
            var h = u[c];
            p.includes(h.toLowerCase()) ||
              ((l.geojson = l.geojson || {}), (l.geojson[h] = e[h]));
          }
          return (
            (function (t, e, n, i, r, a) {
              if (0 != i.length)
                switch (t) {
                  case 'point':
                  case 'linestring':
                    return d.default(e, n, i, r, a);
                  case 'multipoint':
                    return d.multi('point', e, n, i, r, a);
                  case 'multilinestring':
                    return d.multi('default', e, n, i, r, a);
                  case 'polygon':
                    return d.polygon(e, n, i, r, a);
                  case 'multipolygon':
                    return d.multi('polygon', e, n, i, r, a);
                  case 'geometrycollection':
                  default:
                    throw new Error('Unhandled geojson type '.concat(e.type));
                }
            })(i, o, t, s, n, l),
            o
          );
        }
        function m(t, e, n) {
          var i,
            a = new r.b(n),
            o =
              n.filter ||
              function () {
                return !0;
              },
            l = s(e);
          try {
            for (l.s(); !(i = l.n()).done; ) {
              var c = i.value;
              o(c.properties, c.geometry) && f(t, c, a);
            }
          } catch (t) {
            l.e(t);
          } finally {
            l.f();
          }
          return a.removeEmptyFeature(), a.updateExtent(), a;
        }
        e.a = {
          parse: function (t) {
            var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
            (e = Object(o.c)(e)).in = e.in || {};
            var n = e.out,
              i = e.in;
            switch (
              ('string' == typeof t && (t = JSON.parse(t)),
              (i.crs = i.crs || c(t)),
              n.filteringExtent &&
                ('boolean' == typeof n.filteringExtent
                  ? (n.filterExtent = t.extent.as(i.crs))
                  : n.filteringExtent.isExtent &&
                    (n.filterExtent = n.filteringExtent)),
              t.type.toLowerCase())
            ) {
              case 'featurecollection':
                return Promise.resolve(m(i.crs, t.features, n));
              case 'feature':
                return Promise.resolve(m(i.crs, [t], n));
              default:
                throw new Error("Unsupported GeoJSON type: '".concat(t.type));
            }
          },
        };
      },
      46: function (t, e, n) {
        'use strict';
        var i,
          r = {
            Linear: {
              None: function (t) {
                return t;
              },
            },
            Quadratic: {
              In: function (t) {
                return t * t;
              },
              Out: function (t) {
                return t * (2 - t);
              },
              InOut: function (t) {
                return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
              },
            },
            Cubic: {
              In: function (t) {
                return t * t * t;
              },
              Out: function (t) {
                return --t * t * t + 1;
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? 0.5 * t * t * t
                  : 0.5 * ((t -= 2) * t * t + 2);
              },
            },
            Quartic: {
              In: function (t) {
                return t * t * t * t;
              },
              Out: function (t) {
                return 1 - --t * t * t * t;
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? 0.5 * t * t * t * t
                  : -0.5 * ((t -= 2) * t * t * t - 2);
              },
            },
            Quintic: {
              In: function (t) {
                return t * t * t * t * t;
              },
              Out: function (t) {
                return --t * t * t * t * t + 1;
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? 0.5 * t * t * t * t * t
                  : 0.5 * ((t -= 2) * t * t * t * t + 2);
              },
            },
            Sinusoidal: {
              In: function (t) {
                return 1 - Math.cos((t * Math.PI) / 2);
              },
              Out: function (t) {
                return Math.sin((t * Math.PI) / 2);
              },
              InOut: function (t) {
                return 0.5 * (1 - Math.cos(Math.PI * t));
              },
            },
            Exponential: {
              In: function (t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1);
              },
              Out: function (t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
              },
              InOut: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                  ? 1
                  : (t *= 2) < 1
                  ? 0.5 * Math.pow(1024, t - 1)
                  : 0.5 * (2 - Math.pow(2, -10 * (t - 1)));
              },
            },
            Circular: {
              In: function (t) {
                return 1 - Math.sqrt(1 - t * t);
              },
              Out: function (t) {
                return Math.sqrt(1 - --t * t);
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? -0.5 * (Math.sqrt(1 - t * t) - 1)
                  : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
              },
            },
            Elastic: {
              In: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                  ? 1
                  : -Math.pow(2, 10 * (t - 1)) *
                    Math.sin(5 * (t - 1.1) * Math.PI);
              },
              Out: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                  ? 1
                  : Math.pow(2, -10 * t) * Math.sin(5 * (t - 0.1) * Math.PI) +
                    1;
              },
              InOut: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                  ? 1
                  : (t *= 2) < 1
                  ? -0.5 *
                    Math.pow(2, 10 * (t - 1)) *
                    Math.sin(5 * (t - 1.1) * Math.PI)
                  : 0.5 *
                      Math.pow(2, -10 * (t - 1)) *
                      Math.sin(5 * (t - 1.1) * Math.PI) +
                    1;
              },
            },
            Back: {
              In: function (t) {
                var e = 1.70158;
                return t * t * ((e + 1) * t - e);
              },
              Out: function (t) {
                var e = 1.70158;
                return --t * t * ((e + 1) * t + e) + 1;
              },
              InOut: function (t) {
                var e = 2.5949095;
                return (t *= 2) < 1
                  ? t * t * ((e + 1) * t - e) * 0.5
                  : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);
              },
            },
            Bounce: {
              In: function (t) {
                return 1 - r.Bounce.Out(1 - t);
              },
              Out: function (t) {
                return t < 1 / 2.75
                  ? 7.5625 * t * t
                  : t < 2 / 2.75
                  ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
                  : t < 2.5 / 2.75
                  ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
                  : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
              },
              InOut: function (t) {
                return t < 0.5
                  ? 0.5 * r.Bounce.In(2 * t)
                  : 0.5 * r.Bounce.Out(2 * t - 1) + 0.5;
              },
            },
          },
          a =
            'undefined' == typeof self &&
            'undefined' != typeof process &&
            process.hrtime
              ? function () {
                  var t = process.hrtime();
                  return 1e3 * t[0] + t[1] / 1e6;
                }
              : 'undefined' != typeof self &&
                void 0 !== self.performance &&
                void 0 !== self.performance.now
              ? self.performance.now.bind(self.performance)
              : void 0 !== Date.now
              ? Date.now
              : function () {
                  return new Date().getTime();
                },
          o = (function () {
            function t() {
              (this._tweens = {}), (this._tweensAddedDuringUpdate = {});
            }
            return (
              (t.prototype.getAll = function () {
                var t = this;
                return Object.keys(this._tweens).map(function (e) {
                  return t._tweens[e];
                });
              }),
              (t.prototype.removeAll = function () {
                this._tweens = {};
              }),
              (t.prototype.add = function (t) {
                (this._tweens[t.getId()] = t),
                  (this._tweensAddedDuringUpdate[t.getId()] = t);
              }),
              (t.prototype.remove = function (t) {
                delete this._tweens[t.getId()],
                  delete this._tweensAddedDuringUpdate[t.getId()];
              }),
              (t.prototype.update = function (t, e) {
                void 0 === t && (t = a()), void 0 === e && (e = !1);
                var n = Object.keys(this._tweens);
                if (0 === n.length) return !1;
                for (; n.length > 0; ) {
                  this._tweensAddedDuringUpdate = {};
                  for (var i = 0; i < n.length; i++) {
                    var r = this._tweens[n[i]],
                      o = !e;
                    r &&
                      !1 === r.update(t, o) &&
                      !e &&
                      delete this._tweens[n[i]];
                  }
                  n = Object.keys(this._tweensAddedDuringUpdate);
                }
                return !0;
              }),
              t
            );
          })(),
          s = {
            Linear: function (t, e) {
              var n = t.length - 1,
                i = n * e,
                r = Math.floor(i),
                a = s.Utils.Linear;
              return e < 0
                ? a(t[0], t[1], i)
                : e > 1
                ? a(t[n], t[n - 1], n - i)
                : a(t[r], t[r + 1 > n ? n : r + 1], i - r);
            },
            Bezier: function (t, e) {
              for (
                var n = 0,
                  i = t.length - 1,
                  r = Math.pow,
                  a = s.Utils.Bernstein,
                  o = 0;
                o <= i;
                o++
              )
                n += r(1 - e, i - o) * r(e, o) * t[o] * a(i, o);
              return n;
            },
            CatmullRom: function (t, e) {
              var n = t.length - 1,
                i = n * e,
                r = Math.floor(i),
                a = s.Utils.CatmullRom;
              return t[0] === t[n]
                ? (e < 0 && (r = Math.floor((i = n * (1 + e)))),
                  a(
                    t[(r - 1 + n) % n],
                    t[r],
                    t[(r + 1) % n],
                    t[(r + 2) % n],
                    i - r,
                  ))
                : e < 0
                ? t[0] - (a(t[0], t[0], t[1], t[1], -i) - t[0])
                : e > 1
                ? t[n] - (a(t[n], t[n], t[n - 1], t[n - 1], i - n) - t[n])
                : a(
                    t[r ? r - 1 : 0],
                    t[r],
                    t[n < r + 1 ? n : r + 1],
                    t[n < r + 2 ? n : r + 2],
                    i - r,
                  );
            },
            Utils: {
              Linear: function (t, e, n) {
                return (e - t) * n + t;
              },
              Bernstein: function (t, e) {
                var n = s.Utils.Factorial;
                return n(t) / n(e) / n(t - e);
              },
              Factorial:
                ((i = [1]),
                function (t) {
                  var e = 1;
                  if (i[t]) return i[t];
                  for (var n = t; n > 1; n--) e *= n;
                  return (i[t] = e), e;
                }),
              CatmullRom: function (t, e, n, i, r) {
                var a = 0.5 * (n - t),
                  o = 0.5 * (i - e),
                  s = r * r;
                return (
                  (2 * e - 2 * n + a + o) * (r * s) +
                  (-3 * e + 3 * n - 2 * a - o) * s +
                  a * r +
                  e
                );
              },
            },
          },
          l = (function () {
            function t() {}
            return (
              (t.nextId = function () {
                return t._nextId++;
              }),
              (t._nextId = 0),
              t
            );
          })(),
          c = new o(),
          u = (function () {
            function t(t, e) {
              void 0 === e && (e = c),
                (this._object = t),
                (this._group = e),
                (this._isPaused = !1),
                (this._pauseStart = 0),
                (this._valuesStart = {}),
                (this._valuesEnd = {}),
                (this._valuesStartRepeat = {}),
                (this._duration = 1e3),
                (this._initialRepeat = 0),
                (this._repeat = 0),
                (this._yoyo = !1),
                (this._isPlaying = !1),
                (this._reversed = !1),
                (this._delayTime = 0),
                (this._startTime = 0),
                (this._easingFunction = r.Linear.None),
                (this._interpolationFunction = s.Linear),
                (this._chainedTweens = []),
                (this._onStartCallbackFired = !1),
                (this._id = l.nextId()),
                (this._isChainStopped = !1),
                (this._goToEnd = !1);
            }
            return (
              (t.prototype.getId = function () {
                return this._id;
              }),
              (t.prototype.isPlaying = function () {
                return this._isPlaying;
              }),
              (t.prototype.isPaused = function () {
                return this._isPaused;
              }),
              (t.prototype.to = function (t, e) {
                return (
                  (this._valuesEnd = Object.create(t)),
                  void 0 !== e && (this._duration = e),
                  this
                );
              }),
              (t.prototype.duration = function (t) {
                return (this._duration = t), this;
              }),
              (t.prototype.start = function (t) {
                if (this._isPlaying) return this;
                if (
                  (this._group && this._group.add(this),
                  (this._repeat = this._initialRepeat),
                  this._reversed)
                )
                  for (var e in ((this._reversed = !1),
                  this._valuesStartRepeat))
                    this._swapEndStartRepeatValues(e),
                      (this._valuesStart[e] = this._valuesStartRepeat[e]);
                return (
                  (this._isPlaying = !0),
                  (this._isPaused = !1),
                  (this._onStartCallbackFired = !1),
                  (this._isChainStopped = !1),
                  (this._startTime =
                    void 0 !== t
                      ? 'string' == typeof t
                        ? a() + parseFloat(t)
                        : t
                      : a()),
                  (this._startTime += this._delayTime),
                  this._setupProperties(
                    this._object,
                    this._valuesStart,
                    this._valuesEnd,
                    this._valuesStartRepeat,
                  ),
                  this
                );
              }),
              (t.prototype._setupProperties = function (t, e, n, i) {
                for (var r in n) {
                  var a = t[r],
                    o = Array.isArray(a),
                    s = o ? 'array' : typeof a,
                    l = !o && Array.isArray(n[r]);
                  if ('undefined' !== s && 'function' !== s) {
                    if (l) {
                      var c = n[r];
                      if (0 === c.length) continue;
                      (c = c.map(this._handleRelativeValue.bind(this, a))),
                        (n[r] = [a].concat(c));
                    }
                    if (('object' !== s && !o) || !a || l)
                      void 0 === e[r] && (e[r] = a),
                        o || (e[r] *= 1),
                        (i[r] = l ? n[r].slice().reverse() : e[r] || 0);
                    else {
                      for (var u in ((e[r] = o ? [] : {}), a)) e[r][u] = a[u];
                      (i[r] = o ? [] : {}),
                        this._setupProperties(a, e[r], n[r], i[r]);
                    }
                  }
                }
              }),
              (t.prototype.stop = function () {
                return (
                  this._isChainStopped ||
                    ((this._isChainStopped = !0), this.stopChainedTweens()),
                  this._isPlaying
                    ? (this._group && this._group.remove(this),
                      (this._isPlaying = !1),
                      (this._isPaused = !1),
                      this._onStopCallback &&
                        this._onStopCallback(this._object),
                      this)
                    : this
                );
              }),
              (t.prototype.end = function () {
                return (this._goToEnd = !0), this.update(1 / 0), this;
              }),
              (t.prototype.pause = function (t) {
                return (
                  void 0 === t && (t = a()),
                  this._isPaused ||
                    !this._isPlaying ||
                    ((this._isPaused = !0),
                    (this._pauseStart = t),
                    this._group && this._group.remove(this)),
                  this
                );
              }),
              (t.prototype.resume = function (t) {
                return (
                  void 0 === t && (t = a()),
                  this._isPaused && this._isPlaying
                    ? ((this._isPaused = !1),
                      (this._startTime += t - this._pauseStart),
                      (this._pauseStart = 0),
                      this._group && this._group.add(this),
                      this)
                    : this
                );
              }),
              (t.prototype.stopChainedTweens = function () {
                for (var t = 0, e = this._chainedTweens.length; t < e; t++)
                  this._chainedTweens[t].stop();
                return this;
              }),
              (t.prototype.group = function (t) {
                return (this._group = t), this;
              }),
              (t.prototype.delay = function (t) {
                return (this._delayTime = t), this;
              }),
              (t.prototype.repeat = function (t) {
                return (this._initialRepeat = t), (this._repeat = t), this;
              }),
              (t.prototype.repeatDelay = function (t) {
                return (this._repeatDelayTime = t), this;
              }),
              (t.prototype.yoyo = function (t) {
                return (this._yoyo = t), this;
              }),
              (t.prototype.easing = function (t) {
                return (this._easingFunction = t), this;
              }),
              (t.prototype.interpolation = function (t) {
                return (this._interpolationFunction = t), this;
              }),
              (t.prototype.chain = function () {
                for (var t = [], e = 0; e < arguments.length; e++)
                  t[e] = arguments[e];
                return (this._chainedTweens = t), this;
              }),
              (t.prototype.onStart = function (t) {
                return (this._onStartCallback = t), this;
              }),
              (t.prototype.onUpdate = function (t) {
                return (this._onUpdateCallback = t), this;
              }),
              (t.prototype.onRepeat = function (t) {
                return (this._onRepeatCallback = t), this;
              }),
              (t.prototype.onComplete = function (t) {
                return (this._onCompleteCallback = t), this;
              }),
              (t.prototype.onStop = function (t) {
                return (this._onStopCallback = t), this;
              }),
              (t.prototype.update = function (t, e) {
                if (
                  (void 0 === t && (t = a()),
                  void 0 === e && (e = !0),
                  this._isPaused)
                )
                  return !0;
                var n,
                  i,
                  r = this._startTime + this._duration;
                if (!this._goToEnd && !this._isPlaying) {
                  if (t > r) return !1;
                  e && this.start(t);
                }
                if (((this._goToEnd = !1), t < this._startTime)) return !0;
                !1 === this._onStartCallbackFired &&
                  (this._onStartCallback && this._onStartCallback(this._object),
                  (this._onStartCallbackFired = !0)),
                  (i = (t - this._startTime) / this._duration),
                  (i = 0 === this._duration || i > 1 ? 1 : i);
                var o = this._easingFunction(i);
                if (
                  (this._updateProperties(
                    this._object,
                    this._valuesStart,
                    this._valuesEnd,
                    o,
                  ),
                  this._onUpdateCallback &&
                    this._onUpdateCallback(this._object, i),
                  1 === i)
                ) {
                  if (this._repeat > 0) {
                    for (n in (isFinite(this._repeat) && this._repeat--,
                    this._valuesStartRepeat))
                      this._yoyo ||
                        'string' != typeof this._valuesEnd[n] ||
                        (this._valuesStartRepeat[n] =
                          this._valuesStartRepeat[n] +
                          parseFloat(this._valuesEnd[n])),
                        this._yoyo && this._swapEndStartRepeatValues(n),
                        (this._valuesStart[n] = this._valuesStartRepeat[n]);
                    return (
                      this._yoyo && (this._reversed = !this._reversed),
                      void 0 !== this._repeatDelayTime
                        ? (this._startTime = t + this._repeatDelayTime)
                        : (this._startTime = t + this._delayTime),
                      this._onRepeatCallback &&
                        this._onRepeatCallback(this._object),
                      !0
                    );
                  }
                  this._onCompleteCallback &&
                    this._onCompleteCallback(this._object);
                  for (var s = 0, l = this._chainedTweens.length; s < l; s++)
                    this._chainedTweens[s].start(
                      this._startTime + this._duration,
                    );
                  return (this._isPlaying = !1), !1;
                }
                return !0;
              }),
              (t.prototype._updateProperties = function (t, e, n, i) {
                for (var r in n)
                  if (void 0 !== e[r]) {
                    var a = e[r] || 0,
                      o = n[r],
                      s = Array.isArray(t[r]),
                      l = Array.isArray(o);
                    !s && l
                      ? (t[r] = this._interpolationFunction(o, i))
                      : 'object' == typeof o && o
                      ? this._updateProperties(t[r], a, o, i)
                      : 'number' ==
                          typeof (o = this._handleRelativeValue(a, o)) &&
                        (t[r] = a + (o - a) * i);
                  }
              }),
              (t.prototype._handleRelativeValue = function (t, e) {
                return 'string' != typeof e
                  ? e
                  : '+' === e.charAt(0) || '-' === e.charAt(0)
                  ? t + parseFloat(e)
                  : parseFloat(e);
              }),
              (t.prototype._swapEndStartRepeatValues = function (t) {
                var e = this._valuesStartRepeat[t],
                  n = this._valuesEnd[t];
                (this._valuesStartRepeat[t] =
                  'string' == typeof n
                    ? this._valuesStartRepeat[t] + parseFloat(n)
                    : this._valuesEnd[t]),
                  (this._valuesEnd[t] = e);
              }),
              t
            );
          })(),
          h = l.nextId,
          d = c,
          p = d.getAll.bind(d),
          f = d.removeAll.bind(d),
          m = d.add.bind(d),
          g = d.remove.bind(d),
          y = d.update.bind(d),
          v = {
            Easing: r,
            Group: o,
            Interpolation: s,
            now: a,
            Sequence: l,
            nextId: h,
            Tween: u,
            VERSION: '18.6.4',
            getAll: p,
            removeAll: f,
            add: m,
            remove: g,
            update: y,
          };
        e.a = v;
      },
      49: function (t, e, n) {
        'use strict';
        var i = { FINAL: 0, DEPTH: 1, ID: 2 };
        e.a = {
          MODES: i,
          push: function (t, e) {
            var n = void 0 !== t.mode ? t.mode : i.FINAL;
            if (n == e) return function () {};
            var r = function (t) {
              return function (e) {
                var n = e.material;
                n && (n.mode = t);
              };
            };
            return (
              t.traverse(r(e)),
              function () {
                t.traverse(r(n));
              }
            );
          },
        };
      },
      5: function (t, e) {
        (t.exports = function (t) {
          if (void 0 === t)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called",
            );
          return t;
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      51: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(5),
          l = n.n(s),
          c = n(6),
          u = n.n(c),
          h = n(7),
          d = n.n(h),
          p = n(2),
          f = n.n(p),
          m = n(24),
          g = n(63),
          y = n(39);
        function v(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = f()(t);
            if (e) {
              var r = f()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return d()(this, n);
          };
        }
        function x(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return b(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return b(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function b(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function _(t) {
          if (t.dispose) t.dispose();
          else if ((t.geometry && t.geometry.dispose(), t.material))
            if (Array.isArray(t.material)) {
              var e,
                n = x(t.material);
              try {
                for (n.s(); !(e = n.n()).done; ) {
                  e.value.dispose();
                }
              } catch (t) {
                n.e(t);
              } finally {
                n.f();
              }
            } else t.material.dispose();
        }
        var w = (function (t) {
          u()(n, t);
          var e = v(n);
          function n(t, i) {
            var a,
              o =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {};
            if (
              (r()(this, n),
              (o.cacheLifeTime =
                null == o.cacheLifeTime ? y.a.GEOMETRY : o.cacheLifeTime),
              ((a = e.call(this, t, o)).isGeometryLayer = !0),
              !i || !i.isObject3D)
            )
              throw new Error(
                'Missing/Invalid object3d parameter (must be a\n                three.js Object3D instance)',
              );
            return (
              'Group' === i.type && '' === i.name && (i.name = t),
              Object.defineProperty(l()(a), 'object3d', {
                value: i,
                writable: !1,
                configurable: !0,
              }),
              a.defineLayerProperty('opacity', 1, function () {
                (a.parent ? a.parent.object3d : a.object3d).traverse(function (
                  t,
                ) {
                  t.layer == l()(a)
                    ? a.changeOpacity(t)
                    : t.content &&
                      t.content.layer == l()(a) &&
                      t.content.traverse(a.changeOpacity);
                });
              }),
              a.defineLayerProperty('wireframe', !1, function () {
                (a.parent ? a.parent.object3d : a.object3d).traverse(function (
                  t,
                ) {
                  t.layer == l()(a) && t.material
                    ? (t.material.wireframe = a.wireframe)
                    : t.content &&
                      t.content.layer == l()(a) &&
                      t.content.traverse(function (t) {
                        t.material &&
                          t.layer == l()(a) &&
                          (t.material.wireframe = a.wireframe);
                      });
                });
              }),
              (a.attachedLayers = []),
              (a.visible = null == o.visible || o.visible),
              Object.defineProperty(a.zoom, 'max', {
                value: 1 / 0,
                writable: !1,
              }),
              (a.filteringExtent = !a.source.isFileSource),
              (a.structure = '3d'),
              a
            );
          }
          return (
            o()(n, [
              {
                key: 'getObjectToUpdateForAttachedLayers',
                value: function (t) {
                  if (t.parent && t.material)
                    return { element: t, parent: t.parent };
                },
              },
              { key: 'postUpdate', value: function () {} },
              {
                key: 'culling',
                value: function () {
                  return !0;
                },
              },
              {
                key: 'attach',
                value: function (t) {
                  if (!t.update)
                    throw new Error(
                      "Missing 'update' function -> can't attach layer\n                ".concat(
                        t.id,
                      ),
                    );
                  this.attachedLayers.push(t), (t.parent = this);
                },
              },
              {
                key: 'detach',
                value: function (t) {
                  var e = this.attachedLayers.length;
                  return (
                    (this.attachedLayers = this.attachedLayers.filter(function (
                      e,
                    ) {
                      return e.id != t.id;
                    })),
                    (t.parent = void 0),
                    this.attachedLayers.length < e
                  );
                },
              },
              {
                key: 'delete',
                value: function () {
                  var t = this;
                  this.parent &&
                    (function t(e, n) {
                      var i,
                        r = x(e.children);
                      try {
                        for (r.s(); !(i = r.n()).done; ) {
                          t(i.value, n);
                        }
                      } catch (t) {
                        r.e(t);
                      } finally {
                        r.f();
                      }
                      n(e);
                    })(this.parent.object3d, function (e) {
                      e.layer &&
                        e.layer.id == t.id &&
                        (e.parent.remove(e), _(e));
                    }),
                    this.object3d.parent &&
                      this.object3d.parent.remove(this.object3d),
                    this.object3d.traverse(_);
                },
              },
              {
                key: 'pickObjectsAt',
                value: function (t, e) {
                  var n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : this.options.defaultPickingRadius,
                    i =
                      arguments.length > 3 && void 0 !== arguments[3]
                        ? arguments[3]
                        : [],
                    r = this.parent ? this.parent.object3d : this.object3d;
                  return g.a.pickObjectsAt(t, e, n, r, i, this.threejsLayer);
                },
              },
              {
                key: 'changeOpacity',
                value: function (t) {
                  t.material &&
                    (null != t.material.opacity &&
                      ((t.material.transparent = this.opacity < 1),
                      (t.material.opacity = this.opacity)),
                    t.material.uniforms &&
                      null != t.material.uniforms.opacity &&
                      ((t.material.transparent = this.opacity < 1),
                      (t.material.uniforms.opacity.value = this.opacity)));
                },
              },
            ]),
            n
          );
        })(m.b);
        e.a = w;
      },
      52: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return ct;
        });
        var i = n(22),
          r = n.n(i),
          a = n(3),
          o = n.n(a),
          s = n(4),
          l = n.n(s),
          c = n(5),
          u = n.n(c),
          h = n(6),
          d = n.n(h),
          p = n(7),
          f = n.n(p),
          m = n(2),
          g = n.n(m),
          y = n(0),
          v = n(105),
          x = n(19),
          b = n(31),
          _ = n(106),
          w = n(29),
          M = function () {
            try {
              var t = document.createElement('canvas');
              return !(
                !window.WebGLRenderingContext ||
                (!t.getContext('webgl') && !t.getContext('experimental-webgl'))
              );
            } catch (t) {
              return !1;
            }
          },
          q = function () {
            try {
              var t = document.createElement('canvas');
              return !(
                !window.WebGL2RenderingContext || !t.getContext('webgl2')
              );
            } catch (t) {
              return !1;
            }
          },
          S = function (t) {
            var e = {
                1: window.WebGLRenderingContext,
                2: window.WebGL2RenderingContext,
              },
              n =
                'Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>',
              i = document.createElement('div');
            return (
              (i.id = 'webglmessage'),
              (i.style.fontFamily = 'monospace'),
              (i.style.fontSize = '13px'),
              (i.style.fontWeight = 'normal'),
              (i.style.textAlign = 'center'),
              (i.style.background = '#fff'),
              (i.style.color = '#000'),
              (i.style.padding = '1.5em'),
              (i.style.width = '400px'),
              (i.style.margin = '5em auto 0'),
              (n = (n = e[t]
                ? n.replace('$0', 'graphics card')
                : n.replace('$0', 'browser')).replace(
                '$1',
                { 1: 'WebGL', 2: 'WebGL 2' }[t],
              )),
              (i.innerHTML = n),
              i
            );
          };
        var T = (function () {
            function t() {
              var e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : 12,
                n =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : 10,
                i = arguments.length > 2 ? arguments[2] : void 0,
                r = arguments.length > 3 ? arguments[3] : void 0;
              o()(this, t),
                (this.x = e),
                (this.y = n),
                (this.grid = []),
                (this.hidden = []),
                (this.visible = []),
                this.resize(),
                this.reset(),
                (this.width = i),
                (this.height = r);
            }
            return (
              l()(t, [
                {
                  key: 'reset',
                  value: function () {
                    for (var t = 0; t < this.x; t++)
                      for (var e = 0; e < this.y; e++)
                        this.grid[t][e].splice(0, this.grid[t][e].length);
                    (this.hidden = []), (this.visible = []);
                  },
                },
                {
                  key: 'resize',
                  value: function () {
                    for (var t = 0; t < this.x; t++) {
                      this.grid[t] || (this.grid[t] = []);
                      for (var e = 0; e < this.y; e++)
                        this.grid[t][e] || (this.grid[t][e] = []);
                    }
                  },
                },
                {
                  key: 'insert',
                  value: function (t) {
                    for (
                      var e = Math.max(
                          0,
                          Math.floor((t.boundaries.left / this.width) * this.x),
                        ),
                        n = Math.min(
                          this.x - 1,
                          Math.floor(
                            (t.boundaries.right / this.width) * this.x,
                          ),
                        ),
                        i = Math.max(
                          0,
                          Math.floor((t.boundaries.top / this.height) * this.y),
                        ),
                        r = Math.min(
                          this.y - 1,
                          Math.floor(
                            (t.boundaries.bottom / this.height) * this.y,
                          ),
                        ),
                        a = e;
                      a <= n;
                      a++
                    )
                      for (var o = i; o <= r; o++)
                        if (
                          this.grid[a][o].length > 0 &&
                          this.grid[a][o].some(function (e) {
                            return (
                              (n = e.boundaries),
                              (i = t.boundaries),
                              !(
                                n.left > i.right ||
                                n.right < i.left ||
                                n.top > i.bottom ||
                                n.bottom < i.top
                              )
                            );
                            var n, i;
                          })
                        )
                          return this.hidden.push(t), !1;
                    for (var s = e; s <= n; s++)
                      for (var l = i; l <= r; l++) this.grid[s][l].push(t);
                    return !0;
                  },
                },
              ]),
              t
            );
          })(),
          E = new y.Matrix4(),
          A = new y.Vector3(),
          L = (function () {
            function t() {
              o()(this, t),
                (this.domElement = document.createElement('div')),
                (this.domElement.style.overflow = 'hidden'),
                (this.domElement.style.position = 'absolute'),
                (this.domElement.style.height = '100%'),
                (this.domElement.style.width = '100%'),
                (this.domElement.style.zIndex = 1),
                (this.garbage = document.createElement('div')),
                (this.garbage.style.display = 'none'),
                this.domElement.appendChild(this.garbage),
                (this.halfWidth = 0),
                (this.halfHeight = 0),
                (this.grid = new T()),
                (this.infoTileLayer = void 0);
            }
            return (
              l()(t, [
                {
                  key: 'setSize',
                  value: function (t, e) {
                    (this.domElement.style.width = ''.concat(t)),
                      (this.domElement.style.height = ''.concat(e)),
                      (this.halfWidth = t / 2),
                      (this.halfHeight = e / 2),
                      (this.grid.width = t),
                      (this.grid.height = e),
                      (this.grid.x = Math.ceil(t / 20)),
                      (this.grid.y = Math.ceil(e / 20)),
                      this.grid.resize();
                  },
                },
                {
                  key: 'registerLayer',
                  value: function (t) {
                    this.domElement.appendChild(t.domElement);
                  },
                },
                {
                  key: 'render',
                  value: function (t, e) {
                    var n = this;
                    this.infoTileLayer &&
                      this.infoTileLayer.layer.attachedLayers.find(function (
                        t,
                      ) {
                        return t.isLabelLayer && t.visible;
                      }) &&
                      (this.grid.reset(),
                      E.multiplyMatrices(
                        e.projectionMatrix,
                        e.matrixWorldInverse,
                      ),
                      this.culling(t, this.infoTileLayer.displayed.extent),
                      this.grid.visible.sort(function (t, e) {
                        var n = e.order - t.order;
                        return 0 == n ? (!t.visible && e.visible ? 1 : -1) : n;
                      }),
                      this.grid.visible.forEach(function (t) {
                        n.grid.insert(t) &&
                          ((t.visible = !0), t.updateCSSPosition());
                      }),
                      this.grid.hidden.forEach(function (t) {
                        t.visible = !1;
                      }));
                  },
                },
                {
                  key: 'culling',
                  value: function (t, e) {
                    var n = this;
                    if (t.isLabel)
                      !e.isPointInside(t.coordinates) ||
                      (function (t) {
                        var e = t.parent;
                        return (
                          e.material &&
                          !e.material.visible &&
                          e.children.find(function (t) {
                            return (
                              t.isTileMesh &&
                              t.children.find(function (t) {
                                return t.isLabel;
                              })
                            );
                          })
                        );
                      })(t) ||
                      (t.parent.level < 4 &&
                        t.parent.layer.horizonCulling &&
                        t.parent.layer.horizonCulling(t.horizonCullingPoint))
                        ? this.grid.hidden.push(t)
                        : (A.setFromMatrixPosition(t.matrixWorld),
                          A.applyMatrix4(E),
                          t.updateProjectedPosition(
                            A.x * this.halfWidth + this.halfWidth,
                            -A.y * this.halfHeight + this.halfHeight,
                          ),
                          this.grid.visible.some(function (e) {
                            return (
                              e.projectedPosition.x == t.projectedPosition.x &&
                              e.projectedPosition.y == t.projectedPosition.y &&
                              e.baseContent == t.baseContent
                            );
                          })
                            ? (t.parent.remove(t), this.grid.hidden.push(t))
                            : this.grid.visible.push(t));
                    else {
                      if (!t.visible) return void this.hideNodeDOM(t);
                      if (t.extent && !t.extent.intersectsExtent(e))
                        return void this.hideNodeDOM(t);
                      this.showNodeDOM(t),
                        t.children.forEach(function (t) {
                          return n.culling(t, e);
                        });
                    }
                  },
                },
                {
                  key: 'removeLabelDOM',
                  value: function (t) {
                    this.garbage.appendChild(t.content),
                      (this.garbage.innerHTML = '');
                  },
                },
                {
                  key: 'hideNodeDOM',
                  value: function (t) {
                    var e = this;
                    if (t.domElements) {
                      var n = Object.values(t.domElements);
                      n.length > 0
                        ? n.forEach(function (t) {
                            1 == t.visible &&
                              ((t.dom.style.display = 'none'),
                              (t.visible = !1));
                          })
                        : t.children
                            .filter(function (t) {
                              return t.isTileMesh;
                            })
                            .forEach(function (t) {
                              return e.hideNodeDOM(t);
                            });
                    }
                  },
                },
                {
                  key: 'showNodeDOM',
                  value: function (t) {
                    t.domElements &&
                      Object.values(t.domElements).forEach(function (t) {
                        0 == t.visible &&
                          ((t.dom.style.display = 'block'), (t.visible = !0));
                      });
                  },
                },
              ]),
              t
            );
          })(),
          R = new y.Vector4(),
          C = (function () {
            function t(e) {
              var n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {};
              o()(this, t);
              var i = !b.a.isInternetExplorer();
              void 0 === n.antialias && (n.antialias = !0),
                void 0 === n.alpha && (n.alpha = !0),
                void 0 === n.logarithmicDepthBuffer &&
                  (n.logarithmicDepthBuffer = this.gLDebug || i),
                void 0 === n.isWebGL2 && (n.isWebGL2 = !0);
              var r = e.domElement ? e : void 0,
                a = r ? r.domElement : e;
              (this.width = a.clientWidth),
                (this.height = a.clientHeight),
                (this.positionBuffer = null),
                (this._nextThreejsLayer = 1),
                (this.fullSizeRenderTarget = new y.WebGLRenderTarget(
                  this.width,
                  this.height,
                )),
                (this.fullSizeRenderTarget.texture.minFilter = y.LinearFilter),
                (this.fullSizeRenderTarget.texture.magFilter = y.NearestFilter),
                (this.fullSizeRenderTarget.depthBuffer = !0),
                (this.fullSizeRenderTarget.depthTexture = new y.DepthTexture()),
                (this.fullSizeRenderTarget.depthTexture.type =
                  y.UnsignedShortType),
                (this.renderView = function (t) {
                  this.renderer.clear(),
                    this.renderer.render(t.scene, t.camera.camera3D),
                    this.label2dRenderer.render(t.scene, t.camera.camera3D);
                }.bind(this)),
                (this.onWindowResize = function (t, e) {
                  (this.width = t),
                    (this.height = e),
                    this.fullSizeRenderTarget.setSize(this.width, this.height),
                    this.renderer.setSize(this.width, this.height),
                    this.label2dRenderer.setSize(this.width, this.height);
                }.bind(this));
              try {
                (this.label2dRenderer = new L()),
                  this.label2dRenderer.setSize(this.width, this.height),
                  a.appendChild(this.label2dRenderer.domElement),
                  (this.renderer =
                    r ||
                    new (n.isWebGL2 ? y.WebGLRenderer : y.WebGL1Renderer)({
                      canvas: document.createElement('canvas'),
                      antialias: n.antialias,
                      alpha: n.alpha,
                      logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                    })),
                  (this.renderer.domElement.style.position = 'relative'),
                  (this.renderer.domElement.style.zIndex = 0),
                  (this.renderer.domElement.style.top = 0);
              } catch (t) {
                var s = n.isWebGL2 ? '2' : '1';
                console.error(
                  'Failed to create WebGLRenderer webGL '.concat(s, '.'),
                ),
                  (this.renderer = null);
              }
              if (!this.renderer)
                throw (
                  (M() ? q() || a.appendChild(S(2)) : a.appendChild(S(1)),
                  new Error('WebGL unsupported'))
                );
              !r &&
                n.logarithmicDepthBuffer &&
                (this.renderer.capabilities.isWebGL2 ||
                  this.renderer.extensions.get('EXT_frag_depth') ||
                  (this.renderer.dispose(),
                  (this.renderer = new (
                    n.isWebGL2 ? y.WebGLRenderer : y.WebGL1Renderer
                  )({
                    canvas: document.createElement('canvas'),
                    antialias: n.antialias,
                    alpha: n.alpha,
                    logarithmicDepthBuffer: !1,
                  })))),
                -1 === this.renderer.domElement.tabIndex &&
                  (this.renderer.domElement.tabIndex = -1),
                b.a.updateCapabilities(this.renderer),
                this.renderer.setClearColor(197896),
                (this.renderer.autoClear = !1),
                (this.renderer.sortObjects = !0),
                (this.renderer.debug.checkShaderErrors = !1),
                r ||
                  (this.renderer.setPixelRatio(a.devicePixelRatio),
                  this.renderer.setSize(a.clientWidth, a.clientHeight),
                  a.appendChild(this.renderer.domElement));
            }
            return (
              l()(t, [
                {
                  key: 'getWindowSize',
                  value: function () {
                    return new y.Vector2(this.width, this.height);
                  },
                },
                {
                  key: 'getRenderer',
                  value: function () {
                    return this.renderer;
                  },
                },
                {
                  key: 'renderViewToBuffer',
                  value: function (t, e) {
                    return (
                      e ||
                        (e = {
                          x: 0,
                          y: 0,
                          width: this.width,
                          height: this.height,
                        }),
                      (e.buffer =
                        e.buffer || new Uint8Array(4 * e.width * e.height)),
                      this.renderViewToRenderTarget(
                        t,
                        this.fullSizeRenderTarget,
                        e,
                      ),
                      this.renderer.readRenderTargetPixels(
                        this.fullSizeRenderTarget,
                        e.x,
                        this.height - (e.y + e.height),
                        e.width,
                        e.height,
                        e.buffer,
                      ),
                      e.buffer
                    );
                  },
                },
                {
                  key: 'renderViewToRenderTarget',
                  value: function (t, e, n) {
                    e || (e = this.fullSizeRenderTarget);
                    var i = this.renderer.getRenderTarget();
                    return (
                      n &&
                        (this.fullSizeRenderTarget.scissor.set(
                          n.x,
                          e.height - (n.y + n.height),
                          n.width,
                          n.height,
                        ),
                        (this.fullSizeRenderTarget.scissorTest = !0)),
                      this.renderer.setRenderTarget(e),
                      this.renderer.clear(!0, !0, !1),
                      this.renderer.render(t.scene, t.camera.camera3D),
                      this.renderer.setRenderTarget(i),
                      (this.fullSizeRenderTarget.scissorTest = !1),
                      e
                    );
                  },
                },
                {
                  key: 'bufferToImage',
                  value: function (t, e, n) {
                    var i = document.createElement('canvas'),
                      r = i.getContext('2d');
                    (i.width = e), (i.height = n);
                    var a = r.getImageData(0, 0, e, n);
                    a.data.set(t), r.putImageData(a, 0, 0);
                    var o = new Image();
                    return (o.src = i.toDataURL()), o;
                  },
                },
                {
                  key: 'getUniqueThreejsLayer',
                  value: function () {
                    return (
                      this._nextThreejsLayer > 31 &&
                        (console.warn(
                          'Too much three.js layers. Starting from now all of them will use layerMask = 31',
                        ),
                        (this._nextThreejsLayer = 31)),
                      this._nextThreejsLayer++
                    );
                  },
                },
                {
                  key: 'depthBufferRGBAValueToOrthoZ',
                  value: function (t, e) {
                    if (
                      (R.fromArray(t).divideScalar(255),
                      b.a.isLogDepthBufferSupported() &&
                        'PerspectiveCamera' == e.type)
                    ) {
                      var n = Object(w.e)(R),
                        i = 2 / (Math.log(e.far + 1) / Math.LN2);
                      return Math.pow(2, (2 * n) / i);
                    }
                    var r = Object(w.e)(R);
                    return (r = 2 * r - 1);
                  },
                },
              ]),
              t
            );
          })(),
          P = n(49),
          k = n(10),
          I = n(8),
          D = n(109),
          O = n(147),
          N = n.n(O),
          z = {
            executeCommand: function (t) {
              var e = t.layer,
                n = t.extentsSource,
                i = t.extentsDestination || n;
              return Promise.all(
                n.map(function (t, n) {
                  return e.getData(t, i[n]);
                }),
              );
            },
          },
          F = (function () {
            function t(e) {
              o()(this, t),
                (this.command = e),
                (this.isCancelledCommandException = !0);
            }
            return (
              l()(t, [
                {
                  key: 'toString',
                  value: function () {
                    return 'Cancelled command '
                      .concat(this.command.requester.id, '/')
                      .concat(this.command.layer.id);
                  },
                },
              ]),
              t
            );
          })(),
          B = {
            executeCommand: function (t) {
              var e = [],
                n = t.layer,
                i = t.requester,
                r = t.extentsSource;
              if (i && !i.material) return Promise.reject(new F(t));
              for (var a = 0, o = r.length; a < o; a++)
                e.push(n.convert(i, r[a]));
              return Promise.all(e);
            },
          },
          U = n(84),
          j = n(36),
          G = n(74),
          H = function (t, e) {
            if (!t) throw new Error('No array buffer provided.');
            var n = new DataView(t),
              i = 0,
              r = {},
              a = {},
              o = {};
            if (
              ((r.magic = j.a.decode(new Uint8Array(t, i, 4))),
              (i += 4),
              r.magic)
            ) {
              (r.version = n.getUint32(i, !0)),
                (i += Uint32Array.BYTES_PER_ELEMENT),
                (r.byteLength = n.getUint32(i, !0)),
                (i += Uint32Array.BYTES_PER_ELEMENT),
                (r.FTJSONLength = n.getUint32(i, !0)),
                (i += Uint32Array.BYTES_PER_ELEMENT),
                (r.FTBinaryLength = n.getUint32(i, !0)),
                (i += Uint32Array.BYTES_PER_ELEMENT),
                (r.BTJSONLength = n.getUint32(i, !0)),
                (i += Uint32Array.BYTES_PER_ELEMENT),
                (r.BTBinaryLength = n.getUint32(i, !0)),
                (i += Uint32Array.BYTES_PER_ELEMENT);
              var s = {};
              if (r.FTJSONLength > 0) {
                var l = i,
                  c = t.slice(l, r.FTJSONLength + l),
                  u = j.a.decode(new Uint8Array(c));
                s = JSON.parse(u);
              }
              if (
                (r.FTBinaryLength > 0 &&
                  (o = (function (t, e, n) {
                    var i,
                      r = new y.BufferGeometry(),
                      a = j.a.decode(new Uint8Array(t, e, n)),
                      o = JSON.parse(a);
                    o.POINTS_LENGTH && (i = o.POINTS_LENGTH);
                    if (o.POSITION) {
                      var s = o.POSITION.byteOffset + a.length + e,
                        l = new Float32Array(t, s, 3 * i);
                      r.setAttribute('position', new y.BufferAttribute(l, 3));
                    }
                    if (o.RGB) {
                      var c = o.RGB.byteOffset + a.length + e,
                        u = new Uint8Array(t, c, 3 * i);
                      r.setAttribute('color', new y.BufferAttribute(u, 3, !0));
                    }
                    if (o.POSITION_QUANTIZED)
                      throw new Error(
                        'For pnts loader, POSITION_QUANTIZED: not yet managed',
                      );
                    if (o.RGBA)
                      throw new Error('For pnts loader, RGBA: not yet managed');
                    if (o.RGB565)
                      throw new Error(
                        'For pnts loader, RGB565: not yet managed',
                      );
                    if (o.NORMAL)
                      throw new Error(
                        'For pnts loader, NORMAL: not yet managed',
                      );
                    if (o.NORMAL_OCT16P)
                      throw new Error(
                        'For pnts loader, NORMAL_OCT16P: not yet managed',
                      );
                    if (o.BATCH_ID)
                      throw new Error(
                        'For pnts loader, BATCH_ID: not yet managed',
                      );
                    var h = o.RTC_CENTER
                      ? new y.Vector3().fromArray(o.RTC_CENTER)
                      : void 0;
                    return { geometry: r, offset: h };
                  })(t, i, r.FTJSONLength)),
                r.BTJSONLength > 0)
              ) {
                var h = i + r.FTJSONLength + r.FTBinaryLength,
                  d = t.slice(h, r.BTJSONLength + h);
                a = new G.a(d, r.BTBinaryLength, s.BATCH_LENGTH, e);
              }
              var p = { point: o, batchTable: a };
              return Promise.resolve(p);
            }
            throw new Error('Invalid pnts file.');
          };
        var V = n(20);
        function W(t, e, n) {
          var i = y.LoaderUtils.extractUrlBase(n),
            r = {
              gltfUpAxis: e.tileset.asset.gltfUpAxis,
              urlBase: i,
              overrideMaterials: e.overrideMaterials,
              doNotPatchMaterial: e.doNotPatchMaterial,
              opacity: e.opacity,
              registeredExtensions: e.registeredExtensions,
            };
          return U.a.parse(t, r).then(function (t) {
            return { batchTable: t.batchTable, object3d: t.gltf.scene };
          });
        }
        function X(t, e) {
          return H(t, e.registeredExtensions).then(function (t) {
            var n = e.material
                ? e.material.clone()
                : new y.PointsMaterial({ size: 0.05, vertexColors: !0 }),
              i = new y.Points(t.point.geometry, n);
            return (
              t.point.offset && i.position.copy(t.point.offset), { object3d: i }
            );
          });
        }
        var Y = {
            executeCommand: function (t) {
              var e = t.layer,
                n = t.metadata,
                i = new y.Object3D();
              !(function (t, e, n, i) {
                (t.frustumCulled = !1),
                  (t.layer = e),
                  n.transform && t.applyMatrix4(n.transform),
                  (t.geometricError = n.geometricError),
                  (t.tileId = n.tileId),
                  n.refine
                    ? (t.additiveRefinement = 'ADD' === n.refine.toUpperCase())
                    : (t.additiveRefinement = !!i && i.additiveRefinement),
                  (t.viewerRequestVolume = n.viewerRequestVolume),
                  (t.boundingVolume = n.boundingVolume),
                  t.boundingVolume.region && t.add(t.boundingVolume.region),
                  t.updateMatrixWorld();
              })(i, e, n, t.requester);
              var r = n.content && (n.content.url || n.content.uri),
                a = function (t) {
                  t.layers.set(e.threejsLayer),
                    (t.userData.metadata = n),
                    (t.layer = e),
                    t.material &&
                      ((t.material.transparent = e.opacity < 1),
                      (t.material.opacity = e.opacity),
                      (t.material.wireframe = e.wireframe));
                };
              if (r) {
                var o = r.startsWith('http') ? r : n.baseURL + r,
                  s = { b3dm: W, pnts: X };
                return V.a
                  .arrayBuffer(o, e.source.networkOptions)
                  .then(function (t) {
                    if (void 0 !== t) {
                      var r,
                        l = j.a.decode(new Uint8Array(t, 0, 4));
                      if ('{' === l[0]) {
                        t = JSON.parse(j.a.decode(new Uint8Array(t)));
                        var c = o.slice(0, o.lastIndexOf('/') + 1);
                        e.tileset.extendTileset(
                          t,
                          n.tileId,
                          c,
                          e.registeredExtensions,
                        );
                      } else if ('b3dm' == l) r = s.b3dm;
                      else {
                        if ('pnts' != l)
                          return Promise.reject(
                            'Unsupported magic code '.concat(l),
                          );
                        r = s.pnts;
                      }
                      if (r)
                        return r(t, e, o).then(function (t) {
                          return (
                            (i.content = t.object3d),
                            t.batchTable && (i.batchTable = t.batchTable),
                            i.add(t.object3d),
                            i.traverse(a),
                            i
                          );
                        });
                    }
                    return i.traverse(a), i;
                  });
              }
              return i.traverse(a), Promise.resolve(i);
            },
          },
          $ = n(11),
          J = 1;
        var Z = {
          executeCommand: function (t) {
            var e = t.layer,
              n = t.requester;
            return n.load().then(function (i) {
              var r = new y.Points(i, e.material);
              return (
                (function (t) {
                  var e = t.geometry.attributes.position.count,
                    n = new Uint8Array(4 * e),
                    i = J++;
                  if (e > 65535 || i > 65535)
                    return (
                      console.warn(
                        'Currently picking is limited to Points with less than 65535 elements and less than 65535 Points instances',
                      ),
                      t
                    );
                  for (var r = 0; r < e; r++) {
                    var a = (i << 16) | r;
                    (n[4 * r + 0] = (4278190080 & a) >> 24),
                      (n[4 * r + 1] = (16711680 & a) >> 16),
                      (n[4 * r + 2] = (65280 & a) >> 8),
                      (n[4 * r + 3] = (255 & a) >> 0);
                  }
                  (t.baseId = i),
                    t.geometry.setAttribute(
                      'unique_id',
                      new y.BufferAttribute(n, 4, !0),
                    );
                })(r),
                (r.frustumCulled = !1),
                (r.matrixAutoUpdate = !1),
                e.isEntwinePointTileLayer ||
                  (r.position.copy(n.bbox.min), r.scale.copy(e.scale)),
                r.updateMatrix(),
                (r.tightbbox = i.boundingBox.applyMatrix4(r.matrix)),
                r.layers.set(e.threejsLayer),
                (r.layer = e),
                (r.extent = $.a.fromBox3(t.view.referenceCrs, n.bbox)),
                (r.userData.node = n),
                r
              );
            });
          },
        };
        function K(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return Q(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return Q(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function Q(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function tt(t, e) {
          var n = e.priority - t.priority;
          return 0 === n ? e.timestamp - t.timestamp : n;
        }
        function et() {
          return {
            queue: function (t) {
              var e = t.layer,
                n = this.storages.get(e.id);
              n ||
                ((n = {
                  q: new N.a({ comparator: tt }),
                  priority: 1,
                  accumulator: 0,
                }),
                this.storages.set(e.id, n)),
                (n.priority = e.priority || 1),
                n.q.queue(t),
                this.counters.pending++;
            },
            storages: new Map(),
            counters: {
              executing: 0,
              executed: 0,
              failed: 0,
              cancelled: 0,
              pending: 0,
            },
            execute: function (t, e) {
              var n = this;
              return (
                this.counters.pending--,
                this.counters.executing++,
                e.executeCommand(t).then(
                  function (e) {
                    n.counters.executing--, t.resolve(e), n.counters.executed++;
                  },
                  function (e) {
                    n.counters.executing--, t.reject(e), n.counters.failed++;
                  },
                )
              );
            },
          };
        }
        function nt() {
          (this.defaultQueue = et()),
            (this.hostQueues = new Map()),
            (this.providers = {}),
            (this.maxCommandsPerHost = 6),
            this.initDefaultProviders();
        }
        (nt.prototype.constructor = nt),
          (nt.prototype.initDefaultProviders = function () {
            this.addProtocolProvider('tile', B),
              this.addProtocolProvider('3d-tiles', Y),
              this.addProtocolProvider('pointcloud', Z);
          }),
          (nt.prototype.runCommand = function (t, e, n) {
            var i = this,
              r = this.getProtocolProvider(t.layer.protocol);
            if (!r)
              throw new Error(
                'No known provider for layer '.concat(t.layer.id),
              );
            e.execute(t, r, n).then(function () {
              if (
                (t.view.notifyChange(t.requester, t.redraw),
                e.counters.executing < i.maxCommandsPerHost)
              ) {
                var n = i.deQueue(e);
                n && i.runCommand(n, e);
              }
            });
          }),
          (nt.prototype.execute = function (t) {
            var e = this,
              n = t.layer,
              i =
                n.source && n.source.url
                  ? new URL(n.source.url, document.location).host
                  : void 0;
            (t.promise = new Promise(function (e, n) {
              (t.resolve = e), (t.reject = n);
            })),
              i && !this.hostQueues.has(i) && this.hostQueues.set(i, et());
            var r = i ? this.hostQueues.get(i) : this.defaultQueue;
            return (
              (t.timestamp = Date.now()),
              r.queue(t),
              r.counters.executing < this.maxCommandsPerHost &&
                Promise.resolve().then(function () {
                  if (r.counters.executing < e.maxCommandsPerHost) {
                    var t = e.deQueue(r);
                    t && e.runCommand(t, r);
                  }
                }),
              t.promise
            );
          }),
          (nt.prototype.addProtocolProvider = function (t, e) {
            if ('function' != typeof e.executeCommand)
              throw new Error(
                "Can't add provider for ".concat(
                  t,
                  ': missing a executeCommand function.',
                ),
              );
            this.providers[t] = e;
          }),
          (nt.prototype.getProtocolProvider = function (t) {
            return this.providers[t] || z;
          }),
          (nt.prototype.commandsWaitingExecutionCount = function () {
            var t,
              e =
                this.defaultQueue.counters.pending +
                this.defaultQueue.counters.executing,
              n = K(this.hostQueues);
            try {
              for (n.s(); !(t = n.n()).done; ) {
                var i = t.value;
                e += i[1].counters.pending + i[1].counters.executing;
              }
            } catch (t) {
              n.e(t);
            } finally {
              n.f();
            }
            return e;
          }),
          (nt.prototype.commandsRunningCount = function () {
            var t,
              e = this.defaultQueue.counters.executing,
              n = K(this.hostQueues);
            try {
              for (n.s(); !(t = n.n()).done; ) {
                e += t.value[1].counters.executing;
              }
            } catch (t) {
              n.e(t);
            } finally {
              n.f();
            }
            return e;
          }),
          (nt.prototype.resetCommandsCount = function (t) {
            var e = this.defaultQueue.counters[t];
            this.defaultQueue.counters[t] = 0;
            var n,
              i = K(this.hostQueues);
            try {
              for (i.s(); !(n = i.n()).done; ) {
                var r = n.value;
                (e += r[1].counters[t]), (r[1].counters[t] = 0);
              }
            } catch (t) {
              i.e(t);
            } finally {
              i.f();
            }
            return e;
          }),
          (nt.prototype.deQueue = function (t) {
            for (
              var e = (function (t) {
                var e,
                  n,
                  i,
                  r = 0,
                  a = K(t);
                try {
                  for (a.s(); !(i = a.n()).done; ) {
                    var o = i.value[1];
                    o.q.length > 0 &&
                      ((r += o.priority),
                      (o.accumulator += o.priority),
                      (!e || o.accumulator > n) &&
                        ((e = o), (n = o.accumulator)));
                  }
                } catch (t) {
                  a.e(t);
                } finally {
                  a.f();
                }
                if (e) return (e.accumulator -= r), e.q;
              })(t.storages);
              e && e.length > 0;

            ) {
              var n = e.dequeue();
              if (!n.earlyDropFunction || !n.earlyDropFunction(n)) return n;
              t.counters.pending--, t.counters.cancelled++, n.reject(new F(n));
            }
          });
        var it = nt,
          rt = n(63),
          at = n(110);
        function ot(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return st(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return st(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function st(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function lt(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = g()(t);
            if (e) {
              var r = g()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return f()(this, n);
          };
        }
        var ct = {
            LAYERS_INITIALIZED: 'layers-initialized',
            LAYER_REMOVED: 'layer-removed',
            LAYER_ADDED: 'layer-added',
            INITIALIZED: 'initialized',
            COLOR_LAYERS_ORDER_CHANGED: _.a,
          },
          ut = function (t, e) {
            t.object3d && (t.object3d.visible = t.visible),
              t.threejsLayer &&
                (t.visible
                  ? e.camera.camera3D.layers.enable(t.threejsLayer)
                  : e.camera.camera3D.layers.disable(t.threejsLayer));
          };
        var ht,
          dt = new y.Vector2(),
          pt = new y.Matrix4(),
          ft = new y.Vector2(),
          mt = new y.Ray(),
          gt = new y.Vector3(),
          yt = new y.Vector3(),
          vt = new I.a('EPSG:4326'),
          xt = [],
          bt = (function (t) {
            d()(n, t);
            var e = lt(n);
            function n(t, i) {
              var r,
                a,
                s =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : {};
              if ((o()(this, n), !i))
                throw new Error(
                  'Invalid viewerDiv parameter (must non be null/undefined)',
                );
              ((r = e.call(this)).domElement = i),
                (r.referenceCrs = t),
                (vt.crs = t),
                (a =
                  s.renderer && s.renderer.domElement
                    ? new C(s.renderer)
                    : new C(i, s.renderer)),
                (r.mainLoop = s.mainLoop || new x.c(new it(), a)),
                (r.scene = s.scene3D || new y.Scene()),
                s.scene3D || (r.scene.autoUpdate = !1),
                (r.camera = new v.b(
                  r.referenceCrs,
                  r.mainLoop.gfxEngine.getWindowSize().x,
                  r.mainLoop.gfxEngine.getWindowSize().y,
                  s.camera,
                )),
                (r._frameRequesters = {}),
                (r._layers = []),
                window.addEventListener(
                  'resize',
                  function () {
                    return r.resize();
                  },
                  !1,
                ),
                (r._changeSources = new Set()),
                (r._delayedFrameRequesterRemoval = []),
                (r._allLayersAreReadyCallback = function () {
                  r.getLayers().every(function (t) {
                    return t.ready;
                  }) &&
                    0 == r.mainLoop.scheduler.commandsWaitingExecutionCount() &&
                    r.mainLoop.renderingState == x.b &&
                    (r.dispatchEvent({ type: ct.LAYERS_INITIALIZED }),
                    r.removeFrameRequester(
                      x.a.UPDATE_END,
                      r._allLayersAreReadyCallback,
                    ));
                }),
                r.camera.resize(
                  r.domElement.clientWidth,
                  r.domElement.clientHeight,
                );
              var l = function () {
                r.removeEventListener(ct.LAYERS_INITIALIZED, l),
                  r.dispatchEvent({ type: ct.INITIALIZED });
              };
              return (
                r.addEventListener(ct.LAYERS_INITIALIZED, l),
                (r._fullSizeDepthBuffer = new Uint8Array(
                  4 * r.camera.width * r.camera.height,
                )),
                (r._pixelDepthBuffer = new Uint8Array(4)),
                (r.domElement.tabIndex = -1),
                r.domElement.focus(),
                xt.push(u()(r)),
                r
              );
            }
            return (
              l()(n, [
                {
                  key: 'dispose',
                  value: function () {
                    var t = xt.indexOf(this);
                    if (-1 != t) {
                      this.controls &&
                        this.controls.dispose &&
                        this.controls.dispose(),
                        this.removeAllFrameRequesters(),
                        this.removeAllEvents();
                      var e,
                        n = ot(
                          this.getLayers(function (t) {
                            return !t.isTiledGeometryLayer && !t.isAtmosphere;
                          }),
                        );
                      try {
                        for (n.s(); !(e = n.n()).done; ) {
                          var i = e.value;
                          this.removeLayer(i.id);
                        }
                      } catch (t) {
                        n.e(t);
                      } finally {
                        n.f();
                      }
                      var r,
                        a = ot(
                          this.getLayers(function (t) {
                            return t.isAtmosphere;
                          }),
                        );
                      try {
                        for (a.s(); !(r = a.n()).done; ) {
                          var o = r.value;
                          this.removeLayer(o.id);
                        }
                      } catch (t) {
                        a.e(t);
                      } finally {
                        a.f();
                      }
                      var s,
                        l = ot(
                          this.getLayers(function (t) {
                            return t.isTiledGeometryLayer;
                          }),
                        );
                      try {
                        for (l.s(); !(s = l.n()).done; ) {
                          var c = s.value;
                          this.removeLayer(c.id);
                        }
                      } catch (t) {
                        l.e(t);
                      } finally {
                        l.f();
                      }
                      xt.splice(t, 1);
                    } else console.warn('View already disposed');
                  },
                },
                {
                  key: 'addLayer',
                  value: function (t, e) {
                    var n = this;
                    if (!t || !t.isLayer)
                      return Promise.reject(new Error('Add Layer type object'));
                    if (this.getLayerById(t.id))
                      return t._reject(
                        new Error(
                          "Invalid id '".concat(t.id, "': id already used"),
                        ),
                      );
                    if (
                      ((t = (function (t, e, n) {
                        var i = e.source;
                        if (
                          (n &&
                            !e.extent &&
                            ((e.extent = n.extent),
                            i && !i.extent && (i.extent = n.extent)),
                          e.isGeometryLayer
                            ? (n &&
                                (e.threejsLayer =
                                  t.mainLoop.gfxEngine.getUniqueThreejsLayer()),
                              e.defineLayerProperty('visible', !0, function () {
                                return ut(e, t);
                              }),
                              ut(e, t),
                              (e.crs = t.referenceCrs))
                            : e.crs ||
                              (n &&
                              n.tileMatrixSets &&
                              n.tileMatrixSets.includes(k.a.formatToTms(i.crs))
                                ? (e.crs = i.crs)
                                : (e.crs = n && n.extent.crs)),
                          e.isLabelLayer)
                        )
                          t.mainLoop.gfxEngine.label2dRenderer.registerLayer(e);
                        else if (e.labelEnabled || e.addLabelLayer) {
                          e.labelEnabled &&
                            console.info(
                              'layer.labelEnabled is deprecated use addLabelLayer, instead of',
                            ),
                            (e.buildExtent = !0);
                          var r = new at.a(''.concat(e.id, '-label'), {
                            source: i,
                            style: e.style,
                            zoom: e.zoom,
                            crs: i.crs,
                            visible: e.visible,
                          });
                          e.addEventListener(
                            'visible-property-changed',
                            function () {
                              r.visible = e.visible;
                            },
                          );
                          var a = function (n) {
                            n.layerId === e.id && t.removeLayer(r.id),
                              t.removeEventListener(ct.LAYER_REMOVED, a);
                          };
                          t.addEventListener(ct.LAYER_REMOVED, a),
                            (e.whenReady = e.whenReady.then(function () {
                              return t.addLayer(r), e;
                            }));
                        }
                        return e;
                      })(this, t, e)),
                      e)
                    )
                      if (t.isColorLayer) {
                        var i = this.getLayers(function (t) {
                          return t.isColorLayer;
                        });
                        if (
                          ((t.sequence = i.length),
                          !(
                            e.countColorLayersTextures.apply(
                              e,
                              r()(i).concat([t]),
                            ) <= Object(w.d)()
                          ))
                        )
                          return t._reject(
                            new Error(
                              'Cant add color layer '.concat(
                                t.id,
                                ': the maximum layer is reached',
                              ),
                            ),
                          );
                        e.attach(t);
                      } else
                        t.isElevationLayer &&
                        'image/x-bil;bits=32' == t.source.format
                          ? ((t.source.networkOptions.isWebGL2 =
                              this.mainLoop.gfxEngine.renderer.capabilities.isWebGL2),
                            e.attach(t))
                          : e.attach(t);
                    else {
                      if ('function' != typeof t.update)
                        return t._reject(
                          new Error(
                            'Cant add GeometryLayer: missing a update function',
                          ),
                        );
                      if ('function' != typeof t.preUpdate)
                        return t._reject(
                          new Error(
                            'Cant add GeometryLayer: missing a preUpdate function',
                          ),
                        );
                      this._layers.push(t);
                    }
                    return (
                      t.object3d &&
                        !t.object3d.parent &&
                        t.object3d !== this.scene &&
                        this.scene.add(t.object3d),
                      Promise.all(t._promises).then(function () {
                        t._resolve(),
                          n.notifyChange(e || t, !1),
                          (n._frameRequesters[x.a.UPDATE_END] &&
                            n._frameRequesters[x.a.UPDATE_END].includes(
                              n._allLayersAreReadyCallback,
                            )) ||
                            n.addFrameRequester(
                              x.a.UPDATE_END,
                              n._allLayersAreReadyCallback,
                            ),
                          n.dispatchEvent({
                            type: ct.LAYER_ADDED,
                            layerId: t.id,
                          });
                      }, t._reject),
                      t.whenReady
                    );
                  },
                },
                {
                  key: 'removeLayer',
                  value: function (t) {
                    var e = this.getLayerById(t);
                    if (e) {
                      var n = e.parent;
                      if ((e.delete(), n && !n.detach(e)))
                        throw new Error(
                          'Error to detach '.concat(t, ' from ').concat(n.id),
                        );
                      if (
                        (null == n &&
                          this._layers.splice(
                            this._layers.findIndex(function (e) {
                              return e.id == t;
                            }),
                            1,
                          ),
                        e.isColorLayer)
                      ) {
                        var i,
                          r = ot(
                            this.getLayers(function (t) {
                              return t.isColorLayer;
                            }),
                          );
                        try {
                          for (r.s(); !(i = r.n()).done; ) {
                            var a = i.value;
                            a.sequence > e.sequence && a.sequence--;
                          }
                        } catch (t) {
                          r.e(t);
                        } finally {
                          r.f();
                        }
                      }
                      var o,
                        s = 0,
                        l = ot(xt);
                      try {
                        for (l.s(); !(o = l.n()).done; ) {
                          s += o.value.getLayers(function (t) {
                            return (
                              t.source.uid == e.source.uid && t.crs == e.crs
                            );
                          }).length;
                        }
                      } catch (t) {
                        l.e(t);
                      } finally {
                        l.f();
                      }
                      return (
                        e.source.onLayerRemoved({
                          unusedCrs: 0 == s ? e.crs : void 0,
                        }),
                        this.notifyChange(this.camera),
                        this.dispatchEvent({
                          type: ct.LAYER_REMOVED,
                          layerId: t,
                        }),
                        !0
                      );
                    }
                    throw new Error(''.concat(t, " doesn't exist"));
                  },
                },
                {
                  key: 'notifyChange',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : void 0,
                      e =
                        !(arguments.length > 1 && void 0 !== arguments[1]) ||
                        arguments[1];
                    t &&
                      (this._changeSources.add(t),
                      (t.isTileMesh || t.isCamera) &&
                        (this._fullSizeDepthBuffer.needsUpdate = !0)),
                      this.mainLoop.scheduleViewUpdate(this, e);
                  },
                },
                {
                  key: 'getLayers',
                  value: function (t) {
                    var e,
                      n = [],
                      i = ot(this._layers);
                    try {
                      for (i.s(); !(e = i.n()).done; ) {
                        var r = e.value;
                        if (((t && !t(r)) || n.push(r), r.attachedLayers)) {
                          var a,
                            o = ot(r.attachedLayers);
                          try {
                            for (o.s(); !(a = o.n()).done; ) {
                              var s = a.value;
                              (t && !t(s, r)) || n.push(s);
                            }
                          } catch (t) {
                            o.e(t);
                          } finally {
                            o.f();
                          }
                        }
                      }
                    } catch (t) {
                      i.e(t);
                    } finally {
                      i.f();
                    }
                    return n;
                  },
                },
                {
                  key: 'getLayerById',
                  value: function (t) {
                    return this.getLayers(function (e) {
                      return e.id === t;
                    })[0];
                  },
                },
                {
                  key: 'addFrameRequester',
                  value: function (t, e) {
                    if ('function' != typeof e)
                      throw new Error('frameRequester must be a function');
                    this._frameRequesters[t]
                      ? this._frameRequesters[t].push(e)
                      : (this._frameRequesters[t] = [e]);
                  },
                },
                {
                  key: 'removeFrameRequester',
                  value: function (t, e) {
                    this._frameRequesters[t].includes(e)
                      ? this._delayedFrameRequesterRemoval.push({
                          when: t,
                          frameRequester: e,
                        })
                      : console.error(
                          "Invalid call to removeFrameRequester: frameRequester isn't registered",
                        );
                  },
                },
                {
                  key: 'removeAllFrameRequesters',
                  value: function () {
                    for (var t in this._frameRequesters)
                      if (
                        Object.prototype.hasOwnProperty.call(
                          this._frameRequesters,
                          t,
                        )
                      ) {
                        var e,
                          n = ot(this._frameRequesters[t]);
                        try {
                          for (n.s(); !(e = n.n()).done; ) {
                            var i = e.value;
                            this.removeFrameRequester(t, i);
                          }
                        } catch (t) {
                          n.e(t);
                        } finally {
                          n.f();
                        }
                      }
                    this._executeFrameRequestersRemovals();
                  },
                },
                {
                  key: 'removeAllEvents',
                  value: function () {
                    if (void 0 !== this._listeners) {
                      for (var t in this._listeners)
                        Object.prototype.hasOwnProperty.call(
                          this._listeners,
                          t,
                        ) && delete this._listeners[t];
                      this._listeners = void 0;
                    }
                  },
                },
                {
                  key: '_executeFrameRequestersRemovals',
                  value: function () {
                    var t,
                      e = ot(this._delayedFrameRequesterRemoval);
                    try {
                      for (e.s(); !(t = e.n()).done; ) {
                        var n = t.value,
                          i = this._frameRequesters[n.when].indexOf(
                            n.frameRequester,
                          );
                        i >= 0
                          ? this._frameRequesters[n.when].splice(i, 1)
                          : console.warn('FrameReq has already been removed');
                      }
                    } catch (t) {
                      e.e(t);
                    } finally {
                      e.f();
                    }
                    this._delayedFrameRequesterRemoval.length = 0;
                  },
                },
                {
                  key: 'execFrameRequesters',
                  value: function (t, e, n) {
                    if (this._frameRequesters[t]) {
                      this._delayedFrameRequesterRemoval.length > 0 &&
                        this._executeFrameRequestersRemovals();
                      for (
                        var i = arguments.length,
                          r = new Array(i > 3 ? i - 3 : 0),
                          a = 3;
                        a < i;
                        a++
                      )
                        r[a - 3] = arguments[a];
                      var o,
                        s = ot(this._frameRequesters[t]);
                      try {
                        for (s.s(); !(o = s.n()).done; ) {
                          var l = o.value;
                          l.update ? l.update(e, n, r) : l(e, n, r);
                        }
                      } catch (t) {
                        s.e(t);
                      } finally {
                        s.f();
                      }
                    }
                  },
                },
                {
                  key: 'eventToViewCoords',
                  value: function (t) {
                    var e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : dt,
                      n =
                        arguments.length > 2 && void 0 !== arguments[2]
                          ? arguments[2]
                          : 0,
                      i = this.domElement.getBoundingClientRect();
                    if (void 0 !== t.touches && t.touches.length)
                      return e.set(
                        t.touches[n].clientX - i.x,
                        t.touches[n].clientY - i.y,
                      );
                    var r = t.target.getBoundingClientRect();
                    return e.set(r.x + t.offsetX - i.x, r.y + t.offsetY - i.y);
                  },
                },
                {
                  key: 'eventToNormalizedCoords',
                  value: function (t) {
                    var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0;
                    return this.viewToNormalizedCoords(
                      this.eventToViewCoords(t, dt, e),
                    );
                  },
                },
                {
                  key: 'viewToNormalizedCoords',
                  value: function (t) {
                    var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : dt;
                    return (
                      (e.x = (t.x / this.camera.width) * 2 - 1),
                      (e.y = (t.y / this.camera.height) * -2 + 1),
                      e
                    );
                  },
                },
                {
                  key: 'normalizedToViewCoords',
                  value: function (t) {
                    return (
                      (dt.x = 0.5 * (t.x + 1) * this.camera.width),
                      (dt.y = -0.5 * (t.y - 1) * this.camera.height),
                      dt
                    );
                  },
                },
                {
                  key: 'pickObjectsAt',
                  value: function (t) {
                    for (
                      var e = this,
                        n =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : 0,
                        i = arguments.length,
                        r = new Array(i > 2 ? i - 2 : 0),
                        a = 2;
                      a < i;
                      a++
                    )
                      r[a - 2] = arguments[a];
                    var o = [];
                    if (
                      ((r =
                        0 == r.length
                          ? this.getLayers(function (t) {
                              return t.isGeometryLayer;
                            })
                          : r).forEach(function (t) {
                        'string' == typeof t && (t = e.getLayerById(t)),
                          t && (t.isGeometryLayer || t.isObject3D) && o.push(t);
                      }),
                      0 == o.length)
                    )
                      return [];
                    for (
                      var s = [],
                        l = t instanceof Event ? this.eventToViewCoords(t) : t,
                        c = 0,
                        u = o;
                      c < u.length;
                      c++
                    ) {
                      var h = u[c];
                      if (h.isGeometryLayer) {
                        if (!h.ready) {
                          console.warn(
                            'view.pickObjectAt : layer is not ready : ',
                            h,
                          );
                          continue;
                        }
                        h.pickObjectsAt(this, l, n, s);
                      } else rt.a.pickObjectsAt(this, l, n, h, s);
                    }
                    return s;
                  },
                },
                {
                  key: 'getScale',
                  value: function () {
                    var t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0.28;
                    return this.getScaleFromDistance(
                      t,
                      this.getDistanceFromCamera(),
                    );
                  },
                },
                {
                  key: 'getScaleFromDistance',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 0.28,
                      e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 1;
                    t /= 1e3;
                    var n = y.MathUtils.degToRad(this.camera.camera3D.fov),
                      i = this.camera.height / (2 * e * Math.tan(0.5 * n));
                    return t * i;
                  },
                },
                {
                  key: 'getDistanceFromCamera',
                  value: function (t) {
                    return (
                      this.getPickingPositionFromDepth(t, yt),
                      this.camera.camera3D.position.distanceTo(yt)
                    );
                  },
                },
                {
                  key: 'getPixelsToMeters',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 1,
                      e = arguments.length > 1 ? arguments[1] : void 0;
                    return this.camera.camera3D.isOrthographicCamera
                      ? (t *
                          (ht =
                            (this.camera.camera3D.right -
                              this.camera.camera3D.left) /
                            this.camera.camera3D.zoom)) /
                          this.camera.width
                      : this.getPixelsToMetersFromDistance(
                          t,
                          this.getDistanceFromCamera(e),
                        );
                  },
                },
                {
                  key: 'getPixelsToMetersFromDistance',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 1,
                      e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 1;
                    return (t * e) / this.camera._preSSE;
                  },
                },
                {
                  key: 'getMetersToPixels',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 1,
                      e = arguments.length > 1 ? arguments[1] : void 0;
                    return this.camera.camera3D.isOrthographicCamera
                      ? ((ht =
                          (this.camera.camera3D.right -
                            this.camera.camera3D.left) /
                          this.camera.camera3D.zoom),
                        (t * this.camera.width) / ht)
                      : this.getMetersToPixelsFromDistance(
                          t,
                          this.getDistanceFromCamera(e),
                        );
                  },
                },
                {
                  key: 'getMetersToPixelsFromDistance',
                  value: function () {
                    var t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : 1,
                      e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 1;
                    return (this.camera._preSSE * t) / e;
                  },
                },
                {
                  key: 'pickFeaturesAt',
                  value: function (t) {
                    for (
                      var e = this,
                        n =
                          arguments.length > 1 && void 0 !== arguments[1]
                            ? arguments[1]
                            : 3,
                        i = arguments.length,
                        a = new Array(i > 2 ? i - 2 : 0),
                        o = 2;
                      o < i;
                      o++
                    )
                      a[o - 2] = arguments[o];
                    Array.isArray(a[0]) &&
                      (console.warn(
                        'Deprecated: the ...where argument of View#pickFeaturesAt should not be an array anymore, but a list: use the spread operator if needed.',
                      ),
                      (a = a[0]));
                    var s = [],
                      l = {};
                    (a =
                      0 == a.length
                        ? this.getLayers(function (t) {
                            return t.isColorLayer || t.isGeometryLayer;
                          })
                        : a).forEach(function (t) {
                      'string' == typeof t && (t = e.getLayerById(t)),
                        t &&
                          t.isLayer &&
                          ((l[t.id] = []), t.isColorLayer && s.push(t.id));
                    });
                    var c =
                        t instanceof Event ? this.eventToViewCoords(t, dt) : t,
                      u = this.pickObjectsAt.apply(this, [c, n].concat(r()(a)));
                    if (
                      (u.length > 0 &&
                        u.forEach(function (t) {
                          return l[t.layer.id].push(t);
                        }),
                      0 == s.length)
                    )
                      return l;
                    this.getPickingPositionFromDepth(c, yt);
                    var h,
                      d = this.camera.camera3D.position.distanceTo(yt);
                    vt.setFromVector3(yt);
                    var p = {
                      M: this.getPixelsToMetersFromDistance(n, d),
                      D: 0.001 * n,
                    };
                    this.isPlanarView
                      ? (p.D = p.M)
                      : this.getPixelsToDegrees &&
                        (p.D = this.getMetersToDegrees(p.M));
                    var f,
                      m = rt.a.pickTilesAt(this, c, n, this.tileLayer),
                      g = ot(m);
                    try {
                      for (g.s(); !(f = g.n()).done; ) {
                        var y = f.value;
                        if (y.object.material) {
                          var v,
                            x = ot(y.object.material.getLayers(s));
                          try {
                            for (x.s(); !(v = x.n()).done; ) {
                              var b,
                                _ = v.value,
                                w = ot(_.textures);
                              try {
                                for (w.s(); !(b = w.n()).done; ) {
                                  var M = b.value;
                                  M.features &&
                                    ((h = k.a.isMetricUnit(M.features.crs)
                                      ? p.M
                                      : p.D),
                                    (l[_.id] = l[_.id].concat(
                                      D.a.filterFeaturesUnderCoordinate(
                                        vt,
                                        M.features,
                                        h,
                                      ),
                                    )));
                                }
                              } catch (t) {
                                w.e(t);
                              } finally {
                                w.f();
                              }
                            }
                          } catch (t) {
                            x.e(t);
                          } finally {
                            x.f();
                          }
                        }
                      }
                    } catch (t) {
                      g.e(t);
                    } finally {
                      g.f();
                    }
                    return l;
                  },
                },
                {
                  key: 'readDepthBuffer',
                  value: function (t, e, n, i, r) {
                    var a = this.mainLoop.gfxEngine,
                      o = this.tileLayer.wireframe,
                      s = this.tileLayer.opacity,
                      l = this.tileLayer.visible;
                    o && (this.tileLayer.wireframe = !1),
                      s < 1 && (this.tileLayer.opacity = 1),
                      l || (this.tileLayer.visible = !0);
                    var c = this.tileLayer.level0Nodes.map(function (t) {
                      return P.a.push(t, P.a.MODES.DEPTH);
                    });
                    return (
                      (r = a.renderViewToBuffer(
                        { camera: this.camera, scene: this.tileLayer.object3d },
                        { x: t, y: e, width: n, height: i, buffer: r },
                      )),
                      c.forEach(function (t) {
                        return t();
                      }),
                      this.tileLayer.wireframe !== o &&
                        (this.tileLayer.wireframe = o),
                      this.tileLayer.opacity !== s &&
                        (this.tileLayer.opacity = s),
                      this.tileLayer.visible !== l &&
                        (this.tileLayer.visible = l),
                      r
                    );
                  },
                },
                {
                  key: 'getPickingPositionFromDepth',
                  value: function (t) {
                    var e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : new y.Vector3();
                    if (
                      this.tileLayer &&
                      0 != this.tileLayer.level0Nodes.length &&
                      this.tileLayer.level0Nodes[0]
                    ) {
                      var n = this.mainLoop,
                        i =
                          0 == n.scheduler.commandsWaitingExecutionCount() &&
                          n.renderingState == x.b,
                        r = n.gfxEngine,
                        a = r.getWindowSize(),
                        o = this.camera.camera3D;
                      ((t = t || a.clone().multiplyScalar(0.5)).x = Math.floor(
                        t.x,
                      )),
                        (t.y = Math.floor(t.y));
                      var s,
                        l = o.layers.mask;
                      if (
                        ((o.layers.mask = 1 << this.tileLayer.threejsLayer), i)
                      ) {
                        this._fullSizeDepthBuffer.needsUpdate &&
                          (this.readDepthBuffer(
                            0,
                            0,
                            a.x,
                            a.y,
                            this._fullSizeDepthBuffer,
                          ),
                          (this._fullSizeDepthBuffer.needsUpdate = !1));
                        var c = 4 * ((a.y - t.y - 1) * a.x + t.x);
                        s = this._fullSizeDepthBuffer.slice(c, c + 4);
                      } else
                        s = this.readDepthBuffer(
                          t.x,
                          t.y,
                          1,
                          1,
                          this._pixelDepthBuffer,
                        );
                      if (
                        ((ft.x = (t.x / a.x) * 2 - 1),
                        (ft.y = (-t.y / a.y) * 2 + 1),
                        b.a.isLogDepthBufferSupported() &&
                          'PerspectiveCamera' == o.type)
                      ) {
                        mt.origin.copy(o.position),
                          mt.direction.set(ft.x, ft.y, 0.5),
                          pt.multiplyMatrices(
                            o.matrixWorld,
                            pt.copy(o.projectionMatrix).invert(),
                          ),
                          mt.direction.applyMatrix4(pt),
                          mt.direction.sub(mt.origin),
                          gt.set(0, 0, 1),
                          gt.applyMatrix4(pt),
                          gt.sub(mt.origin);
                        var u = gt.angleTo(mt.direction),
                          h = r.depthBufferRGBAValueToOrthoZ(s, o),
                          d = h / Math.cos(u);
                        e.addVectors(o.position, mt.direction.setLength(d));
                      } else {
                        var p = r.depthBufferRGBAValueToOrthoZ(s, o);
                        e.set(ft.x, ft.y, p), e.unproject(o);
                      }
                      if (((o.layers.mask = l), !(e.length() > 1e7))) return e;
                    } else e = void 0;
                  },
                },
                {
                  key: 'resize',
                  value: function (t, e) {
                    null == t && (t = this.domElement.clientWidth),
                      null == e && (e = this.domElement.clientHeight),
                      (this._fullSizeDepthBuffer = new Uint8Array(4 * t * e)),
                      this.mainLoop.gfxEngine.onWindowResize(t, e),
                      this.camera.resize(t, e),
                      this.notifyChange(this.camera.camera3D);
                  },
                },
              ]),
              n
            );
          })(y.EventDispatcher);
        e.b = bt;
      },
      54: function (t, e) {
        function n(e) {
          return (
            'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
              ? ((t.exports = n =
                  function (t) {
                    return typeof t;
                  }),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0))
              : ((t.exports = n =
                  function (t) {
                    return t &&
                      'function' == typeof Symbol &&
                      t.constructor === Symbol &&
                      t !== Symbol.prototype
                      ? 'symbol'
                      : typeof t;
                  }),
                (t.exports.default = t.exports),
                (t.exports.__esModule = !0)),
            n(e)
          );
        }
        (t.exports = n),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      55: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(16),
          l = n(39),
          c = n(20),
          u = n(88);
        function h(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return d(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return d(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function d(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        var p = new l.b(),
          f = document.createElement('canvas'),
          m = {};
        function g() {
          var t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : { z: 0 };
          return t.z;
        }
        function y(t, e, n, i) {
          n[t] = n[t] || {};
          var r,
            a = h(m[t]);
          try {
            for (a.s(); !(r = a.n()).done; ) {
              var o = r.value,
                s = x(e[t][o], i);
              void 0 !== s && (n[t][o] = s);
            }
          } catch (t) {
            a.e(t);
          } finally {
            a.f();
          }
        }
        function v(t) {
          if (!t) return {};
          if (t.stops || t.expression) return { color: t };
          if ('string' == typeof t) {
            var e = t.match(
              /(?:((hsl|rgb)a? *\(([\d.%]+(?:deg|g?rad|turn)?)[ ,]*([\d.%]+)[ ,]*([\d.%]+)[ ,/]*([\d.%]*)\))|(#((?:[\d\w]{3}){1,2})([\d\w]{1,2})?))/i,
            );
            if (!e) return { color: t, opacity: 1 };
            if (e[7]) {
              var n = 1;
              return (
                e[9] &&
                  (n =
                    parseInt(
                      1 == e[9].length ? ''.concat(e[9]).concat(e[9]) : e[9],
                      16,
                    ) *
                    (1 / 255)),
                { color: '#'.concat(e[8]), opacity: n }
              );
            }
            if (e[0])
              return {
                color: ''
                  .concat(e[2], '(')
                  .concat(e[3], ',')
                  .concat(e[4], ',')
                  .concat(e[5], ')'),
                opacity: Number(e[6]) || 1,
              };
          }
        }
        function x(t, e) {
          if (null != t) {
            if (t.expression) return t.expression.evaluate(e);
            if (t.stops) {
              for (var n = t.stops.length - 1; n >= 0; n--) {
                var i = t.stops[n];
                if (e.globals.zoom >= i[0]) return i[1];
              }
              return t.stops[0][1];
            }
            return t instanceof Function ? t(e.properties()) : t;
          }
        }
        function b(t, e) {
          if (null != t)
            return u.a.isExpression(t)
              ? u.a.createExpression(t, e).value
              : t.base || t;
        }
        function _(t, e) {
          var n = document.createElement('img');
          if ('string' == typeof t) n.src = t;
          else if (t && t[e]) {
            var i = t[e];
            (f.width = i.width),
              (f.height = i.height),
              f
                .getContext('2d')
                .drawImage(
                  t.img,
                  i.x,
                  i.y,
                  i.width,
                  i.height,
                  0,
                  0,
                  i.width,
                  i.height,
                ),
              (n.src = f.toDataURL('image/png'));
          }
          return n;
        }
        var w = {
          left: [0, -0.5],
          right: [-1, -0.5],
          top: [-0.5, 0],
          bottom: [-0.5, -1],
          'top-right': [-1, 0],
          'bottom-left': [0, -1],
          'bottom-right': [-1, -1],
          center: [-0.5, -0.5],
          'top-left': [0, 0],
        };
        function M(t, e, n, i, r) {
          var a;
          Object.defineProperty(t[e], n, {
            enumerable: !0,
            get: function () {
              return void 0 === a ? t.parent[e][n] || r : a;
            },
            set: function (t) {
              a = t;
            },
          }),
            (t[e][n] = i);
        }
        var q = (function () {
            function t() {
              var e = this,
                n =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : {},
                i = arguments.length > 1 ? arguments[1] : void 0;
              r()(this, t),
                (this.isStyle = !0),
                (this.order = 0),
                (this.parent = i || {
                  zoom: {},
                  fill: {},
                  stroke: {},
                  point: {},
                  text: {},
                }),
                (n.zoom = n.zoom || {}),
                (n.fill = n.fill || {}),
                (n.stroke = n.stroke || {}),
                (n.point = n.point || {}),
                (n.text = n.text || {}),
                (this.zoom = {}),
                M(this, 'zoom', 'min', n.zoom.min),
                M(this, 'zoom', 'max', n.zoom.max),
                (this.fill = {}),
                M(this, 'fill', 'color', n.fill.color),
                M(this, 'fill', 'opacity', n.fill.opacity, 1),
                M(this, 'fill', 'pattern', n.fill.pattern),
                M(this, 'fill', 'base_altitude', n.fill.base_altitude, g),
                M(this, 'fill', 'extrusion_height', n.fill.extrusion_height),
                'string' == typeof this.fill.pattern &&
                  c.a.texture(this.fill.pattern).then(function (t) {
                    e.fill.pattern = t.image;
                  }),
                (this.stroke = {}),
                M(this, 'stroke', 'color', n.stroke.color),
                M(this, 'stroke', 'opacity', n.stroke.opacity, 1),
                M(this, 'stroke', 'width', n.stroke.width, 1),
                M(this, 'stroke', 'dasharray', n.stroke.dasharray, []),
                M(this, 'stroke', 'base_altitude', n.stroke.base_altitude, g),
                (this.point = {}),
                M(this, 'point', 'color', n.point.color),
                M(this, 'point', 'line', n.point.line),
                M(this, 'point', 'opacity', n.point.opacity, 1),
                M(this, 'point', 'radius', n.point.radius, 2),
                M(this, 'point', 'width', n.point.width, 0),
                M(this, 'point', 'base_altitude', n.point.base_altitude, g),
                (this.text = {}),
                M(this, 'text', 'field', n.text.field),
                M(this, 'text', 'zOrder', n.text.zOrder, 'auto'),
                M(this, 'text', 'color', n.text.color, '#000000'),
                M(this, 'text', 'anchor', n.text.anchor, 'center'),
                M(this, 'text', 'offset', n.text.offset, [0, 0]),
                M(this, 'text', 'padding', n.text.padding, 2),
                M(this, 'text', 'size', n.text.size, 16),
                M(this, 'text', 'placement', n.text.placement, 'point'),
                M(this, 'text', 'rotation', n.text.rotation, 'auto'),
                M(this, 'text', 'wrap', n.text.wrap, 10),
                M(this, 'text', 'spacing', n.text.spacing, 0),
                M(this, 'text', 'transform', n.text.transform, 'none'),
                M(this, 'text', 'justify', n.text.justify, 'center'),
                M(this, 'text', 'opacity', n.text.opacity, 1),
                M(this, 'text', 'font', n.text.font, [
                  'Open Sans Regular',
                  'Arial Unicode MS Regular',
                  'sans-serif',
                ]),
                M(this, 'text', 'haloColor', n.text.haloColor, '#000000'),
                M(this, 'text', 'haloWidth', n.text.haloWidth, 0),
                M(this, 'text', 'haloBlur', n.text.haloBlur, 0);
            }
            return (
              o()(t, [
                {
                  key: 'drawingStylefromContext',
                  value: function (t) {
                    var e = {};
                    if (
                      ((this.fill.color ||
                        this.fill.pattern ||
                        t.globals.fill) &&
                        y('fill', this, e, t),
                      (this.stroke.color || t.globals.stroke) &&
                        y('stroke', this, e, t),
                      (this.point.color || t.globals.point) &&
                        y('point', this, e, t),
                      Object.keys(e).length)
                    )
                      return e;
                  },
                },
                {
                  key: 'symbolStylefromContext',
                  value: function (e) {
                    var n = new t();
                    return (
                      y('text', this, n, e),
                      this.icon && y('icon', this, n, e),
                      n
                    );
                  },
                },
                {
                  key: 'copy',
                  value: function (t) {
                    return (
                      Object.assign(this.fill, t.fill),
                      Object.assign(this.stroke, t.stroke),
                      Object.assign(this.point, t.point),
                      Object.assign(this.text, t.text),
                      this
                    );
                  },
                },
                {
                  key: 'clone',
                  value: function () {
                    return new t().copy(this);
                  },
                },
                {
                  key: 'setFromGeojsonProperties',
                  value: function (t, e) {
                    return (
                      e === s.a.POINT
                        ? ((this.point.color = t.fill),
                          (this.point.opacity = t['fill-opacity']),
                          (this.point.line = t.stroke),
                          (this.point.radius = t.radius),
                          (this.text.color = t['label-color']),
                          (this.text.opacity = t['label-opacity']),
                          (this.text.size = t['label-size']),
                          t.icon && (this.icon = { image: t.icon, size: 1 }))
                        : ((this.stroke.color = t.stroke),
                          (this.stroke.width = t['stroke-width']),
                          (this.stroke.opacity = t['stroke-opacity']),
                          e !== s.a.LINE &&
                            ((this.fill.color = t.fill),
                            (this.fill.opacity = t['fill-opacity']))),
                      this
                    );
                  },
                },
                {
                  key: 'setFromVectorTileLayer',
                  value: function (t, e) {
                    var n =
                        arguments.length > 2 && void 0 !== arguments[2]
                          ? arguments[2]
                          : 0,
                      i =
                        arguments.length > 3 &&
                        void 0 !== arguments[3] &&
                        arguments[3];
                    if (
                      ((t.layout = t.layout || {}),
                      (t.paint = t.paint || {}),
                      (this.order = n),
                      'fill' !== t.type || this.fill.color)
                    )
                      if ('line' !== t.type || this.stroke.color) {
                        if ('circle' === t.type || i) {
                          var r = v(
                              b(t.paint['circle-color'], { type: 'color' }),
                            ),
                            a = r.color,
                            o = r.opacity;
                          (this.point.color = a),
                            (this.point.opacity = o),
                            (this.point.radius = b(t.paint['circle-radius']));
                        } else if ('symbol' === t.type) {
                          (this.text.zOrder = b(t.layout['symbol-z-order'])),
                            'auto' == this.text.zOrder
                              ? (this.text.zOrder =
                                  b(t.layout['symbol-sort-key']) || 'Y')
                              : 'viewport-y' == this.text.zOrder
                              ? (this.text.zOrder = 'Y')
                              : 'source' == this.text.zOrder &&
                                (this.text.zOrder = 0),
                            (this.text.anchor = b(t.layout['text-anchor'])),
                            (this.text.offset = b(t.layout['text-offset'])),
                            (this.text.padding = b(t.layout['text-padding'])),
                            (this.text.size = b(t.layout['text-size'])),
                            (this.text.placement = b(
                              t.layout['symbol-placement'],
                            )),
                            (this.text.rotation = b(
                              t.layout['text-rotation-alignment'],
                            )),
                            (this.text.field = b(t.layout['text-field'])),
                            (this.text.wrap = b(t.layout['text-max-width'])),
                            (this.text.spacing = b(
                              t.layout['text-letter-spacing'],
                            )),
                            (this.text.transform = b(
                              t.layout['text-transform'],
                            )),
                            (this.text.justify = b(t.layout['text-justify']));
                          var s = v(
                              b(t.paint['text-color'], { type: 'color' }),
                            ),
                            l = s.color,
                            c = s.opacity;
                          (this.text.color = l),
                            (this.text.opacity =
                              b(t.paint['text-opacity']) ||
                              (void 0 !== c && c)),
                            (this.text.font = b(t.layout['text-font']));
                          var u = b(t.paint['text-halo-color'], {
                            type: 'color',
                          });
                          u &&
                            ((this.text.haloColor = u.color || u),
                            (this.text.haloWidth = b(
                              t.paint['text-halo-width'],
                            )),
                            (this.text.haloBlur = b(
                              t.paint['text-halo-blur'],
                            )));
                          var h = b(t.layout['icon-image']);
                          h &&
                            ((this.icon = { key: h }),
                            (this.icon.size = b(t.layout['icon-size']) || 1));
                        }
                      } else {
                        var d = b(t.paint['line-color'], { type: 'color' }),
                          p = v(d),
                          f = p.color,
                          m = p.opacity;
                        (this.stroke.dasharray = b(t.paint['line-dasharray'])),
                          (this.stroke.color = f),
                          (this.stroke.lineCap = t.layout['line-cap']),
                          (this.stroke.width = b(t.paint['line-width'])),
                          (this.stroke.opacity =
                            b(t.paint['line-opacity']) || m);
                      }
                    else {
                      var g = v(
                          b(t.paint['fill-color'] || t.paint['fill-pattern'], {
                            type: 'color',
                          }),
                        ),
                        y = g.color,
                        x = g.opacity;
                      if (
                        ((this.fill.color = y),
                        (this.fill.opacity = b(t.paint['fill-opacity']) || x),
                        t.paint['fill-pattern'] &&
                          e &&
                          (this.fill.pattern = _(e, t.paint['fill-pattern'])),
                        t.paint['fill-outline-color'])
                      ) {
                        var w = v(
                            b(t.paint['fill-outline-color'], { type: 'color' }),
                          ),
                          M = w.color,
                          q = w.opacity;
                        (this.stroke.color = M),
                          (this.stroke.opacity = q),
                          (this.stroke.width = 1),
                          (this.stroke.dasharray = []);
                      }
                    }
                    return this;
                  },
                },
                {
                  key: 'applyToHTML',
                  value: function (t, e) {
                    var n = this;
                    if (
                      ((t.style.padding = ''.concat(this.text.padding, 'px')),
                      (t.style.maxWidth = ''.concat(this.text.wrap, 'em')),
                      (t.style.color = this.text.color),
                      this.text.size > 0 &&
                        (t.style.fontSize = ''.concat(this.text.size, 'px')),
                      (t.style.fontFamily = this.text.font.join(',')),
                      (t.style.textTransform = this.text.transform),
                      (t.style.letterSpacing = ''.concat(
                        this.text.spacing,
                        'em',
                      )),
                      (t.style.textAlign = this.text.justify),
                      (t.style['white-space'] = 'pre-line'),
                      this.text.haloWidth > 0 &&
                        (t.style.setProperty('--text_stroke_display', 'block'),
                        t.style.setProperty(
                          '--text_stroke_width',
                          ''.concat(this.text.haloWidth, 'px'),
                        ),
                        t.style.setProperty(
                          '--text_stroke_color',
                          this.text.haloColor,
                        ),
                        t.setAttribute('data-before', t.textContent)),
                      this.icon)
                    ) {
                      var i = this.icon.image,
                        r = this.icon.size,
                        a = this.icon.key,
                        o = p.get(i || a, r);
                      o ||
                        (((o = a && e ? _(e, a) : _(i)).style.position =
                          'absolute'),
                        p.set(o, i || a, r));
                      var s = function () {
                        var e = o.cloneNode();
                        switch (
                          ((e.width *= r), (e.height *= r), n.text.anchor)
                        ) {
                          case 'left':
                            (e.style.right = 'calc(100% - '.concat(
                              0.5 * e.width,
                              'px)',
                            )),
                              (e.style.top = 'calc(50% - '.concat(
                                0.5 * e.height,
                                'px)',
                              ));
                            break;
                          case 'right':
                            e.style.top = 'calc(50% - '.concat(
                              0.5 * e.height,
                              'px)',
                            );
                            break;
                          case 'top':
                            e.style.right = 'calc(50% - '.concat(
                              0.5 * e.width,
                              'px)',
                            );
                            break;
                          case 'bottom':
                            (e.style.top = 'calc(100% - '.concat(
                              0.5 * e.height,
                              'px)',
                            )),
                              (e.style.right = 'calc(50% - '.concat(
                                0.5 * e.width,
                                'px)',
                              ));
                            break;
                          case 'bottom-left':
                            (e.style.top = 'calc(100% - '.concat(
                              0.5 * e.height,
                              'px)',
                            )),
                              (e.style.right = 'calc(100% - '.concat(
                                0.5 * e.width,
                                'px)',
                              ));
                            break;
                          case 'bottom-right':
                            e.style.top = 'calc(100% - '.concat(
                              0.5 * e.height,
                              'px)',
                            );
                            break;
                          case 'top-left':
                            e.style.right = 'calc(100% - '.concat(
                              0.5 * e.width,
                              'px)',
                            );
                            break;
                          case 'top-right':
                            break;
                          case 'center':
                          default:
                            (e.style.top = 'calc(50% - '.concat(
                              0.5 * e.height,
                              'px)',
                            )),
                              (e.style.right = 'calc(50% - '.concat(
                                0.5 * e.width,
                                'px)',
                              ));
                        }
                        (e.style['z-index'] = -1),
                          t.appendChild(e),
                          o.removeEventListener('load', s);
                      };
                      o.complete ? s() : o.addEventListener('load', s);
                    }
                  },
                },
                {
                  key: 'getTextAnchorPosition',
                  value: function () {
                    return w[this.text.anchor];
                  },
                },
                {
                  key: 'getTextFromProperties',
                  value: function (t) {
                    return this.text.field.expression
                      ? x(this.text.field, t)
                      : this.text.field
                          .replace(/\{(.+?)\}/g, function (e, n) {
                            return t.properties()[n] || '';
                          })
                          .trim();
                  },
                },
              ]),
              t
            );
          })(),
          S = {
            itowns_stroke_single_before:
              '.itowns-stroke-single:before {\n    display: var(--text_stroke_display);\n    content: attr(data-before);\n    opacity: 1;\n    position: absolute;\n    -webkit-text-stroke-width: var(--text_stroke_width);\n    -webkit-text-stroke-color: var(--text_stroke_color);\n    left: 0;\n    right: 0;\n    bottom: 0;\n    top: 0;\n    z-index: -1;\n    white-space: inherit;\n    overflow-wrap: inherit;\n    letter-spacing: inherit;\n    text-align: inherit;\n    padding: inherit;\n    font-family: inherit;\n    text-transform: inherit;\n    max-width: inherit;\n    font-size: inherit;\n}\n',
          },
          T = document.createElement('style');
        (T.type = 'text/css'),
          Object.keys(S).forEach(function (t) {
            T.innerHTML += ''.concat(S[t], '\n\n');
          }),
          document.getElementsByTagName('head')[0].appendChild(T);
        var E = new q();
        (m.fill = Object.keys(E.fill)),
          (m.stroke = Object.keys(E.stroke)),
          (m.point = Object.keys(E.point)),
          (m.text = Object.keys(E.text)),
          (m.icon = ['image', 'size', 'key']),
          (e.a = q);
      },
      59: function (t, e, n) {
        'use strict';
        var i = n(22),
          r = n.n(i);
        function a(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return o(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return o(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            s = !0,
            l = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (s = t.done), t;
            },
            e: function (t) {
              (l = !0), (a = t);
            },
            f: function () {
              try {
                s || null == n.return || n.return();
              } finally {
                if (l) throw a;
              }
            },
          };
        }
        function o(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        e.a = {
          cleanup: function (t) {
            if (((t.layer = null), 'function' == typeof t.dispose)) t.dispose();
            else if ((t.geometry && t.geometry.dispose(), t.material))
              if (Array.isArray(t.material)) {
                var e,
                  n = a(t.material);
                try {
                  for (n.s(); !(e = n.n()).done; ) {
                    e.value.dispose();
                  }
                } catch (t) {
                  n.e(t);
                } finally {
                  n.f();
                }
              } else t.material.dispose();
          },
          removeChildren: function (t, e) {
            var n = e.children.filter(function (e) {
              return (e.layer && e.layer.id) === t.id;
            });
            return e.remove.apply(e, r()(n)), n;
          },
          removeChildrenAndCleanup: function (t, e) {
            var n = e.children.filter(function (e) {
              return (e.layer && e.layer.id) === t.id;
            });
            return (
              e.remove.apply(e, r()(n)), e.layer === t && this.cleanup(e), n
            );
          },
          removeChildrenAndCleanupRecursively: function (t, e) {
            var n,
              i = e.children.filter(function (e) {
                return (e.layer && e.layer.id) === t.id;
              }),
              o = a(i);
            try {
              for (o.s(); !(n = o.n()).done; ) {
                var s = n.value;
                this.removeChildrenAndCleanupRecursively(t, s);
              }
            } catch (t) {
              o.e(t);
            } finally {
              o.f();
            }
            return (
              e.remove.apply(e, r()(i)),
              e.layer && e.layer.id === t.id && this.cleanup(e),
              i
            );
          },
        };
      },
      6: function (t, e, n) {
        var i = n(208);
        (t.exports = function (t, e) {
          if ('function' != typeof e && null !== e)
            throw new TypeError(
              'Super expression must either be null or a function',
            );
          (t.prototype = Object.create(e && e.prototype, {
            constructor: { value: t, writable: !0, configurable: !0 },
          })),
            e && i(t, e);
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      62: function (t, e, n) {
        'use strict';
        var i = new RegExp('gl_Position.*(?![^]*gl_Position)'),
          r = new RegExp('[^\\w]*main[^\\w]*(void)?[^\\w]*{');
        e.a = {
          patchMaterialForLogDepthSupport: function (t) {
            if (
              !t.vertexShader.includes('USE_LOGDEPTHBUF') &&
              !t.vertexShader.includes('logdepthbuf_pars_vertex')
            ) {
              t.vertexShader =
                '#include <logdepthbuf_pars_vertex>\n#define EPSILON 1e-6\n'.concat(
                  t.vertexShader,
                );
              var e = i.exec(t.vertexShader),
                n = e[0].length + e.index;
              (t.vertexShader = ''
                .concat(
                  t.vertexShader.slice(0, n),
                  '\n#include <logdepthbuf_vertex>\n',
                )
                .concat(t.vertexShader.slice(n))),
                (t.fragmentShader =
                  '#include <itowns/precision_qualifier\n'.concat(
                    t.fragmentShader,
                  )),
                (t.fragmentShader =
                  '#include <logdepthbuf_pars_fragment>\n'.concat(
                    t.fragmentShader,
                  )),
                (n = (e = r.exec(t.fragmentShader))[0].length + e.index),
                (t.fragmentShader = ''
                  .concat(
                    t.fragmentShader.slice(0, n),
                    '\n#include <logdepthbuf_fragment>\n',
                  )
                  .concat(t.fragmentShader.slice(n))),
                (t.defines = { USE_LOGDEPTHBUF: 1, USE_LOGDEPTHBUF_EXT: 1 });
            }
          },
          unrollLoops: function (t, e) {
            return t.replace(
              /#pragma unroll_loop\s+for\s*\(\s*int\s+i\s*=\s*([\w\d]+);\s*i\s+<\s+([\w\d]+);\s*i\s*\+\+\s*\)\s*\{\n([^}]*)\}/g,
              function (t, n, i, r) {
                var a = '';
                (n = n in e ? e[n] : parseInt(n, 10)),
                  (i = i in e ? e[i] : parseInt(i, 10));
                for (var o = n; o < i; o++)
                  a += r.replace(/\bi\b/g, ' '.concat(o, ' '));
                return a;
              },
            );
          },
        };
      },
      63: function (t, e, n) {
        'use strict';
        var i = n(0),
          r = n(49),
          a = n(29);
        function o(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return s(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return s(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            l = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (l = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (l) throw a;
              }
            },
          };
        }
        function s(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function l(t) {
          var e =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : 0,
            n = t.camera.camera3D.layers.mask;
          return (
            (t.camera.camera3D.layers.mask = 1 << e),
            function () {
              t.camera.camera3D.layers.mask = n;
            }
          );
        }
        var c = new i.Vector4();
        function u(t, e, n) {
          var o =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : 0,
            s = t.mainLoop.gfxEngine.getWindowSize();
          n = n || new i.Vector2(Math.floor(s.x / 2), Math.floor(s.y / 2));
          var u = e.level0Nodes.map(function (t) {
              return r.a.push(t, r.a.MODES.ID);
            }),
            d = l(t, e.object3d, e.threejsLayer),
            p = t.mainLoop.gfxEngine.renderViewToBuffer(
              { camera: t.camera, scene: e.object3d },
              { x: n.x - o, y: n.y - o, width: 1 + 2 * o, height: 1 + 2 * o },
            );
          d(),
            u.forEach(function (t) {
              return t();
            });
          var f = [];
          return (
            h(o, function (t, e) {
              var n = 4 * (2 * e * o + t),
                i = p.slice(n, n + 4 || void 0);
              c.fromArray(i).divideScalar(255);
              var r = Object(a.e)(c, Math.pow(256, 3)),
                s = Math.round(r);
              f.includes(s) || f.push(s);
            }),
            f
          );
        }
        function h(t, e) {
          for (var n, i = 0; i <= t; i++) {
            for (var r = i * i, a = -i; a <= i; a++)
              for (var o = a * a, s = -i; s <= i; s++) {
                var l = o + s * s;
                if (!(l > r) && !(l <= n) && !1 === e(a, s)) return;
              }
            n = r;
          }
        }
        function d(t) {
          return t.layer ? t.layer : t.parent ? d(t.parent) : void 0;
        }
        var p = new i.Raycaster();
        e.a = {
          pickTilesAt: function (t, e, n, i) {
            var r,
              a =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : [],
              s = u(t, i, e, n),
              l = function (t) {
                s.includes(t.id) &&
                  t.isTileMesh &&
                  a.push({ object: t, layer: i });
              },
              c = o(i.level0Nodes);
            try {
              for (c.s(); !(r = c.n()).done; ) {
                var h = r.value;
                h.traverse(l);
              }
            } catch (t) {
              c.e(t);
            } finally {
              c.f();
            }
            return a;
          },
          pickPointsAt: function (t, e, n, i) {
            var r =
              arguments.length > 4 && void 0 !== arguments[4]
                ? arguments[4]
                : [];
            if (i.root) {
              i.object3d.traverse(function (t) {
                t.isPoints && t.baseId && t.material.enablePicking(!0);
              });
              var a = l(t, i.object3d, i.threejsLayer),
                o = t.mainLoop.gfxEngine.renderViewToBuffer(
                  { camera: t.camera, scene: i.object3d },
                  {
                    x: e.x - n,
                    y: e.y - n,
                    width: 1 + 2 * n,
                    height: 1 + 2 * n,
                  },
                );
              a();
              var s = [];
              return (
                h(n, function (t, e) {
                  for (
                    var i = 4 * (2 * e * n + t),
                      r = o.slice(i, i + 4),
                      a = {
                        objId: (r[0] << 8) | r[1],
                        index: (r[2] << 8) | r[3],
                      },
                      l = 0;
                    l < s.length;
                    l++
                  )
                    if (s[l].objId == a.objId && s[l].index == a.index) return;
                  s.push(a);
                }),
                i.object3d.traverse(function (t) {
                  if (t.isPoints && t.baseId) {
                    t.material.enablePicking(!1);
                    for (var e = 0; e < s.length; e++)
                      s[e].objId == t.baseId &&
                        r.push({ object: t, index: s[e].index, layer: i });
                  }
                }),
                r
              );
            }
          },
          pickObjectsAt: function (t, e, n, r) {
            var a =
                arguments.length > 4 && void 0 !== arguments[4]
                  ? arguments[4]
                  : [],
              s = arguments.length > 5 ? arguments[5] : void 0;
            if (
              (void 0 !== s ? p.layers.set(s) : p.layers.enableAll(), n < 0)
            ) {
              var l = t.viewToNormalizedCoords(e);
              p.setFromCamera(l, t.camera.camera3D);
              var c,
                u = p.intersectObject(r, !0),
                f = o(u);
              try {
                for (f.s(); !(c = f.n()).done; ) {
                  var m = c.value;
                  (m.layer = d(m.object)), a.push(m);
                }
              } catch (t) {
                f.e(t);
              } finally {
                f.f();
              }
              return a;
            }
            var g = {
                x: e.x - n,
                y: e.y - n,
                width: 1 + 2 * n,
                height: 1 + 2 * n,
              },
              y = t.mainLoop.gfxEngine.renderViewToBuffer(
                { scene: r, camera: t.camera },
                g,
              ),
              v = new i.Color();
            t.mainLoop.gfxEngine.renderer.getClearColor(v);
            var x = Math.round(255 * v.r),
              b = Math.round(255 * v.g),
              _ = Math.round(255 * v.b),
              w = t.viewToNormalizedCoords(e),
              M = w.clone();
            return (
              h(n, function (e, i) {
                var s = 4 * ((i + n) * (2 * n + 1) + (e + n)),
                  l = y[s],
                  c = y[s + 1],
                  u = y[s + 2];
                if (
                  !(
                    Math.abs(x - l) <= 1 &&
                    Math.abs(b - c) <= 1 &&
                    Math.abs(_ - u) <= 1
                  )
                ) {
                  M.setX(w.x + e / t.camera.width).setY(
                    w.y + i / t.camera.height,
                  ),
                    p.setFromCamera(M, t.camera.camera3D);
                  var h,
                    f = o(p.intersectObject(r, !0));
                  try {
                    for (f.s(); !(h = f.n()).done; ) {
                      var m = h.value;
                      (m.layer = d(m.object)), a.push(m);
                    }
                  } catch (t) {
                    f.e(t);
                  } finally {
                    f.f();
                  }
                  return 0 == a.length;
                }
              }),
              a
            );
          },
        };
      },
      68: function (t, e, n) {
        'use strict';
        n.d(e, 'c', function () {
          return r;
        }),
          n.d(e, 'b', function () {
            return a;
          }),
          n.d(e, 'd', function () {
            return o;
          }),
          n.d(e, 'a', function () {
            return s;
          }),
          n.d(e, 'e', function () {
            return d;
          });
        var i = n(87),
          r = 0,
          a = 1,
          o = 2,
          s = 3;
        function l(t, e, n) {
          return t.pendingSubdivision ? n : e;
        }
        function c(t, e) {
          var n = e.groups.filter(function (e) {
            return e <= t;
          });
          return n.length ? n[n.length - 1] : e.groups[0];
        }
        function u(t, e, n) {
          return Math.min(t, e + (n.increment || 1));
        }
        function h(t, e) {
          var n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return e == i.a
            ? n.zoom
              ? n.zoom.min
              : 0
            : Math.min(t, Math.ceil((e + t) / 2));
        }
        function d(t, e) {
          var n,
            i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : e.level,
            d = arguments.length > 3 ? arguments[3] : void 0,
            p = arguments.length > 4 ? arguments[4] : void 0,
            f = arguments.length > 5 ? arguments[5] : void 0,
            m = p.source.zoom ? p.source.zoom.max : 1 / 0;
          if (f.lowestLevelError != 1 / 0)
            (n = h(f.lowestLevelError, d, p.source)),
              (n = f.lowestLevelError == n ? n - 1 : n),
              t == a && (n = c(n, p.updateStrategy.options));
          else {
            switch (t) {
              case a:
                n = c(i, p.updateStrategy.options);
                break;
              case o:
                n = u(i, d, p.updateStrategy.options);
                break;
              case s:
                n = h(i, d, p.source);
                break;
              case r:
              default:
                n = l(e, i, d);
            }
            n = Math.min(n, m);
          }
          return n;
        }
      },
      684: function (t, e, n) {
        t.exports = n(686);
      },
      686: function (t, e, n) {
        'use strict';
        n.r(e),
          n.d(e, 'Debug', function () {
            return Ma;
          }),
          n.d(e, 'PotreeDebug', function () {
            return Ea;
          }),
          n.d(e, 'createTileDebugUI', function () {
            return Ga;
          }),
          n.d(e, 'create3dTilesDebugUI', function () {
            return Va;
          }),
          n.d(e, 'GeometryDebug', function () {
            return za;
          });
        var i = n(0),
          r = n(8),
          a = n(19),
          o = n(86);
        const s =
          'undefined' == typeof window
            ? function (t) {
                return t();
              }
            : window.requestAnimationFrame;
        function l(t, e, n) {
          const i = n || ((t) => Array.prototype.slice.call(t));
          let r = !1,
            a = [];
          return function (...n) {
            (a = i(n)),
              r ||
                ((r = !0),
                s.call(window, () => {
                  (r = !1), t.apply(e, a);
                }));
          };
        }
        const c = (t) =>
            'start' === t ? 'left' : 'end' === t ? 'right' : 'center',
          u = (t, e, n) => ('start' === t ? e : 'end' === t ? n : (e + n) / 2);
        const h = (function () {
          let t = 0;
          return function () {
            return t++;
          };
        })();
        function d(t) {
          return null == t;
        }
        function p(t) {
          if (Array.isArray && Array.isArray(t)) return !0;
          const e = Object.prototype.toString.call(t);
          return '[object' === e.substr(0, 7) && 'Array]' === e.substr(-6);
        }
        function f(t) {
          return (
            null !== t &&
            '[object Object]' === Object.prototype.toString.call(t)
          );
        }
        const m = (t) =>
          ('number' == typeof t || t instanceof Number) && isFinite(+t);
        function g(t, e) {
          return m(t) ? t : e;
        }
        function y(t, e) {
          return void 0 === t ? e : t;
        }
        const v = (t, e) =>
          'string' == typeof t && t.endsWith('%')
            ? (parseFloat(t) / 100) * e
            : +t;
        function x(t, e, n) {
          if (t && 'function' == typeof t.call) return t.apply(n, e);
        }
        function b(t, e, n, i) {
          let r, a, o;
          if (p(t))
            if (((a = t.length), i))
              for (r = a - 1; r >= 0; r--) e.call(n, t[r], r);
            else for (r = 0; r < a; r++) e.call(n, t[r], r);
          else if (f(t))
            for (o = Object.keys(t), a = o.length, r = 0; r < a; r++)
              e.call(n, t[o[r]], o[r]);
        }
        function _(t, e) {
          let n, i, r, a;
          if (!t || !e || t.length !== e.length) return !1;
          for (n = 0, i = t.length; n < i; ++n)
            if (
              ((r = t[n]),
              (a = e[n]),
              r.datasetIndex !== a.datasetIndex || r.index !== a.index)
            )
              return !1;
          return !0;
        }
        function w(t) {
          if (p(t)) return t.map(w);
          if (f(t)) {
            const e = Object.create(null),
              n = Object.keys(t),
              i = n.length;
            let r = 0;
            for (; r < i; ++r) e[n[r]] = w(t[n[r]]);
            return e;
          }
          return t;
        }
        function M(t) {
          return -1 === ['__proto__', 'prototype', 'constructor'].indexOf(t);
        }
        function q(t, e, n, i) {
          if (!M(t)) return;
          const r = e[t],
            a = n[t];
          f(r) && f(a) ? S(r, a, i) : (e[t] = w(a));
        }
        function S(t, e, n) {
          const i = p(e) ? e : [e],
            r = i.length;
          if (!f(t)) return t;
          const a = (n = n || {}).merger || q;
          for (let o = 0; o < r; ++o) {
            if (!f((e = i[o]))) continue;
            const r = Object.keys(e);
            for (let i = 0, o = r.length; i < o; ++i) a(r[i], t, e, n);
          }
          return t;
        }
        function T(t, e) {
          return S(t, e, { merger: E });
        }
        function E(t, e, n) {
          if (!M(t)) return;
          const i = e[t],
            r = n[t];
          f(i) && f(r)
            ? T(i, r)
            : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = w(r));
        }
        function A(t, e) {
          const n = t.indexOf('.', e);
          return -1 === n ? t.length : n;
        }
        function L(t, e) {
          if ('' === e) return t;
          let n = 0,
            i = A(e, n);
          for (; t && i > n; )
            (t = t[e.substr(n, i - n)]), (n = i + 1), (i = A(e, n));
          return t;
        }
        function R(t) {
          return t.charAt(0).toUpperCase() + t.slice(1);
        }
        const C = (t) => void 0 !== t,
          P = (t) => 'function' == typeof t,
          k = Math.PI,
          I = 2 * k,
          D = I + k,
          O = Number.POSITIVE_INFINITY,
          N = k / 180,
          z = k / 2,
          F = k / 4,
          B = (2 * k) / 3,
          U = Math.log10,
          j = Math.sign;
        function G(t) {
          const e = Math.pow(10, Math.floor(U(t))),
            n = t / e;
          return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * e;
        }
        function H(t) {
          return !isNaN(parseFloat(t)) && isFinite(t);
        }
        function V(t, e, n) {
          return Math.abs(t - e) < n;
        }
        function W(t, e, n) {
          let i, r, a;
          for (i = 0, r = t.length; i < r; i++)
            (a = t[i][n]),
              isNaN(a) ||
                ((e.min = Math.min(e.min, a)), (e.max = Math.max(e.max, a)));
        }
        function X(t) {
          return t * (k / 180);
        }
        function Y(t) {
          return t * (180 / k);
        }
        function $(t, e) {
          return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
        }
        function J(t, e) {
          return ((t - e + D) % I) - k;
        }
        function Z(t) {
          return ((t % I) + I) % I;
        }
        function K(t, e, n) {
          const i = Z(t),
            r = Z(e),
            a = Z(n),
            o = Z(r - i),
            s = Z(a - i),
            l = Z(i - r),
            c = Z(i - a);
          return i === r || i === a || (o > s && l < c);
        }
        function Q(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        const tt = (t) => 0 === t || 1 === t,
          et = (t, e, n) =>
            -Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - e) * I) / n),
          nt = (t, e, n) =>
            Math.pow(2, -10 * t) * Math.sin(((t - e) * I) / n) + 1,
          it = {
            linear: (t) => t,
            easeInQuad: (t) => t * t,
            easeOutQuad: (t) => -t * (t - 2),
            easeInOutQuad: (t) =>
              (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
            easeInCubic: (t) => t * t * t,
            easeOutCubic: (t) => (t -= 1) * t * t + 1,
            easeInOutCubic: (t) =>
              (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
            easeInQuart: (t) => t * t * t * t,
            easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
            easeInOutQuart: (t) =>
              (t /= 0.5) < 1
                ? 0.5 * t * t * t * t
                : -0.5 * ((t -= 2) * t * t * t - 2),
            easeInQuint: (t) => t * t * t * t * t,
            easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
            easeInOutQuint: (t) =>
              (t /= 0.5) < 1
                ? 0.5 * t * t * t * t * t
                : 0.5 * ((t -= 2) * t * t * t * t + 2),
            easeInSine: (t) => 1 - Math.cos(t * z),
            easeOutSine: (t) => Math.sin(t * z),
            easeInOutSine: (t) => -0.5 * (Math.cos(k * t) - 1),
            easeInExpo: (t) => (0 === t ? 0 : Math.pow(2, 10 * (t - 1))),
            easeOutExpo: (t) => (1 === t ? 1 : 1 - Math.pow(2, -10 * t)),
            easeInOutExpo: (t) =>
              tt(t)
                ? t
                : t < 0.5
                ? 0.5 * Math.pow(2, 10 * (2 * t - 1))
                : 0.5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
            easeInCirc: (t) => (t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)),
            easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
            easeInOutCirc: (t) =>
              (t /= 0.5) < 1
                ? -0.5 * (Math.sqrt(1 - t * t) - 1)
                : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
            easeInElastic: (t) => (tt(t) ? t : et(t, 0.075, 0.3)),
            easeOutElastic: (t) => (tt(t) ? t : nt(t, 0.075, 0.3)),
            easeInOutElastic(t) {
              const e = 0.1125;
              return tt(t)
                ? t
                : t < 0.5
                ? 0.5 * et(2 * t, e, 0.45)
                : 0.5 + 0.5 * nt(2 * t - 1, e, 0.45);
            },
            easeInBack(t) {
              const e = 1.70158;
              return t * t * ((e + 1) * t - e);
            },
            easeOutBack(t) {
              const e = 1.70158;
              return (t -= 1) * t * ((e + 1) * t + e) + 1;
            },
            easeInOutBack(t) {
              let e = 1.70158;
              return (t /= 0.5) < 1
                ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5
                : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);
            },
            easeInBounce: (t) => 1 - it.easeOutBounce(1 - t),
            easeOutBounce(t) {
              const e = 7.5625,
                n = 2.75;
              return t < 1 / n
                ? e * t * t
                : t < 2 / n
                ? e * (t -= 1.5 / n) * t + 0.75
                : t < 2.5 / n
                ? e * (t -= 2.25 / n) * t + 0.9375
                : e * (t -= 2.625 / n) * t + 0.984375;
            },
            easeInOutBounce: (t) =>
              t < 0.5
                ? 0.5 * it.easeInBounce(2 * t)
                : 0.5 * it.easeOutBounce(2 * t - 1) + 0.5,
          },
          rt = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            A: 10,
            B: 11,
            C: 12,
            D: 13,
            E: 14,
            F: 15,
            a: 10,
            b: 11,
            c: 12,
            d: 13,
            e: 14,
            f: 15,
          },
          at = '0123456789ABCDEF',
          ot = (t) => at[15 & t],
          st = (t) => at[(240 & t) >> 4] + at[15 & t],
          lt = (t) => (240 & t) >> 4 == (15 & t);
        function ct(t) {
          var e = (function (t) {
            return lt(t.r) && lt(t.g) && lt(t.b) && lt(t.a);
          })(t)
            ? ot
            : st;
          return t
            ? '#' + e(t.r) + e(t.g) + e(t.b) + (t.a < 255 ? e(t.a) : '')
            : t;
        }
        function ut(t) {
          return (t + 0.5) | 0;
        }
        const ht = (t, e, n) => Math.max(Math.min(t, n), e);
        function dt(t) {
          return ht(ut(2.55 * t), 0, 255);
        }
        function pt(t) {
          return ht(ut(255 * t), 0, 255);
        }
        function ft(t) {
          return ht(ut(t / 2.55) / 100, 0, 1);
        }
        function mt(t) {
          return ht(ut(100 * t), 0, 100);
        }
        const gt =
          /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        const yt =
          /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function vt(t, e, n) {
          const i = e * Math.min(n, 1 - n),
            r = (e, r = (e + t / 30) % 12) =>
              n - i * Math.max(Math.min(r - 3, 9 - r, 1), -1);
          return [r(0), r(8), r(4)];
        }
        function xt(t, e, n) {
          const i = (i, r = (i + t / 60) % 6) =>
            n - n * e * Math.max(Math.min(r, 4 - r, 1), 0);
          return [i(5), i(3), i(1)];
        }
        function bt(t, e, n) {
          const i = vt(t, 1, 0.5);
          let r;
          for (
            e + n > 1 && ((r = 1 / (e + n)), (e *= r), (n *= r)), r = 0;
            r < 3;
            r++
          )
            (i[r] *= 1 - e - n), (i[r] += e);
          return i;
        }
        function _t(t) {
          const e = t.r / 255,
            n = t.g / 255,
            i = t.b / 255,
            r = Math.max(e, n, i),
            a = Math.min(e, n, i),
            o = (r + a) / 2;
          let s, l, c;
          return (
            r !== a &&
              ((c = r - a),
              (l = o > 0.5 ? c / (2 - r - a) : c / (r + a)),
              (s =
                r === e
                  ? (n - i) / c + (n < i ? 6 : 0)
                  : r === n
                  ? (i - e) / c + 2
                  : (e - n) / c + 4),
              (s = 60 * s + 0.5)),
            [0 | s, l || 0, o]
          );
        }
        function wt(t, e, n, i) {
          return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, n, i)).map(pt);
        }
        function Mt(t, e, n) {
          return wt(vt, t, e, n);
        }
        function qt(t) {
          return ((t % 360) + 360) % 360;
        }
        function St(t) {
          const e = yt.exec(t);
          let n,
            i = 255;
          if (!e) return;
          e[5] !== n && (i = e[6] ? dt(+e[5]) : pt(+e[5]));
          const r = qt(+e[2]),
            a = +e[3] / 100,
            o = +e[4] / 100;
          return (
            (n =
              'hwb' === e[1]
                ? (function (t, e, n) {
                    return wt(bt, t, e, n);
                  })(r, a, o)
                : 'hsv' === e[1]
                ? (function (t, e, n) {
                    return wt(xt, t, e, n);
                  })(r, a, o)
                : Mt(r, a, o)),
            { r: n[0], g: n[1], b: n[2], a: i }
          );
        }
        const Tt = {
            x: 'dark',
            Z: 'light',
            Y: 're',
            X: 'blu',
            W: 'gr',
            V: 'medium',
            U: 'slate',
            A: 'ee',
            T: 'ol',
            S: 'or',
            B: 'ra',
            C: 'lateg',
            D: 'ights',
            R: 'in',
            Q: 'turquois',
            E: 'hi',
            P: 'ro',
            O: 'al',
            N: 'le',
            M: 'de',
            L: 'yello',
            F: 'en',
            K: 'ch',
            G: 'arks',
            H: 'ea',
            I: 'ightg',
            J: 'wh',
          },
          Et = {
            OiceXe: 'f0f8ff',
            antiquewEte: 'faebd7',
            aqua: 'ffff',
            aquamarRe: '7fffd4',
            azuY: 'f0ffff',
            beige: 'f5f5dc',
            bisque: 'ffe4c4',
            black: '0',
            blanKedOmond: 'ffebcd',
            Xe: 'ff',
            XeviTet: '8a2be2',
            bPwn: 'a52a2a',
            burlywood: 'deb887',
            caMtXe: '5f9ea0',
            KartYuse: '7fff00',
            KocTate: 'd2691e',
            cSO: 'ff7f50',
            cSnflowerXe: '6495ed',
            cSnsilk: 'fff8dc',
            crimson: 'dc143c',
            cyan: 'ffff',
            xXe: '8b',
            xcyan: '8b8b',
            xgTMnPd: 'b8860b',
            xWay: 'a9a9a9',
            xgYF: '6400',
            xgYy: 'a9a9a9',
            xkhaki: 'bdb76b',
            xmagFta: '8b008b',
            xTivegYF: '556b2f',
            xSange: 'ff8c00',
            xScEd: '9932cc',
            xYd: '8b0000',
            xsOmon: 'e9967a',
            xsHgYF: '8fbc8f',
            xUXe: '483d8b',
            xUWay: '2f4f4f',
            xUgYy: '2f4f4f',
            xQe: 'ced1',
            xviTet: '9400d3',
            dAppRk: 'ff1493',
            dApskyXe: 'bfff',
            dimWay: '696969',
            dimgYy: '696969',
            dodgerXe: '1e90ff',
            fiYbrick: 'b22222',
            flSOwEte: 'fffaf0',
            foYstWAn: '228b22',
            fuKsia: 'ff00ff',
            gaRsbSo: 'dcdcdc',
            ghostwEte: 'f8f8ff',
            gTd: 'ffd700',
            gTMnPd: 'daa520',
            Way: '808080',
            gYF: '8000',
            gYFLw: 'adff2f',
            gYy: '808080',
            honeyMw: 'f0fff0',
            hotpRk: 'ff69b4',
            RdianYd: 'cd5c5c',
            Rdigo: '4b0082',
            ivSy: 'fffff0',
            khaki: 'f0e68c',
            lavFMr: 'e6e6fa',
            lavFMrXsh: 'fff0f5',
            lawngYF: '7cfc00',
            NmoncEffon: 'fffacd',
            ZXe: 'add8e6',
            ZcSO: 'f08080',
            Zcyan: 'e0ffff',
            ZgTMnPdLw: 'fafad2',
            ZWay: 'd3d3d3',
            ZgYF: '90ee90',
            ZgYy: 'd3d3d3',
            ZpRk: 'ffb6c1',
            ZsOmon: 'ffa07a',
            ZsHgYF: '20b2aa',
            ZskyXe: '87cefa',
            ZUWay: '778899',
            ZUgYy: '778899',
            ZstAlXe: 'b0c4de',
            ZLw: 'ffffe0',
            lime: 'ff00',
            limegYF: '32cd32',
            lRF: 'faf0e6',
            magFta: 'ff00ff',
            maPon: '800000',
            VaquamarRe: '66cdaa',
            VXe: 'cd',
            VScEd: 'ba55d3',
            VpurpN: '9370db',
            VsHgYF: '3cb371',
            VUXe: '7b68ee',
            VsprRggYF: 'fa9a',
            VQe: '48d1cc',
            VviTetYd: 'c71585',
            midnightXe: '191970',
            mRtcYam: 'f5fffa',
            mistyPse: 'ffe4e1',
            moccasR: 'ffe4b5',
            navajowEte: 'ffdead',
            navy: '80',
            Tdlace: 'fdf5e6',
            Tive: '808000',
            TivedBb: '6b8e23',
            Sange: 'ffa500',
            SangeYd: 'ff4500',
            ScEd: 'da70d6',
            pOegTMnPd: 'eee8aa',
            pOegYF: '98fb98',
            pOeQe: 'afeeee',
            pOeviTetYd: 'db7093',
            papayawEp: 'ffefd5',
            pHKpuff: 'ffdab9',
            peru: 'cd853f',
            pRk: 'ffc0cb',
            plum: 'dda0dd',
            powMrXe: 'b0e0e6',
            purpN: '800080',
            YbeccapurpN: '663399',
            Yd: 'ff0000',
            Psybrown: 'bc8f8f',
            PyOXe: '4169e1',
            saddNbPwn: '8b4513',
            sOmon: 'fa8072',
            sandybPwn: 'f4a460',
            sHgYF: '2e8b57',
            sHshell: 'fff5ee',
            siFna: 'a0522d',
            silver: 'c0c0c0',
            skyXe: '87ceeb',
            UXe: '6a5acd',
            UWay: '708090',
            UgYy: '708090',
            snow: 'fffafa',
            sprRggYF: 'ff7f',
            stAlXe: '4682b4',
            tan: 'd2b48c',
            teO: '8080',
            tEstN: 'd8bfd8',
            tomato: 'ff6347',
            Qe: '40e0d0',
            viTet: 'ee82ee',
            JHt: 'f5deb3',
            wEte: 'ffffff',
            wEtesmoke: 'f5f5f5',
            Lw: 'ffff00',
            LwgYF: '9acd32',
          };
        let At;
        function Lt(t) {
          At ||
            ((At = (function () {
              const t = {},
                e = Object.keys(Et),
                n = Object.keys(Tt);
              let i, r, a, o, s;
              for (i = 0; i < e.length; i++) {
                for (o = s = e[i], r = 0; r < n.length; r++)
                  (a = n[r]), (s = s.replace(a, Tt[a]));
                (a = parseInt(Et[o], 16)),
                  (t[s] = [(a >> 16) & 255, (a >> 8) & 255, 255 & a]);
              }
              return t;
            })()),
            (At.transparent = [0, 0, 0, 0]));
          const e = At[t.toLowerCase()];
          return (
            e && { r: e[0], g: e[1], b: e[2], a: 4 === e.length ? e[3] : 255 }
          );
        }
        function Rt(t, e, n) {
          if (t) {
            let i = _t(t);
            (i[e] = Math.max(0, Math.min(i[e] + i[e] * n, 0 === e ? 360 : 1))),
              (i = Mt(i)),
              (t.r = i[0]),
              (t.g = i[1]),
              (t.b = i[2]);
          }
        }
        function Ct(t, e) {
          return t ? Object.assign(e || {}, t) : t;
        }
        function Pt(t) {
          var e = { r: 0, g: 0, b: 0, a: 255 };
          return (
            Array.isArray(t)
              ? t.length >= 3 &&
                ((e = { r: t[0], g: t[1], b: t[2], a: 255 }),
                t.length > 3 && (e.a = pt(t[3])))
              : ((e = Ct(t, { r: 0, g: 0, b: 0, a: 1 })).a = pt(e.a)),
            e
          );
        }
        function kt(t) {
          return 'r' === t.charAt(0)
            ? (function (t) {
                const e = gt.exec(t);
                let n,
                  i,
                  r,
                  a = 255;
                if (e) {
                  if (e[7] !== n) {
                    const t = +e[7];
                    a = 255 & (e[8] ? dt(t) : 255 * t);
                  }
                  return (
                    (n = +e[1]),
                    (i = +e[3]),
                    (r = +e[5]),
                    (n = 255 & (e[2] ? dt(n) : n)),
                    (i = 255 & (e[4] ? dt(i) : i)),
                    (r = 255 & (e[6] ? dt(r) : r)),
                    { r: n, g: i, b: r, a: a }
                  );
                }
              })(t)
            : St(t);
        }
        class It {
          constructor(t) {
            if (t instanceof It) return t;
            const e = typeof t;
            let n;
            var i, r, a;
            'object' === e
              ? (n = Pt(t))
              : 'string' === e &&
                ((a = (i = t).length),
                '#' === i[0] &&
                  (4 === a || 5 === a
                    ? (r = {
                        r: 255 & (17 * rt[i[1]]),
                        g: 255 & (17 * rt[i[2]]),
                        b: 255 & (17 * rt[i[3]]),
                        a: 5 === a ? 17 * rt[i[4]] : 255,
                      })
                    : (7 !== a && 9 !== a) ||
                      (r = {
                        r: (rt[i[1]] << 4) | rt[i[2]],
                        g: (rt[i[3]] << 4) | rt[i[4]],
                        b: (rt[i[5]] << 4) | rt[i[6]],
                        a: 9 === a ? (rt[i[7]] << 4) | rt[i[8]] : 255,
                      })),
                (n = r || Lt(t) || kt(t))),
              (this._rgb = n),
              (this._valid = !!n);
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var t = Ct(this._rgb);
            return t && (t.a = ft(t.a)), t;
          }
          set rgb(t) {
            this._rgb = Pt(t);
          }
          rgbString() {
            return this._valid
              ? (t = this._rgb) &&
                  (t.a < 255
                    ? `rgba(${t.r}, ${t.g}, ${t.b}, ${ft(t.a)})`
                    : `rgb(${t.r}, ${t.g}, ${t.b})`)
              : this._rgb;
            var t;
          }
          hexString() {
            return this._valid ? ct(this._rgb) : this._rgb;
          }
          hslString() {
            return this._valid
              ? (function (t) {
                  if (!t) return;
                  const e = _t(t),
                    n = e[0],
                    i = mt(e[1]),
                    r = mt(e[2]);
                  return t.a < 255
                    ? `hsla(${n}, ${i}%, ${r}%, ${ft(t.a)})`
                    : `hsl(${n}, ${i}%, ${r}%)`;
                })(this._rgb)
              : this._rgb;
          }
          mix(t, e) {
            const n = this;
            if (t) {
              const i = n.rgb,
                r = t.rgb;
              let a;
              const o = e === a ? 0.5 : e,
                s = 2 * o - 1,
                l = i.a - r.a,
                c = ((s * l == -1 ? s : (s + l) / (1 + s * l)) + 1) / 2;
              (a = 1 - c),
                (i.r = 255 & (c * i.r + a * r.r + 0.5)),
                (i.g = 255 & (c * i.g + a * r.g + 0.5)),
                (i.b = 255 & (c * i.b + a * r.b + 0.5)),
                (i.a = o * i.a + (1 - o) * r.a),
                (n.rgb = i);
            }
            return n;
          }
          clone() {
            return new It(this.rgb);
          }
          alpha(t) {
            return (this._rgb.a = pt(t)), this;
          }
          clearer(t) {
            return (this._rgb.a *= 1 - t), this;
          }
          greyscale() {
            const t = this._rgb,
              e = ut(0.3 * t.r + 0.59 * t.g + 0.11 * t.b);
            return (t.r = t.g = t.b = e), this;
          }
          opaquer(t) {
            return (this._rgb.a *= 1 + t), this;
          }
          negate() {
            const t = this._rgb;
            return (
              (t.r = 255 - t.r), (t.g = 255 - t.g), (t.b = 255 - t.b), this
            );
          }
          lighten(t) {
            return Rt(this._rgb, 2, t), this;
          }
          darken(t) {
            return Rt(this._rgb, 2, -t), this;
          }
          saturate(t) {
            return Rt(this._rgb, 1, t), this;
          }
          desaturate(t) {
            return Rt(this._rgb, 1, -t), this;
          }
          rotate(t) {
            return (
              (function (t, e) {
                var n = _t(t);
                (n[0] = qt(n[0] + e)),
                  (n = Mt(n)),
                  (t.r = n[0]),
                  (t.g = n[1]),
                  (t.b = n[2]);
              })(this._rgb, t),
              this
            );
          }
        }
        function Dt(t) {
          return new It(t);
        }
        const Ot = (t) =>
          t instanceof CanvasGradient || t instanceof CanvasPattern;
        function Nt(t) {
          return Ot(t) ? t : Dt(t);
        }
        function zt(t) {
          return Ot(t) ? t : Dt(t).saturate(0.5).darken(0.1).hexString();
        }
        const Ft = Object.create(null),
          Bt = Object.create(null);
        function Ut(t, e) {
          if (!e) return t;
          const n = e.split('.');
          for (let e = 0, i = n.length; e < i; ++e) {
            const i = n[e];
            t = t[i] || (t[i] = Object.create(null));
          }
          return t;
        }
        function jt(t, e, n) {
          return 'string' == typeof e ? S(Ut(t, e), n) : S(Ut(t, ''), e);
        }
        var Gt = new (class {
          constructor(t) {
            (this.animation = void 0),
              (this.backgroundColor = 'rgba(0,0,0,0.1)'),
              (this.borderColor = 'rgba(0,0,0,0.1)'),
              (this.color = '#666'),
              (this.datasets = {}),
              (this.devicePixelRatio = (t) =>
                t.chart.platform.getDevicePixelRatio()),
              (this.elements = {}),
              (this.events = [
                'mousemove',
                'mouseout',
                'click',
                'touchstart',
                'touchmove',
              ]),
              (this.font = {
                family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                size: 12,
                style: 'normal',
                lineHeight: 1.2,
                weight: null,
              }),
              (this.hover = {}),
              (this.hoverBackgroundColor = (t, e) => zt(e.backgroundColor)),
              (this.hoverBorderColor = (t, e) => zt(e.borderColor)),
              (this.hoverColor = (t, e) => zt(e.color)),
              (this.indexAxis = 'x'),
              (this.interaction = { mode: 'nearest', intersect: !0 }),
              (this.maintainAspectRatio = !0),
              (this.onHover = null),
              (this.onClick = null),
              (this.parsing = !0),
              (this.plugins = {}),
              (this.responsive = !0),
              (this.scale = void 0),
              (this.scales = {}),
              (this.showLine = !0),
              this.describe(t);
          }
          set(t, e) {
            return jt(this, t, e);
          }
          get(t) {
            return Ut(this, t);
          }
          describe(t, e) {
            return jt(Bt, t, e);
          }
          override(t, e) {
            return jt(Ft, t, e);
          }
          route(t, e, n, i) {
            const r = Ut(this, t),
              a = Ut(this, n),
              o = '_' + e;
            Object.defineProperties(r, {
              [o]: { value: r[e], writable: !0 },
              [e]: {
                enumerable: !0,
                get() {
                  const t = this[o],
                    e = a[i];
                  return f(t) ? Object.assign({}, e, t) : y(t, e);
                },
                set(t) {
                  this[o] = t;
                },
              },
            });
          }
        })({
          _scriptable: (t) => !t.startsWith('on'),
          _indexable: (t) => 'events' !== t,
          hover: { _fallback: 'interaction' },
          interaction: { _scriptable: !1, _indexable: !1 },
        });
        function Ht(t, e, n, i, r) {
          let a = e[r];
          return (
            a || ((a = e[r] = t.measureText(r).width), n.push(r)),
            a > i && (i = a),
            i
          );
        }
        function Vt(t, e, n, i) {
          let r = ((i = i || {}).data = i.data || {}),
            a = (i.garbageCollect = i.garbageCollect || []);
          i.font !== e &&
            ((r = i.data = {}), (a = i.garbageCollect = []), (i.font = e)),
            t.save(),
            (t.font = e);
          let o = 0;
          const s = n.length;
          let l, c, u, h, d;
          for (l = 0; l < s; l++)
            if (((h = n[l]), null != h && !0 !== p(h))) o = Ht(t, r, a, o, h);
            else if (p(h))
              for (c = 0, u = h.length; c < u; c++)
                (d = h[c]), null == d || p(d) || (o = Ht(t, r, a, o, d));
          t.restore();
          const f = a.length / 2;
          if (f > n.length) {
            for (l = 0; l < f; l++) delete r[a[l]];
            a.splice(0, f);
          }
          return o;
        }
        function Wt(t, e, n) {
          const i = t.currentDevicePixelRatio,
            r = 0 !== n ? Math.max(n / 2, 0.5) : 0;
          return Math.round((e - r) * i) / i + r;
        }
        function Xt(t, e) {
          (e = e || t.getContext('2d')).save(),
            e.resetTransform(),
            e.clearRect(0, 0, t.width, t.height),
            e.restore();
        }
        function Yt(t, e, n, i) {
          let r, a, o, s, l;
          const c = e.pointStyle,
            u = e.rotation,
            h = e.radius;
          let d = (u || 0) * N;
          if (
            c &&
            'object' == typeof c &&
            ((r = c.toString()),
            '[object HTMLImageElement]' === r ||
              '[object HTMLCanvasElement]' === r)
          )
            return (
              t.save(),
              t.translate(n, i),
              t.rotate(d),
              t.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height),
              void t.restore()
            );
          if (!(isNaN(h) || h <= 0)) {
            switch ((t.beginPath(), c)) {
              default:
                t.arc(n, i, h, 0, I), t.closePath();
                break;
              case 'triangle':
                t.moveTo(n + Math.sin(d) * h, i - Math.cos(d) * h),
                  (d += B),
                  t.lineTo(n + Math.sin(d) * h, i - Math.cos(d) * h),
                  (d += B),
                  t.lineTo(n + Math.sin(d) * h, i - Math.cos(d) * h),
                  t.closePath();
                break;
              case 'rectRounded':
                (l = 0.516 * h),
                  (s = h - l),
                  (a = Math.cos(d + F) * s),
                  (o = Math.sin(d + F) * s),
                  t.arc(n - a, i - o, l, d - k, d - z),
                  t.arc(n + o, i - a, l, d - z, d),
                  t.arc(n + a, i + o, l, d, d + z),
                  t.arc(n - o, i + a, l, d + z, d + k),
                  t.closePath();
                break;
              case 'rect':
                if (!u) {
                  (s = Math.SQRT1_2 * h), t.rect(n - s, i - s, 2 * s, 2 * s);
                  break;
                }
                d += F;
              case 'rectRot':
                (a = Math.cos(d) * h),
                  (o = Math.sin(d) * h),
                  t.moveTo(n - a, i - o),
                  t.lineTo(n + o, i - a),
                  t.lineTo(n + a, i + o),
                  t.lineTo(n - o, i + a),
                  t.closePath();
                break;
              case 'crossRot':
                d += F;
              case 'cross':
                (a = Math.cos(d) * h),
                  (o = Math.sin(d) * h),
                  t.moveTo(n - a, i - o),
                  t.lineTo(n + a, i + o),
                  t.moveTo(n + o, i - a),
                  t.lineTo(n - o, i + a);
                break;
              case 'star':
                (a = Math.cos(d) * h),
                  (o = Math.sin(d) * h),
                  t.moveTo(n - a, i - o),
                  t.lineTo(n + a, i + o),
                  t.moveTo(n + o, i - a),
                  t.lineTo(n - o, i + a),
                  (d += F),
                  (a = Math.cos(d) * h),
                  (o = Math.sin(d) * h),
                  t.moveTo(n - a, i - o),
                  t.lineTo(n + a, i + o),
                  t.moveTo(n + o, i - a),
                  t.lineTo(n - o, i + a);
                break;
              case 'line':
                (a = Math.cos(d) * h),
                  (o = Math.sin(d) * h),
                  t.moveTo(n - a, i - o),
                  t.lineTo(n + a, i + o);
                break;
              case 'dash':
                t.moveTo(n, i),
                  t.lineTo(n + Math.cos(d) * h, i + Math.sin(d) * h);
            }
            t.fill(), e.borderWidth > 0 && t.stroke();
          }
        }
        function $t(t, e, n) {
          return (
            (n = n || 0.5),
            t &&
              t.x > e.left - n &&
              t.x < e.right + n &&
              t.y > e.top - n &&
              t.y < e.bottom + n
          );
        }
        function Jt(t, e) {
          t.save(),
            t.beginPath(),
            t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top),
            t.clip();
        }
        function Zt(t) {
          t.restore();
        }
        function Kt(t, e, n, i, r) {
          if (!e) return t.lineTo(n.x, n.y);
          if ('middle' === r) {
            const i = (e.x + n.x) / 2;
            t.lineTo(i, e.y), t.lineTo(i, n.y);
          } else
            ('after' === r) != !!i ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y);
          t.lineTo(n.x, n.y);
        }
        function Qt(t, e, n, i) {
          if (!e) return t.lineTo(n.x, n.y);
          t.bezierCurveTo(
            i ? e.cp1x : e.cp2x,
            i ? e.cp1y : e.cp2y,
            i ? n.cp2x : n.cp1x,
            i ? n.cp2y : n.cp1y,
            n.x,
            n.y,
          );
        }
        function te(t, e, n, i, r, a = {}) {
          const o = p(e) ? e : [e],
            s = a.strokeWidth > 0 && '' !== a.strokeColor;
          let l, c;
          for (
            t.save(),
              a.translation && t.translate(a.translation[0], a.translation[1]),
              d(a.rotation) || t.rotate(a.rotation),
              t.font = r.string,
              a.color && (t.fillStyle = a.color),
              a.textAlign && (t.textAlign = a.textAlign),
              a.textBaseline && (t.textBaseline = a.textBaseline),
              l = 0;
            l < o.length;
            ++l
          ) {
            if (
              ((c = o[l]),
              s &&
                (a.strokeColor && (t.strokeStyle = a.strokeColor),
                d(a.strokeWidth) || (t.lineWidth = a.strokeWidth),
                t.strokeText(c, n, i, a.maxWidth)),
              t.fillText(c, n, i, a.maxWidth),
              a.strikethrough || a.underline)
            ) {
              const e = t.measureText(c),
                r = n - e.actualBoundingBoxLeft,
                o = n + e.actualBoundingBoxRight,
                s = i - e.actualBoundingBoxAscent,
                l = i + e.actualBoundingBoxDescent,
                u = a.strikethrough ? (s + l) / 2 : l;
              (t.strokeStyle = t.fillStyle),
                t.beginPath(),
                (t.lineWidth = a.decorationWidth || 2),
                t.moveTo(r, u),
                t.lineTo(o, u),
                t.stroke();
            }
            i += r.lineHeight;
          }
          t.restore();
        }
        const ee = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        function ne(t, e) {
          const n = ('' + t).match(ee);
          if (!n || 'normal' === n[1]) return 1.2 * e;
          switch (((t = +n[2]), n[3])) {
            case 'px':
              return t;
            case '%':
              t /= 100;
          }
          return e * t;
        }
        function ie(t, e) {
          const n = {},
            i = f(e),
            r = i ? Object.keys(e) : e,
            a = f(t) ? (i ? (n) => y(t[n], t[e[n]]) : (e) => t[e]) : () => t;
          for (const t of r) n[t] = +a(t) || 0;
          return n;
        }
        function re(t) {
          return ie(t, { top: 'y', right: 'x', bottom: 'y', left: 'x' });
        }
        function ae(t) {
          const e = re(t);
          return (e.width = e.left + e.right), (e.height = e.top + e.bottom), e;
        }
        function oe(t, e) {
          (t = t || {}), (e = e || Gt.font);
          let n = y(t.size, e.size);
          'string' == typeof n && (n = parseInt(n, 10));
          const i = {
            family: y(t.family, e.family),
            lineHeight: ne(y(t.lineHeight, e.lineHeight), n),
            size: n,
            style: y(t.style, e.style),
            weight: y(t.weight, e.weight),
            string: '',
          };
          return (
            (i.string = (function (t) {
              return !t || d(t.size) || d(t.family)
                ? null
                : (t.style ? t.style + ' ' : '') +
                    (t.weight ? t.weight + ' ' : '') +
                    t.size +
                    'px ' +
                    t.family;
            })(i)),
            i
          );
        }
        function se(t, e, n, i) {
          let r,
            a,
            o,
            s = !0;
          for (r = 0, a = t.length; r < a; ++r)
            if (
              ((o = t[r]),
              void 0 !== o &&
                (void 0 !== e &&
                  'function' == typeof o &&
                  ((o = o(e)), (s = !1)),
                void 0 !== n && p(o) && ((o = o[n % o.length]), (s = !1)),
                void 0 !== o))
            )
              return i && !s && (i.cacheable = !1), o;
        }
        function le(t, e, n) {
          n = n || ((n) => t[n] < e);
          let i,
            r = t.length - 1,
            a = 0;
          for (; r - a > 1; ) (i = (a + r) >> 1), n(i) ? (a = i) : (r = i);
          return { lo: a, hi: r };
        }
        const ce = (t, e, n) => le(t, n, (i) => t[i][e] < n),
          ue = (t, e, n) => le(t, n, (i) => t[i][e] >= n);
        const he = ['push', 'pop', 'shift', 'splice', 'unshift'];
        function de(t, e) {
          const n = t._chartjs;
          if (!n) return;
          const i = n.listeners,
            r = i.indexOf(e);
          -1 !== r && i.splice(r, 1),
            i.length > 0 ||
              (he.forEach((e) => {
                delete t[e];
              }),
              delete t._chartjs);
        }
        function pe(t) {
          const e = new Set();
          let n, i;
          for (n = 0, i = t.length; n < i; ++n) e.add(t[n]);
          if (e.size === i) return t;
          const r = [];
          return (
            e.forEach((t) => {
              r.push(t);
            }),
            r
          );
        }
        function fe(t, e = [''], n = t, i) {
          C(i) || (i = Se('_fallback', t));
          const r = {
            [Symbol.toStringTag]: 'Object',
            _cacheable: !0,
            _scopes: t,
            _rootScopes: n,
            _fallback: i,
            override: (r) => fe([r, ...t], e, n, i),
          };
          return new Proxy(r, {
            deleteProperty: (e, n) => (
              delete e[n], delete e._keys, delete t[0][n], !0
            ),
            get: (n, i) =>
              xe(n, i, () =>
                (function (t, e, n, i) {
                  let r;
                  for (const a of e)
                    if (((r = Se(ye(a, t), n)), C(r)))
                      return ve(t, r) ? Me(n, i, t, r) : r;
                })(i, e, t, n),
              ),
            getOwnPropertyDescriptor: (t, e) =>
              Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
            getPrototypeOf: () => Reflect.getPrototypeOf(t[0]),
            has: (t, e) => Te(t).includes(e),
            ownKeys: (t) => Te(t),
            set: (e, n, i) => ((t[0][n] = i), delete e[n], delete e._keys, !0),
          });
        }
        function me(t, e, n, i) {
          const r = {
            _cacheable: !1,
            _proxy: t,
            _context: e,
            _subProxy: n,
            _stack: new Set(),
            _descriptors: ge(t, i),
            setContext: (e) => me(t, e, n, i),
            override: (r) => me(t.override(r), e, n, i),
          };
          return new Proxy(r, {
            deleteProperty: (e, n) => (delete e[n], delete t[n], !0),
            get: (t, e, n) =>
              xe(t, e, () =>
                (function (t, e, n) {
                  const {
                    _proxy: i,
                    _context: r,
                    _subProxy: a,
                    _descriptors: o,
                  } = t;
                  let s = i[e];
                  P(s) &&
                    o.isScriptable(e) &&
                    (s = (function (t, e, n, i) {
                      const {
                        _proxy: r,
                        _context: a,
                        _subProxy: o,
                        _stack: s,
                      } = n;
                      if (s.has(t))
                        throw new Error(
                          'Recursion detected: ' + [...s].join('->') + '->' + t,
                        );
                      s.add(t),
                        (e = e(a, o || i)),
                        s.delete(t),
                        f(e) && (e = Me(r._scopes, r, t, e));
                      return e;
                    })(e, s, t, n));
                  p(s) &&
                    s.length &&
                    (s = (function (t, e, n, i) {
                      const {
                        _proxy: r,
                        _context: a,
                        _subProxy: o,
                        _descriptors: s,
                      } = n;
                      if (C(a.index) && i(t)) e = e[a.index % e.length];
                      else if (f(e[0])) {
                        const n = e,
                          i = r._scopes.filter((t) => t !== n);
                        e = [];
                        for (const l of n) {
                          const n = Me(i, r, t, l);
                          e.push(me(n, a, o && o[t], s));
                        }
                      }
                      return e;
                    })(e, s, t, o.isIndexable));
                  ve(e, s) && (s = me(s, r, a && a[e], o));
                  return s;
                })(t, e, n),
              ),
            getOwnPropertyDescriptor: (e, n) =>
              e._descriptors.allKeys
                ? Reflect.has(t, n)
                  ? { enumerable: !0, configurable: !0 }
                  : void 0
                : Reflect.getOwnPropertyDescriptor(t, n),
            getPrototypeOf: () => Reflect.getPrototypeOf(t),
            has: (e, n) => Reflect.has(t, n),
            ownKeys: () => Reflect.ownKeys(t),
            set: (e, n, i) => ((t[n] = i), delete e[n], !0),
          });
        }
        function ge(t, e = { scriptable: !0, indexable: !0 }) {
          const {
            _scriptable: n = e.scriptable,
            _indexable: i = e.indexable,
            _allKeys: r = e.allKeys,
          } = t;
          return {
            allKeys: r,
            scriptable: n,
            indexable: i,
            isScriptable: P(n) ? n : () => n,
            isIndexable: P(i) ? i : () => i,
          };
        }
        const ye = (t, e) => (t ? t + R(e) : e),
          ve = (t, e) => f(e) && 'adapters' !== t;
        function xe(t, e, n) {
          let i = t[e];
          return C(i) || ((i = n()), C(i) && (t[e] = i)), i;
        }
        function be(t, e, n) {
          return P(t) ? t(e, n) : t;
        }
        const _e = (t, e) =>
          !0 === t ? e : 'string' == typeof t ? L(e, t) : void 0;
        function we(t, e, n, i) {
          for (const r of e) {
            const e = _e(n, r);
            if (e) {
              t.add(e);
              const r = be(e._fallback, n, e);
              if (C(r) && r !== n && r !== i) return r;
            } else if (!1 === e && C(i) && n !== i) return null;
          }
          return !1;
        }
        function Me(t, e, n, i) {
          const r = e._rootScopes,
            a = be(e._fallback, n, i),
            o = [...t, ...r],
            s = new Set(),
            l = t[0];
          f(l) && !(n in l) && s.add((l[n] = {})), s.add(i);
          let c = qe(s, o, n, a || n);
          return (
            null !== c &&
            (!C(a) || a === n || ((c = qe(s, o, a, c)), null !== c)) &&
            fe([...s], [''], r, a)
          );
        }
        function qe(t, e, n, i) {
          for (; n; ) n = we(t, e, n, i);
          return n;
        }
        function Se(t, e) {
          for (const n of e) {
            if (!n) continue;
            const e = n[t];
            if (C(e)) return e;
          }
        }
        function Te(t) {
          let e = t._keys;
          return (
            e ||
              (e = t._keys =
                (function (t) {
                  const e = new Set();
                  for (const n of t)
                    for (const t of Object.keys(n).filter(
                      (t) => !t.startsWith('_'),
                    ))
                      e.add(t);
                  return [...e];
                })(t._scopes)),
            e
          );
        }
        const Ee = Number.EPSILON || 1e-14,
          Ae = (t, e) => e < t.length && !t[e].skip && t[e];
        function Le(t, e, n, i) {
          const r = t.skip ? e : t,
            a = e,
            o = n.skip ? e : n,
            s = $(a, r),
            l = $(o, a);
          let c = s / (s + l),
            u = l / (s + l);
          (c = isNaN(c) ? 0 : c), (u = isNaN(u) ? 0 : u);
          const h = i * c,
            d = i * u;
          return {
            previous: { x: a.x - h * (o.x - r.x), y: a.y - h * (o.y - r.y) },
            next: { x: a.x + d * (o.x - r.x), y: a.y + d * (o.y - r.y) },
          };
        }
        function Re(t) {
          const e = t.length,
            n = Array(e).fill(0),
            i = Array(e);
          let r,
            a,
            o,
            s = Ae(t, 0);
          for (r = 0; r < e; ++r)
            if (((a = o), (o = s), (s = Ae(t, r + 1)), o)) {
              if (s) {
                const t = s.x - o.x;
                n[r] = 0 !== t ? (s.y - o.y) / t : 0;
              }
              i[r] = a
                ? s
                  ? j(n[r - 1]) !== j(n[r])
                    ? 0
                    : (n[r - 1] + n[r]) / 2
                  : n[r - 1]
                : n[r];
            }
          !(function (t, e, n) {
            const i = t.length;
            let r,
              a,
              o,
              s,
              l,
              c = Ae(t, 0);
            for (let u = 0; u < i - 1; ++u)
              (l = c),
                (c = Ae(t, u + 1)),
                l &&
                  c &&
                  (V(e[u], 0, Ee)
                    ? (n[u] = n[u + 1] = 0)
                    : ((r = n[u] / e[u]),
                      (a = n[u + 1] / e[u]),
                      (s = Math.pow(r, 2) + Math.pow(a, 2)),
                      s <= 9 ||
                        ((o = 3 / Math.sqrt(s)),
                        (n[u] = r * o * e[u]),
                        (n[u + 1] = a * o * e[u]))));
          })(t, n, i),
            (function (t, e) {
              const n = t.length;
              let i,
                r,
                a,
                o = Ae(t, 0);
              for (let s = 0; s < n; ++s) {
                if (((r = a), (a = o), (o = Ae(t, s + 1)), !a)) continue;
                const { x: n, y: l } = a;
                r &&
                  ((i = (n - r.x) / 3),
                  (a.cp1x = n - i),
                  (a.cp1y = l - i * e[s])),
                  o &&
                    ((i = (o.x - n) / 3),
                    (a.cp2x = n + i),
                    (a.cp2y = l + i * e[s]));
              }
            })(t, i);
        }
        function Ce(t, e, n) {
          return Math.max(Math.min(t, n), e);
        }
        function Pe(t, e, n, i) {
          let r, a, o, s;
          if (
            (e.spanGaps && (t = t.filter((t) => !t.skip)),
            'monotone' === e.cubicInterpolationMode)
          )
            Re(t);
          else {
            let n = i ? t[t.length - 1] : t[0];
            for (r = 0, a = t.length; r < a; ++r)
              (o = t[r]),
                (s = Le(
                  n,
                  o,
                  t[Math.min(r + 1, a - (i ? 0 : 1)) % a],
                  e.tension,
                )),
                (o.cp1x = s.previous.x),
                (o.cp1y = s.previous.y),
                (o.cp2x = s.next.x),
                (o.cp2y = s.next.y),
                (n = o);
          }
          e.capBezierPoints &&
            (function (t, e) {
              let n,
                i,
                r,
                a,
                o,
                s = $t(t[0], e);
              for (n = 0, i = t.length; n < i; ++n)
                (o = a),
                  (a = s),
                  (s = n < i - 1 && $t(t[n + 1], e)),
                  a &&
                    ((r = t[n]),
                    o &&
                      ((r.cp1x = Ce(r.cp1x, e.left, e.right)),
                      (r.cp1y = Ce(r.cp1y, e.top, e.bottom))),
                    s &&
                      ((r.cp2x = Ce(r.cp2x, e.left, e.right)),
                      (r.cp2y = Ce(r.cp2y, e.top, e.bottom))));
            })(t, n);
        }
        function ke(t) {
          let e = t.parentNode;
          return e && '[object ShadowRoot]' === e.toString() && (e = e.host), e;
        }
        function Ie(t, e, n) {
          let i;
          return (
            'string' == typeof t
              ? ((i = parseInt(t, 10)),
                -1 !== t.indexOf('%') && (i = (i / 100) * e.parentNode[n]))
              : (i = t),
            i
          );
        }
        const De = (t) => window.getComputedStyle(t, null);
        const Oe = ['top', 'right', 'bottom', 'left'];
        function Ne(t, e, n) {
          const i = {};
          n = n ? '-' + n : '';
          for (let r = 0; r < 4; r++) {
            const a = Oe[r];
            i[a] = parseFloat(t[e + '-' + a + n]) || 0;
          }
          return (i.width = i.left + i.right), (i.height = i.top + i.bottom), i;
        }
        function ze(t, e) {
          const { canvas: n, currentDevicePixelRatio: i } = e,
            r = De(n),
            a = 'border-box' === r.boxSizing,
            o = Ne(r, 'padding'),
            s = Ne(r, 'border', 'width'),
            {
              x: l,
              y: c,
              box: u,
            } = (function (t, e) {
              const n = t.native || t,
                i = n.touches,
                r = i && i.length ? i[0] : n,
                { offsetX: a, offsetY: o } = r;
              let s,
                l,
                c = !1;
              if (
                ((t, e, n) => (t > 0 || e > 0) && (!n || !n.shadowRoot))(
                  a,
                  o,
                  n.target,
                )
              )
                (s = a), (l = o);
              else {
                const t = e.getBoundingClientRect();
                (s = r.clientX - t.left), (l = r.clientY - t.top), (c = !0);
              }
              return { x: s, y: l, box: c };
            })(t, n),
            h = o.left + (u && s.left),
            d = o.top + (u && s.top);
          let { width: p, height: f } = e;
          return (
            a && ((p -= o.width + s.width), (f -= o.height + s.height)),
            {
              x: Math.round((((l - h) / p) * n.width) / i),
              y: Math.round((((c - d) / f) * n.height) / i),
            }
          );
        }
        const Fe = (t) => Math.round(10 * t) / 10;
        function Be(t, e, n, i) {
          const r = De(t),
            a = Ne(r, 'margin'),
            o = Ie(r.maxWidth, t, 'clientWidth') || O,
            s = Ie(r.maxHeight, t, 'clientHeight') || O,
            l = (function (t, e, n) {
              let i, r;
              if (void 0 === e || void 0 === n) {
                const a = ke(t);
                if (a) {
                  const t = a.getBoundingClientRect(),
                    o = De(a),
                    s = Ne(o, 'border', 'width'),
                    l = Ne(o, 'padding');
                  (e = t.width - l.width - s.width),
                    (n = t.height - l.height - s.height),
                    (i = Ie(o.maxWidth, a, 'clientWidth')),
                    (r = Ie(o.maxHeight, a, 'clientHeight'));
                } else (e = t.clientWidth), (n = t.clientHeight);
              }
              return {
                width: e,
                height: n,
                maxWidth: i || O,
                maxHeight: r || O,
              };
            })(t, e, n);
          let { width: c, height: u } = l;
          if ('content-box' === r.boxSizing) {
            const t = Ne(r, 'border', 'width'),
              e = Ne(r, 'padding');
            (c -= e.width + t.width), (u -= e.height + t.height);
          }
          return (
            (c = Math.max(0, c - a.width)),
            (u = Math.max(0, i ? Math.floor(c / i) : u - a.height)),
            (c = Fe(Math.min(c, o, l.maxWidth))),
            (u = Fe(Math.min(u, s, l.maxHeight))),
            c && !u && (u = Fe(c / 2)),
            { width: c, height: u }
          );
        }
        function Ue(t, e, n) {
          const i = (t.currentDevicePixelRatio = e || 1),
            { canvas: r, width: a, height: o } = t;
          (r.height = o * i),
            (r.width = a * i),
            t.ctx.setTransform(i, 0, 0, i, 0, 0),
            r.style &&
              (n || (!r.style.height && !r.style.width)) &&
              ((r.style.height = o + 'px'), (r.style.width = a + 'px'));
        }
        const je = (function () {
          let t = !1;
          try {
            const e = {
              get passive() {
                return (t = !0), !1;
              },
            };
            window.addEventListener('test', null, e),
              window.removeEventListener('test', null, e);
          } catch (t) {}
          return t;
        })();
        function Ge(t, e) {
          const n = (function (t, e) {
              return De(t).getPropertyValue(e);
            })(t, e),
            i = n && n.match(/^(\d+)(\.\d+)?px$/);
          return i ? +i[1] : void 0;
        }
        function He(t, e, n, i) {
          return { x: t.x + n * (e.x - t.x), y: t.y + n * (e.y - t.y) };
        }
        function Ve(t, e, n, i) {
          return {
            x: t.x + n * (e.x - t.x),
            y:
              'middle' === i
                ? n < 0.5
                  ? t.y
                  : e.y
                : 'after' === i
                ? n < 1
                  ? t.y
                  : e.y
                : n > 0
                ? e.y
                : t.y,
          };
        }
        function We(t, e, n, i) {
          const r = { x: t.cp2x, y: t.cp2y },
            a = { x: e.cp1x, y: e.cp1y },
            o = He(t, r, n),
            s = He(r, a, n),
            l = He(a, e, n),
            c = He(o, s, n),
            u = He(s, l, n);
          return He(c, u, n);
        }
        const Xe = new Map();
        function Ye(t, e, n) {
          return (function (t, e) {
            e = e || {};
            const n = t + JSON.stringify(e);
            let i = Xe.get(n);
            return i || ((i = new Intl.NumberFormat(t, e)), Xe.set(n, i)), i;
          })(e, n).format(t);
        }
        function $e(t, e, n) {
          return t
            ? (function (t, e) {
                return {
                  x: (n) => t + t + e - n,
                  setWidth(t) {
                    e = t;
                  },
                  textAlign: (t) =>
                    'center' === t ? t : 'right' === t ? 'left' : 'right',
                  xPlus: (t, e) => t - e,
                  leftForLtr: (t, e) => t - e,
                };
              })(e, n)
            : {
                x: (t) => t,
                setWidth(t) {},
                textAlign: (t) => t,
                xPlus: (t, e) => t + e,
                leftForLtr: (t, e) => t,
              };
        }
        function Je(t, e) {
          let n, i;
          ('ltr' !== e && 'rtl' !== e) ||
            ((n = t.canvas.style),
            (i = [
              n.getPropertyValue('direction'),
              n.getPropertyPriority('direction'),
            ]),
            n.setProperty('direction', e, 'important'),
            (t.prevTextDirection = i));
        }
        function Ze(t, e) {
          void 0 !== e &&
            (delete t.prevTextDirection,
            t.canvas.style.setProperty('direction', e[0], e[1]));
        }
        function Ke(t) {
          return 'angle' === t
            ? { between: K, compare: J, normalize: Z }
            : {
                between: (t, e, n) => t >= e && t <= n,
                compare: (t, e) => t - e,
                normalize: (t) => t,
              };
        }
        function Qe(t, e, n, i) {
          return { start: t % i, end: e % i, loop: n && (e - t + 1) % i == 0 };
        }
        function tn(t, e, n) {
          if (!n) return [t];
          const { property: i, start: r, end: a } = n,
            o = e.length,
            { compare: s, between: l, normalize: c } = Ke(i),
            {
              start: u,
              end: h,
              loop: d,
            } = (function (t, e, n) {
              const { property: i, start: r, end: a } = n,
                { between: o, normalize: s } = Ke(i),
                l = e.length;
              let c,
                u,
                { start: h, end: d, loop: p } = t;
              if (p) {
                for (
                  h += l, d += l, c = 0, u = l;
                  c < u && o(s(e[h % l][i]), r, a);
                  ++c
                )
                  h--, d--;
                (h %= l), (d %= l);
              }
              return d < h && (d += l), { start: h, end: d, loop: p };
            })(t, e, n),
            p = [];
          let f,
            m,
            g,
            y = !1,
            v = null;
          const x = () => y || (l(r, g, f) && 0 !== s(r, g)),
            b = () => !y || 0 === s(a, f) || l(a, g, f);
          for (let t = u, n = u; t <= h; ++t)
            (m = e[t % o]),
              m.skip ||
                ((f = c(m[i])),
                (y = l(f, r, a)),
                null === v && x() && (v = 0 === s(f, r) ? t : n),
                null !== v && b() && (p.push(Qe(v, t, d, o)), (v = null)),
                (n = t),
                (g = f));
          return null !== v && p.push(Qe(v, h, d, o)), p;
        }
        function en(t, e) {
          const n = [],
            i = t.segments;
          for (let r = 0; r < i.length; r++) {
            const a = tn(i[r], t.points, e);
            a.length && n.push(...a);
          }
          return n;
        }
        var nn = new /*!
         * Chart.js v3.0.2
         * https://www.chartjs.org
         * (c) 2021 Chart.js Contributors
         * Released under the MIT License
         */
        (class {
          constructor() {
            (this._request = null),
              (this._charts = new Map()),
              (this._running = !1),
              (this._lastDate = void 0);
          }
          _notify(t, e, n, i) {
            const r = e.listeners[i],
              a = e.duration;
            r.forEach((i) =>
              i({
                chart: t,
                numSteps: a,
                currentStep: Math.min(n - e.start, a),
              }),
            );
          }
          _refresh() {
            const t = this;
            t._request ||
              ((t._running = !0),
              (t._request = s.call(window, () => {
                t._update(), (t._request = null), t._running && t._refresh();
              })));
          }
          _update(t = Date.now()) {
            const e = this;
            let n = 0;
            e._charts.forEach((i, r) => {
              if (!i.running || !i.items.length) return;
              const a = i.items;
              let o,
                s = a.length - 1,
                l = !1;
              for (; s >= 0; --s)
                (o = a[s]),
                  o._active
                    ? (o._total > i.duration && (i.duration = o._total),
                      o.tick(t),
                      (l = !0))
                    : ((a[s] = a[a.length - 1]), a.pop());
              l && (r.draw(), e._notify(r, i, t, 'progress')),
                a.length || ((i.running = !1), e._notify(r, i, t, 'complete')),
                (n += a.length);
            }),
              (e._lastDate = t),
              0 === n && (e._running = !1);
          }
          _getAnims(t) {
            const e = this._charts;
            let n = e.get(t);
            return (
              n ||
                ((n = {
                  running: !1,
                  items: [],
                  listeners: { complete: [], progress: [] },
                }),
                e.set(t, n)),
              n
            );
          }
          listen(t, e, n) {
            this._getAnims(t).listeners[e].push(n);
          }
          add(t, e) {
            e && e.length && this._getAnims(t).items.push(...e);
          }
          has(t) {
            return this._getAnims(t).items.length > 0;
          }
          start(t) {
            const e = this._charts.get(t);
            e &&
              ((e.running = !0),
              (e.start = Date.now()),
              (e.duration = e.items.reduce(
                (t, e) => Math.max(t, e._duration),
                0,
              )),
              this._refresh());
          }
          running(t) {
            if (!this._running) return !1;
            const e = this._charts.get(t);
            return !!(e && e.running && e.items.length);
          }
          stop(t) {
            const e = this._charts.get(t);
            if (!e || !e.items.length) return;
            const n = e.items;
            let i = n.length - 1;
            for (; i >= 0; --i) n[i].cancel();
            (e.items = []), this._notify(t, e, Date.now(), 'complete');
          }
          remove(t) {
            return this._charts.delete(t);
          }
        })();
        const rn = {
          boolean: (t, e, n) => (n > 0.5 ? e : t),
          color(t, e, n) {
            const i = Nt(t || 'transparent'),
              r = i.valid && Nt(e || 'transparent');
            return r && r.valid ? r.mix(i, n).hexString() : e;
          },
          number: (t, e, n) => t + (e - t) * n,
        };
        class an {
          constructor(t, e, n, i) {
            const r = e[n];
            i = se([t.to, i, r, t.from]);
            const a = se([t.from, r, i]);
            (this._active = !0),
              (this._fn = t.fn || rn[t.type || typeof a]),
              (this._easing = it[t.easing] || it.linear),
              (this._start = Math.floor(Date.now() + (t.delay || 0))),
              (this._duration = this._total = Math.floor(t.duration)),
              (this._loop = !!t.loop),
              (this._target = e),
              (this._prop = n),
              (this._from = a),
              (this._to = i),
              (this._promises = void 0);
          }
          active() {
            return this._active;
          }
          update(t, e, n) {
            const i = this;
            if (i._active) {
              i._notify(!1);
              const r = i._target[i._prop],
                a = n - i._start,
                o = i._duration - a;
              (i._start = n),
                (i._duration = Math.floor(Math.max(o, t.duration))),
                (i._total += a),
                (i._loop = !!t.loop),
                (i._to = se([t.to, e, r, t.from])),
                (i._from = se([t.from, r, e]));
            }
          }
          cancel() {
            const t = this;
            t._active && (t.tick(Date.now()), (t._active = !1), t._notify(!1));
          }
          tick(t) {
            const e = this,
              n = t - e._start,
              i = e._duration,
              r = e._prop,
              a = e._from,
              o = e._loop,
              s = e._to;
            let l;
            if (((e._active = a !== s && (o || n < i)), !e._active))
              return (e._target[r] = s), void e._notify(!0);
            n < 0
              ? (e._target[r] = a)
              : ((l = (n / i) % 2),
                (l = o && l > 1 ? 2 - l : l),
                (l = e._easing(Math.min(1, Math.max(0, l)))),
                (e._target[r] = e._fn(a, s, l)));
          }
          wait() {
            const t = this._promises || (this._promises = []);
            return new Promise((e, n) => {
              t.push({ res: e, rej: n });
            });
          }
          _notify(t) {
            const e = t ? 'res' : 'rej',
              n = this._promises || [];
            for (let t = 0; t < n.length; t++) n[t][e]();
          }
        }
        Gt.set('animation', {
          delay: void 0,
          duration: 1e3,
          easing: 'easeOutQuart',
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0,
        });
        const on = Object.keys(Gt.animation);
        Gt.describe('animation', {
          _fallback: !1,
          _indexable: !1,
          _scriptable: (t) =>
            'onProgress' !== t && 'onComplete' !== t && 'fn' !== t,
        }),
          Gt.set('animations', {
            colors: {
              type: 'color',
              properties: ['color', 'borderColor', 'backgroundColor'],
            },
            numbers: {
              type: 'number',
              properties: ['x', 'y', 'borderWidth', 'radius', 'tension'],
            },
          }),
          Gt.describe('animations', { _fallback: 'animation' }),
          Gt.set('transitions', {
            active: { animation: { duration: 400 } },
            resize: { animation: { duration: 0 } },
            show: {
              animations: {
                colors: { from: 'transparent' },
                visible: { type: 'boolean', duration: 0 },
              },
            },
            hide: {
              animations: {
                colors: { to: 'transparent' },
                visible: {
                  type: 'boolean',
                  easing: 'linear',
                  fn: (t) => 0 | t,
                },
              },
            },
          });
        class sn {
          constructor(t, e) {
            (this._chart = t),
              (this._properties = new Map()),
              this.configure(e);
          }
          configure(t) {
            if (!f(t)) return;
            const e = this._properties;
            Object.getOwnPropertyNames(t).forEach((n) => {
              const i = t[n];
              if (!f(i)) return;
              const r = {};
              for (const t of on) r[t] = i[t];
              ((p(i.properties) && i.properties) || [n]).forEach((t) => {
                (t !== n && e.has(t)) || e.set(t, r);
              });
            });
          }
          _animateOptions(t, e) {
            const n = e.options,
              i = (function (t, e) {
                if (!e) return;
                let n = t.options;
                if (!n) return void (t.options = e);
                n.$shared &&
                  (t.options = n =
                    Object.assign({}, n, { $shared: !1, $animations: {} }));
                return n;
              })(t, n);
            if (!i) return [];
            const r = this._createAnimations(i, n);
            return (
              n.$shared &&
                (function (t, e) {
                  const n = [],
                    i = Object.keys(e);
                  for (let e = 0; e < i.length; e++) {
                    const r = t[i[e]];
                    r && r.active() && n.push(r.wait());
                  }
                  return Promise.all(n);
                })(t.options.$animations, n).then(
                  () => {
                    t.options = n;
                  },
                  () => {},
                ),
              r
            );
          }
          _createAnimations(t, e) {
            const n = this._properties,
              i = [],
              r = t.$animations || (t.$animations = {}),
              a = Object.keys(e),
              o = Date.now();
            let s;
            for (s = a.length - 1; s >= 0; --s) {
              const l = a[s];
              if ('$' === l.charAt(0)) continue;
              if ('options' === l) {
                i.push(...this._animateOptions(t, e));
                continue;
              }
              const c = e[l];
              let u = r[l];
              const h = n.get(l);
              if (u) {
                if (h && u.active()) {
                  u.update(h, c, o);
                  continue;
                }
                u.cancel();
              }
              h && h.duration
                ? ((r[l] = u = new an(h, t, l, c)), i.push(u))
                : (t[l] = c);
            }
            return i;
          }
          update(t, e) {
            if (0 === this._properties.size) return void Object.assign(t, e);
            const n = this._createAnimations(t, e);
            return n.length ? (nn.add(this._chart, n), !0) : void 0;
          }
        }
        function ln(t, e) {
          const n = (t && t.options) || {},
            i = n.reverse,
            r = void 0 === n.min ? e : 0,
            a = void 0 === n.max ? e : 0;
          return { start: i ? a : r, end: i ? r : a };
        }
        function cn(t, e) {
          const n = [],
            i = t._getSortedDatasetMetas(e);
          let r, a;
          for (r = 0, a = i.length; r < a; ++r) n.push(i[r].index);
          return n;
        }
        function un(t, e, n, i) {
          const r = t.keys,
            a = 'single' === i.mode;
          let o, s, l, c;
          if (null !== e) {
            for (o = 0, s = r.length; o < s; ++o) {
              if (((l = +r[o]), l === n)) {
                if (i.all) continue;
                break;
              }
              (c = t.values[l]),
                m(c) && (a || 0 === e || j(e) === j(c)) && (e += c);
            }
            return e;
          }
        }
        function hn(t, e) {
          const n = t && t.options.stacked;
          return n || (void 0 === n && void 0 !== e.stack);
        }
        function dn(t, e, n) {
          const i = t[e] || (t[e] = {});
          return i[n] || (i[n] = {});
        }
        function pn(t, e) {
          const { chart: n, _cachedMeta: i } = t,
            r = n._stacks || (n._stacks = {}),
            { iScale: a, vScale: o, index: s } = i,
            l = a.axis,
            c = o.axis,
            u = (function (t, e, n) {
              return t.id + '.' + e.id + '.' + n.stack + '.' + n.type;
            })(a, o, i),
            h = e.length;
          let d;
          for (let t = 0; t < h; ++t) {
            const n = e[t],
              { [l]: i, [c]: a } = n;
            (d = (n._stacks || (n._stacks = {}))[c] = dn(r, u, i)), (d[s] = a);
          }
        }
        function fn(t, e) {
          const n = t.scales;
          return Object.keys(n)
            .filter((t) => n[t].axis === e)
            .shift();
        }
        function mn(t, e) {
          e = e || t._parsed;
          for (const n of e) {
            const e = n._stacks;
            if (
              !e ||
              void 0 === e[t.vScale.id] ||
              void 0 === e[t.vScale.id][t.index]
            )
              return;
            delete e[t.vScale.id][t.index];
          }
        }
        const gn = (t) => 'reset' === t || 'none' === t,
          yn = (t, e) => (e ? t : Object.assign({}, t));
        class vn {
          constructor(t, e) {
            (this.chart = t),
              (this._ctx = t.ctx),
              (this.index = e),
              (this._cachedDataOpts = {}),
              (this._cachedMeta = this.getMeta()),
              (this._type = this._cachedMeta.type),
              (this.options = void 0),
              (this._parsing = !1),
              (this._data = void 0),
              (this._objectData = void 0),
              (this._sharedOptions = void 0),
              (this._drawStart = void 0),
              (this._drawCount = void 0),
              (this.enableOptionSharing = !1),
              (this.$context = void 0),
              this.initialize();
          }
          initialize() {
            const t = this._cachedMeta;
            this.configure(),
              this.linkScales(),
              (t._stacked = hn(t.vScale, t)),
              this.addElements();
          }
          updateIndex(t) {
            this.index = t;
          }
          linkScales() {
            const t = this,
              e = t.chart,
              n = t._cachedMeta,
              i = t.getDataset(),
              r = (t, e, n, i) => ('x' === t ? e : 'r' === t ? i : n),
              a = (n.xAxisID = y(i.xAxisID, fn(e, 'x'))),
              o = (n.yAxisID = y(i.yAxisID, fn(e, 'y'))),
              s = (n.rAxisID = y(i.rAxisID, fn(e, 'r'))),
              l = n.indexAxis,
              c = (n.iAxisID = r(l, a, o, s)),
              u = (n.vAxisID = r(l, o, a, s));
            (n.xScale = t.getScaleForId(a)),
              (n.yScale = t.getScaleForId(o)),
              (n.rScale = t.getScaleForId(s)),
              (n.iScale = t.getScaleForId(c)),
              (n.vScale = t.getScaleForId(u));
          }
          getDataset() {
            return this.chart.data.datasets[this.index];
          }
          getMeta() {
            return this.chart.getDatasetMeta(this.index);
          }
          getScaleForId(t) {
            return this.chart.scales[t];
          }
          _getOtherScale(t) {
            const e = this._cachedMeta;
            return t === e.iScale ? e.vScale : e.iScale;
          }
          reset() {
            this._update('reset');
          }
          _destroy() {
            const t = this._cachedMeta;
            this._data && de(this._data, this), t._stacked && mn(t);
          }
          _dataCheck() {
            const t = this,
              e = t.getDataset(),
              n = e.data || (e.data = []);
            var i, r;
            f(n)
              ? (t._data = (function (t) {
                  const e = Object.keys(t),
                    n = new Array(e.length);
                  let i, r, a;
                  for (i = 0, r = e.length; i < r; ++i)
                    (a = e[i]), (n[i] = { x: a, y: t[a] });
                  return n;
                })(n))
              : t._data !== n &&
                (t._data && (de(t._data, t), mn(t._cachedMeta)),
                n &&
                  Object.isExtensible(n) &&
                  ((r = t),
                  (i = n)._chartjs
                    ? i._chartjs.listeners.push(r)
                    : (Object.defineProperty(i, '_chartjs', {
                        configurable: !0,
                        enumerable: !1,
                        value: { listeners: [r] },
                      }),
                      he.forEach((t) => {
                        const e = '_onData' + R(t),
                          n = i[t];
                        Object.defineProperty(i, t, {
                          configurable: !0,
                          enumerable: !1,
                          value(...t) {
                            const r = n.apply(this, t);
                            return (
                              i._chartjs.listeners.forEach((n) => {
                                'function' == typeof n[e] && n[e](...t);
                              }),
                              r
                            );
                          },
                        });
                      }))),
                (t._data = n));
          }
          addElements() {
            const t = this,
              e = t._cachedMeta;
            t._dataCheck(),
              t.datasetElementType && (e.dataset = new t.datasetElementType());
          }
          buildOrUpdateElements(t) {
            const e = this,
              n = e._cachedMeta,
              i = e.getDataset();
            let r = !1;
            e._dataCheck(),
              (n._stacked = hn(n.vScale, n)),
              n.stack !== i.stack && ((r = !0), mn(n), (n.stack = i.stack)),
              e._resyncElements(t),
              r && pn(e, n._parsed);
          }
          configure() {
            const t = this,
              e = t.chart.config,
              n = e.datasetScopeKeys(t._type),
              i = e.getOptionScopes(t.getDataset(), n, !0);
            (t.options = e.createResolver(i, t.getContext())),
              (t._parsing = t.options.parsing);
          }
          parse(t, e) {
            const n = this,
              { _cachedMeta: i, _data: r } = n,
              { iScale: a, _stacked: o } = i,
              s = a.axis;
            let l,
              c,
              u,
              h = (0 === t && e === r.length) || i._sorted,
              d = t > 0 && i._parsed[t - 1];
            if (!1 === n._parsing) (i._parsed = r), (i._sorted = !0);
            else {
              u = p(r[t])
                ? n.parseArrayData(i, r, t, e)
                : f(r[t])
                ? n.parseObjectData(i, r, t, e)
                : n.parsePrimitiveData(i, r, t, e);
              const a = () => null === c[s] || (d && c[s] < d[s]);
              for (l = 0; l < e; ++l)
                (i._parsed[l + t] = c = u[l]), h && (a() && (h = !1), (d = c));
              i._sorted = h;
            }
            o && pn(n, u);
          }
          parsePrimitiveData(t, e, n, i) {
            const { iScale: r, vScale: a } = t,
              o = r.axis,
              s = a.axis,
              l = r.getLabels(),
              c = r === a,
              u = new Array(i);
            let h, d, p;
            for (h = 0, d = i; h < d; ++h)
              (p = h + n),
                (u[h] = { [o]: c || r.parse(l[p], p), [s]: a.parse(e[p], p) });
            return u;
          }
          parseArrayData(t, e, n, i) {
            const { xScale: r, yScale: a } = t,
              o = new Array(i);
            let s, l, c, u;
            for (s = 0, l = i; s < l; ++s)
              (c = s + n),
                (u = e[c]),
                (o[s] = { x: r.parse(u[0], c), y: a.parse(u[1], c) });
            return o;
          }
          parseObjectData(t, e, n, i) {
            const { xScale: r, yScale: a } = t,
              { xAxisKey: o = 'x', yAxisKey: s = 'y' } = this._parsing,
              l = new Array(i);
            let c, u, h, d;
            for (c = 0, u = i; c < u; ++c)
              (h = c + n),
                (d = e[h]),
                (l[c] = { x: r.parse(L(d, o), h), y: a.parse(L(d, s), h) });
            return l;
          }
          getParsed(t) {
            return this._cachedMeta._parsed[t];
          }
          getDataElement(t) {
            return this._cachedMeta.data[t];
          }
          applyStack(t, e, n) {
            const i = this.chart,
              r = this._cachedMeta,
              a = e[t.axis];
            return un(
              { keys: cn(i, !0), values: e._stacks[t.axis] },
              a,
              r.index,
              { mode: n },
            );
          }
          updateRangeFromParsed(t, e, n, i) {
            const r = n[e.axis];
            let a = null === r ? NaN : r;
            const o = i && n._stacks[e.axis];
            i &&
              o &&
              ((i.values = o),
              (t.min = Math.min(t.min, a)),
              (t.max = Math.max(t.max, a)),
              (a = un(i, r, this._cachedMeta.index, { all: !0 }))),
              (t.min = Math.min(t.min, a)),
              (t.max = Math.max(t.max, a));
          }
          getMinMax(t, e) {
            const n = this,
              i = n._cachedMeta,
              r = i._parsed,
              a = i._sorted && t === i.iScale,
              o = r.length,
              s = n._getOtherScale(t),
              l = e && i._stacked && { keys: cn(n.chart, !0), values: null },
              c = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY,
              },
              { min: u, max: h } = (function (t) {
                const {
                  min: e,
                  max: n,
                  minDefined: i,
                  maxDefined: r,
                } = t.getUserBounds();
                return {
                  min: i ? e : Number.NEGATIVE_INFINITY,
                  max: r ? n : Number.POSITIVE_INFINITY,
                };
              })(s);
            let d, p, f, g;
            function y() {
              return (
                (f = r[d]),
                (p = f[t.axis]),
                (g = f[s.axis]),
                !m(p) || u > g || h < g
              );
            }
            for (
              d = 0;
              d < o && (y() || (n.updateRangeFromParsed(c, t, f, l), !a));
              ++d
            );
            if (a)
              for (d = o - 1; d >= 0; --d)
                if (!y()) {
                  n.updateRangeFromParsed(c, t, f, l);
                  break;
                }
            return c;
          }
          getAllParsedValues(t) {
            const e = this._cachedMeta._parsed,
              n = [];
            let i, r, a;
            for (i = 0, r = e.length; i < r; ++i)
              (a = e[i][t.axis]), m(a) && n.push(a);
            return n;
          }
          getMaxOverflow() {
            return !1;
          }
          getLabelAndValue(t) {
            const e = this._cachedMeta,
              n = e.iScale,
              i = e.vScale,
              r = this.getParsed(t);
            return {
              label: n ? '' + n.getLabelForValue(r[n.axis]) : '',
              value: i ? '' + i.getLabelForValue(r[i.axis]) : '',
            };
          }
          _update(t) {
            const e = this,
              n = e._cachedMeta;
            e.configure(),
              (e._cachedDataOpts = {}),
              e.update(t || 'default'),
              (n._clip = (function (t) {
                let e, n, i, r;
                return (
                  f(t)
                    ? ((e = t.top), (n = t.right), (i = t.bottom), (r = t.left))
                    : (e = n = i = r = t),
                  { top: e, right: n, bottom: i, left: r }
                );
              })(
                y(
                  e.options.clip,
                  (function (t, e, n) {
                    if (!1 === n) return !1;
                    const i = ln(t, n),
                      r = ln(e, n);
                    return {
                      top: r.end,
                      right: i.end,
                      bottom: r.start,
                      left: i.start,
                    };
                  })(n.xScale, n.yScale, e.getMaxOverflow()),
                ),
              ));
          }
          update(t) {}
          draw() {
            const t = this,
              e = t._ctx,
              n = t.chart,
              i = t._cachedMeta,
              r = i.data || [],
              a = n.chartArea,
              o = [],
              s = t._drawStart || 0,
              l = t._drawCount || r.length - s;
            let c;
            for (
              i.dataset && i.dataset.draw(e, a, s, l), c = s;
              c < s + l;
              ++c
            ) {
              const t = r[c];
              t.active ? o.push(t) : t.draw(e, a);
            }
            for (c = 0; c < o.length; ++c) o[c].draw(e, a);
          }
          getStyle(t, e) {
            const n = e ? 'active' : 'default';
            return void 0 === t && this._cachedMeta.dataset
              ? this.resolveDatasetElementOptions(n)
              : this.resolveDataElementOptions(t || 0, n);
          }
          getContext(t, e, n) {
            const i = this,
              r = i.getDataset();
            let a;
            if (t >= 0 && t < i._cachedMeta.data.length) {
              const e = i._cachedMeta.data[t];
              (a =
                e.$context ||
                (e.$context = (function (t, e, n) {
                  return Object.assign(Object.create(t), {
                    active: !1,
                    dataIndex: e,
                    parsed: void 0,
                    raw: void 0,
                    element: n,
                    index: e,
                    mode: 'default',
                    type: 'data',
                  });
                })(i.getContext(), t, e))),
                (a.parsed = i.getParsed(t)),
                (a.raw = r.data[t]);
            } else
              (a =
                i.$context ||
                (i.$context = (function (t, e) {
                  return Object.assign(Object.create(t), {
                    active: !1,
                    dataset: void 0,
                    datasetIndex: e,
                    index: e,
                    mode: 'default',
                    type: 'dataset',
                  });
                })(i.chart.getContext(), i.index))),
                (a.dataset = r);
            return (a.active = !!e), (a.mode = n), a;
          }
          resolveDatasetElementOptions(t) {
            return this._resolveElementOptions(this.datasetElementType.id, t);
          }
          resolveDataElementOptions(t, e) {
            return this._resolveElementOptions(this.dataElementType.id, e, t);
          }
          _resolveElementOptions(t, e = 'default', n) {
            const i = this,
              r = 'active' === e,
              a = i._cachedDataOpts,
              o = t + '-' + e,
              s = a[o],
              l = i.enableOptionSharing && C(n);
            if (s) return yn(s, l);
            const c = i.chart.config,
              u = c.datasetElementScopeKeys(i._type, t),
              h = r ? [t + 'Hover', 'hover', t, ''] : [t, ''],
              d = c.getOptionScopes(i.getDataset(), u),
              p = Object.keys(Gt.elements[t]),
              f = c.resolveNamedOptions(d, p, () => i.getContext(n, r), h);
            return (
              f.$shared && ((f.$shared = l), (a[o] = Object.freeze(yn(f, l)))),
              f
            );
          }
          _resolveAnimations(t, e, n) {
            const i = this,
              r = i.chart,
              a = i._cachedDataOpts,
              o = 'animation-' + e,
              s = a[o];
            if (s) return s;
            let l;
            if (!1 !== r.options.animation) {
              const r = i.chart.config,
                a = r.datasetAnimationScopeKeys(i._type, e),
                o = r.getOptionScopes(i.getDataset(), a);
              l = r.createResolver(o, i.getContext(t, n, e));
            }
            const c = new sn(r, l && l.animations);
            return l && l._cacheable && (a[o] = Object.freeze(c)), c;
          }
          getSharedOptions(t) {
            if (t.$shared)
              return (
                this._sharedOptions ||
                (this._sharedOptions = Object.assign({}, t))
              );
          }
          includeOptions(t, e) {
            return !e || gn(t) || this.chart._animationsDisabled;
          }
          updateElement(t, e, n, i) {
            gn(i)
              ? Object.assign(t, n)
              : this._resolveAnimations(e, i).update(t, n);
          }
          updateSharedOptions(t, e, n) {
            t && !gn(e) && this._resolveAnimations(void 0, e).update(t, n);
          }
          _setStyle(t, e, n, i) {
            t.active = i;
            const r = this.getStyle(e, i);
            this._resolveAnimations(e, n, i).update(t, {
              options: (!i && this.getSharedOptions(r)) || r,
            });
          }
          removeHoverStyle(t, e, n) {
            this._setStyle(t, n, 'active', !1);
          }
          setHoverStyle(t, e, n) {
            this._setStyle(t, n, 'active', !0);
          }
          _removeDatasetHoverStyle() {
            const t = this._cachedMeta.dataset;
            t && this._setStyle(t, void 0, 'active', !1);
          }
          _setDatasetHoverStyle() {
            const t = this._cachedMeta.dataset;
            t && this._setStyle(t, void 0, 'active', !0);
          }
          _resyncElements(t) {
            const e = this,
              n = e._cachedMeta.data.length,
              i = e._data.length;
            i > n
              ? e._insertElements(n, i - n, t)
              : i < n && e._removeElements(i, n - i);
            const r = Math.min(i, n);
            r && e.parse(0, r);
          }
          _insertElements(t, e, n = !0) {
            const i = this,
              r = i._cachedMeta,
              a = r.data,
              o = t + e;
            let s;
            const l = (t) => {
              for (t.length += e, s = t.length - 1; s >= o; s--)
                t[s] = t[s - e];
            };
            for (l(a), s = t; s < o; ++s) a[s] = new i.dataElementType();
            i._parsing && l(r._parsed),
              i.parse(t, e),
              n && i.updateElements(a, t, e, 'reset');
          }
          updateElements(t, e, n, i) {}
          _removeElements(t, e) {
            const n = this._cachedMeta;
            if (this._parsing) {
              const i = n._parsed.splice(t, e);
              n._stacked && mn(n, i);
            }
            n.data.splice(t, e);
          }
          _onDataPush() {
            const t = arguments.length;
            this._insertElements(this.getDataset().data.length - t, t);
          }
          _onDataPop() {
            this._removeElements(this._cachedMeta.data.length - 1, 1);
          }
          _onDataShift() {
            this._removeElements(0, 1);
          }
          _onDataSplice(t, e) {
            this._removeElements(t, e),
              this._insertElements(t, arguments.length - 2);
          }
          _onDataUnshift() {
            this._insertElements(0, arguments.length);
          }
        }
        function xn(t) {
          const e = (function (t) {
            if (!t._cache.$bar) {
              const e = t.getMatchingVisibleMetas('bar');
              let n = [];
              for (let i = 0, r = e.length; i < r; i++)
                n = n.concat(e[i].controller.getAllParsedValues(t));
              t._cache.$bar = pe(n.sort((t, e) => t - e));
            }
            return t._cache.$bar;
          })(t);
          let n,
            i,
            r,
            a,
            o = t._length;
          const s = () => {
            (o = Math.min(o, (n && Math.abs(r - a)) || o)), (a = r);
          };
          for (n = 0, i = e.length; n < i; ++n)
            (r = t.getPixelForValue(e[n])), s();
          for (n = 0, i = t.ticks.length; n < i; ++n)
            (r = t.getPixelForTick(n)), s();
          return o;
        }
        function bn(t, e, n, i) {
          return (
            p(t)
              ? (function (t, e, n, i) {
                  const r = n.parse(t[0], i),
                    a = n.parse(t[1], i),
                    o = Math.min(r, a),
                    s = Math.max(r, a);
                  let l = o,
                    c = s;
                  Math.abs(o) > Math.abs(s) && ((l = s), (c = o)),
                    (e[n.axis] = c),
                    (e._custom = {
                      barStart: l,
                      barEnd: c,
                      start: r,
                      end: a,
                      min: o,
                      max: s,
                    });
                })(t, e, n, i)
              : (e[n.axis] = n.parse(t, i)),
            e
          );
        }
        function _n(t, e, n, i) {
          const r = t.iScale,
            a = t.vScale,
            o = r.getLabels(),
            s = r === a,
            l = [];
          let c, u, h, d;
          for (c = n, u = n + i; c < u; ++c)
            (d = e[c]),
              (h = {}),
              (h[r.axis] = s || r.parse(o[c], c)),
              l.push(bn(d, h, a, c));
          return l;
        }
        function wn(t) {
          return t && void 0 !== t.barStart && void 0 !== t.barEnd;
        }
        (vn.defaults = {}),
          (vn.prototype.datasetElementType = null),
          (vn.prototype.dataElementType = null);
        class Mn extends vn {
          parsePrimitiveData(t, e, n, i) {
            return _n(t, e, n, i);
          }
          parseArrayData(t, e, n, i) {
            return _n(t, e, n, i);
          }
          parseObjectData(t, e, n, i) {
            const { iScale: r, vScale: a } = t,
              { xAxisKey: o = 'x', yAxisKey: s = 'y' } = this._parsing,
              l = 'x' === r.axis ? o : s,
              c = 'x' === a.axis ? o : s,
              u = [];
            let h, d, p, f;
            for (h = n, d = n + i; h < d; ++h)
              (f = e[h]),
                (p = {}),
                (p[r.axis] = r.parse(L(f, l), h)),
                u.push(bn(L(f, c), p, a, h));
            return u;
          }
          updateRangeFromParsed(t, e, n, i) {
            super.updateRangeFromParsed(t, e, n, i);
            const r = n._custom;
            r &&
              e === this._cachedMeta.vScale &&
              ((t.min = Math.min(t.min, r.min)),
              (t.max = Math.max(t.max, r.max)));
          }
          getLabelAndValue(t) {
            const e = this._cachedMeta,
              { iScale: n, vScale: i } = e,
              r = this.getParsed(t),
              a = r._custom,
              o = wn(a)
                ? '[' + a.start + ', ' + a.end + ']'
                : '' + i.getLabelForValue(r[i.axis]);
            return { label: '' + n.getLabelForValue(r[n.axis]), value: o };
          }
          initialize() {
            (this.enableOptionSharing = !0), super.initialize();
            this._cachedMeta.stack = this.getDataset().stack;
          }
          update(t) {
            const e = this._cachedMeta;
            this.updateElements(e.data, 0, e.data.length, t);
          }
          updateElements(t, e, n, i) {
            const r = this,
              a = 'reset' === i,
              o = r._cachedMeta.vScale,
              s = o.getBasePixel(),
              l = o.isHorizontal(),
              c = r._getRuler(),
              u = r.resolveDataElementOptions(e, i),
              h = r.getSharedOptions(u),
              d = r.includeOptions(i, h);
            r.updateSharedOptions(h, i, u);
            for (let o = e; o < e + n; o++) {
              const e = a
                  ? { base: s, head: s }
                  : r._calculateBarValuePixels(o),
                n = r._calculateBarIndexPixels(o, c),
                u = {
                  horizontal: l,
                  base: e.base,
                  x: l ? e.head : n.center,
                  y: l ? n.center : e.head,
                  height: l ? n.size : void 0,
                  width: l ? void 0 : n.size,
                };
              d && (u.options = h || r.resolveDataElementOptions(o, i)),
                r.updateElement(t[o], o, u, i);
            }
          }
          _getStacks(t, e) {
            const n = this._cachedMeta.iScale,
              i = n.getMatchingVisibleMetas(this._type),
              r = n.options.stacked,
              a = i.length,
              o = [];
            let s, l;
            for (s = 0; s < a; ++s) {
              if (((l = i[s]), void 0 !== e)) {
                const t =
                  l.controller.getParsed(e)[
                    l.controller._cachedMeta.vScale.axis
                  ];
                if (d(t) || isNaN(t)) continue;
              }
              if (
                ((!1 === r ||
                  -1 === o.indexOf(l.stack) ||
                  (void 0 === r && void 0 === l.stack)) &&
                  o.push(l.stack),
                l.index === t)
              )
                break;
            }
            return o.length || o.push(void 0), o;
          }
          _getStackCount(t) {
            return this._getStacks(void 0, t).length;
          }
          _getStackIndex(t, e) {
            const n = this._getStacks(t),
              i = void 0 !== e ? n.indexOf(e) : -1;
            return -1 === i ? n.length - 1 : i;
          }
          _getRuler() {
            const t = this,
              e = t.options,
              n = t._cachedMeta,
              i = n.iScale,
              r = [];
            let a, o;
            for (a = 0, o = n.data.length; a < o; ++a)
              r.push(i.getPixelForValue(t.getParsed(a)[i.axis], a));
            const s = e.barThickness;
            return {
              min: s || xn(i),
              pixels: r,
              start: i._startPixel,
              end: i._endPixel,
              stackCount: t._getStackCount(),
              scale: i,
              grouped: e.grouped,
              ratio: s ? 1 : e.categoryPercentage * e.barPercentage,
            };
          }
          _calculateBarValuePixels(t) {
            const { vScale: e, _stacked: n } = this._cachedMeta,
              { base: i, minBarLength: r } = this.options,
              a = this.getParsed(t),
              o = a._custom,
              s = wn(o);
            let l,
              c,
              u = a[e.axis],
              h = 0,
              p = n ? this.applyStack(e, a, n) : u;
            p !== u && ((h = p - u), (p = u)),
              s &&
                ((u = o.barStart),
                (p = o.barEnd - o.barStart),
                0 !== u && j(u) !== j(o.barEnd) && (h = 0),
                (h += u));
            const f = d(i) || s ? h : i;
            let m = e.getPixelForValue(f);
            (l = this.chart.getDataVisibility(t)
              ? e.getPixelForValue(h + p)
              : m),
              (c = l - m),
              void 0 !== r &&
                Math.abs(c) < r &&
                ((c = c < 0 ? -r : r), 0 === u && (m -= c / 2), (l = m + c));
            const g = i || 0;
            if (m === e.getPixelForValue(g)) {
              const t = e.getLineWidthForValue(g) / 2;
              c > 0 ? ((m += t), (c -= t)) : c < 0 && ((m -= t), (c += t));
            }
            return { size: c, base: m, head: l, center: l + c / 2 };
          }
          _calculateBarIndexPixels(t, e) {
            const n = this,
              i = e.scale,
              r = n.options,
              a = y(r.maxBarThickness, 1 / 0);
            let o, s;
            if (e.grouped) {
              const i = r.skipNull ? n._getStackCount(t) : e.stackCount,
                l =
                  'flex' === r.barThickness
                    ? (function (t, e, n, i) {
                        const r = e.pixels,
                          a = r[t];
                        let o = t > 0 ? r[t - 1] : null,
                          s = t < r.length - 1 ? r[t + 1] : null;
                        const l = n.categoryPercentage;
                        null === o &&
                          (o = a - (null === s ? e.end - e.start : s - a)),
                          null === s && (s = a + a - o);
                        const c = a - ((a - Math.min(o, s)) / 2) * l;
                        return {
                          chunk: ((Math.abs(s - o) / 2) * l) / i,
                          ratio: n.barPercentage,
                          start: c,
                        };
                      })(t, e, r, i)
                    : (function (t, e, n, i) {
                        const r = n.barThickness;
                        let a, o;
                        return (
                          d(r)
                            ? ((a = e.min * n.categoryPercentage),
                              (o = n.barPercentage))
                            : ((a = r * i), (o = 1)),
                          { chunk: a / i, ratio: o, start: e.pixels[t] - a / 2 }
                        );
                      })(t, e, r, i),
                c = n._getStackIndex(n.index, n._cachedMeta.stack);
              (o = l.start + l.chunk * c + l.chunk / 2),
                (s = Math.min(a, l.chunk * l.ratio));
            } else
              (o = i.getPixelForValue(n.getParsed(t)[i.axis], t)),
                (s = Math.min(a, e.min * e.ratio));
            return { base: o - s / 2, head: o + s / 2, center: o, size: s };
          }
          draw() {
            const t = this,
              e = t.chart,
              n = t._cachedMeta,
              i = n.vScale,
              r = n.data,
              a = r.length;
            let o = 0;
            for (Jt(e.ctx, e.chartArea); o < a; ++o)
              null !== t.getParsed(o)[i.axis] && r[o].draw(t._ctx);
            Zt(e.ctx);
          }
        }
        (Mn.id = 'bar'),
          (Mn.defaults = {
            datasetElementType: !1,
            dataElementType: 'bar',
            categoryPercentage: 0.8,
            barPercentage: 0.9,
            grouped: !0,
            animations: {
              numbers: {
                type: 'number',
                properties: ['x', 'y', 'base', 'width', 'height'],
              },
            },
          }),
          (Mn.overrides = {
            interaction: { mode: 'index' },
            scales: {
              _index_: { type: 'category', offset: !0, grid: { offset: !0 } },
              _value_: { type: 'linear', beginAtZero: !0 },
            },
          });
        class qn extends vn {
          initialize() {
            (this.enableOptionSharing = !0), super.initialize();
          }
          parseObjectData(t, e, n, i) {
            const { xScale: r, yScale: a } = t,
              { xAxisKey: o = 'x', yAxisKey: s = 'y' } = this._parsing,
              l = [];
            let c, u, h;
            for (c = n, u = n + i; c < u; ++c)
              (h = e[c]),
                l.push({
                  x: r.parse(L(h, o), c),
                  y: a.parse(L(h, s), c),
                  _custom: h && h.r && +h.r,
                });
            return l;
          }
          getMaxOverflow() {
            const { data: t, _parsed: e } = this._cachedMeta;
            let n = 0;
            for (let i = t.length - 1; i >= 0; --i)
              n = Math.max(n, t[i].size() / 2, e[i]._custom);
            return n > 0 && n;
          }
          getLabelAndValue(t) {
            const e = this._cachedMeta,
              { xScale: n, yScale: i } = e,
              r = this.getParsed(t),
              a = n.getLabelForValue(r.x),
              o = i.getLabelForValue(r.y),
              s = r._custom;
            return {
              label: e.label,
              value: '(' + a + ', ' + o + (s ? ', ' + s : '') + ')',
            };
          }
          update(t) {
            const e = this._cachedMeta.data;
            this.updateElements(e, 0, e.length, t);
          }
          updateElements(t, e, n, i) {
            const r = this,
              a = 'reset' === i,
              { xScale: o, yScale: s } = r._cachedMeta,
              l = r.resolveDataElementOptions(e, i),
              c = r.getSharedOptions(l),
              u = r.includeOptions(i, c);
            for (let l = e; l < e + n; l++) {
              const e = t[l],
                n = !a && r.getParsed(l),
                c = a ? o.getPixelForDecimal(0.5) : o.getPixelForValue(n.x),
                h = a ? s.getBasePixel() : s.getPixelForValue(n.y),
                d = { x: c, y: h, skip: isNaN(c) || isNaN(h) };
              u &&
                ((d.options = r.resolveDataElementOptions(l, i)),
                a && (d.options.radius = 0)),
                r.updateElement(e, l, d, i);
            }
            r.updateSharedOptions(c, i, l);
          }
          resolveDataElementOptions(t, e) {
            const n = this.getParsed(t);
            let i = super.resolveDataElementOptions(t, e);
            i.$shared && (i = Object.assign({}, i, { $shared: !1 }));
            const r = i.radius;
            return (
              'active' !== e && (i.radius = 0),
              (i.radius += y(n && n._custom, r)),
              i
            );
          }
        }
        (qn.id = 'bubble'),
          (qn.defaults = {
            datasetElementType: !1,
            dataElementType: 'point',
            animations: {
              numbers: {
                type: 'number',
                properties: ['x', 'y', 'borderWidth', 'radius'],
              },
            },
          }),
          (qn.overrides = {
            scales: { x: { type: 'linear' }, y: { type: 'linear' } },
            plugins: { tooltip: { callbacks: { title: () => '' } } },
          });
        class Sn extends vn {
          constructor(t, e) {
            super(t, e),
              (this.enableOptionSharing = !0),
              (this.innerRadius = void 0),
              (this.outerRadius = void 0),
              (this.offsetX = void 0),
              (this.offsetY = void 0);
          }
          linkScales() {}
          parse(t, e) {
            const n = this.getDataset().data,
              i = this._cachedMeta;
            let r, a;
            for (r = t, a = t + e; r < a; ++r) i._parsed[r] = +n[r];
          }
          _getRotation() {
            return X(this.options.rotation - 90);
          }
          _getCircumference() {
            return X(this.options.circumference);
          }
          _getRotationExtents() {
            let t = I,
              e = -I;
            const n = this;
            for (let i = 0; i < n.chart.data.datasets.length; ++i)
              if (n.chart.isDatasetVisible(i)) {
                const r = n.chart.getDatasetMeta(i).controller,
                  a = r._getRotation(),
                  o = r._getCircumference();
                (t = Math.min(t, a)), (e = Math.max(e, a + o));
              }
            return { rotation: t, circumference: e - t };
          }
          update(t) {
            const e = this,
              n = e.chart,
              { chartArea: i } = n,
              r = e._cachedMeta,
              a = r.data,
              o = e.getMaxBorderWidth() + e.getMaxOffset(a),
              s = Math.max((Math.min(i.width, i.height) - o) / 2, 0),
              l = Math.min(
                ((c = e.options.cutout),
                (u = s),
                'string' == typeof c && c.endsWith('%')
                  ? parseFloat(c) / 100
                  : c / u),
                1,
              );
            var c, u;
            const h = e._getRingWeight(e.index),
              { circumference: d, rotation: p } = e._getRotationExtents(),
              {
                ratioX: f,
                ratioY: m,
                offsetX: g,
                offsetY: y,
              } = (function (t, e, n) {
                let i = 1,
                  r = 1,
                  a = 0,
                  o = 0;
                if (e < I) {
                  const s = t,
                    l = s + e,
                    c = Math.cos(s),
                    u = Math.sin(s),
                    h = Math.cos(l),
                    d = Math.sin(l),
                    p = (t, e, i) =>
                      K(t, s, l) ? 1 : Math.max(e, e * n, i, i * n),
                    f = (t, e, i) =>
                      K(t, s, l) ? -1 : Math.min(e, e * n, i, i * n),
                    m = p(0, c, h),
                    g = p(z, u, d),
                    y = f(k, c, h),
                    v = f(k + z, u, d);
                  (i = (m - y) / 2),
                    (r = (g - v) / 2),
                    (a = -(m + y) / 2),
                    (o = -(g + v) / 2);
                }
                return { ratioX: i, ratioY: r, offsetX: a, offsetY: o };
              })(p, d, l),
              x = (i.width - o) / f,
              b = (i.height - o) / m,
              _ = Math.max(Math.min(x, b) / 2, 0),
              w = v(e.options.radius, _),
              M = (w - Math.max(w * l, 0)) / e._getVisibleDatasetWeightTotal();
            (e.offsetX = g * w),
              (e.offsetY = y * w),
              (r.total = e.calculateTotal()),
              (e.outerRadius = w - M * e._getRingWeightOffset(e.index)),
              (e.innerRadius = Math.max(e.outerRadius - M * h, 0)),
              e.updateElements(a, 0, a.length, t);
          }
          _circumference(t, e) {
            const n = this.options,
              i = this._cachedMeta,
              r = this._getCircumference();
            return (e && n.animation.animateRotate) ||
              !this.chart.getDataVisibility(t) ||
              null === i._parsed[t]
              ? 0
              : this.calculateCircumference((i._parsed[t] * r) / I);
          }
          updateElements(t, e, n, i) {
            const r = this,
              a = 'reset' === i,
              o = r.chart,
              s = o.chartArea,
              l = o.options.animation,
              c = (s.left + s.right) / 2,
              u = (s.top + s.bottom) / 2,
              h = a && l.animateScale,
              d = h ? 0 : r.innerRadius,
              p = h ? 0 : r.outerRadius,
              f = r.resolveDataElementOptions(e, i),
              m = r.getSharedOptions(f),
              g = r.includeOptions(i, m);
            let y,
              v = r._getRotation();
            for (y = 0; y < e; ++y) v += r._circumference(y, a);
            for (y = e; y < e + n; ++y) {
              const e = r._circumference(y, a),
                n = t[y],
                o = {
                  x: c + r.offsetX,
                  y: u + r.offsetY,
                  startAngle: v,
                  endAngle: v + e,
                  circumference: e,
                  outerRadius: p,
                  innerRadius: d,
                };
              g && (o.options = m || r.resolveDataElementOptions(y, i)),
                (v += e),
                r.updateElement(n, y, o, i);
            }
            r.updateSharedOptions(m, i, f);
          }
          calculateTotal() {
            const t = this._cachedMeta,
              e = t.data;
            let n,
              i = 0;
            for (n = 0; n < e.length; n++) {
              const e = t._parsed[n];
              null !== e &&
                !isNaN(e) &&
                this.chart.getDataVisibility(n) &&
                (i += Math.abs(e));
            }
            return i;
          }
          calculateCircumference(t) {
            const e = this._cachedMeta.total;
            return e > 0 && !isNaN(t) ? I * (Math.abs(t) / e) : 0;
          }
          getLabelAndValue(t) {
            const e = this._cachedMeta,
              n = this.chart,
              i = n.data.labels || [],
              r = Ye(e._parsed[t], n.options.locale);
            return { label: i[t] || '', value: r };
          }
          getMaxBorderWidth(t) {
            const e = this;
            let n = 0;
            const i = e.chart;
            let r, a, o, s, l;
            if (!t)
              for (r = 0, a = i.data.datasets.length; r < a; ++r)
                if (i.isDatasetVisible(r)) {
                  (o = i.getDatasetMeta(r)),
                    (t = o.data),
                    (s = o.controller),
                    s !== e && s.configure();
                  break;
                }
            if (!t) return 0;
            for (r = 0, a = t.length; r < a; ++r)
              (l = s.resolveDataElementOptions(r)),
                'inner' !== l.borderAlign &&
                  (n = Math.max(
                    n,
                    l.borderWidth || 0,
                    l.hoverBorderWidth || 0,
                  ));
            return n;
          }
          getMaxOffset(t) {
            let e = 0;
            for (let n = 0, i = t.length; n < i; ++n) {
              const t = this.resolveDataElementOptions(n);
              e = Math.max(e, t.offset || 0, t.hoverOffset || 0);
            }
            return e;
          }
          _getRingWeightOffset(t) {
            let e = 0;
            for (let n = 0; n < t; ++n)
              this.chart.isDatasetVisible(n) && (e += this._getRingWeight(n));
            return e;
          }
          _getRingWeight(t) {
            return Math.max(y(this.chart.data.datasets[t].weight, 1), 0);
          }
          _getVisibleDatasetWeightTotal() {
            return (
              this._getRingWeightOffset(this.chart.data.datasets.length) || 1
            );
          }
        }
        (Sn.id = 'doughnut'),
          (Sn.defaults = {
            datasetElementType: !1,
            dataElementType: 'arc',
            animation: { animateRotate: !0, animateScale: !1 },
            animations: {
              numbers: {
                type: 'number',
                properties: [
                  'circumference',
                  'endAngle',
                  'innerRadius',
                  'outerRadius',
                  'startAngle',
                  'x',
                  'y',
                  'offset',
                  'borderWidth',
                ],
              },
            },
            cutout: '50%',
            rotation: 0,
            circumference: 360,
            radius: '100%',
            indexAxis: 'r',
          }),
          (Sn.overrides = {
            aspectRatio: 1,
            plugins: {
              legend: {
                labels: {
                  generateLabels(t) {
                    const e = t.data;
                    return e.labels.length && e.datasets.length
                      ? e.labels.map((e, n) => {
                          const i = t.getDatasetMeta(0).controller.getStyle(n);
                          return {
                            text: e,
                            fillStyle: i.backgroundColor,
                            strokeStyle: i.borderColor,
                            lineWidth: i.borderWidth,
                            hidden: !t.getDataVisibility(n),
                            index: n,
                          };
                        })
                      : [];
                  },
                },
                onClick(t, e, n) {
                  n.chart.toggleDataVisibility(e.index), n.chart.update();
                },
              },
              tooltip: {
                callbacks: {
                  title: () => '',
                  label(t) {
                    let e = t.label;
                    const n = ': ' + t.formattedValue;
                    return p(e) ? ((e = e.slice()), (e[0] += n)) : (e += n), e;
                  },
                },
              },
            },
          });
        class Tn extends vn {
          initialize() {
            (this.enableOptionSharing = !0), super.initialize();
          }
          update(t) {
            const e = this,
              n = e._cachedMeta,
              { dataset: i, data: r = [], _dataset: a } = n,
              o = e.chart._animationsDisabled;
            let { start: s, count: l } = (function (t, e, n) {
              const i = e.length;
              let r = 0,
                a = i;
              if (t._sorted) {
                const { iScale: o, _parsed: s } = t,
                  l = o.axis,
                  {
                    min: c,
                    max: u,
                    minDefined: h,
                    maxDefined: d,
                  } = o.getUserBounds();
                h &&
                  (r = Q(
                    Math.min(
                      ce(s, o.axis, c).lo,
                      n ? i : ce(e, l, o.getPixelForValue(c)).lo,
                    ),
                    0,
                    i - 1,
                  )),
                  (a = d
                    ? Q(
                        Math.max(
                          ce(s, o.axis, u).hi + 1,
                          n ? 0 : ce(e, l, o.getPixelForValue(u)).hi + 1,
                        ),
                        r,
                        i,
                      ) - r
                    : i - r);
              }
              return { start: r, count: a };
            })(n, r, o);
            if (
              ((e._drawStart = s),
              (e._drawCount = l),
              (function (t) {
                const { xScale: e, yScale: n, _scaleRanges: i } = t,
                  r = { xmin: e.min, xmax: e.max, ymin: n.min, ymax: n.max };
                if (!i) return (t._scaleRanges = r), !0;
                const a =
                  i.xmin !== e.min ||
                  i.xmax !== e.max ||
                  i.ymin !== n.min ||
                  i.ymax !== n.max;
                return Object.assign(i, r), a;
              })(n) && ((s = 0), (l = r.length)),
              (i._decimated = !!a._decimated),
              (i.points = r),
              'resize' !== t)
            ) {
              const n = e.resolveDatasetElementOptions(t);
              e.options.showLine || (n.borderWidth = 0),
                e.updateElement(i, void 0, { animated: !o, options: n }, t);
            }
            e.updateElements(r, s, l, t);
          }
          updateElements(t, e, n, i) {
            const r = this,
              a = 'reset' === i,
              { xScale: o, yScale: s, _stacked: l } = r._cachedMeta,
              c = r.resolveDataElementOptions(e, i),
              u = r.getSharedOptions(c),
              h = r.includeOptions(i, u),
              d = r.options.spanGaps,
              p = H(d) ? d : Number.POSITIVE_INFINITY,
              f = r.chart._animationsDisabled || a || 'none' === i;
            let m = e > 0 && r.getParsed(e - 1);
            for (let c = e; c < e + n; ++c) {
              const e = t[c],
                n = r.getParsed(c),
                d = f ? e : {},
                g = (d.x = o.getPixelForValue(n.x, c)),
                y = (d.y = a
                  ? s.getBasePixel()
                  : s.getPixelForValue(l ? r.applyStack(s, n, l) : n.y, c));
              (d.skip = isNaN(g) || isNaN(y)),
                (d.stop = c > 0 && n.x - m.x > p),
                h && (d.options = u || r.resolveDataElementOptions(c, i)),
                f || r.updateElement(e, c, d, i),
                (m = n);
            }
            r.updateSharedOptions(u, i, c);
          }
          getMaxOverflow() {
            const t = this._cachedMeta,
              e = t.dataset,
              n = (e.options && e.options.borderWidth) || 0,
              i = t.data || [];
            if (!i.length) return n;
            const r = i[0].size(this.resolveDataElementOptions(0)),
              a = i[i.length - 1].size(
                this.resolveDataElementOptions(i.length - 1),
              );
            return Math.max(n, r, a) / 2;
          }
          draw() {
            this._cachedMeta.dataset.updateControlPoints(this.chart.chartArea),
              super.draw();
          }
        }
        (Tn.id = 'line'),
          (Tn.defaults = {
            datasetElementType: 'line',
            dataElementType: 'point',
            showLine: !0,
            spanGaps: !1,
          }),
          (Tn.overrides = {
            scales: {
              _index_: { type: 'category' },
              _value_: { type: 'linear' },
            },
          });
        class En extends vn {
          constructor(t, e) {
            super(t, e),
              (this.innerRadius = void 0),
              (this.outerRadius = void 0);
          }
          update(t) {
            const e = this._cachedMeta.data;
            this._updateRadius(), this.updateElements(e, 0, e.length, t);
          }
          _updateRadius() {
            const t = this,
              e = t.chart,
              n = e.chartArea,
              i = e.options,
              r = Math.min(n.right - n.left, n.bottom - n.top),
              a = Math.max(r / 2, 0),
              o =
                (a -
                  Math.max(
                    i.cutoutPercentage ? (a / 100) * i.cutoutPercentage : 1,
                    0,
                  )) /
                e.getVisibleDatasetCount();
            (t.outerRadius = a - o * t.index),
              (t.innerRadius = t.outerRadius - o);
          }
          updateElements(t, e, n, i) {
            const r = this,
              a = 'reset' === i,
              o = r.chart,
              s = r.getDataset(),
              l = o.options.animation,
              c = r._cachedMeta.rScale,
              u = c.xCenter,
              h = c.yCenter,
              d = c.getIndexAngle(0) - 0.5 * k;
            let p,
              f = d;
            const m = 360 / r.countVisibleElements();
            for (p = 0; p < e; ++p) f += r._computeAngle(p, i, m);
            for (p = e; p < e + n; p++) {
              const e = t[p];
              let n = f,
                g = f + r._computeAngle(p, i, m),
                y = o.getDataVisibility(p)
                  ? c.getDistanceFromCenterForValue(s.data[p])
                  : 0;
              (f = g),
                a &&
                  (l.animateScale && (y = 0), l.animateRotate && (n = g = d));
              const v = {
                x: u,
                y: h,
                innerRadius: 0,
                outerRadius: y,
                startAngle: n,
                endAngle: g,
                options: r.resolveDataElementOptions(p, i),
              };
              r.updateElement(e, p, v, i);
            }
          }
          countVisibleElements() {
            const t = this.getDataset(),
              e = this._cachedMeta;
            let n = 0;
            return (
              e.data.forEach((e, i) => {
                !isNaN(t.data[i]) && this.chart.getDataVisibility(i) && n++;
              }),
              n
            );
          }
          _computeAngle(t, e, n) {
            return this.chart.getDataVisibility(t)
              ? X(this.resolveDataElementOptions(t, e).angle || n)
              : 0;
          }
        }
        (En.id = 'polarArea'),
          (En.defaults = {
            dataElementType: 'arc',
            animation: { animateRotate: !0, animateScale: !0 },
            animations: {
              numbers: {
                type: 'number',
                properties: [
                  'x',
                  'y',
                  'startAngle',
                  'endAngle',
                  'innerRadius',
                  'outerRadius',
                ],
              },
            },
            indexAxis: 'r',
            startAngle: 0,
          }),
          (En.overrides = {
            aspectRatio: 1,
            plugins: {
              legend: {
                labels: {
                  generateLabels(t) {
                    const e = t.data;
                    return e.labels.length && e.datasets.length
                      ? e.labels.map((e, n) => {
                          const i = t.getDatasetMeta(0).controller.getStyle(n);
                          return {
                            text: e,
                            fillStyle: i.backgroundColor,
                            strokeStyle: i.borderColor,
                            lineWidth: i.borderWidth,
                            hidden: !t.getDataVisibility(n),
                            index: n,
                          };
                        })
                      : [];
                  },
                },
                onClick(t, e, n) {
                  n.chart.toggleDataVisibility(e.index), n.chart.update();
                },
              },
              tooltip: {
                callbacks: {
                  title: () => '',
                  label: (t) =>
                    t.chart.data.labels[t.dataIndex] + ': ' + t.formattedValue,
                },
              },
            },
            scales: {
              r: {
                type: 'radialLinear',
                angleLines: { display: !1 },
                beginAtZero: !0,
                grid: { circular: !0 },
                pointLabels: { display: !1 },
                startAngle: 0,
              },
            },
          });
        class An extends Sn {}
        (An.id = 'pie'),
          (An.defaults = {
            cutout: 0,
            rotation: 0,
            circumference: 360,
            radius: '100%',
          });
        class Ln extends vn {
          getLabelAndValue(t) {
            const e = this._cachedMeta.vScale,
              n = this.getParsed(t);
            return {
              label: e.getLabels()[t],
              value: '' + e.getLabelForValue(n[e.axis]),
            };
          }
          update(t) {
            const e = this,
              n = e._cachedMeta,
              i = n.dataset,
              r = n.data || [],
              a = n.iScale.getLabels();
            if (((i.points = r), 'resize' !== t)) {
              const n = e.resolveDatasetElementOptions(t);
              e.options.showLine || (n.borderWidth = 0);
              const o = {
                _loop: !0,
                _fullLoop: a.length === r.length,
                options: n,
              };
              e.updateElement(i, void 0, o, t);
            }
            e.updateElements(r, 0, r.length, t);
          }
          updateElements(t, e, n, i) {
            const r = this,
              a = r.getDataset(),
              o = r._cachedMeta.rScale,
              s = 'reset' === i;
            for (let l = e; l < e + n; l++) {
              const e = t[l],
                n = r.resolveDataElementOptions(l, i),
                c = o.getPointPositionForValue(l, a.data[l]),
                u = s ? o.xCenter : c.x,
                h = s ? o.yCenter : c.y,
                d = {
                  x: u,
                  y: h,
                  angle: c.angle,
                  skip: isNaN(u) || isNaN(h),
                  options: n,
                };
              r.updateElement(e, l, d, i);
            }
          }
        }
        (Ln.id = 'radar'),
          (Ln.defaults = {
            datasetElementType: 'line',
            dataElementType: 'point',
            indexAxis: 'r',
            showLine: !0,
            elements: { line: { fill: 'start' } },
          }),
          (Ln.overrides = {
            aspectRatio: 1,
            scales: { r: { type: 'radialLinear' } },
          });
        class Rn extends Tn {}
        (Rn.id = 'scatter'),
          (Rn.defaults = { showLine: !1, fill: !1 }),
          (Rn.overrides = {
            interaction: { mode: 'point' },
            plugins: {
              tooltip: {
                callbacks: {
                  title: () => '',
                  label: (t) => '(' + t.label + ', ' + t.formattedValue + ')',
                },
              },
            },
            scales: { x: { type: 'linear' }, y: { type: 'linear' } },
          });
        function Cn() {
          throw new Error(
            'This method is not implemented: either no adapter can be found or an incomplete integration was provided.',
          );
        }
        class Pn {
          constructor(t) {
            this.options = t || {};
          }
          formats() {
            return Cn();
          }
          parse(t, e) {
            return Cn();
          }
          format(t, e) {
            return Cn();
          }
          add(t, e, n) {
            return Cn();
          }
          diff(t, e, n) {
            return Cn();
          }
          startOf(t, e, n) {
            return Cn();
          }
          endOf(t, e) {
            return Cn();
          }
        }
        Pn.override = function (t) {
          Object.assign(Pn.prototype, t);
        };
        var kn = { _date: Pn };
        function In(t, e) {
          return 'native' in t ? { x: t.x, y: t.y } : ze(t, e);
        }
        function Dn(t, e, n, i) {
          const { controller: r, data: a, _sorted: o } = t,
            s = r._cachedMeta.iScale;
          if (s && e === s.axis && o && a.length) {
            const t = s._reversePixels ? ue : ce;
            if (!i) return t(a, e, n);
            if (r._sharedOptions) {
              const i = a[0],
                r = 'function' == typeof i.getRange && i.getRange(e);
              if (r) {
                const i = t(a, e, n - r),
                  o = t(a, e, n + r);
                return { lo: i.lo, hi: o.hi };
              }
            }
          }
          return { lo: 0, hi: a.length - 1 };
        }
        function On(t, e, n, i, r) {
          const a = t.getSortedVisibleDatasetMetas(),
            o = n[e];
          for (let t = 0, n = a.length; t < n; ++t) {
            const { index: n, data: s } = a[t],
              { lo: l, hi: c } = Dn(a[t], e, o, r);
            for (let t = l; t <= c; ++t) {
              const e = s[t];
              e.skip || i(e, n, t);
            }
          }
        }
        function Nn(t, e, n, i) {
          const r = [];
          if (!$t(e, t.chartArea, t._minPadding)) return r;
          return (
            On(
              t,
              n,
              e,
              function (t, n, a) {
                t.inRange(e.x, e.y, i) &&
                  r.push({ element: t, datasetIndex: n, index: a });
              },
              !0,
            ),
            r
          );
        }
        function zn(t, e, n, i, r) {
          const a = (function (t) {
            const e = -1 !== t.indexOf('x'),
              n = -1 !== t.indexOf('y');
            return function (t, i) {
              const r = e ? Math.abs(t.x - i.x) : 0,
                a = n ? Math.abs(t.y - i.y) : 0;
              return Math.sqrt(Math.pow(r, 2) + Math.pow(a, 2));
            };
          })(n);
          let o = Number.POSITIVE_INFINITY,
            s = [];
          if (!$t(e, t.chartArea, t._minPadding)) return s;
          return (
            On(t, n, e, function (t, n, l) {
              if (i && !t.inRange(e.x, e.y, r)) return;
              const c = t.getCenterPoint(r),
                u = a(e, c);
              u < o
                ? ((s = [{ element: t, datasetIndex: n, index: l }]), (o = u))
                : u === o && s.push({ element: t, datasetIndex: n, index: l });
            }),
            s
          );
        }
        function Fn(t, e, n, i) {
          const r = In(e, t),
            a = [],
            o = n.axis,
            s = 'x' === o ? 'inXRange' : 'inYRange';
          let l = !1;
          return (
            (function (t, e) {
              const n = t.getSortedVisibleDatasetMetas();
              let i, r, a;
              for (let t = 0, o = n.length; t < o; ++t) {
                ({ index: i, data: r } = n[t]);
                for (let t = 0, n = r.length; t < n; ++t)
                  (a = r[t]), a.skip || e(a, i, t);
              }
            })(t, (t, e, n) => {
              t[s](r[o], i) &&
                a.push({ element: t, datasetIndex: e, index: n }),
                t.inRange(r.x, r.y, i) && (l = !0);
            }),
            n.intersect && !l ? [] : a
          );
        }
        var Bn = {
          modes: {
            index(t, e, n, i) {
              const r = In(e, t),
                a = n.axis || 'x',
                o = n.intersect ? Nn(t, r, a, i) : zn(t, r, a, !1, i),
                s = [];
              return o.length
                ? (t.getSortedVisibleDatasetMetas().forEach((t) => {
                    const e = o[0].index,
                      n = t.data[e];
                    n &&
                      !n.skip &&
                      s.push({ element: n, datasetIndex: t.index, index: e });
                  }),
                  s)
                : [];
            },
            dataset(t, e, n, i) {
              const r = In(e, t),
                a = n.axis || 'xy';
              let o = n.intersect ? Nn(t, r, a, i) : zn(t, r, a, !1, i);
              if (o.length > 0) {
                const e = o[0].datasetIndex,
                  n = t.getDatasetMeta(e).data;
                o = [];
                for (let t = 0; t < n.length; ++t)
                  o.push({ element: n[t], datasetIndex: e, index: t });
              }
              return o;
            },
            point: (t, e, n, i) => Nn(t, In(e, t), n.axis || 'xy', i),
            nearest: (t, e, n, i) =>
              zn(t, In(e, t), n.axis || 'xy', n.intersect, i),
            x: (t, e, n, i) => ((n.axis = 'x'), Fn(t, e, n, i)),
            y: (t, e, n, i) => ((n.axis = 'y'), Fn(t, e, n, i)),
          },
        };
        const Un = ['left', 'top', 'right', 'bottom'];
        function jn(t, e) {
          return t.filter((t) => t.pos === e);
        }
        function Gn(t, e) {
          return t.filter((t) => -1 === Un.indexOf(t.pos) && t.box.axis === e);
        }
        function Hn(t, e) {
          return t.sort((t, n) => {
            const i = e ? n : t,
              r = e ? t : n;
            return i.weight === r.weight
              ? i.index - r.index
              : i.weight - r.weight;
          });
        }
        function Vn(t, e, n, i) {
          return Math.max(t[n], e[n]) + Math.max(t[i], e[i]);
        }
        function Wn(t, e) {
          (t.top = Math.max(t.top, e.top)),
            (t.left = Math.max(t.left, e.left)),
            (t.bottom = Math.max(t.bottom, e.bottom)),
            (t.right = Math.max(t.right, e.right));
        }
        function Xn(t, e, n) {
          const i = n.box,
            r = t.maxPadding;
          if (f(n.pos)) return { same: !1, other: !1 };
          n.size && (t[n.pos] -= n.size),
            (n.size = n.horizontal ? i.height : i.width),
            (t[n.pos] += n.size),
            i.getPadding && Wn(r, i.getPadding());
          const a = Math.max(0, e.outerWidth - Vn(r, t, 'left', 'right')),
            o = Math.max(0, e.outerHeight - Vn(r, t, 'top', 'bottom')),
            s = a !== t.w,
            l = o !== t.h;
          return (
            (t.w = a),
            (t.h = o),
            n.horizontal ? { same: s, other: l } : { same: l, other: s }
          );
        }
        function Yn(t, e) {
          const n = e.maxPadding;
          function i(t) {
            const i = { left: 0, top: 0, right: 0, bottom: 0 };
            return (
              t.forEach((t) => {
                i[t] = Math.max(e[t], n[t]);
              }),
              i
            );
          }
          return i(t ? ['left', 'right'] : ['top', 'bottom']);
        }
        function $n(t, e, n) {
          const i = [];
          let r, a, o, s, l, c;
          for (r = 0, a = t.length, l = 0; r < a; ++r) {
            (o = t[r]),
              (s = o.box),
              s.update(o.width || e.w, o.height || e.h, Yn(o.horizontal, e));
            const { same: a, other: u } = Xn(e, n, o);
            (l |= a && i.length), (c = c || u), s.fullSize || i.push(o);
          }
          return (l && $n(i, e, n)) || c;
        }
        function Jn(t, e, n) {
          const i = n.padding;
          let r,
            a,
            o,
            s,
            l = e.x,
            c = e.y;
          for (r = 0, a = t.length; r < a; ++r)
            (o = t[r]),
              (s = o.box),
              o.horizontal
                ? ((s.left = s.fullSize ? i.left : e.left),
                  (s.right = s.fullSize
                    ? n.outerWidth - i.right
                    : e.left + e.w),
                  (s.top = c),
                  (s.bottom = c + s.height),
                  (s.width = s.right - s.left),
                  (c = s.bottom))
                : ((s.left = l),
                  (s.right = l + s.width),
                  (s.top = s.fullSize ? i.top : e.top),
                  (s.bottom = s.fullSize
                    ? n.outerHeight - i.right
                    : e.top + e.h),
                  (s.height = s.bottom - s.top),
                  (l = s.right));
          (e.x = l), (e.y = c);
        }
        Gt.set('layout', { padding: { top: 0, right: 0, bottom: 0, left: 0 } });
        var Zn = {
          addBox(t, e) {
            t.boxes || (t.boxes = []),
              (e.fullSize = e.fullSize || !1),
              (e.position = e.position || 'top'),
              (e.weight = e.weight || 0),
              (e._layers =
                e._layers ||
                function () {
                  return [
                    {
                      z: 0,
                      draw(t) {
                        e.draw(t);
                      },
                    },
                  ];
                }),
              t.boxes.push(e);
          },
          removeBox(t, e) {
            const n = t.boxes ? t.boxes.indexOf(e) : -1;
            -1 !== n && t.boxes.splice(n, 1);
          },
          configure(t, e, n) {
            (e.fullSize = n.fullSize),
              (e.position = n.position),
              (e.weight = n.weight);
          },
          update(t, e, n, i) {
            if (!t) return;
            const r = ae(t.options.layout.padding),
              a = e - r.width,
              o = n - r.height,
              s = (function (t) {
                const e = (function (t) {
                    const e = [];
                    let n, i, r;
                    for (n = 0, i = (t || []).length; n < i; ++n)
                      (r = t[n]),
                        e.push({
                          index: n,
                          box: r,
                          pos: r.position,
                          horizontal: r.isHorizontal(),
                          weight: r.weight,
                        });
                    return e;
                  })(t),
                  n = Hn(
                    e.filter((t) => t.box.fullSize),
                    !0,
                  ),
                  i = Hn(jn(e, 'left'), !0),
                  r = Hn(jn(e, 'right')),
                  a = Hn(jn(e, 'top'), !0),
                  o = Hn(jn(e, 'bottom')),
                  s = Gn(e, 'x'),
                  l = Gn(e, 'y');
                return {
                  fullSize: n,
                  leftAndTop: i.concat(a),
                  rightAndBottom: r.concat(l).concat(o).concat(s),
                  chartArea: jn(e, 'chartArea'),
                  vertical: i.concat(r).concat(l),
                  horizontal: a.concat(o).concat(s),
                };
              })(t.boxes),
              l = s.vertical,
              c = s.horizontal;
            b(t.boxes, (t) => {
              'function' == typeof t.beforeLayout && t.beforeLayout();
            });
            const u =
                l.reduce(
                  (t, e) =>
                    e.box.options && !1 === e.box.options.display ? t : t + 1,
                  0,
                ) || 1,
              h = Object.freeze({
                outerWidth: e,
                outerHeight: n,
                padding: r,
                availableWidth: a,
                availableHeight: o,
                vBoxMaxWidth: a / 2 / u,
                hBoxMaxHeight: o / 2,
              }),
              d = Object.assign({}, r);
            Wn(d, ae(i));
            const p = Object.assign(
              { maxPadding: d, w: a, h: o, x: r.left, y: r.top },
              r,
            );
            !(function (t, e) {
              let n, i, r;
              for (n = 0, i = t.length; n < i; ++n)
                (r = t[n]),
                  r.horizontal
                    ? ((r.width = r.box.fullSize && e.availableWidth),
                      (r.height = e.hBoxMaxHeight))
                    : ((r.width = e.vBoxMaxWidth),
                      (r.height = r.box.fullSize && e.availableHeight));
            })(l.concat(c), h),
              $n(s.fullSize, p, h),
              $n(l, p, h),
              $n(c, p, h) && $n(l, p, h),
              (function (t) {
                const e = t.maxPadding;
                function n(n) {
                  const i = Math.max(e[n] - t[n], 0);
                  return (t[n] += i), i;
                }
                (t.y += n('top')), (t.x += n('left')), n('right'), n('bottom');
              })(p),
              Jn(s.leftAndTop, p, h),
              (p.x += p.w),
              (p.y += p.h),
              Jn(s.rightAndBottom, p, h),
              (t.chartArea = {
                left: p.left,
                top: p.top,
                right: p.left + p.w,
                bottom: p.top + p.h,
                height: p.h,
                width: p.w,
              }),
              b(s.chartArea, (e) => {
                const n = e.box;
                Object.assign(n, t.chartArea), n.update(p.w, p.h);
              });
          },
        };
        class Kn {
          acquireContext(t, e) {}
          releaseContext(t) {
            return !1;
          }
          addEventListener(t, e, n) {}
          removeEventListener(t, e, n) {}
          getDevicePixelRatio() {
            return 1;
          }
          getMaximumSize(t, e, n, i) {
            return (
              (e = Math.max(0, e || t.width)),
              (n = n || t.height),
              { width: e, height: Math.max(0, i ? Math.floor(e / i) : n) }
            );
          }
          isAttached(t) {
            return !0;
          }
        }
        class Qn extends Kn {
          acquireContext(t) {
            return (t && t.getContext && t.getContext('2d')) || null;
          }
        }
        const ti = {
            touchstart: 'mousedown',
            touchmove: 'mousemove',
            touchend: 'mouseup',
            pointerenter: 'mouseenter',
            pointerdown: 'mousedown',
            pointermove: 'mousemove',
            pointerup: 'mouseup',
            pointerleave: 'mouseout',
            pointerout: 'mouseout',
          },
          ei = (t) => null === t || '' === t;
        const ni = !!je && { passive: !0 };
        function ii(t, e, n) {
          t.canvas.removeEventListener(e, n, ni);
        }
        function ri(t, e, n) {
          const i = t.canvas,
            r = (i && ke(i)) || i,
            a = new MutationObserver((t) => {
              const e = ke(r);
              t.forEach((t) => {
                for (let i = 0; i < t.addedNodes.length; i++) {
                  const a = t.addedNodes[i];
                  (a !== r && a !== e) || n(t.target);
                }
              });
            });
          return a.observe(document, { childList: !0, subtree: !0 }), a;
        }
        function ai(t, e, n) {
          const i = t.canvas,
            r = i && ke(i);
          if (!r) return;
          const a = new MutationObserver((t) => {
            t.forEach((t) => {
              for (let e = 0; e < t.removedNodes.length; e++)
                if (t.removedNodes[e] === i) {
                  n();
                  break;
                }
            });
          });
          return a.observe(r, { childList: !0 }), a;
        }
        const oi = new Map();
        let si = 0;
        function li() {
          const t = window.devicePixelRatio;
          t !== si &&
            ((si = t),
            oi.forEach((e, n) => {
              n.currentDevicePixelRatio !== t && e();
            }));
        }
        function ci(t, e, n) {
          const i = t.canvas,
            r = i && ke(i);
          if (!r) return;
          const a = l((t, e) => {
              const i = r.clientWidth;
              n(t, e), i < r.clientWidth && n();
            }, window),
            o = new ResizeObserver((t) => {
              const e = t[0],
                n = e.contentRect.width,
                i = e.contentRect.height;
              (0 === n && 0 === i) || a(n, i);
            });
          return (
            o.observe(r),
            (function (t, e) {
              oi.size || window.addEventListener('resize', li), oi.set(t, e);
            })(t, a),
            o
          );
        }
        function ui(t, e, n) {
          n && n.disconnect(),
            'resize' === e &&
              (function (t) {
                oi.delete(t),
                  oi.size || window.removeEventListener('resize', li);
              })(t);
        }
        function hi(t, e, n) {
          const i = t.canvas,
            r = l(
              (e) => {
                null !== t.ctx &&
                  n(
                    (function (t, e) {
                      const n = ti[t.type] || t.type,
                        { x: i, y: r } = ze(t, e);
                      return {
                        type: n,
                        chart: e,
                        native: t,
                        x: void 0 !== i ? i : null,
                        y: void 0 !== r ? r : null,
                      };
                    })(e, t),
                  );
              },
              t,
              (t) => {
                const e = t[0];
                return [e, e.offsetX, e.offsetY];
              },
            );
          return (
            (function (t, e, n) {
              t.addEventListener(e, n, ni);
            })(i, e, r),
            r
          );
        }
        class di extends Kn {
          acquireContext(t, e) {
            const n = t && t.getContext && t.getContext('2d');
            return n && n.canvas === t
              ? ((function (t, e) {
                  const n = t.style,
                    i = t.getAttribute('height'),
                    r = t.getAttribute('width');
                  if (
                    ((t.$chartjs = {
                      initial: {
                        height: i,
                        width: r,
                        style: {
                          display: n.display,
                          height: n.height,
                          width: n.width,
                        },
                      },
                    }),
                    (n.display = n.display || 'block'),
                    (n.boxSizing = n.boxSizing || 'border-box'),
                    ei(r))
                  ) {
                    const e = Ge(t, 'width');
                    void 0 !== e && (t.width = e);
                  }
                  if (ei(i))
                    if ('' === t.style.height) t.height = t.width / (e || 2);
                    else {
                      const e = Ge(t, 'height');
                      void 0 !== e && (t.height = e);
                    }
                })(t, e),
                n)
              : null;
          }
          releaseContext(t) {
            const e = t.canvas;
            if (!e.$chartjs) return !1;
            const n = e.$chartjs.initial;
            ['height', 'width'].forEach((t) => {
              const i = n[t];
              d(i) ? e.removeAttribute(t) : e.setAttribute(t, i);
            });
            const i = n.style || {};
            return (
              Object.keys(i).forEach((t) => {
                e.style[t] = i[t];
              }),
              (e.width = e.width),
              delete e.$chartjs,
              !0
            );
          }
          addEventListener(t, e, n) {
            this.removeEventListener(t, e);
            const i = t.$proxies || (t.$proxies = {}),
              r = { attach: ri, detach: ai, resize: ci }[e] || hi;
            i[e] = r(t, e, n);
          }
          removeEventListener(t, e) {
            const n = t.$proxies || (t.$proxies = {}),
              i = n[e];
            if (!i) return;
            (({ attach: ui, detach: ui, resize: ui }[e] || ii)(t, e, i),
              (n[e] = void 0));
          }
          getDevicePixelRatio() {
            return window.devicePixelRatio;
          }
          getMaximumSize(t, e, n, i) {
            return Be(t, e, n, i);
          }
          isAttached(t) {
            const e = ke(t);
            return !(!e || !ke(e));
          }
        }
        class pi {
          constructor() {
            (this.x = void 0),
              (this.y = void 0),
              (this.active = !1),
              (this.options = void 0),
              (this.$animations = void 0);
          }
          tooltipPosition(t) {
            const { x: e, y: n } = this.getProps(['x', 'y'], t);
            return { x: e, y: n };
          }
          hasValue() {
            return H(this.x) && H(this.y);
          }
          getProps(t, e) {
            const n = this,
              i = this.$animations;
            if (!e || !i) return n;
            const r = {};
            return (
              t.forEach((t) => {
                r[t] = i[t] && i[t].active() ? i[t]._to : n[t];
              }),
              r
            );
          }
        }
        (pi.defaults = {}), (pi.defaultRoutes = void 0);
        const fi = {
          values: (t) => (p(t) ? t : '' + t),
          numeric(t, e, n) {
            if (0 === t) return '0';
            const i = this.chart.options.locale;
            let r,
              a = t;
            if (n.length > 1) {
              const e = Math.max(
                Math.abs(n[0].value),
                Math.abs(n[n.length - 1].value),
              );
              (e < 1e-4 || e > 1e15) && (r = 'scientific'),
                (a = (function (t, e) {
                  let n =
                    e.length > 3
                      ? e[2].value - e[1].value
                      : e[1].value - e[0].value;
                  Math.abs(n) > 1 &&
                    t !== Math.floor(t) &&
                    (n = t - Math.floor(t));
                  return n;
                })(t, n));
            }
            const o = U(Math.abs(a)),
              s = Math.max(Math.min(-1 * Math.floor(o), 20), 0),
              l = {
                notation: r,
                minimumFractionDigits: s,
                maximumFractionDigits: s,
              };
            return Object.assign(l, this.options.ticks.format), Ye(t, i, l);
          },
          logarithmic(t, e, n) {
            if (0 === t) return '0';
            const i = t / Math.pow(10, Math.floor(U(t)));
            return 1 === i || 2 === i || 5 === i
              ? fi.numeric.call(this, t, e, n)
              : '';
          },
        };
        var mi = { formatters: fi };
        function gi(t, e) {
          const n = t.options.ticks,
            i =
              n.maxTicksLimit ||
              (function (t) {
                const e = t.options.offset,
                  n = t._tickSize(),
                  i = t._length / n + (e ? 0 : 1),
                  r = t._maxLength / n;
                return Math.floor(Math.min(i, r));
              })(t),
            r = n.major.enabled
              ? (function (t) {
                  const e = [];
                  let n, i;
                  for (n = 0, i = t.length; n < i; n++) t[n].major && e.push(n);
                  return e;
                })(e)
              : [],
            a = r.length,
            o = r[0],
            s = r[a - 1],
            l = [];
          if (a > i)
            return (
              (function (t, e, n, i) {
                let r,
                  a = 0,
                  o = n[0];
                for (i = Math.ceil(i), r = 0; r < t.length; r++)
                  r === o && (e.push(t[r]), a++, (o = n[a * i]));
              })(e, l, r, a / i),
              l
            );
          const c = (function (t, e, n) {
            const i = (function (t) {
                const e = t.length;
                let n, i;
                if (e < 2) return !1;
                for (i = t[0], n = 1; n < e; ++n)
                  if (t[n] - t[n - 1] !== i) return !1;
                return i;
              })(t),
              r = e.length / n;
            if (!i) return Math.max(r, 1);
            const a = (function (t) {
              const e = [],
                n = Math.sqrt(t);
              let i;
              for (i = 1; i < n; i++) t % i == 0 && (e.push(i), e.push(t / i));
              return (
                n === (0 | n) && e.push(n), e.sort((t, e) => t - e).pop(), e
              );
            })(i);
            for (let t = 0, e = a.length - 1; t < e; t++) {
              const e = a[t];
              if (e > r) return e;
            }
            return Math.max(r, 1);
          })(r, e, i);
          if (a > 0) {
            let t, n;
            const i = a > 1 ? Math.round((s - o) / (a - 1)) : null;
            for (yi(e, l, c, d(i) ? 0 : o - i, o), t = 0, n = a - 1; t < n; t++)
              yi(e, l, c, r[t], r[t + 1]);
            return yi(e, l, c, s, d(i) ? e.length : s + i), l;
          }
          return yi(e, l, c), l;
        }
        function yi(t, e, n, i, r) {
          const a = y(i, 0),
            o = Math.min(y(r, t.length), t.length);
          let s,
            l,
            c,
            u = 0;
          for (
            n = Math.ceil(n),
              r && ((s = r - i), (n = s / Math.floor(s / n))),
              c = a;
            c < 0;

          )
            u++, (c = Math.round(a + u * n));
          for (l = Math.max(a, 0); l < o; l++)
            l === c && (e.push(t[l]), u++, (c = Math.round(a + u * n)));
        }
        Gt.set('scale', {
          display: !0,
          offset: !1,
          reverse: !1,
          beginAtZero: !1,
          bounds: 'ticks',
          grace: 0,
          grid: {
            display: !0,
            lineWidth: 1,
            drawBorder: !0,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: (t, e) => e.lineWidth,
            tickColor: (t, e) => e.color,
            offset: !1,
            borderDash: [],
            borderDashOffset: 0,
            borderColor: (t, e) => e.color,
            borderWidth: (t, e) => e.lineWidth,
          },
          title: { display: !1, text: '', padding: { top: 4, bottom: 4 } },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: '',
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: mi.formatters.values,
            minor: {},
            major: {},
            align: 'center',
            crossAlign: 'near',
          },
        }),
          Gt.route('scale.ticks', 'color', '', 'color'),
          Gt.route('scale.grid', 'color', '', 'borderColor'),
          Gt.route('scale.title', 'color', '', 'color'),
          Gt.describe('scale', {
            _fallback: !1,
            _scriptable: (t) =>
              !t.startsWith('before') &&
              !t.startsWith('after') &&
              'callback' !== t &&
              'parser' !== t,
            _indexable: (t) => 'borderDash' !== t && 'tickBorderDash' !== t,
          }),
          Gt.describe('scales', { _fallback: 'scale' });
        const vi = (t, e, n) =>
          'top' === e || 'left' === e ? t[e] + n : t[e] - n;
        function xi(t, e) {
          const n = [],
            i = t.length / e,
            r = t.length;
          let a = 0;
          for (; a < r; a += i) n.push(t[Math.floor(a)]);
          return n;
        }
        function bi(t, e, n) {
          const i = t.ticks.length,
            r = Math.min(e, i - 1),
            a = t._startPixel,
            o = t._endPixel;
          let s,
            l = t.getPixelForTick(r);
          if (
            !(
              n &&
              ((s =
                1 === i
                  ? Math.max(l - a, o - l)
                  : 0 === e
                  ? (t.getPixelForTick(1) - l) / 2
                  : (l - t.getPixelForTick(r - 1)) / 2),
              (l += r < e ? s : -s),
              l < a - 1e-6 || l > o + 1e-6)
            )
          )
            return l;
        }
        function _i(t) {
          return t.drawTicks ? t.tickLength : 0;
        }
        function wi(t, e) {
          if (!t.display) return 0;
          const n = oe(t.font, e),
            i = ae(t.padding);
          return (p(t.text) ? t.text.length : 1) * n.lineHeight + i.height;
        }
        function Mi(t, e, n) {
          let i = c(t);
          return (
            ((n && 'right' !== e) || (!n && 'right' === e)) &&
              (i = ((t) =>
                'left' === t ? 'right' : 'right' === t ? 'left' : t)(i)),
            i
          );
        }
        class qi extends pi {
          constructor(t) {
            super(),
              (this.id = t.id),
              (this.type = t.type),
              (this.options = void 0),
              (this.ctx = t.ctx),
              (this.chart = t.chart),
              (this.top = void 0),
              (this.bottom = void 0),
              (this.left = void 0),
              (this.right = void 0),
              (this.width = void 0),
              (this.height = void 0),
              (this._margins = { left: 0, right: 0, top: 0, bottom: 0 }),
              (this.maxWidth = void 0),
              (this.maxHeight = void 0),
              (this.paddingTop = void 0),
              (this.paddingBottom = void 0),
              (this.paddingLeft = void 0),
              (this.paddingRight = void 0),
              (this.axis = void 0),
              (this.labelRotation = void 0),
              (this.min = void 0),
              (this.max = void 0),
              (this.ticks = []),
              (this._gridLineItems = null),
              (this._labelItems = null),
              (this._labelSizes = null),
              (this._length = 0),
              (this._maxLength = 0),
              (this._longestTextCache = {}),
              (this._startPixel = void 0),
              (this._endPixel = void 0),
              (this._reversePixels = !1),
              (this._userMax = void 0),
              (this._userMin = void 0),
              (this._suggestedMax = void 0),
              (this._suggestedMin = void 0),
              (this._ticksLength = 0),
              (this._borderValue = 0),
              (this._cache = {}),
              (this._dataLimitsCached = !1),
              (this.$context = void 0);
          }
          init(t) {
            const e = this;
            (e.options = t),
              (e.axis = t.axis),
              (e._userMin = e.parse(t.min)),
              (e._userMax = e.parse(t.max)),
              (e._suggestedMin = e.parse(t.suggestedMin)),
              (e._suggestedMax = e.parse(t.suggestedMax));
          }
          parse(t, e) {
            return t;
          }
          getUserBounds() {
            let {
              _userMin: t,
              _userMax: e,
              _suggestedMin: n,
              _suggestedMax: i,
            } = this;
            return (
              (t = g(t, Number.POSITIVE_INFINITY)),
              (e = g(e, Number.NEGATIVE_INFINITY)),
              (n = g(n, Number.POSITIVE_INFINITY)),
              (i = g(i, Number.NEGATIVE_INFINITY)),
              { min: g(t, n), max: g(e, i), minDefined: m(t), maxDefined: m(e) }
            );
          }
          getMinMax(t) {
            const e = this;
            let n,
              {
                min: i,
                max: r,
                minDefined: a,
                maxDefined: o,
              } = e.getUserBounds();
            if (a && o) return { min: i, max: r };
            const s = e.getMatchingVisibleMetas();
            for (let l = 0, c = s.length; l < c; ++l)
              (n = s[l].controller.getMinMax(e, t)),
                a || (i = Math.min(i, n.min)),
                o || (r = Math.max(r, n.max));
            return { min: g(i, g(r, i)), max: g(r, g(i, r)) };
          }
          getPadding() {
            return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0,
            };
          }
          getTicks() {
            return this.ticks;
          }
          getLabels() {
            const t = this.chart.data;
            return (
              this.options.labels ||
              (this.isHorizontal() ? t.xLabels : t.yLabels) ||
              t.labels ||
              []
            );
          }
          beforeLayout() {
            (this._cache = {}), (this._dataLimitsCached = !1);
          }
          beforeUpdate() {
            x(this.options.beforeUpdate, [this]);
          }
          update(t, e, n) {
            const i = this,
              r = i.options.ticks,
              a = r.sampleSize;
            i.beforeUpdate(),
              (i.maxWidth = t),
              (i.maxHeight = e),
              (i._margins = n =
                Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, n)),
              (i.ticks = null),
              (i._labelSizes = null),
              (i._gridLineItems = null),
              (i._labelItems = null),
              i.beforeSetDimensions(),
              i.setDimensions(),
              i.afterSetDimensions(),
              (i._maxLength = i.isHorizontal()
                ? i.width + n.left + n.right
                : i.height + n.top + n.bottom),
              i._dataLimitsCached ||
                (i.beforeDataLimits(),
                i.determineDataLimits(),
                i.afterDataLimits(),
                (i._dataLimitsCached = !0)),
              i.beforeBuildTicks(),
              (i.ticks = i.buildTicks() || []),
              i.afterBuildTicks();
            const o = a < i.ticks.length;
            i._convertTicksToLabels(o ? xi(i.ticks, a) : i.ticks),
              i.configure(),
              i.beforeCalculateLabelRotation(),
              i.calculateLabelRotation(),
              i.afterCalculateLabelRotation(),
              r.display &&
                (r.autoSkip || 'auto' === r.source) &&
                ((i.ticks = gi(i, i.ticks)), (i._labelSizes = null)),
              o && i._convertTicksToLabels(i.ticks),
              i.beforeFit(),
              i.fit(),
              i.afterFit(),
              i.afterUpdate();
          }
          configure() {
            const t = this;
            let e,
              n,
              i = t.options.reverse;
            t.isHorizontal()
              ? ((e = t.left), (n = t.right))
              : ((e = t.top), (n = t.bottom), (i = !i)),
              (t._startPixel = e),
              (t._endPixel = n),
              (t._reversePixels = i),
              (t._length = n - e),
              (t._alignToPixels = t.options.alignToPixels);
          }
          afterUpdate() {
            x(this.options.afterUpdate, [this]);
          }
          beforeSetDimensions() {
            x(this.options.beforeSetDimensions, [this]);
          }
          setDimensions() {
            const t = this;
            t.isHorizontal()
              ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
              : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
              (t.paddingLeft = 0),
              (t.paddingTop = 0),
              (t.paddingRight = 0),
              (t.paddingBottom = 0);
          }
          afterSetDimensions() {
            x(this.options.afterSetDimensions, [this]);
          }
          _callHooks(t) {
            this.chart.notifyPlugins(t, this.getContext()),
              x(this.options[t], [this]);
          }
          beforeDataLimits() {
            this._callHooks('beforeDataLimits');
          }
          determineDataLimits() {}
          afterDataLimits() {
            this._callHooks('afterDataLimits');
          }
          beforeBuildTicks() {
            this._callHooks('beforeBuildTicks');
          }
          buildTicks() {
            return [];
          }
          afterBuildTicks() {
            this._callHooks('afterBuildTicks');
          }
          beforeTickToLabelConversion() {
            x(this.options.beforeTickToLabelConversion, [this]);
          }
          generateTickLabels(t) {
            const e = this,
              n = e.options.ticks;
            let i, r, a;
            for (i = 0, r = t.length; i < r; i++)
              (a = t[i]), (a.label = x(n.callback, [a.value, i, t], e));
          }
          afterTickToLabelConversion() {
            x(this.options.afterTickToLabelConversion, [this]);
          }
          beforeCalculateLabelRotation() {
            x(this.options.beforeCalculateLabelRotation, [this]);
          }
          calculateLabelRotation() {
            const t = this,
              e = t.options,
              n = e.ticks,
              i = t.ticks.length,
              r = n.minRotation || 0,
              a = n.maxRotation;
            let o,
              s,
              l,
              c = r;
            if (
              !t._isVisible() ||
              !n.display ||
              r >= a ||
              i <= 1 ||
              !t.isHorizontal()
            )
              return void (t.labelRotation = r);
            const u = t._getLabelSizes(),
              h = u.widest.width,
              d = u.highest.height,
              p = Q(t.chart.width - h, 0, t.maxWidth);
            (o = e.offset ? t.maxWidth / i : p / (i - 1)),
              h + 6 > o &&
                ((o = p / (i - (e.offset ? 0.5 : 1))),
                (s =
                  t.maxHeight -
                  _i(e.grid) -
                  n.padding -
                  wi(e.title, t.chart.options.font)),
                (l = Math.sqrt(h * h + d * d)),
                (c = Y(
                  Math.min(
                    Math.asin(Math.min((u.highest.height + 6) / o, 1)),
                    Math.asin(Math.min(s / l, 1)) - Math.asin(d / l),
                  ),
                )),
                (c = Math.max(r, Math.min(a, c)))),
              (t.labelRotation = c);
          }
          afterCalculateLabelRotation() {
            x(this.options.afterCalculateLabelRotation, [this]);
          }
          beforeFit() {
            x(this.options.beforeFit, [this]);
          }
          fit() {
            const t = this,
              e = { width: 0, height: 0 },
              {
                chart: n,
                options: { ticks: i, title: r, grid: a },
              } = t,
              o = t._isVisible(),
              s = t.isHorizontal();
            if (o) {
              const o = wi(r, n.options.font);
              if (
                (s
                  ? ((e.width = t.maxWidth), (e.height = _i(a) + o))
                  : ((e.height = t.maxHeight), (e.width = _i(a) + o)),
                i.display && t.ticks.length)
              ) {
                const {
                    first: n,
                    last: r,
                    widest: a,
                    highest: o,
                  } = t._getLabelSizes(),
                  l = 2 * i.padding,
                  c = X(t.labelRotation),
                  u = Math.cos(c),
                  h = Math.sin(c);
                if (s) {
                  const n = h * a.width + u * o.height;
                  e.height = Math.min(t.maxHeight, e.height + n + l);
                } else {
                  const n = i.mirror ? 0 : u * a.width + h * o.height;
                  e.width = Math.min(t.maxWidth, e.width + n + l);
                }
                t._calculatePadding(n, r, h, u);
              }
            }
            t._handleMargins(),
              s
                ? ((t.width = t._length =
                    n.width - t._margins.left - t._margins.right),
                  (t.height = e.height))
                : ((t.width = e.width),
                  (t.height = t._length =
                    n.height - t._margins.top - t._margins.bottom));
          }
          _calculatePadding(t, e, n, i) {
            const r = this,
              {
                ticks: { align: a, padding: o },
                position: s,
              } = r.options,
              l = 0 !== r.labelRotation,
              c = 'top' !== s && 'x' === r.axis;
            if (r.isHorizontal()) {
              const s = r.getPixelForTick(0) - r.left,
                u = r.right - r.getPixelForTick(r.ticks.length - 1);
              let h = 0,
                d = 0;
              l
                ? c
                  ? ((h = i * t.width), (d = n * e.height))
                  : ((h = n * t.height), (d = i * e.width))
                : 'start' === a
                ? (d = e.width)
                : 'end' === a
                ? (h = t.width)
                : ((h = t.width / 2), (d = e.width / 2)),
                (r.paddingLeft = Math.max(
                  ((h - s + o) * r.width) / (r.width - s),
                  0,
                )),
                (r.paddingRight = Math.max(
                  ((d - u + o) * r.width) / (r.width - u),
                  0,
                ));
            } else {
              let n = e.height / 2,
                i = t.height / 2;
              'start' === a
                ? ((n = 0), (i = t.height))
                : 'end' === a && ((n = e.height), (i = 0)),
                (r.paddingTop = n + o),
                (r.paddingBottom = i + o);
            }
          }
          _handleMargins() {
            const t = this;
            t._margins &&
              ((t._margins.left = Math.max(t.paddingLeft, t._margins.left)),
              (t._margins.top = Math.max(t.paddingTop, t._margins.top)),
              (t._margins.right = Math.max(t.paddingRight, t._margins.right)),
              (t._margins.bottom = Math.max(
                t.paddingBottom,
                t._margins.bottom,
              )));
          }
          afterFit() {
            x(this.options.afterFit, [this]);
          }
          isHorizontal() {
            const { axis: t, position: e } = this.options;
            return 'top' === e || 'bottom' === e || 'x' === t;
          }
          isFullSize() {
            return this.options.fullSize;
          }
          _convertTicksToLabels(t) {
            this.beforeTickToLabelConversion(),
              this.generateTickLabels(t),
              this.afterTickToLabelConversion();
          }
          _getLabelSizes() {
            const t = this;
            let e = t._labelSizes;
            if (!e) {
              const n = t.options.ticks.sampleSize;
              let i = t.ticks;
              n < i.length && (i = xi(i, n)),
                (t._labelSizes = e = t._computeLabelSizes(i, i.length));
            }
            return e;
          }
          _computeLabelSizes(t, e) {
            const { ctx: n, _longestTextCache: i } = this,
              r = [],
              a = [];
            let o,
              s,
              l,
              c,
              u,
              h,
              f,
              m,
              g,
              y,
              v,
              x = 0,
              _ = 0;
            for (o = 0; o < e; ++o) {
              if (
                ((c = t[o].label),
                (u = this._resolveTickFontOptions(o)),
                (n.font = h = u.string),
                (f = i[h] = i[h] || { data: {}, gc: [] }),
                (m = u.lineHeight),
                (g = y = 0),
                d(c) || p(c))
              ) {
                if (p(c))
                  for (s = 0, l = c.length; s < l; ++s)
                    (v = c[s]),
                      d(v) ||
                        p(v) ||
                        ((g = Ht(n, f.data, f.gc, g, v)), (y += m));
              } else (g = Ht(n, f.data, f.gc, g, c)), (y = m);
              r.push(g), a.push(y), (x = Math.max(g, x)), (_ = Math.max(y, _));
            }
            !(function (t, e) {
              b(t, (t) => {
                const n = t.gc,
                  i = n.length / 2;
                let r;
                if (i > e) {
                  for (r = 0; r < i; ++r) delete t.data[n[r]];
                  n.splice(0, i);
                }
              });
            })(i, e);
            const w = r.indexOf(x),
              M = a.indexOf(_),
              q = (t) => ({ width: r[t] || 0, height: a[t] || 0 });
            return { first: q(0), last: q(e - 1), widest: q(w), highest: q(M) };
          }
          getLabelForValue(t) {
            return t;
          }
          getPixelForValue(t, e) {
            return NaN;
          }
          getValueForPixel(t) {}
          getPixelForTick(t) {
            const e = this.ticks;
            return t < 0 || t > e.length - 1
              ? null
              : this.getPixelForValue(e[t].value);
          }
          getPixelForDecimal(t) {
            const e = this;
            e._reversePixels && (t = 1 - t);
            const n = e._startPixel + t * e._length;
            return Q(e._alignToPixels ? Wt(e.chart, n, 0) : n, -32768, 32767);
          }
          getDecimalForPixel(t) {
            const e = (t - this._startPixel) / this._length;
            return this._reversePixels ? 1 - e : e;
          }
          getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
          }
          getBaseValue() {
            const { min: t, max: e } = this;
            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
          }
          getContext(t) {
            const e = this,
              n = e.ticks || [];
            if (t >= 0 && t < n.length) {
              const i = n[t];
              return (
                i.$context ||
                (i.$context = (function (t, e, n) {
                  return Object.assign(Object.create(t), {
                    tick: n,
                    index: e,
                    type: 'tick',
                  });
                })(e.getContext(), t, i))
              );
            }
            return (
              e.$context ||
              (e.$context =
                ((i = e.chart.getContext()),
                (r = e),
                Object.assign(Object.create(i), { scale: r, type: 'scale' })))
            );
            var i, r;
          }
          _tickSize() {
            const t = this.options.ticks,
              e = X(this.labelRotation),
              n = Math.abs(Math.cos(e)),
              i = Math.abs(Math.sin(e)),
              r = this._getLabelSizes(),
              a = t.autoSkipPadding || 0,
              o = r ? r.widest.width + a : 0,
              s = r ? r.highest.height + a : 0;
            return this.isHorizontal()
              ? s * n > o * i
                ? o / n
                : s / i
              : s * i < o * n
              ? s / n
              : o / i;
          }
          _isVisible() {
            const t = this.options.display;
            return 'auto' !== t
              ? !!t
              : this.getMatchingVisibleMetas().length > 0;
          }
          _computeGridLineItems(t) {
            const e = this,
              n = e.axis,
              i = e.chart,
              r = e.options,
              { grid: a, position: o } = r,
              s = a.offset,
              l = e.isHorizontal(),
              c = e.ticks.length + (s ? 1 : 0),
              u = _i(a),
              h = [],
              d = a.setContext(e.getContext(0)),
              p = d.drawBorder ? d.borderWidth : 0,
              m = p / 2,
              g = function (t) {
                return Wt(i, t, p);
              };
            let y, v, x, b, _, w, M, q, S, T, E, A;
            if ('top' === o)
              (y = g(e.bottom)),
                (w = e.bottom - u),
                (q = y - m),
                (T = g(t.top) + m),
                (A = t.bottom);
            else if ('bottom' === o)
              (y = g(e.top)),
                (T = t.top),
                (A = g(t.bottom) - m),
                (w = y + m),
                (q = e.top + u);
            else if ('left' === o)
              (y = g(e.right)),
                (_ = e.right - u),
                (M = y - m),
                (S = g(t.left) + m),
                (E = t.right);
            else if ('right' === o)
              (y = g(e.left)),
                (S = t.left),
                (E = g(t.right) - m),
                (_ = y + m),
                (M = e.left + u);
            else if ('x' === n) {
              if ('center' === o) y = g((t.top + t.bottom) / 2 + 0.5);
              else if (f(o)) {
                const t = Object.keys(o)[0],
                  n = o[t];
                y = g(e.chart.scales[t].getPixelForValue(n));
              }
              (T = t.top), (A = t.bottom), (w = y + m), (q = w + u);
            } else if ('y' === n) {
              if ('center' === o) y = g((t.left + t.right) / 2);
              else if (f(o)) {
                const t = Object.keys(o)[0],
                  n = o[t];
                y = g(e.chart.scales[t].getPixelForValue(n));
              }
              (_ = y - m), (M = _ - u), (S = t.left), (E = t.right);
            }
            for (v = 0; v < c; ++v) {
              const t = a.setContext(e.getContext(v)),
                n = t.lineWidth,
                r = t.color,
                o = a.borderDash || [],
                c = t.borderDashOffset,
                u = t.tickWidth,
                d = t.tickColor,
                p = t.tickBorderDash || [],
                f = t.tickBorderDashOffset;
              (x = bi(e, v, s)),
                void 0 !== x &&
                  ((b = Wt(i, x, n)),
                  l ? (_ = M = S = E = b) : (w = q = T = A = b),
                  h.push({
                    tx1: _,
                    ty1: w,
                    tx2: M,
                    ty2: q,
                    x1: S,
                    y1: T,
                    x2: E,
                    y2: A,
                    width: n,
                    color: r,
                    borderDash: o,
                    borderDashOffset: c,
                    tickWidth: u,
                    tickColor: d,
                    tickBorderDash: p,
                    tickBorderDashOffset: f,
                  }));
            }
            return (e._ticksLength = c), (e._borderValue = y), h;
          }
          _computeLabelItems(t) {
            const e = this,
              n = e.axis,
              i = e.options,
              { position: r, ticks: a } = i,
              o = e.isHorizontal(),
              s = e.ticks,
              { align: l, crossAlign: c, padding: u } = a,
              h = _i(i.grid),
              d = h + u,
              m = -X(e.labelRotation),
              g = [];
            let y,
              v,
              x,
              b,
              _,
              w,
              M,
              q,
              S,
              T,
              E,
              A,
              L = 'middle';
            if ('top' === r)
              (w = e.bottom - d), (M = e._getXAxisLabelAlignment());
            else if ('bottom' === r)
              (w = e.top + d), (M = e._getXAxisLabelAlignment());
            else if ('left' === r) {
              const t = this._getYAxisLabelAlignment(h);
              (M = t.textAlign), (_ = t.x);
            } else if ('right' === r) {
              const t = this._getYAxisLabelAlignment(h);
              (M = t.textAlign), (_ = t.x);
            } else if ('x' === n) {
              if ('center' === r) w = (t.top + t.bottom) / 2 + d;
              else if (f(r)) {
                const t = Object.keys(r)[0],
                  n = r[t];
                w = e.chart.scales[t].getPixelForValue(n) + d;
              }
              M = e._getXAxisLabelAlignment();
            } else if ('y' === n) {
              if ('center' === r) _ = (t.left + t.right) / 2 - d;
              else if (f(r)) {
                const t = Object.keys(r)[0],
                  n = r[t];
                _ = e.chart.scales[t].getPixelForValue(n);
              }
              M = this._getYAxisLabelAlignment(h).textAlign;
            }
            'y' === n &&
              ('start' === l ? (L = 'top') : 'end' === l && (L = 'bottom'));
            const R = e._getLabelSizes();
            for (y = 0, v = s.length; y < v; ++y) {
              (x = s[y]), (b = x.label);
              const t = a.setContext(e.getContext(y));
              (q = e.getPixelForTick(y) + a.labelOffset),
                (S = e._resolveTickFontOptions(y)),
                (T = S.lineHeight),
                (E = p(b) ? b.length : 1);
              const n = E / 2,
                i = t.color,
                l = t.textStrokeColor,
                u = t.textStrokeWidth;
              o
                ? ((_ = q),
                  (A =
                    'top' === r
                      ? 'near' === c || 0 !== m
                        ? -E * T + T / 2
                        : 'center' === c
                        ? -R.highest.height / 2 - n * T + T
                        : -R.highest.height + T / 2
                      : 'near' === c || 0 !== m
                      ? T / 2
                      : 'center' === c
                      ? R.highest.height / 2 - n * T
                      : R.highest.height - E * T))
                : ((w = q), (A = ((1 - E) * T) / 2)),
                g.push({
                  rotation: m,
                  label: b,
                  font: S,
                  color: i,
                  strokeColor: l,
                  strokeWidth: u,
                  textOffset: A,
                  textAlign: M,
                  textBaseline: L,
                  translation: [_, w],
                });
            }
            return g;
          }
          _getXAxisLabelAlignment() {
            const { position: t, ticks: e } = this.options;
            if (-X(this.labelRotation)) return 'top' === t ? 'left' : 'right';
            let n = 'center';
            return (
              'start' === e.align
                ? (n = 'left')
                : 'end' === e.align && (n = 'right'),
              n
            );
          }
          _getYAxisLabelAlignment(t) {
            const e = this,
              {
                position: n,
                ticks: { crossAlign: i, mirror: r, padding: a },
              } = e.options,
              o = t + a,
              s = e._getLabelSizes().widest.width;
            let l, c;
            return (
              'left' === n
                ? r
                  ? ((l = 'left'), (c = e.right - a))
                  : ((c = e.right - o),
                    'near' === i
                      ? (l = 'right')
                      : 'center' === i
                      ? ((l = 'center'), (c -= s / 2))
                      : ((l = 'left'), (c = e.left)))
                : 'right' === n
                ? r
                  ? ((l = 'right'), (c = e.left + a))
                  : ((c = e.left + o),
                    'near' === i
                      ? (l = 'left')
                      : 'center' === i
                      ? ((l = 'center'), (c += s / 2))
                      : ((l = 'right'), (c = e.right)))
                : (l = 'right'),
              { textAlign: l, x: c }
            );
          }
          _computeLabelArea() {
            const t = this;
            if (t.options.ticks.mirror) return;
            const e = t.chart,
              n = t.options.position;
            return 'left' === n || 'right' === n
              ? { top: 0, left: t.left, bottom: e.height, right: t.right }
              : 'top' === n || 'bottom' === n
              ? { top: t.top, left: 0, bottom: t.bottom, right: e.width }
              : void 0;
          }
          drawBackground() {
            const {
              ctx: t,
              options: { backgroundColor: e },
              left: n,
              top: i,
              width: r,
              height: a,
            } = this;
            e &&
              (t.save(),
              (t.fillStyle = e),
              t.fillRect(n, i, r, a),
              t.restore());
          }
          getLineWidthForValue(t) {
            const e = this,
              n = e.options.grid;
            if (!e._isVisible() || !n.display) return 0;
            const i = e.ticks.findIndex((e) => e.value === t);
            if (i >= 0) {
              return n.setContext(e.getContext(i)).lineWidth;
            }
            return 0;
          }
          drawGrid(t) {
            const e = this,
              n = e.options.grid,
              i = e.ctx,
              r = e.chart,
              a = n.setContext(e.getContext(0)),
              o = n.drawBorder ? a.borderWidth : 0,
              s =
                e._gridLineItems ||
                (e._gridLineItems = e._computeGridLineItems(t));
            let l, c;
            const u = (t, e, n) => {
              n.width &&
                n.color &&
                (i.save(),
                (i.lineWidth = n.width),
                (i.strokeStyle = n.color),
                i.setLineDash(n.borderDash || []),
                (i.lineDashOffset = n.borderDashOffset),
                i.beginPath(),
                i.moveTo(t.x, t.y),
                i.lineTo(e.x, e.y),
                i.stroke(),
                i.restore());
            };
            if (n.display)
              for (l = 0, c = s.length; l < c; ++l) {
                const t = s[l];
                n.drawOnChartArea &&
                  u({ x: t.x1, y: t.y1 }, { x: t.x2, y: t.y2 }, t),
                  n.drawTicks &&
                    u(
                      { x: t.tx1, y: t.ty1 },
                      { x: t.tx2, y: t.ty2 },
                      {
                        color: t.tickColor,
                        width: t.tickWidth,
                        borderDash: t.tickBorderDash,
                        borderDashOffset: t.tickBorderDashOffset,
                      },
                    );
              }
            if (o) {
              const t = n.setContext(e.getContext(e._ticksLength - 1)),
                i = t.lineWidth,
                a = e._borderValue;
              let s, l, c, h;
              e.isHorizontal()
                ? ((s = Wt(r, e.left, o) - o / 2),
                  (l = Wt(r, e.right, i) + i / 2),
                  (c = h = a))
                : ((c = Wt(r, e.top, o) - o / 2),
                  (h = Wt(r, e.bottom, i) + i / 2),
                  (s = l = a)),
                u(
                  { x: s, y: c },
                  { x: l, y: h },
                  { width: o, color: t.borderColor },
                );
            }
          }
          drawLabels(t) {
            const e = this;
            if (!e.options.ticks.display) return;
            const n = e.ctx,
              i = e._computeLabelArea();
            i && Jt(n, i);
            const r =
              e._labelItems || (e._labelItems = e._computeLabelItems(t));
            let a, o;
            for (a = 0, o = r.length; a < o; ++a) {
              const t = r[a],
                e = t.font;
              te(n, t.label, 0, t.textOffset, e, t);
            }
            i && Zt(n);
          }
          drawTitle() {
            const {
              ctx: t,
              options: { position: e, title: n, reverse: i },
            } = this;
            if (!n.display) return;
            const r = oe(n.font),
              a = ae(n.padding),
              o = n.align;
            let s = r.lineHeight / 2;
            'bottom' === e
              ? ((s += a.bottom),
                p(n.text) && (s += r.lineHeight * (n.text.length - 1)))
              : (s += a.top);
            const {
              titleX: l,
              titleY: c,
              maxWidth: h,
              rotation: d,
            } = (function (t, e, n, i) {
              const { top: r, left: a, bottom: o, right: s } = t;
              let l,
                c,
                h,
                d = 0;
              return (
                t.isHorizontal()
                  ? ((c = u(i, a, s)), (h = vi(t, n, e)), (l = s - a))
                  : ((c = vi(t, n, e)),
                    (h = u(i, o, r)),
                    (d = 'left' === n ? -z : z)),
                { titleX: c, titleY: h, maxWidth: l, rotation: d }
              );
            })(this, s, e, o);
            te(t, n.text, 0, 0, r, {
              color: n.color,
              maxWidth: h,
              rotation: d,
              textAlign: Mi(o, e, i),
              textBaseline: 'middle',
              translation: [l, c],
            });
          }
          draw(t) {
            const e = this;
            e._isVisible() &&
              (e.drawBackground(),
              e.drawGrid(t),
              e.drawTitle(),
              e.drawLabels(t));
          }
          _layers() {
            const t = this,
              e = t.options,
              n = (e.ticks && e.ticks.z) || 0,
              i = (e.grid && e.grid.z) || 0;
            return t._isVisible() && n !== i && t.draw === qi.prototype.draw
              ? [
                  {
                    z: i,
                    draw(e) {
                      t.drawBackground(), t.drawGrid(e), t.drawTitle();
                    },
                  },
                  {
                    z: n,
                    draw(e) {
                      t.drawLabels(e);
                    },
                  },
                ]
              : [
                  {
                    z: n,
                    draw(e) {
                      t.draw(e);
                    },
                  },
                ];
          }
          getMatchingVisibleMetas(t) {
            const e = this,
              n = e.chart.getSortedVisibleDatasetMetas(),
              i = e.axis + 'AxisID',
              r = [];
            let a, o;
            for (a = 0, o = n.length; a < o; ++a) {
              const o = n[a];
              o[i] !== e.id || (t && o.type !== t) || r.push(o);
            }
            return r;
          }
          _resolveTickFontOptions(t) {
            return oe(this.options.ticks.setContext(this.getContext(t)).font);
          }
        }
        class Si {
          constructor(t, e, n) {
            (this.type = t),
              (this.scope = e),
              (this.override = n),
              (this.items = Object.create(null));
          }
          isForType(t) {
            return Object.prototype.isPrototypeOf.call(
              this.type.prototype,
              t.prototype,
            );
          }
          register(t) {
            const e = this,
              n = Object.getPrototypeOf(t);
            let i;
            (function (t) {
              return 'id' in t && 'defaults' in t;
            })(n) && (i = e.register(n));
            const r = e.items,
              a = t.id,
              o = e.scope + '.' + a;
            if (!a) throw new Error('class does not have id: ' + t);
            return (
              a in r ||
                ((r[a] = t),
                (function (t, e, n) {
                  const i = S(Object.create(null), [
                    n ? Gt.get(n) : {},
                    Gt.get(e),
                    t.defaults,
                  ]);
                  Gt.set(e, i),
                    t.defaultRoutes &&
                      (function (t, e) {
                        Object.keys(e).forEach((n) => {
                          const i = n.split('.'),
                            r = i.pop(),
                            a = [t].concat(i).join('.'),
                            o = e[n].split('.'),
                            s = o.pop(),
                            l = o.join('.');
                          Gt.route(a, r, l, s);
                        });
                      })(e, t.defaultRoutes);
                  t.descriptors && Gt.describe(e, t.descriptors);
                })(t, o, i),
                e.override && Gt.override(t.id, t.overrides)),
              o
            );
          }
          get(t) {
            return this.items[t];
          }
          unregister(t) {
            const e = this.items,
              n = t.id,
              i = this.scope;
            n in e && delete e[n],
              i &&
                n in Gt[i] &&
                (delete Gt[i][n], this.override && delete Ft[n]);
          }
        }
        var Ti = new (class {
          constructor() {
            (this.controllers = new Si(vn, 'datasets', !0)),
              (this.elements = new Si(pi, 'elements')),
              (this.plugins = new Si(Object, 'plugins')),
              (this.scales = new Si(qi, 'scales')),
              (this._typedRegistries = [
                this.controllers,
                this.scales,
                this.elements,
              ]);
          }
          add(...t) {
            this._each('register', t);
          }
          remove(...t) {
            this._each('unregister', t);
          }
          addControllers(...t) {
            this._each('register', t, this.controllers);
          }
          addElements(...t) {
            this._each('register', t, this.elements);
          }
          addPlugins(...t) {
            this._each('register', t, this.plugins);
          }
          addScales(...t) {
            this._each('register', t, this.scales);
          }
          getController(t) {
            return this._get(t, this.controllers, 'controller');
          }
          getElement(t) {
            return this._get(t, this.elements, 'element');
          }
          getPlugin(t) {
            return this._get(t, this.plugins, 'plugin');
          }
          getScale(t) {
            return this._get(t, this.scales, 'scale');
          }
          removeControllers(...t) {
            this._each('unregister', t, this.controllers);
          }
          removeElements(...t) {
            this._each('unregister', t, this.elements);
          }
          removePlugins(...t) {
            this._each('unregister', t, this.plugins);
          }
          removeScales(...t) {
            this._each('unregister', t, this.scales);
          }
          _each(t, e, n) {
            const i = this;
            [...e].forEach((e) => {
              const r = n || i._getRegistryForType(e);
              n || r.isForType(e) || (r === i.plugins && e.id)
                ? i._exec(t, r, e)
                : b(e, (e) => {
                    const r = n || i._getRegistryForType(e);
                    i._exec(t, r, e);
                  });
            });
          }
          _exec(t, e, n) {
            const i = R(t);
            x(n['before' + i], [], n), e[t](n), x(n['after' + i], [], n);
          }
          _getRegistryForType(t) {
            for (let e = 0; e < this._typedRegistries.length; e++) {
              const n = this._typedRegistries[e];
              if (n.isForType(t)) return n;
            }
            return this.plugins;
          }
          _get(t, e, n) {
            const i = e.get(t);
            if (void 0 === i)
              throw new Error('"' + t + '" is not a registered ' + n + '.');
            return i;
          }
        })();
        class Ei {
          constructor() {
            this._init = [];
          }
          notify(t, e, n) {
            const i = this;
            'beforeInit' === e &&
              ((i._init = i._createDescriptors(t, !0)),
              i._notify(i._init, t, 'install'));
            const r = i._descriptors(t),
              a = i._notify(r, t, e, n);
            return (
              'destroy' === e &&
                (i._notify(r, t, 'stop'), i._notify(i._init, t, 'uninstall')),
              a
            );
          }
          _notify(t, e, n, i) {
            i = i || {};
            for (const r of t) {
              const t = r.plugin;
              if (!1 === x(t[n], [e, i, r.options], t) && i.cancelable)
                return !1;
            }
            return !0;
          }
          invalidate() {
            d(this._cache) ||
              ((this._oldCache = this._cache), (this._cache = void 0));
          }
          _descriptors(t) {
            if (this._cache) return this._cache;
            const e = (this._cache = this._createDescriptors(t));
            return this._notifyStateChanges(t), e;
          }
          _createDescriptors(t, e) {
            const n = t && t.config,
              i = y(n.options && n.options.plugins, {}),
              r = (function (t) {
                const e = [],
                  n = Object.keys(Ti.plugins.items);
                for (let t = 0; t < n.length; t++) e.push(Ti.getPlugin(n[t]));
                const i = t.plugins || [];
                for (let t = 0; t < i.length; t++) {
                  const n = i[t];
                  -1 === e.indexOf(n) && e.push(n);
                }
                return e;
              })(n);
            return !1 !== i || e
              ? (function (t, e, n, i) {
                  const r = [],
                    a = t.getContext();
                  for (let o = 0; o < e.length; o++) {
                    const s = e[o],
                      l = s.id,
                      c = Ai(n[l], i);
                    null !== c &&
                      r.push({ plugin: s, options: Li(t.config, s, c, a) });
                  }
                  return r;
                })(t, r, i, e)
              : [];
          }
          _notifyStateChanges(t) {
            const e = this._oldCache || [],
              n = this._cache,
              i = (t, e) =>
                t.filter((t) => !e.some((e) => t.plugin.id === e.plugin.id));
            this._notify(i(e, n), t, 'stop'), this._notify(i(n, e), t, 'start');
          }
        }
        function Ai(t, e) {
          return e || !1 !== t ? (!0 === t ? {} : t) : null;
        }
        function Li(t, e, n, i) {
          const r = t.pluginScopeKeys(e),
            a = t.getOptionScopes(n, r);
          return t.createResolver(a, i, [''], {
            scriptable: !1,
            indexable: !1,
            allKeys: !0,
          });
        }
        function Ri(t, e) {
          const n = Gt.datasets[t] || {};
          return (
            ((e.datasets || {})[t] || {}).indexAxis ||
            e.indexAxis ||
            n.indexAxis ||
            'x'
          );
        }
        function Ci(t, e) {
          return 'x' === t || 'y' === t
            ? t
            : e.axis ||
                ('top' === (n = e.position) || 'bottom' === n
                  ? 'x'
                  : 'left' === n || 'right' === n
                  ? 'y'
                  : void 0) ||
                t.charAt(0).toLowerCase();
          var n;
        }
        function Pi(t) {
          const e = t.options || (t.options = {});
          (e.plugins = y(e.plugins, {})),
            (e.scales = (function (t, e) {
              const n = Ft[t.type] || { scales: {} },
                i = e.scales || {},
                r = Ri(t.type, e),
                a = Object.create(null),
                o = Object.create(null);
              return (
                Object.keys(i).forEach((t) => {
                  const e = i[t],
                    s = Ci(t, e),
                    l = (function (t, e) {
                      return t === e ? '_index_' : '_value_';
                    })(s, r),
                    c = n.scales || {};
                  (a[s] = a[s] || t),
                    (o[t] = T(Object.create(null), [
                      { axis: s },
                      e,
                      c[s],
                      c[l],
                    ]));
                }),
                t.data.datasets.forEach((n) => {
                  const r = n.type || t.type,
                    s = n.indexAxis || Ri(r, e),
                    l = (Ft[r] || {}).scales || {};
                  Object.keys(l).forEach((t) => {
                    const e = (function (t, e) {
                        let n = t;
                        return (
                          '_index_' === t
                            ? (n = e)
                            : '_value_' === t && (n = 'x' === e ? 'y' : 'x'),
                          n
                        );
                      })(t, s),
                      r = n[e + 'AxisID'] || a[e] || e;
                    (o[r] = o[r] || Object.create(null)),
                      T(o[r], [{ axis: e }, i[r], l[t]]);
                  });
                }),
                Object.keys(o).forEach((t) => {
                  const e = o[t];
                  T(e, [Gt.scales[e.type], Gt.scale]);
                }),
                o
              );
            })(t, e));
        }
        const ki = new Map(),
          Ii = new Set();
        function Di(t, e) {
          let n = ki.get(t);
          return n || ((n = e()), ki.set(t, n), Ii.add(n)), n;
        }
        const Oi = (t, e, n) => {
          const i = L(e, n);
          void 0 !== i && t.add(i);
        };
        class Ni {
          constructor(t) {
            (this._config = (function (t) {
              const e = ((t = t || {}).data = t.data || {
                datasets: [],
                labels: [],
              });
              return (
                (e.datasets = e.datasets || []),
                (e.labels = e.labels || []),
                Pi(t),
                t
              );
            })(t)),
              (this._scopeCache = new Map()),
              (this._resolverCache = new Map());
          }
          get type() {
            return this._config.type;
          }
          set type(t) {
            this._config.type = t;
          }
          get data() {
            return this._config.data;
          }
          set data(t) {
            this._config.data = t;
          }
          get options() {
            return this._config.options;
          }
          set options(t) {
            this._config.options = t;
          }
          get plugins() {
            return this._config.plugins;
          }
          update() {
            const t = this._config;
            this.clearCache(), Pi(t);
          }
          clearCache() {
            this._scopeCache.clear(), this._resolverCache.clear();
          }
          datasetScopeKeys(t) {
            return Di(t, () => [['datasets.' + t, '']]);
          }
          datasetAnimationScopeKeys(t, e) {
            return Di(`${t}.transition.${e}`, () => [
              [`datasets.${t}.transitions.${e}`, 'transitions.' + e],
              ['datasets.' + t, ''],
            ]);
          }
          datasetElementScopeKeys(t, e) {
            return Di(`${t}-${e}`, () => [
              [
                `datasets.${t}.elements.${e}`,
                'datasets.' + t,
                'elements.' + e,
                '',
              ],
            ]);
          }
          pluginScopeKeys(t) {
            const e = t.id;
            return Di(`${this.type}-plugin-${e}`, () => [
              ['plugins.' + e, ...(t.additionalOptionScopes || [])],
            ]);
          }
          _cachedScopes(t, e) {
            const n = this._scopeCache;
            let i = n.get(t);
            return (i && !e) || ((i = new Map()), n.set(t, i)), i;
          }
          getOptionScopes(t, e, n) {
            const { options: i, type: r } = this,
              a = this._cachedScopes(t, n),
              o = a.get(e);
            if (o) return o;
            const s = new Set();
            e.forEach((e) => {
              t && (s.add(t), e.forEach((e) => Oi(s, t, e))),
                e.forEach((t) => Oi(s, i, t)),
                e.forEach((t) => Oi(s, Ft[r] || {}, t)),
                e.forEach((t) => Oi(s, Gt, t)),
                e.forEach((t) => Oi(s, Bt, t));
            });
            const l = [...s];
            return Ii.has(e) && a.set(e, l), l;
          }
          chartOptionScopes() {
            const { options: t, type: e } = this;
            return [t, Ft[e] || {}, Gt.datasets[e] || {}, { type: e }, Gt, Bt];
          }
          resolveNamedOptions(t, e, n, i = ['']) {
            const r = { $shared: !0 },
              { resolver: a, subPrefixes: o } = zi(this._resolverCache, t, i);
            let s = a;
            if (
              (function (t, e) {
                const { isScriptable: n, isIndexable: i } = ge(t);
                for (const r of e)
                  if ((n(r) && P(t[r])) || (i(r) && p(t[r]))) return !0;
                return !1;
              })(a, e)
            ) {
              r.$shared = !1;
              s = me(a, (n = P(n) ? n() : n), this.createResolver(t, n, o));
            }
            for (const t of e) r[t] = s[t];
            return r;
          }
          createResolver(t, e, n = [''], i) {
            const { resolver: r } = zi(this._resolverCache, t, n);
            return f(e) ? me(r, e, void 0, i) : r;
          }
        }
        function zi(t, e, n) {
          let i = t.get(e);
          i || ((i = new Map()), t.set(e, i));
          const r = n.join();
          let a = i.get(r);
          if (!a) {
            (a = {
              resolver: fe(e, n),
              subPrefixes: n.filter((t) => !t.toLowerCase().includes('hover')),
            }),
              i.set(r, a);
          }
          return a;
        }
        const Fi = ['top', 'bottom', 'left', 'right', 'chartArea'];
        function Bi(t, e) {
          return (
            'top' === t || 'bottom' === t || (-1 === Fi.indexOf(t) && 'x' === e)
          );
        }
        function Ui(t, e) {
          return function (n, i) {
            return n[t] === i[t] ? n[e] - i[e] : n[t] - i[t];
          };
        }
        function ji(t) {
          const e = t.chart,
            n = e.options.animation;
          e.notifyPlugins('afterRender'), x(n && n.onComplete, [t], e);
        }
        function Gi(t) {
          const e = t.chart,
            n = e.options.animation;
          x(n && n.onProgress, [t], e);
        }
        function Hi() {
          return 'undefined' != typeof window && 'undefined' != typeof document;
        }
        function Vi(t) {
          return (
            Hi() && 'string' == typeof t
              ? (t = document.getElementById(t))
              : t && t.length && (t = t[0]),
            t && t.canvas && (t = t.canvas),
            t
          );
        }
        const Wi = {},
          Xi = (t) => {
            const e = Vi(t);
            return Object.values(Wi)
              .filter((t) => t.canvas === e)
              .pop();
          };
        class Yi {
          constructor(t, e) {
            const n = this;
            this.config = e = new Ni(e);
            const i = Vi(t),
              r = Xi(i);
            if (r)
              throw new Error(
                "Canvas is already in use. Chart with ID '" +
                  r.id +
                  "' must be destroyed before the canvas can be reused.",
              );
            const a = e.createResolver(e.chartOptionScopes(), n.getContext());
            this.platform = n._initializePlatform(i, e);
            const o = n.platform.acquireContext(i, a.aspectRatio),
              s = o && o.canvas,
              l = s && s.height,
              c = s && s.width;
            (this.id = h()),
              (this.ctx = o),
              (this.canvas = s),
              (this.width = c),
              (this.height = l),
              (this._options = a),
              (this._aspectRatio = this.aspectRatio),
              (this._layers = []),
              (this._metasets = []),
              (this._stacks = void 0),
              (this.boxes = []),
              (this.currentDevicePixelRatio = void 0),
              (this.chartArea = void 0),
              (this._active = []),
              (this._lastEvent = void 0),
              (this._listeners = {}),
              (this._sortedMetasets = []),
              (this.scales = {}),
              (this.scale = void 0),
              (this._plugins = new Ei()),
              (this.$proxies = {}),
              (this._hiddenIndices = {}),
              (this.attached = !1),
              (this._animationsDisabled = void 0),
              (this.$context = void 0),
              (this._doResize = (function (t, e) {
                let n;
                return function () {
                  return e ? (clearTimeout(n), (n = setTimeout(t, e))) : t(), e;
                };
              })(() => this.update('resize'), a.resizeDelay || 0)),
              (Wi[n.id] = n),
              o && s
                ? (nn.listen(n, 'complete', ji),
                  nn.listen(n, 'progress', Gi),
                  n._initialize(),
                  n.attached && n.update())
                : console.error(
                    "Failed to create chart: can't acquire context from the given item",
                  );
          }
          get aspectRatio() {
            const {
              options: { aspectRatio: t, maintainAspectRatio: e },
              width: n,
              height: i,
              _aspectRatio: r,
            } = this;
            return d(t) ? (e && r ? r : i ? n / i : null) : t;
          }
          get data() {
            return this.config.data;
          }
          set data(t) {
            this.config.data = t;
          }
          get options() {
            return this._options;
          }
          set options(t) {
            this.config.options = t;
          }
          _initialize() {
            const t = this;
            return (
              t.notifyPlugins('beforeInit'),
              t.options.responsive
                ? t.resize()
                : Ue(t, t.options.devicePixelRatio),
              t.bindEvents(),
              t.notifyPlugins('afterInit'),
              t
            );
          }
          _initializePlatform(t, e) {
            return e.platform
              ? new e.platform()
              : !Hi() ||
                ('undefined' != typeof OffscreenCanvas &&
                  t instanceof OffscreenCanvas)
              ? new Qn()
              : new di();
          }
          clear() {
            return Xt(this.canvas, this.ctx), this;
          }
          stop() {
            return nn.stop(this), this;
          }
          resize(t, e) {
            nn.running(this)
              ? (this._resizeBeforeDraw = { width: t, height: e })
              : this._resize(t, e);
          }
          _resize(t, e) {
            const n = this,
              i = n.options,
              r = n.canvas,
              a = i.maintainAspectRatio && n.aspectRatio,
              o = n.platform.getMaximumSize(r, t, e, a),
              s = n.currentDevicePixelRatio,
              l = i.devicePixelRatio || n.platform.getDevicePixelRatio();
            (n.width === o.width && n.height === o.height && s === l) ||
              ((n.width = o.width),
              (n.height = o.height),
              (n._aspectRatio = n.aspectRatio),
              Ue(n, l, !0),
              n.notifyPlugins('resize', { size: o }),
              x(i.onResize, [n, o], n),
              n.attached && n._doResize() && n.render());
          }
          ensureScalesHaveIDs() {
            b(this.options.scales || {}, (t, e) => {
              t.id = e;
            });
          }
          buildOrUpdateScales() {
            const t = this,
              e = t.options,
              n = e.scales,
              i = t.scales,
              r = Object.keys(i).reduce((t, e) => ((t[e] = !1), t), {});
            let a = [];
            n &&
              (a = a.concat(
                Object.keys(n).map((t) => {
                  const e = n[t],
                    i = Ci(t, e),
                    r = 'r' === i,
                    a = 'x' === i;
                  return {
                    options: e,
                    dposition: r ? 'chartArea' : a ? 'bottom' : 'left',
                    dtype: r ? 'radialLinear' : a ? 'category' : 'linear',
                  };
                }),
              )),
              b(a, (n) => {
                const a = n.options,
                  o = a.id,
                  s = Ci(o, a),
                  l = y(a.type, n.dtype);
                (void 0 !== a.position &&
                  Bi(a.position, s) === Bi(n.dposition)) ||
                  (a.position = n.dposition),
                  (r[o] = !0);
                let c = null;
                if (o in i && i[o].type === l) c = i[o];
                else {
                  (c = new (Ti.getScale(l))({
                    id: o,
                    type: l,
                    ctx: t.ctx,
                    chart: t,
                  })),
                    (i[c.id] = c);
                }
                c.init(a, e);
              }),
              b(r, (t, e) => {
                t || delete i[e];
              }),
              b(i, (e) => {
                Zn.configure(t, e, e.options), Zn.addBox(t, e);
              });
          }
          _updateMetasetIndex(t, e) {
            const n = this._metasets,
              i = t.index;
            i !== e && ((n[i] = n[e]), (n[e] = t), (t.index = e));
          }
          _updateMetasets() {
            const t = this,
              e = t._metasets,
              n = t.data.datasets.length,
              i = e.length;
            if (i > n) {
              for (let e = n; e < i; ++e) t._destroyDatasetMeta(e);
              e.splice(n, i - n);
            }
            t._sortedMetasets = e.slice(0).sort(Ui('order', 'index'));
          }
          _removeUnreferencedMetasets() {
            const t = this,
              {
                _metasets: e,
                data: { datasets: n },
              } = t;
            e.length > n.length && delete t._stacks,
              e.forEach((e, i) => {
                0 === n.filter((t) => t === e._dataset).length &&
                  t._destroyDatasetMeta(i);
              });
          }
          buildOrUpdateControllers() {
            const t = this,
              e = [],
              n = t.data.datasets;
            let i, r;
            for (
              t._removeUnreferencedMetasets(), i = 0, r = n.length;
              i < r;
              i++
            ) {
              const r = n[i];
              let a = t.getDatasetMeta(i);
              const o = r.type || t.config.type;
              if (
                (a.type &&
                  a.type !== o &&
                  (t._destroyDatasetMeta(i), (a = t.getDatasetMeta(i))),
                (a.type = o),
                (a.indexAxis = r.indexAxis || Ri(o, t.options)),
                (a.order = r.order || 0),
                t._updateMetasetIndex(a, i),
                (a.label = '' + r.label),
                (a.visible = t.isDatasetVisible(i)),
                a.controller)
              )
                a.controller.updateIndex(i), a.controller.linkScales();
              else {
                const n = Ti.getController(o),
                  { datasetElementType: r, dataElementType: s } =
                    Gt.datasets[o];
                Object.assign(n.prototype, {
                  dataElementType: Ti.getElement(s),
                  datasetElementType: r && Ti.getElement(r),
                }),
                  (a.controller = new n(t, i)),
                  e.push(a.controller);
              }
            }
            return t._updateMetasets(), e;
          }
          _resetElements() {
            const t = this;
            b(
              t.data.datasets,
              (e, n) => {
                t.getDatasetMeta(n).controller.reset();
              },
              t,
            );
          }
          reset() {
            this._resetElements(), this.notifyPlugins('reset');
          }
          update(t) {
            const e = this,
              n = e.config;
            n.update(),
              (e._options = n.createResolver(
                n.chartOptionScopes(),
                e.getContext(),
              )),
              b(e.scales, (t) => {
                Zn.removeBox(e, t);
              });
            const i = (e._animationsDisabled = !e.options.animation);
            if (
              (e.ensureScalesHaveIDs(),
              e.buildOrUpdateScales(),
              e._plugins.invalidate(),
              !1 ===
                e.notifyPlugins('beforeUpdate', { mode: t, cancelable: !0 }))
            )
              return;
            const r = e.buildOrUpdateControllers();
            e.notifyPlugins('beforeElementsUpdate');
            let a = 0;
            for (let t = 0, n = e.data.datasets.length; t < n; t++) {
              const { controller: n } = e.getDatasetMeta(t),
                o = !i && -1 === r.indexOf(n);
              n.buildOrUpdateElements(o),
                (a = Math.max(+n.getMaxOverflow(), a));
            }
            (e._minPadding = a),
              e._updateLayout(a),
              i ||
                b(r, (t) => {
                  t.reset();
                }),
              e._updateDatasets(t),
              e.notifyPlugins('afterUpdate', { mode: t }),
              e._layers.sort(Ui('z', '_idx')),
              e._lastEvent && e._eventHandler(e._lastEvent, !0),
              e.render();
          }
          _updateLayout(t) {
            const e = this;
            if (!1 === e.notifyPlugins('beforeLayout', { cancelable: !0 }))
              return;
            Zn.update(e, e.width, e.height, t);
            const n = e.chartArea,
              i = n.width <= 0 || n.height <= 0;
            (e._layers = []),
              b(
                e.boxes,
                (t) => {
                  (i && 'chartArea' === t.position) ||
                    (t.configure && t.configure(),
                    e._layers.push(...t._layers()));
                },
                e,
              ),
              e._layers.forEach((t, e) => {
                t._idx = e;
              }),
              e.notifyPlugins('afterLayout');
          }
          _updateDatasets(t) {
            const e = this,
              n = 'function' == typeof t;
            if (
              !1 !==
              e.notifyPlugins('beforeDatasetsUpdate', {
                mode: t,
                cancelable: !0,
              })
            ) {
              for (let i = 0, r = e.data.datasets.length; i < r; ++i)
                e._updateDataset(i, n ? t({ datasetIndex: i }) : t);
              e.notifyPlugins('afterDatasetsUpdate', { mode: t });
            }
          }
          _updateDataset(t, e) {
            const n = this.getDatasetMeta(t),
              i = { meta: n, index: t, mode: e, cancelable: !0 };
            !1 !== this.notifyPlugins('beforeDatasetUpdate', i) &&
              (n.controller._update(e),
              (i.cancelable = !1),
              this.notifyPlugins('afterDatasetUpdate', i));
          }
          render() {
            const t = this;
            !1 !== t.notifyPlugins('beforeRender', { cancelable: !0 }) &&
              (nn.has(t)
                ? t.attached && !nn.running(t) && nn.start(t)
                : (t.draw(), ji({ chart: t })));
          }
          draw() {
            const t = this;
            let e;
            if (t._resizeBeforeDraw) {
              const { width: e, height: n } = t._resizeBeforeDraw;
              t._resize(e, n), (t._resizeBeforeDraw = null);
            }
            if ((t.clear(), t.width <= 0 || t.height <= 0)) return;
            if (!1 === t.notifyPlugins('beforeDraw', { cancelable: !0 }))
              return;
            const n = t._layers;
            for (e = 0; e < n.length && n[e].z <= 0; ++e)
              n[e].draw(t.chartArea);
            for (t._drawDatasets(); e < n.length; ++e) n[e].draw(t.chartArea);
            t.notifyPlugins('afterDraw');
          }
          _getSortedDatasetMetas(t) {
            const e = this._sortedMetasets,
              n = [];
            let i, r;
            for (i = 0, r = e.length; i < r; ++i) {
              const r = e[i];
              (t && !r.visible) || n.push(r);
            }
            return n;
          }
          getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(!0);
          }
          _drawDatasets() {
            const t = this;
            if (
              !1 === t.notifyPlugins('beforeDatasetsDraw', { cancelable: !0 })
            )
              return;
            const e = t.getSortedVisibleDatasetMetas();
            for (let n = e.length - 1; n >= 0; --n) t._drawDataset(e[n]);
            t.notifyPlugins('afterDatasetsDraw');
          }
          _drawDataset(t) {
            const e = this,
              n = e.ctx,
              i = t._clip,
              r = e.chartArea,
              a = { meta: t, index: t.index, cancelable: !0 };
            !1 !== e.notifyPlugins('beforeDatasetDraw', a) &&
              (Jt(n, {
                left: !1 === i.left ? 0 : r.left - i.left,
                right: !1 === i.right ? e.width : r.right + i.right,
                top: !1 === i.top ? 0 : r.top - i.top,
                bottom: !1 === i.bottom ? e.height : r.bottom + i.bottom,
              }),
              t.controller.draw(),
              Zt(n),
              (a.cancelable = !1),
              e.notifyPlugins('afterDatasetDraw', a));
          }
          getElementsAtEventForMode(t, e, n, i) {
            const r = Bn.modes[e];
            return 'function' == typeof r ? r(this, t, n, i) : [];
          }
          getDatasetMeta(t) {
            const e = this.data.datasets[t],
              n = this._metasets;
            let i = n.filter((t) => t && t._dataset === e).pop();
            return (
              i ||
                (i = n[t] =
                  {
                    type: null,
                    data: [],
                    dataset: null,
                    controller: null,
                    hidden: null,
                    xAxisID: null,
                    yAxisID: null,
                    order: (e && e.order) || 0,
                    index: t,
                    _dataset: e,
                    _parsed: [],
                    _sorted: !1,
                  }),
              i
            );
          }
          getContext() {
            return (
              this.$context || (this.$context = { chart: this, type: 'chart' })
            );
          }
          getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
          }
          isDatasetVisible(t) {
            const e = this.data.datasets[t];
            if (!e) return !1;
            const n = this.getDatasetMeta(t);
            return 'boolean' == typeof n.hidden ? !n.hidden : !e.hidden;
          }
          setDatasetVisibility(t, e) {
            this.getDatasetMeta(t).hidden = !e;
          }
          toggleDataVisibility(t) {
            this._hiddenIndices[t] = !this._hiddenIndices[t];
          }
          getDataVisibility(t) {
            return !this._hiddenIndices[t];
          }
          _updateDatasetVisibility(t, e) {
            const n = e ? 'show' : 'hide',
              i = this.getDatasetMeta(t),
              r = i.controller._resolveAnimations(void 0, n);
            this.setDatasetVisibility(t, e),
              r.update(i, { visible: e }),
              this.update((e) => (e.datasetIndex === t ? n : void 0));
          }
          hide(t) {
            this._updateDatasetVisibility(t, !1);
          }
          show(t) {
            this._updateDatasetVisibility(t, !0);
          }
          _destroyDatasetMeta(t) {
            const e = this,
              n = e._metasets && e._metasets[t];
            n &&
              n.controller &&
              (n.controller._destroy(), delete e._metasets[t]);
          }
          destroy() {
            const t = this,
              { canvas: e, ctx: n } = t;
            let i, r;
            for (
              t.stop(), nn.remove(t), i = 0, r = t.data.datasets.length;
              i < r;
              ++i
            )
              t._destroyDatasetMeta(i);
            t.config.clearCache(),
              e &&
                (t.unbindEvents(),
                Xt(e, n),
                t.platform.releaseContext(n),
                (t.canvas = null),
                (t.ctx = null)),
              t.notifyPlugins('destroy'),
              delete Wi[t.id];
          }
          toBase64Image(...t) {
            return this.canvas.toDataURL(...t);
          }
          bindEvents() {
            const t = this,
              e = t._listeners,
              n = t.platform,
              i = (i, r) => {
                n.addEventListener(t, i, r), (e[i] = r);
              },
              r = (i, r) => {
                e[i] && (n.removeEventListener(t, i, r), delete e[i]);
              };
            let a = function (e, n, i) {
              (e.offsetX = n), (e.offsetY = i), t._eventHandler(e);
            };
            if ((b(t.options.events, (t) => i(t, a)), t.options.responsive)) {
              let e;
              a = (e, n) => {
                t.canvas && t.resize(e, n);
              };
              const o = () => {
                r('attach', o),
                  (t.attached = !0),
                  t.resize(),
                  i('resize', a),
                  i('detach', e);
              };
              (e = () => {
                (t.attached = !1), r('resize', a), i('attach', o);
              }),
                n.isAttached(t.canvas) ? o() : e();
            } else t.attached = !0;
          }
          unbindEvents() {
            const t = this,
              e = t._listeners;
            e &&
              (delete t._listeners,
              b(e, (e, n) => {
                t.platform.removeEventListener(t, n, e);
              }));
          }
          updateHoverStyle(t, e, n) {
            const i = n ? 'set' : 'remove';
            let r, a, o, s;
            for (
              'dataset' === e &&
                ((r = this.getDatasetMeta(t[0].datasetIndex)),
                r.controller['_' + i + 'DatasetHoverStyle']()),
                o = 0,
                s = t.length;
              o < s;
              ++o
            ) {
              a = t[o];
              const e = a && this.getDatasetMeta(a.datasetIndex).controller;
              e && e[i + 'HoverStyle'](a.element, a.datasetIndex, a.index);
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(t) {
            const e = this,
              n = e._active || [],
              i = t.map(({ datasetIndex: t, index: n }) => {
                const i = e.getDatasetMeta(t);
                if (!i) throw new Error('No dataset found at index ' + t);
                return { datasetIndex: t, element: i.data[n], index: n };
              });
            !_(i, n) && ((e._active = i), e._updateHoverStyles(i, n));
          }
          notifyPlugins(t, e) {
            return this._plugins.notify(this, t, e);
          }
          _updateHoverStyles(t, e, n) {
            const i = this,
              r = i.options.hover,
              a = (t, e) =>
                t.filter(
                  (t) =>
                    !e.some(
                      (e) =>
                        t.datasetIndex === e.datasetIndex &&
                        t.index === e.index,
                    ),
                ),
              o = a(e, t),
              s = n ? t : a(t, e);
            o.length && i.updateHoverStyle(o, r.mode, !1),
              s.length && r.mode && i.updateHoverStyle(s, r.mode, !0);
          }
          _eventHandler(t, e) {
            const n = this,
              i = { event: t, replay: e, cancelable: !0 };
            if (!1 === n.notifyPlugins('beforeEvent', i)) return;
            const r = n._handleEvent(t, e);
            return (
              (i.cancelable = !1),
              n.notifyPlugins('afterEvent', i),
              (r || i.changed) && n.render(),
              n
            );
          }
          _handleEvent(t, e) {
            const n = this,
              { _active: i = [], options: r } = n,
              a = r.hover,
              o = e;
            let s = [],
              l = !1,
              c = null;
            return (
              'mouseout' !== t.type &&
                ((s = n.getElementsAtEventForMode(t, a.mode, a, o)),
                (c = 'click' === t.type ? n._lastEvent : t)),
              (n._lastEvent = null),
              x(r.onHover, [t, s, n], n),
              ('mouseup' !== t.type &&
                'click' !== t.type &&
                'contextmenu' !== t.type) ||
                ($t(t, n.chartArea, n._minPadding) &&
                  x(r.onClick, [t, s, n], n)),
              (l = !_(s, i)),
              (l || e) && ((n._active = s), n._updateHoverStyles(s, i, e)),
              (n._lastEvent = c),
              l
            );
          }
        }
        const $i = () => b(Yi.instances, (t) => t._plugins.invalidate());
        function Ji(t, e) {
          const {
            startAngle: n,
            endAngle: i,
            pixelMargin: r,
            x: a,
            y: o,
            outerRadius: s,
            innerRadius: l,
          } = e;
          let c = r / s;
          t.beginPath(),
            t.arc(a, o, s, n - c, i + c),
            l > r
              ? ((c = r / l), t.arc(a, o, l, i + c, n - c, !0))
              : t.arc(a, o, r, i + z, n - z),
            t.closePath(),
            t.clip();
        }
        function Zi(t, e) {
          const { x: n, y: i, startAngle: r, endAngle: a, pixelMargin: o } = e,
            s = Math.max(e.outerRadius - o, 0),
            l = e.innerRadius + o;
          t.beginPath(),
            t.arc(n, i, s, r, a),
            t.arc(n, i, l, a, r, !0),
            t.closePath();
        }
        function Ki(t, e) {
          const {
              x: n,
              y: i,
              startAngle: r,
              endAngle: a,
              pixelMargin: o,
              options: s,
            } = e,
            l = e.outerRadius,
            c = e.innerRadius + o,
            u = 'inner' === s.borderAlign;
          s.borderWidth &&
            (u
              ? ((t.lineWidth = 2 * s.borderWidth), (t.lineJoin = 'round'))
              : ((t.lineWidth = s.borderWidth), (t.lineJoin = 'bevel')),
            e.fullCircles &&
              (function (t, e, n) {
                const {
                    x: i,
                    y: r,
                    startAngle: a,
                    endAngle: o,
                    pixelMargin: s,
                  } = e,
                  l = Math.max(e.outerRadius - s, 0),
                  c = e.innerRadius + s;
                let u;
                for (
                  n &&
                    ((e.endAngle = e.startAngle + I),
                    Ji(t, e),
                    (e.endAngle = o),
                    e.endAngle === e.startAngle &&
                      ((e.endAngle += I), e.fullCircles--)),
                    t.beginPath(),
                    t.arc(i, r, c, a + I, a, !0),
                    u = 0;
                  u < e.fullCircles;
                  ++u
                )
                  t.stroke();
                for (
                  t.beginPath(), t.arc(i, r, l, a, a + I), u = 0;
                  u < e.fullCircles;
                  ++u
                )
                  t.stroke();
              })(t, e, u),
            u && Ji(t, e),
            t.beginPath(),
            t.arc(n, i, l, r, a),
            t.arc(n, i, c, a, r, !0),
            t.closePath(),
            t.stroke());
        }
        Object.defineProperties(Yi, {
          defaults: { enumerable: !0, value: Gt },
          instances: { enumerable: !0, value: Wi },
          overrides: { enumerable: !0, value: Ft },
          registry: { enumerable: !0, value: Ti },
          version: { enumerable: !0, value: '3.0.2' },
          getChart: { enumerable: !0, value: Xi },
          register: {
            enumerable: !0,
            value: (...t) => {
              Ti.add(...t), $i();
            },
          },
          unregister: {
            enumerable: !0,
            value: (...t) => {
              Ti.remove(...t), $i();
            },
          },
        });
        class Qi extends pi {
          constructor(t) {
            super(),
              (this.options = void 0),
              (this.circumference = void 0),
              (this.startAngle = void 0),
              (this.endAngle = void 0),
              (this.innerRadius = void 0),
              (this.outerRadius = void 0),
              (this.pixelMargin = 0),
              (this.fullCircles = 0),
              t && Object.assign(this, t);
          }
          inRange(t, e, n) {
            const i = this.getProps(['x', 'y'], n),
              { angle: r, distance: a } = (function (t, e) {
                const n = e.x - t.x,
                  i = e.y - t.y,
                  r = Math.sqrt(n * n + i * i);
                let a = Math.atan2(i, n);
                return a < -0.5 * k && (a += I), { angle: a, distance: r };
              })(i, { x: t, y: e }),
              {
                startAngle: o,
                endAngle: s,
                innerRadius: l,
                outerRadius: c,
                circumference: u,
              } = this.getProps(
                [
                  'startAngle',
                  'endAngle',
                  'innerRadius',
                  'outerRadius',
                  'circumference',
                ],
                n,
              );
            return (u >= I || K(r, o, s)) && a >= l && a <= c;
          }
          getCenterPoint(t) {
            const {
                x: e,
                y: n,
                startAngle: i,
                endAngle: r,
                innerRadius: a,
                outerRadius: o,
              } = this.getProps(
                [
                  'x',
                  'y',
                  'startAngle',
                  'endAngle',
                  'innerRadius',
                  'outerRadius',
                ],
                t,
              ),
              s = (i + r) / 2,
              l = (a + o) / 2;
            return { x: e + Math.cos(s) * l, y: n + Math.sin(s) * l };
          }
          tooltipPosition(t) {
            return this.getCenterPoint(t);
          }
          draw(t) {
            const e = this,
              n = e.options,
              i = n.offset || 0;
            if (
              ((e.pixelMargin = 'inner' === n.borderAlign ? 0.33 : 0),
              (e.fullCircles = Math.floor(e.circumference / I)),
              !(
                0 === e.circumference ||
                e.innerRadius < 0 ||
                e.outerRadius < 0
              ))
            ) {
              if ((t.save(), i && e.circumference < I)) {
                const n = (e.startAngle + e.endAngle) / 2;
                t.translate(Math.cos(n) * i, Math.sin(n) * i);
              }
              (t.fillStyle = n.backgroundColor),
                (t.strokeStyle = n.borderColor),
                (function (t, e) {
                  if (e.fullCircles) {
                    (e.endAngle = e.startAngle + I), Zi(t, e);
                    for (let n = 0; n < e.fullCircles; ++n) t.fill();
                  }
                  isNaN(e.circumference) ||
                    (e.endAngle = e.startAngle + (e.circumference % I)),
                    Zi(t, e),
                    t.fill();
                })(t, e),
                Ki(t, e),
                t.restore();
            }
          }
        }
        function tr(t, e, n) {
          t.lineTo(n.x, n.y);
        }
        function er(t, e, n) {
          n = n || {};
          const i = t.length,
            r = Math.max(n.start || 0, e.start),
            a = Math.min(n.end || i - 1, e.end);
          return {
            count: i,
            start: r,
            loop: e.loop,
            ilen: a < r ? i + a - r : a - r,
          };
        }
        function nr(t, e, n, i) {
          const { points: r, options: a } = e,
            { count: o, start: s, loop: l, ilen: c } = er(r, n, i),
            u = (function (t) {
              return t.stepped ? Kt : t.tension ? Qt : tr;
            })(a);
          let h,
            d,
            p,
            { move: f = !0, reverse: m } = i || {};
          for (h = 0; h <= c; ++h)
            (d = r[(s + (m ? c - h : h)) % o]),
              d.skip ||
                (f ? (t.moveTo(d.x, d.y), (f = !1)) : u(t, p, d, m, a.stepped),
                (p = d));
          return (
            l && ((d = r[(s + (m ? c : 0)) % o]), u(t, p, d, m, a.stepped)), !!l
          );
        }
        function ir(t, e, n, i) {
          const r = e.points,
            { count: a, start: o, ilen: s } = er(r, n, i),
            { move: l = !0, reverse: c } = i || {};
          let u,
            h,
            d,
            p,
            f,
            m,
            g = 0,
            y = 0;
          const v = (t) => (o + (c ? s - t : t)) % a,
            x = () => {
              p !== f && (t.lineTo(g, f), t.lineTo(g, p), t.lineTo(g, m));
            };
          for (l && ((h = r[v(0)]), t.moveTo(h.x, h.y)), u = 0; u <= s; ++u) {
            if (((h = r[v(u)]), h.skip)) continue;
            const e = h.x,
              n = h.y,
              i = 0 | e;
            i === d
              ? (n < p ? (p = n) : n > f && (f = n), (g = (y * g + e) / ++y))
              : (x(), t.lineTo(e, n), (d = i), (y = 0), (p = f = n)),
              (m = n);
          }
          x();
        }
        function rr(t) {
          const e = t.options,
            n = e.borderDash && e.borderDash.length;
          return !(t._decimated || t._loop || e.tension || e.stepped || n)
            ? ir
            : nr;
        }
        (Qi.id = 'arc'),
          (Qi.defaults = {
            borderAlign: 'center',
            borderColor: '#fff',
            borderWidth: 2,
            offset: 0,
            angle: void 0,
          }),
          (Qi.defaultRoutes = { backgroundColor: 'backgroundColor' });
        const ar =
          'function' == typeof Path2D
            ? function (t, e, n, i) {
                let r = e._path;
                r ||
                  ((r = e._path = new Path2D()),
                  e.path(r, n, i) && r.closePath()),
                  t.stroke(r);
              }
            : function (t, e, n, i) {
                t.beginPath(), e.path(t, n, i) && t.closePath(), t.stroke();
              };
        class or extends pi {
          constructor(t) {
            super(),
              (this.animated = !0),
              (this.options = void 0),
              (this._loop = void 0),
              (this._fullLoop = void 0),
              (this._path = void 0),
              (this._points = void 0),
              (this._segments = void 0),
              (this._decimated = !1),
              (this._pointsUpdated = !1),
              t && Object.assign(this, t);
          }
          updateControlPoints(t) {
            const e = this,
              n = e.options;
            if (n.tension && !n.stepped && !e._pointsUpdated) {
              const i = n.spanGaps ? e._loop : e._fullLoop;
              Pe(e._points, n, t, i), (e._pointsUpdated = !0);
            }
          }
          set points(t) {
            (this._points = t),
              delete this._segments,
              delete this._path,
              (this._pointsUpdated = !1);
          }
          get points() {
            return this._points;
          }
          get segments() {
            return (
              this._segments ||
              (this._segments = (function (t) {
                const e = t.points,
                  n = t.options.spanGaps,
                  i = e.length;
                if (!i) return [];
                const r = !!t._loop,
                  { start: a, end: o } = (function (t, e, n, i) {
                    let r = 0,
                      a = e - 1;
                    if (n && !i) for (; r < e && !t[r].skip; ) r++;
                    for (; r < e && t[r].skip; ) r++;
                    for (r %= e, n && (a += r); a > r && t[a % e].skip; ) a--;
                    return (a %= e), { start: r, end: a };
                  })(e, i, r, n);
                return !0 === n
                  ? [{ start: a, end: o, loop: r }]
                  : (function (t, e, n, i) {
                      const r = t.length,
                        a = [];
                      let o,
                        s = e,
                        l = t[e];
                      for (o = e + 1; o <= n; ++o) {
                        const n = t[o % r];
                        n.skip || n.stop
                          ? l.skip ||
                            ((i = !1),
                            a.push({ start: e % r, end: (o - 1) % r, loop: i }),
                            (e = s = n.stop ? o : null))
                          : ((s = o), l.skip && (e = o)),
                          (l = n);
                      }
                      return (
                        null !== s &&
                          a.push({ start: e % r, end: s % r, loop: i }),
                        a
                      );
                    })(
                      e,
                      a,
                      o < a ? o + i : o,
                      !!t._fullLoop && 0 === a && o === i - 1,
                    );
              })(this))
            );
          }
          first() {
            const t = this.segments,
              e = this.points;
            return t.length && e[t[0].start];
          }
          last() {
            const t = this.segments,
              e = this.points,
              n = t.length;
            return n && e[t[n - 1].end];
          }
          interpolate(t, e) {
            const n = this.options,
              i = t[e],
              r = this.points,
              a = en(this, { property: e, start: i, end: i });
            if (!a.length) return;
            const o = [],
              s = (function (t) {
                return t.stepped ? Ve : t.tension ? We : He;
              })(n);
            let l, c;
            for (l = 0, c = a.length; l < c; ++l) {
              const { start: c, end: u } = a[l],
                h = r[c],
                d = r[u];
              if (h === d) {
                o.push(h);
                continue;
              }
              const p = s(
                h,
                d,
                Math.abs((i - h[e]) / (d[e] - h[e])),
                n.stepped,
              );
              (p[e] = t[e]), o.push(p);
            }
            return 1 === o.length ? o[0] : o;
          }
          pathSegment(t, e, n) {
            return rr(this)(t, this, e, n);
          }
          path(t, e, n) {
            const i = this,
              r = i.segments,
              a = r.length,
              o = rr(i);
            let s = i._loop;
            (e = e || 0), (n = n || i.points.length - e);
            for (let l = 0; l < a; ++l)
              s &= o(t, i, r[l], { start: e, end: e + n - 1 });
            return !!s;
          }
          draw(t, e, n, i) {
            const r = this,
              a = r.options || {};
            (r.points || []).length &&
              a.borderWidth &&
              (t.save(),
              (function (t, e) {
                (t.lineCap = e.borderCapStyle),
                  t.setLineDash(e.borderDash),
                  (t.lineDashOffset = e.borderDashOffset),
                  (t.lineJoin = e.borderJoinStyle),
                  (t.lineWidth = e.borderWidth),
                  (t.strokeStyle = e.borderColor);
              })(t, a),
              ar(t, r, n, i),
              t.restore(),
              r.animated && ((r._pointsUpdated = !1), (r._path = void 0)));
          }
        }
        function sr(t, e, n, i) {
          const r = t.options,
            { [n]: a } = t.getProps([n], i);
          return Math.abs(e - a) < r.radius + r.hitRadius;
        }
        (or.id = 'line'),
          (or.defaults = {
            borderCapStyle: 'butt',
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: 'miter',
            borderWidth: 3,
            capBezierPoints: !0,
            cubicInterpolationMode: 'default',
            fill: !1,
            spanGaps: !1,
            stepped: !1,
            tension: 0,
          }),
          (or.defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor',
          }),
          (or.descriptors = {
            _scriptable: !0,
            _indexable: (t) => 'borderDash' !== t && 'fill' !== t,
          });
        class lr extends pi {
          constructor(t) {
            super(),
              (this.options = void 0),
              (this.skip = void 0),
              (this.stop = void 0),
              t && Object.assign(this, t);
          }
          inRange(t, e, n) {
            const i = this.options,
              { x: r, y: a } = this.getProps(['x', 'y'], n);
            return (
              Math.pow(t - r, 2) + Math.pow(e - a, 2) <
              Math.pow(i.hitRadius + i.radius, 2)
            );
          }
          inXRange(t, e) {
            return sr(this, t, 'x', e);
          }
          inYRange(t, e) {
            return sr(this, t, 'y', e);
          }
          getCenterPoint(t) {
            const { x: e, y: n } = this.getProps(['x', 'y'], t);
            return { x: e, y: n };
          }
          size(t) {
            let e = (t = t || this.options || {}).radius || 0;
            e = Math.max(e, (e && t.hoverRadius) || 0);
            return 2 * (e + ((e && t.borderWidth) || 0));
          }
          draw(t) {
            const e = this.options;
            this.skip ||
              e.radius < 0.1 ||
              ((t.strokeStyle = e.borderColor),
              (t.lineWidth = e.borderWidth),
              (t.fillStyle = e.backgroundColor),
              Yt(t, e, this.x, this.y));
          }
          getRange() {
            const t = this.options || {};
            return t.radius + t.hitRadius;
          }
        }
        function cr(t, e) {
          const {
            x: n,
            y: i,
            base: r,
            width: a,
            height: o,
          } = t.getProps(['x', 'y', 'base', 'width', 'height'], e);
          let s, l, c, u, h;
          return (
            t.horizontal
              ? ((h = o / 2),
                (s = Math.min(n, r)),
                (l = Math.max(n, r)),
                (c = i - h),
                (u = i + h))
              : ((h = a / 2),
                (s = n - h),
                (l = n + h),
                (c = Math.min(i, r)),
                (u = Math.max(i, r))),
            { left: s, top: c, right: l, bottom: u }
          );
        }
        function ur(t) {
          let e = t.options.borderSkipped;
          const n = {};
          return e
            ? ((e = t.horizontal
                ? hr(e, 'left', 'right', t.base > t.x)
                : hr(e, 'bottom', 'top', t.base < t.y)),
              (n[e] = !0),
              n)
            : n;
        }
        function hr(t, e, n, i) {
          var r, a, o;
          return (
            i
              ? ((o = n),
                (t = dr((t = (r = t) === (a = e) ? o : r === o ? a : r), n, e)))
              : (t = dr(t, e, n)),
            t
          );
        }
        function dr(t, e, n) {
          return 'start' === t ? e : 'end' === t ? n : t;
        }
        function pr(t, e, n, i) {
          return t ? 0 : Math.max(Math.min(e, i), n);
        }
        function fr(t, e, n) {
          const i = (function (t) {
              return ie(t, [
                'topLeft',
                'topRight',
                'bottomLeft',
                'bottomRight',
              ]);
            })(t.options.borderRadius),
            r = Math.min(e, n),
            a = ur(t);
          return {
            topLeft: pr(a.top || a.left, i.topLeft, 0, r),
            topRight: pr(a.top || a.right, i.topRight, 0, r),
            bottomLeft: pr(a.bottom || a.left, i.bottomLeft, 0, r),
            bottomRight: pr(a.bottom || a.right, i.bottomRight, 0, r),
          };
        }
        function mr(t) {
          const e = cr(t),
            n = e.right - e.left,
            i = e.bottom - e.top,
            r = (function (t, e, n) {
              const i = t.options.borderWidth,
                r = ur(t),
                a = re(i);
              return {
                t: pr(r.top, a.top, 0, n),
                r: pr(r.right, a.right, 0, e),
                b: pr(r.bottom, a.bottom, 0, n),
                l: pr(r.left, a.left, 0, e),
              };
            })(t, n / 2, i / 2),
            a = fr(t, n / 2, i / 2);
          return {
            outer: { x: e.left, y: e.top, w: n, h: i, radius: a },
            inner: {
              x: e.left + r.l,
              y: e.top + r.t,
              w: n - r.l - r.r,
              h: i - r.t - r.b,
              radius: {
                topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)),
                topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)),
                bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)),
                bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r)),
              },
            },
          };
        }
        function gr(t, e, n, i) {
          const r = null === e,
            a = null === n,
            o = t && !(r && a) && cr(t, i);
          return (
            o &&
            (r || (e >= o.left && e <= o.right)) &&
            (a || (n >= o.top && n <= o.bottom))
          );
        }
        function yr(t, e) {
          const { x: n, y: i, w: r, h: a, radius: o } = e;
          t.arc(n + o.topLeft, i + o.topLeft, o.topLeft, -z, k, !0),
            t.lineTo(n, i + a - o.bottomLeft),
            t.arc(
              n + o.bottomLeft,
              i + a - o.bottomLeft,
              o.bottomLeft,
              k,
              z,
              !0,
            ),
            t.lineTo(n + r - o.bottomRight, i + a),
            t.arc(
              n + r - o.bottomRight,
              i + a - o.bottomRight,
              o.bottomRight,
              z,
              0,
              !0,
            ),
            t.lineTo(n + r, i + o.topRight),
            t.arc(n + r - o.topRight, i + o.topRight, o.topRight, 0, -z, !0),
            t.lineTo(n + o.topLeft, i);
        }
        function vr(t, e) {
          t.rect(e.x, e.y, e.w, e.h);
        }
        (lr.id = 'point'),
          (lr.defaults = {
            borderWidth: 1,
            hitRadius: 1,
            hoverBorderWidth: 1,
            hoverRadius: 4,
            pointStyle: 'circle',
            radius: 3,
            rotation: 0,
          }),
          (lr.defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor',
          });
        class xr extends pi {
          constructor(t) {
            super(),
              (this.options = void 0),
              (this.horizontal = void 0),
              (this.base = void 0),
              (this.width = void 0),
              (this.height = void 0),
              t && Object.assign(this, t);
          }
          draw(t) {
            const e = this.options,
              { inner: n, outer: i } = mr(this),
              r =
                (a = i.radius).topLeft ||
                a.topRight ||
                a.bottomLeft ||
                a.bottomRight
                  ? yr
                  : vr;
            var a;
            t.save(),
              (i.w === n.w && i.h === n.h) ||
                (t.beginPath(),
                r(t, i),
                t.clip(),
                r(t, n),
                (t.fillStyle = e.borderColor),
                t.fill('evenodd')),
              t.beginPath(),
              r(t, n),
              (t.fillStyle = e.backgroundColor),
              t.fill(),
              t.restore();
          }
          inRange(t, e, n) {
            return gr(this, t, e, n);
          }
          inXRange(t, e) {
            return gr(this, t, null, e);
          }
          inYRange(t, e) {
            return gr(this, null, t, e);
          }
          getCenterPoint(t) {
            const {
              x: e,
              y: n,
              base: i,
              horizontal: r,
            } = this.getProps(['x', 'y', 'base', 'horizontal'], t);
            return { x: r ? (e + i) / 2 : e, y: r ? n : (n + i) / 2 };
          }
          getRange(t) {
            return 'x' === t ? this.width / 2 : this.height / 2;
          }
        }
        (xr.id = 'bar'),
          (xr.defaults = {
            borderSkipped: 'start',
            borderWidth: 0,
            borderRadius: 0,
            pointStyle: void 0,
          }),
          (xr.defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor',
          });
        const br = {
          average(t) {
            if (!t.length) return !1;
            let e,
              n,
              i = 0,
              r = 0,
              a = 0;
            for (e = 0, n = t.length; e < n; ++e) {
              const n = t[e].element;
              if (n && n.hasValue()) {
                const t = n.tooltipPosition();
                (i += t.x), (r += t.y), ++a;
              }
            }
            return { x: i / a, y: r / a };
          },
          nearest(t, e) {
            let n,
              i,
              r,
              a = e.x,
              o = e.y,
              s = Number.POSITIVE_INFINITY;
            for (n = 0, i = t.length; n < i; ++n) {
              const i = t[n].element;
              if (i && i.hasValue()) {
                const t = $(e, i.getCenterPoint());
                t < s && ((s = t), (r = i));
              }
            }
            if (r) {
              const t = r.tooltipPosition();
              (a = t.x), (o = t.y);
            }
            return { x: a, y: o };
          },
        };
        function _r(t, e) {
          return e && (p(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
        }
        function wr(t) {
          return ('string' == typeof t || t instanceof String) &&
            t.indexOf('\n') > -1
            ? t.split('\n')
            : t;
        }
        function Mr(t, e) {
          const { element: n, datasetIndex: i, index: r } = e,
            a = t.getDatasetMeta(i).controller,
            { label: o, value: s } = a.getLabelAndValue(r);
          return {
            chart: t,
            label: o,
            parsed: a.getParsed(r),
            raw: t.data.datasets[i].data[r],
            formattedValue: s,
            dataset: a.getDataset(),
            dataIndex: r,
            datasetIndex: i,
            element: n,
          };
        }
        function qr(t, e) {
          const n = t._chart.ctx,
            { body: i, footer: r, title: a } = t,
            { boxWidth: o, boxHeight: s } = e,
            l = oe(e.bodyFont),
            c = oe(e.titleFont),
            u = oe(e.footerFont),
            h = a.length,
            d = r.length,
            p = i.length,
            f = ae(e.padding);
          let m = f.height,
            g = 0,
            y = i.reduce(
              (t, e) => t + e.before.length + e.lines.length + e.after.length,
              0,
            );
          if (
            ((y += t.beforeBody.length + t.afterBody.length),
            h &&
              (m +=
                h * c.lineHeight +
                (h - 1) * e.titleSpacing +
                e.titleMarginBottom),
            y)
          ) {
            m +=
              p * (e.displayColors ? Math.max(s, l.lineHeight) : l.lineHeight) +
              (y - p) * l.lineHeight +
              (y - 1) * e.bodySpacing;
          }
          d &&
            (m +=
              e.footerMarginTop + d * u.lineHeight + (d - 1) * e.footerSpacing);
          let v = 0;
          const x = function (t) {
            g = Math.max(g, n.measureText(t).width + v);
          };
          return (
            n.save(),
            (n.font = c.string),
            b(t.title, x),
            (n.font = l.string),
            b(t.beforeBody.concat(t.afterBody), x),
            (v = e.displayColors ? o + 2 : 0),
            b(i, (t) => {
              b(t.before, x), b(t.lines, x), b(t.after, x);
            }),
            (v = 0),
            (n.font = u.string),
            b(t.footer, x),
            n.restore(),
            (g += f.width),
            { width: g, height: m }
          );
        }
        function Sr(t, e, n, i) {
          const { x: r, width: a } = n,
            {
              width: o,
              chartArea: { left: s, right: l },
            } = t;
          let c = 'center';
          return (
            'center' === i
              ? (c = r <= (s + l) / 2 ? 'left' : 'right')
              : r <= a / 2
              ? (c = 'left')
              : r >= o - a / 2 && (c = 'right'),
            (function (t, e, n, i) {
              const { x: r, width: a } = i,
                o = n.caretSize + n.caretPadding;
              return (
                ('left' === t && r + a + o > e.width) ||
                ('right' === t && r - a - o < 0) ||
                void 0
              );
            })(c, t, e, n) && (c = 'center'),
            c
          );
        }
        function Tr(t, e, n) {
          const i =
            e.yAlign ||
            (function (t, e) {
              const { y: n, height: i } = e;
              return n < i / 2
                ? 'top'
                : n > t.height - i / 2
                ? 'bottom'
                : 'center';
            })(t, n);
          return { xAlign: e.xAlign || Sr(t, e, n, i), yAlign: i };
        }
        function Er(t, e, n, i) {
          const { caretSize: r, caretPadding: a, cornerRadius: o } = t,
            { xAlign: s, yAlign: l } = n,
            c = r + a,
            u = o + a;
          let h = (function (t, e) {
            let { x: n, width: i } = t;
            return 'right' === e ? (n -= i) : 'center' === e && (n -= i / 2), n;
          })(e, s);
          const d = (function (t, e, n) {
            let { y: i, height: r } = t;
            return (
              'top' === e ? (i += n) : (i -= 'bottom' === e ? r + n : r / 2), i
            );
          })(e, l, c);
          return (
            'center' === l
              ? 'left' === s
                ? (h += c)
                : 'right' === s && (h -= c)
              : 'left' === s
              ? (h -= u)
              : 'right' === s && (h += u),
            { x: Q(h, 0, i.width - e.width), y: Q(d, 0, i.height - e.height) }
          );
        }
        function Ar(t, e, n) {
          const i = ae(n.padding);
          return 'center' === e
            ? t.x + t.width / 2
            : 'right' === e
            ? t.x + t.width - i.right
            : t.x + i.left;
        }
        function Lr(t) {
          return _r([], wr(t));
        }
        function Rr(t, e) {
          const n =
            e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
          return n ? t.override(n) : t;
        }
        class Cr extends pi {
          constructor(t) {
            super(),
              (this.opacity = 0),
              (this._active = []),
              (this._chart = t._chart),
              (this._eventPosition = void 0),
              (this._size = void 0),
              (this._cachedAnimations = void 0),
              (this._tooltipItems = []),
              (this.$animations = void 0),
              (this.$context = void 0),
              (this.options = t.options),
              (this.dataPoints = void 0),
              (this.title = void 0),
              (this.beforeBody = void 0),
              (this.body = void 0),
              (this.afterBody = void 0),
              (this.footer = void 0),
              (this.xAlign = void 0),
              (this.yAlign = void 0),
              (this.x = void 0),
              (this.y = void 0),
              (this.height = void 0),
              (this.width = void 0),
              (this.caretX = void 0),
              (this.caretY = void 0),
              (this.labelColors = void 0),
              (this.labelPointStyles = void 0),
              (this.labelTextColors = void 0);
          }
          initialize(t) {
            (this.options = t),
              (this._cachedAnimations = void 0),
              (this.$context = void 0);
          }
          _resolveAnimations() {
            const t = this,
              e = t._cachedAnimations;
            if (e) return e;
            const n = t._chart,
              i = t.options.setContext(t.getContext()),
              r = i.enabled && n.options.animation && i.animations,
              a = new sn(t._chart, r);
            return r._cacheable && (t._cachedAnimations = Object.freeze(a)), a;
          }
          getContext() {
            const t = this;
            return (
              t.$context ||
              (t.$context =
                ((e = t._chart.getContext()),
                (n = t),
                (i = t._tooltipItems),
                Object.assign(Object.create(e), {
                  tooltip: n,
                  tooltipItems: i,
                  type: 'tooltip',
                })))
            );
            var e, n, i;
          }
          getTitle(t, e) {
            const { callbacks: n } = e,
              i = n.beforeTitle.apply(this, [t]),
              r = n.title.apply(this, [t]),
              a = n.afterTitle.apply(this, [t]);
            let o = [];
            return (
              (o = _r(o, wr(i))), (o = _r(o, wr(r))), (o = _r(o, wr(a))), o
            );
          }
          getBeforeBody(t, e) {
            return Lr(e.callbacks.beforeBody.apply(this, [t]));
          }
          getBody(t, e) {
            const n = this,
              { callbacks: i } = e,
              r = [];
            return (
              b(t, (t) => {
                const e = { before: [], lines: [], after: [] },
                  a = Rr(i, t);
                _r(e.before, wr(a.beforeLabel.call(n, t))),
                  _r(e.lines, a.label.call(n, t)),
                  _r(e.after, wr(a.afterLabel.call(n, t))),
                  r.push(e);
              }),
              r
            );
          }
          getAfterBody(t, e) {
            return Lr(e.callbacks.afterBody.apply(this, [t]));
          }
          getFooter(t, e) {
            const { callbacks: n } = e,
              i = n.beforeFooter.apply(this, [t]),
              r = n.footer.apply(this, [t]),
              a = n.afterFooter.apply(this, [t]);
            let o = [];
            return (
              (o = _r(o, wr(i))), (o = _r(o, wr(r))), (o = _r(o, wr(a))), o
            );
          }
          _createItems(t) {
            const e = this,
              n = e._active,
              i = e._chart.data,
              r = [],
              a = [],
              o = [];
            let s,
              l,
              c = [];
            for (s = 0, l = n.length; s < l; ++s) c.push(Mr(e._chart, n[s]));
            return (
              t.filter && (c = c.filter((e, n, r) => t.filter(e, n, r, i))),
              t.itemSort && (c = c.sort((e, n) => t.itemSort(e, n, i))),
              b(c, (n) => {
                const i = Rr(t.callbacks, n);
                r.push(i.labelColor.call(e, n)),
                  a.push(i.labelPointStyle.call(e, n)),
                  o.push(i.labelTextColor.call(e, n));
              }),
              (e.labelColors = r),
              (e.labelPointStyles = a),
              (e.labelTextColors = o),
              (e.dataPoints = c),
              c
            );
          }
          update(t, e) {
            const n = this,
              i = n.options.setContext(n.getContext()),
              r = n._active;
            let a,
              o = [];
            if (r.length) {
              const t = br[i.position].call(n, r, n._eventPosition);
              (o = n._createItems(i)),
                (n.title = n.getTitle(o, i)),
                (n.beforeBody = n.getBeforeBody(o, i)),
                (n.body = n.getBody(o, i)),
                (n.afterBody = n.getAfterBody(o, i)),
                (n.footer = n.getFooter(o, i));
              const e = (n._size = qr(n, i)),
                s = Object.assign({}, t, e),
                l = Tr(n._chart, i, s),
                c = Er(i, s, l, n._chart);
              (n.xAlign = l.xAlign),
                (n.yAlign = l.yAlign),
                (a = {
                  opacity: 1,
                  x: c.x,
                  y: c.y,
                  width: e.width,
                  height: e.height,
                  caretX: t.x,
                  caretY: t.y,
                });
            } else 0 !== n.opacity && (a = { opacity: 0 });
            (n._tooltipItems = o),
              (n.$context = void 0),
              a && n._resolveAnimations().update(n, a),
              t &&
                i.external &&
                i.external.call(n, { chart: n._chart, tooltip: n, replay: e });
          }
          drawCaret(t, e, n, i) {
            const r = this.getCaretPosition(t, n, i);
            e.lineTo(r.x1, r.y1), e.lineTo(r.x2, r.y2), e.lineTo(r.x3, r.y3);
          }
          getCaretPosition(t, e, n) {
            const { xAlign: i, yAlign: r } = this,
              { cornerRadius: a, caretSize: o } = n,
              { x: s, y: l } = t,
              { width: c, height: u } = e;
            let h, d, p, f, m, g;
            return (
              'center' === r
                ? ((m = l + u / 2),
                  'left' === i
                    ? ((h = s), (d = h - o), (f = m + o), (g = m - o))
                    : ((h = s + c), (d = h + o), (f = m - o), (g = m + o)),
                  (p = h))
                : ((d =
                    'left' === i
                      ? s + a + o
                      : 'right' === i
                      ? s + c - a - o
                      : this.caretX),
                  'top' === r
                    ? ((f = l), (m = f - o), (h = d - o), (p = d + o))
                    : ((f = l + u), (m = f + o), (h = d + o), (p = d - o)),
                  (g = f)),
              { x1: h, x2: d, x3: p, y1: f, y2: m, y3: g }
            );
          }
          drawTitle(t, e, n) {
            const i = this,
              r = i.title,
              a = r.length;
            let o, s, l;
            if (a) {
              const c = $e(n.rtl, i.x, i.width);
              for (
                t.x = Ar(i, n.titleAlign, n),
                  e.textAlign = c.textAlign(n.titleAlign),
                  e.textBaseline = 'middle',
                  o = oe(n.titleFont),
                  s = n.titleSpacing,
                  e.fillStyle = n.titleColor,
                  e.font = o.string,
                  l = 0;
                l < a;
                ++l
              )
                e.fillText(r[l], c.x(t.x), t.y + o.lineHeight / 2),
                  (t.y += o.lineHeight + s),
                  l + 1 === a && (t.y += n.titleMarginBottom - s);
            }
          }
          _drawColorBox(t, e, n, i, r) {
            const a = this.labelColors[n],
              o = this.labelPointStyles[n],
              { boxHeight: s, boxWidth: l } = r,
              c = oe(r.bodyFont),
              u = Ar(this, 'left', r),
              h = i.x(u),
              d = s < c.lineHeight ? (c.lineHeight - s) / 2 : 0,
              p = e.y + d;
            if (r.usePointStyle) {
              const e = {
                  radius: Math.min(l, s) / 2,
                  pointStyle: o.pointStyle,
                  rotation: o.rotation,
                  borderWidth: 1,
                },
                n = i.leftForLtr(h, l) + l / 2,
                c = p + s / 2;
              (t.strokeStyle = r.multiKeyBackground),
                (t.fillStyle = r.multiKeyBackground),
                Yt(t, e, n, c),
                (t.strokeStyle = a.borderColor),
                (t.fillStyle = a.backgroundColor),
                Yt(t, e, n, c);
            } else
              (t.fillStyle = r.multiKeyBackground),
                t.fillRect(i.leftForLtr(h, l), p, l, s),
                (t.lineWidth = 1),
                (t.strokeStyle = a.borderColor),
                t.strokeRect(i.leftForLtr(h, l), p, l, s),
                (t.fillStyle = a.backgroundColor),
                t.fillRect(
                  i.leftForLtr(i.xPlus(h, 1), l - 2),
                  p + 1,
                  l - 2,
                  s - 2,
                );
            t.fillStyle = this.labelTextColors[n];
          }
          drawBody(t, e, n) {
            const i = this,
              { body: r } = i,
              {
                bodySpacing: a,
                bodyAlign: o,
                displayColors: s,
                boxHeight: l,
                boxWidth: c,
              } = n,
              u = oe(n.bodyFont);
            let h = u.lineHeight,
              d = 0;
            const p = $e(n.rtl, i.x, i.width),
              f = function (n) {
                e.fillText(n, p.x(t.x + d), t.y + h / 2), (t.y += h + a);
              },
              m = p.textAlign(o);
            let g, y, v, x, _, w, M;
            for (
              e.textAlign = o,
                e.textBaseline = 'middle',
                e.font = u.string,
                t.x = Ar(i, m, n),
                e.fillStyle = n.bodyColor,
                b(i.beforeBody, f),
                d =
                  s && 'right' !== m ? ('center' === o ? c / 2 + 1 : c + 2) : 0,
                x = 0,
                w = r.length;
              x < w;
              ++x
            ) {
              for (
                g = r[x],
                  y = i.labelTextColors[x],
                  e.fillStyle = y,
                  b(g.before, f),
                  v = g.lines,
                  s &&
                    v.length &&
                    (i._drawColorBox(e, t, x, p, n),
                    (h = Math.max(u.lineHeight, l))),
                  _ = 0,
                  M = v.length;
                _ < M;
                ++_
              )
                f(v[_]), (h = u.lineHeight);
              b(g.after, f);
            }
            (d = 0), (h = u.lineHeight), b(i.afterBody, f), (t.y -= a);
          }
          drawFooter(t, e, n) {
            const i = this,
              r = i.footer,
              a = r.length;
            let o, s;
            if (a) {
              const l = $e(n.rtl, i.x, i.width);
              for (
                t.x = Ar(i, n.footerAlign, n),
                  t.y += n.footerMarginTop,
                  e.textAlign = l.textAlign(n.footerAlign),
                  e.textBaseline = 'middle',
                  o = oe(n.footerFont),
                  e.fillStyle = n.footerColor,
                  e.font = o.string,
                  s = 0;
                s < a;
                ++s
              )
                e.fillText(r[s], l.x(t.x), t.y + o.lineHeight / 2),
                  (t.y += o.lineHeight + n.footerSpacing);
            }
          }
          drawBackground(t, e, n, i) {
            const { xAlign: r, yAlign: a } = this,
              { x: o, y: s } = t,
              { width: l, height: c } = n,
              u = i.cornerRadius;
            (e.fillStyle = i.backgroundColor),
              (e.strokeStyle = i.borderColor),
              (e.lineWidth = i.borderWidth),
              e.beginPath(),
              e.moveTo(o + u, s),
              'top' === a && this.drawCaret(t, e, n, i),
              e.lineTo(o + l - u, s),
              e.quadraticCurveTo(o + l, s, o + l, s + u),
              'center' === a && 'right' === r && this.drawCaret(t, e, n, i),
              e.lineTo(o + l, s + c - u),
              e.quadraticCurveTo(o + l, s + c, o + l - u, s + c),
              'bottom' === a && this.drawCaret(t, e, n, i),
              e.lineTo(o + u, s + c),
              e.quadraticCurveTo(o, s + c, o, s + c - u),
              'center' === a && 'left' === r && this.drawCaret(t, e, n, i),
              e.lineTo(o, s + u),
              e.quadraticCurveTo(o, s, o + u, s),
              e.closePath(),
              e.fill(),
              i.borderWidth > 0 && e.stroke();
          }
          _updateAnimationTarget(t) {
            const e = this,
              n = e._chart,
              i = e.$animations,
              r = i && i.x,
              a = i && i.y;
            if (r || a) {
              const i = br[t.position].call(e, e._active, e._eventPosition);
              if (!i) return;
              const o = (e._size = qr(e, t)),
                s = Object.assign({}, i, e._size),
                l = Tr(n, t, s),
                c = Er(t, s, l, n);
              (r._to === c.x && a._to === c.y) ||
                ((e.xAlign = l.xAlign),
                (e.yAlign = l.yAlign),
                (e.width = o.width),
                (e.height = o.height),
                (e.caretX = i.x),
                (e.caretY = i.y),
                e._resolveAnimations().update(e, c));
            }
          }
          draw(t) {
            const e = this,
              n = e.options.setContext(e.getContext());
            let i = e.opacity;
            if (!i) return;
            e._updateAnimationTarget(n);
            const r = { width: e.width, height: e.height },
              a = { x: e.x, y: e.y };
            i = Math.abs(i) < 0.001 ? 0 : i;
            const o = ae(n.padding),
              s =
                e.title.length ||
                e.beforeBody.length ||
                e.body.length ||
                e.afterBody.length ||
                e.footer.length;
            n.enabled &&
              s &&
              (t.save(),
              (t.globalAlpha = i),
              e.drawBackground(a, t, r, n),
              Je(t, n.textDirection),
              (a.y += o.top),
              e.drawTitle(a, t, n),
              e.drawBody(a, t, n),
              e.drawFooter(a, t, n),
              Ze(t, n.textDirection),
              t.restore());
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(t, e) {
            const n = this,
              i = n._active,
              r = t.map(({ datasetIndex: t, index: e }) => {
                const i = n._chart.getDatasetMeta(t);
                if (!i) throw new Error('Cannot find a dataset at index ' + t);
                return { datasetIndex: t, element: i.data[e], index: e };
              }),
              a = !_(i, r),
              o = n._positionChanged(r, e);
            (a || o) && ((n._active = r), (n._eventPosition = e), n.update(!0));
          }
          handleEvent(t, e) {
            const n = this,
              i = n.options,
              r = n._active || [];
            let a = !1,
              o = [];
            'mouseout' !== t.type &&
              ((o = n._chart.getElementsAtEventForMode(t, i.mode, i, e)),
              i.reverse && o.reverse());
            const s = n._positionChanged(o, t);
            return (
              (a = e || !_(o, r) || s),
              a &&
                ((n._active = o),
                (i.enabled || i.external) &&
                  ((n._eventPosition = { x: t.x, y: t.y }), n.update(!0, e))),
              a
            );
          }
          _positionChanged(t, e) {
            const n = br[this.options.position].call(this, t, e);
            return this.caretX !== n.x || this.caretY !== n.y;
          }
        }
        Cr.positioners = br;
        function Pr(t, e, n) {
          const i = t.indexOf(e);
          if (-1 === i)
            return ((t, e, n) =>
              'string' == typeof e ? t.push(e) - 1 : isNaN(e) ? null : n)(
              t,
              e,
              n,
            );
          return i !== t.lastIndexOf(e) ? n : i;
        }
        class kr extends qi {
          constructor(t) {
            super(t), (this._startValue = void 0), (this._valueRange = 0);
          }
          parse(t, e) {
            if (d(t)) return null;
            const n = this.getLabels();
            return ((t, e) => (null === t ? null : Q(Math.round(t), 0, e)))(
              (e = isFinite(e) && n[e] === t ? e : Pr(n, t, y(e, t))),
              n.length - 1,
            );
          }
          determineDataLimits() {
            const t = this,
              { minDefined: e, maxDefined: n } = t.getUserBounds();
            let { min: i, max: r } = t.getMinMax(!0);
            'ticks' === t.options.bounds &&
              (e || (i = 0), n || (r = t.getLabels().length - 1)),
              (t.min = i),
              (t.max = r);
          }
          buildTicks() {
            const t = this,
              e = t.min,
              n = t.max,
              i = t.options.offset,
              r = [];
            let a = t.getLabels();
            (a = 0 === e && n === a.length - 1 ? a : a.slice(e, n + 1)),
              (t._valueRange = Math.max(a.length - (i ? 0 : 1), 1)),
              (t._startValue = t.min - (i ? 0.5 : 0));
            for (let t = e; t <= n; t++) r.push({ value: t });
            return r;
          }
          getLabelForValue(t) {
            const e = this.getLabels();
            return t >= 0 && t < e.length ? e[t] : t;
          }
          configure() {
            const t = this;
            super.configure(),
              t.isHorizontal() || (t._reversePixels = !t._reversePixels);
          }
          getPixelForValue(t) {
            const e = this;
            return (
              'number' != typeof t && (t = e.parse(t)),
              null === t
                ? NaN
                : e.getPixelForDecimal((t - e._startValue) / e._valueRange)
            );
          }
          getPixelForTick(t) {
            const e = this.ticks;
            return t < 0 || t > e.length - 1
              ? null
              : this.getPixelForValue(e[t].value);
          }
          getValueForPixel(t) {
            return Math.round(
              this._startValue + this.getDecimalForPixel(t) * this._valueRange,
            );
          }
          getBasePixel() {
            return this.bottom;
          }
        }
        function Ir(t, e) {
          const n = [],
            {
              step: i,
              min: r,
              max: a,
              precision: o,
              count: s,
              maxTicks: l,
            } = t,
            c = i || 1,
            u = l - 1,
            { min: h, max: p } = e,
            f = !d(r),
            g = !d(a),
            y = !d(s);
          let v,
            x,
            b,
            _,
            w = G((p - h) / u / c) * c;
          if (w < 1e-14 && !f && !g) return [{ value: h }, { value: p }];
          (_ = Math.ceil(p / w) - Math.floor(h / w)),
            _ > u && (w = G((_ * w) / u / c) * c),
            d(o) || ((v = Math.pow(10, o)), (w = Math.ceil(w * v) / v)),
            (x = Math.floor(h / w) * w),
            (b = Math.ceil(p / w) * w),
            f &&
            g &&
            i &&
            (function (t, e) {
              const n = Math.round(t);
              return n - e <= t && n + e >= t;
            })((a - r) / i, w / 1e3)
              ? ((_ = Math.min((a - r) / w, l)),
                (w = (a - r) / _),
                (x = r),
                (b = a))
              : y
              ? ((x = f ? r : x),
                (b = g ? a : b),
                (_ = s - 1),
                (w = (b - x) / _))
              : ((_ = (b - x) / w),
                (_ = V(_, Math.round(_), w / 1e3)
                  ? Math.round(_)
                  : Math.ceil(_))),
            (v = Math.pow(
              10,
              d(o)
                ? (function (t) {
                    if (!m(t)) return;
                    let e = 1,
                      n = 0;
                    for (; Math.round(t * e) / e !== t; ) (e *= 10), n++;
                    return n;
                  })(w)
                : o,
            )),
            (x = Math.round(x * v) / v),
            (b = Math.round(b * v) / v);
          let M = 0;
          for (
            f &&
            (n.push({ value: r }),
            x <= r && M++,
            V(Math.round((x + M * w) * v) / v, r, w / 10) && M++);
            M < _;
            ++M
          )
            n.push({ value: Math.round((x + M * w) * v) / v });
          return (
            g
              ? V(n[n.length - 1].value, a, w / 10)
                ? (n[n.length - 1].value = a)
                : n.push({ value: a })
              : n.push({ value: b }),
            n
          );
        }
        (kr.id = 'category'),
          (kr.defaults = {
            ticks: { callback: kr.prototype.getLabelForValue },
          });
        class Dr extends qi {
          constructor(t) {
            super(t),
              (this.start = void 0),
              (this.end = void 0),
              (this._startValue = void 0),
              (this._endValue = void 0),
              (this._valueRange = 0);
          }
          parse(t, e) {
            return d(t) ||
              (('number' == typeof t || t instanceof Number) && !isFinite(+t))
              ? null
              : +t;
          }
          handleTickRangeOptions() {
            const t = this,
              { beginAtZero: e, stacked: n } = t.options,
              { minDefined: i, maxDefined: r } = t.getUserBounds();
            let { min: a, max: o } = t;
            const s = (t) => (a = i ? a : t),
              l = (t) => (o = r ? o : t);
            if (e || n) {
              const t = j(a),
                e = j(o);
              t < 0 && e < 0 ? l(0) : t > 0 && e > 0 && s(0);
            }
            a === o && (l(o + 1), e || s(a - 1)), (t.min = a), (t.max = o);
          }
          getTickLimit() {
            const t = this,
              e = t.options.ticks;
            let n,
              { maxTicksLimit: i, stepSize: r } = e;
            return (
              r
                ? (n = Math.ceil(t.max / r) - Math.floor(t.min / r) + 1)
                : ((n = t.computeTickLimit()), (i = i || 11)),
              i && (n = Math.min(i, n)),
              n
            );
          }
          computeTickLimit() {
            return Number.POSITIVE_INFINITY;
          }
          buildTicks() {
            const t = this,
              e = t.options,
              n = e.ticks;
            let i = t.getTickLimit();
            i = Math.max(2, i);
            const r = Ir(
              {
                maxTicks: i,
                min: e.min,
                max: e.max,
                precision: n.precision,
                step: n.stepSize,
                count: n.count,
              },
              (function (t, e) {
                const { min: n, max: i } = t;
                return { min: n - Math.abs(v(e, n)), max: i + v(e, i) };
              })(t, e.grace),
            );
            return (
              'ticks' === e.bounds && W(r, t, 'value'),
              e.reverse
                ? (r.reverse(), (t.start = t.max), (t.end = t.min))
                : ((t.start = t.min), (t.end = t.max)),
              r
            );
          }
          configure() {
            const t = this,
              e = t.ticks;
            let n = t.min,
              i = t.max;
            if ((super.configure(), t.options.offset && e.length)) {
              const t = (i - n) / Math.max(e.length - 1, 1) / 2;
              (n -= t), (i += t);
            }
            (t._startValue = n), (t._endValue = i), (t._valueRange = i - n);
          }
          getLabelForValue(t) {
            return Ye(t, this.chart.options.locale);
          }
        }
        class Or extends Dr {
          determineDataLimits() {
            const { min: t, max: e } = this.getMinMax(!0);
            (this.min = m(t) ? t : 0),
              (this.max = m(e) ? e : 1),
              this.handleTickRangeOptions();
          }
          computeTickLimit() {
            const t = this;
            if (t.isHorizontal()) return Math.ceil(t.width / 40);
            const e = t._resolveTickFontOptions(0);
            return Math.ceil(t.height / e.lineHeight);
          }
          getPixelForValue(t) {
            return null === t
              ? NaN
              : this.getPixelForDecimal(
                  (t - this._startValue) / this._valueRange,
                );
          }
          getValueForPixel(t) {
            return (
              this._startValue + this.getDecimalForPixel(t) * this._valueRange
            );
          }
        }
        function Nr(t) {
          return 1 === t / Math.pow(10, Math.floor(U(t)));
        }
        (Or.id = 'linear'),
          (Or.defaults = { ticks: { callback: mi.formatters.numeric } });
        class zr extends qi {
          constructor(t) {
            super(t),
              (this.start = void 0),
              (this.end = void 0),
              (this._startValue = void 0),
              (this._valueRange = 0);
          }
          parse(t, e) {
            const n = Dr.prototype.parse.apply(this, [t, e]);
            if (0 !== n) return m(n) && n > 0 ? n : null;
            this._zero = !0;
          }
          determineDataLimits() {
            const t = this,
              { min: e, max: n } = t.getMinMax(!0);
            (t.min = m(e) ? Math.max(0, e) : null),
              (t.max = m(n) ? Math.max(0, n) : null),
              t.options.beginAtZero && (t._zero = !0),
              t.handleTickRangeOptions();
          }
          handleTickRangeOptions() {
            const t = this,
              { minDefined: e, maxDefined: n } = t.getUserBounds();
            let i = t.min,
              r = t.max;
            const a = (t) => (i = e ? i : t),
              o = (t) => (r = n ? r : t),
              s = (t, e) => Math.pow(10, Math.floor(U(t)) + e);
            i === r && (i <= 0 ? (a(1), o(10)) : (a(s(i, -1)), o(s(r, 1)))),
              i <= 0 && a(s(r, -1)),
              r <= 0 && o(s(i, 1)),
              t._zero &&
                t.min !== t._suggestedMin &&
                i === s(t.min, 0) &&
                a(s(i, -1)),
              (t.min = i),
              (t.max = r);
          }
          buildTicks() {
            const t = this,
              e = t.options,
              n = (function (t, e) {
                const n = Math.floor(U(e.max)),
                  i = Math.ceil(e.max / Math.pow(10, n)),
                  r = [];
                let a = g(t.min, Math.pow(10, Math.floor(U(e.min)))),
                  o = Math.floor(U(a)),
                  s = Math.floor(a / Math.pow(10, o)),
                  l = o < 0 ? Math.pow(10, Math.abs(o)) : 1;
                do {
                  r.push({ value: a, major: Nr(a) }),
                    ++s,
                    10 === s && ((s = 1), ++o, (l = o >= 0 ? 1 : l)),
                    (a = Math.round(s * Math.pow(10, o) * l) / l);
                } while (o < n || (o === n && s < i));
                const c = g(t.max, a);
                return r.push({ value: c, major: Nr(a) }), r;
              })({ min: t._userMin, max: t._userMax }, t);
            return (
              'ticks' === e.bounds && W(n, t, 'value'),
              e.reverse
                ? (n.reverse(), (t.start = t.max), (t.end = t.min))
                : ((t.start = t.min), (t.end = t.max)),
              n
            );
          }
          getLabelForValue(t) {
            return void 0 === t ? '0' : Ye(t, this.chart.options.locale);
          }
          configure() {
            const t = this.min;
            super.configure(),
              (this._startValue = U(t)),
              (this._valueRange = U(this.max) - U(t));
          }
          getPixelForValue(t) {
            const e = this;
            return (
              (void 0 !== t && 0 !== t) || (t = e.min),
              null === t || isNaN(t)
                ? NaN
                : e.getPixelForDecimal(
                    t === e.min ? 0 : (U(t) - e._startValue) / e._valueRange,
                  )
            );
          }
          getValueForPixel(t) {
            const e = this.getDecimalForPixel(t);
            return Math.pow(10, this._startValue + e * this._valueRange);
          }
        }
        function Fr(t) {
          const e = t.ticks;
          if (e.display && t.display) {
            const t = ae(e.backdropPadding);
            return y(e.font && e.font.size, Gt.font.size) + t.height;
          }
          return 0;
        }
        function Br(t, e, n, i, r) {
          return t === i || t === r
            ? { start: e - n / 2, end: e + n / 2 }
            : t < i || t > r
            ? { start: e - n, end: e }
            : { start: e, end: e + n };
        }
        function Ur(t) {
          return 0 === t || 180 === t ? 'center' : t < 180 ? 'left' : 'right';
        }
        function jr(t, e, n) {
          90 === t || 270 === t
            ? (n.y -= e.h / 2)
            : (t > 270 || t < 90) && (n.y -= e.h);
        }
        function Gr(t, e, n, i) {
          const { ctx: r } = t;
          if (n) r.arc(t.xCenter, t.yCenter, e, 0, I);
          else {
            let n = t.getPointPosition(0, e);
            r.moveTo(n.x, n.y);
            for (let a = 1; a < i; a++)
              (n = t.getPointPosition(a, e)), r.lineTo(n.x, n.y);
          }
        }
        function Hr(t) {
          return H(t) ? t : 0;
        }
        (zr.id = 'logarithmic'),
          (zr.defaults = {
            ticks: {
              callback: mi.formatters.logarithmic,
              major: { enabled: !0 },
            },
          });
        class Vr extends Dr {
          constructor(t) {
            super(t),
              (this.xCenter = void 0),
              (this.yCenter = void 0),
              (this.drawingArea = void 0),
              (this._pointLabels = []),
              (this._pointLabelItems = []);
          }
          setDimensions() {
            const t = this;
            (t.width = t.maxWidth),
              (t.height = t.maxHeight),
              (t.paddingTop = Fr(t.options) / 2),
              (t.xCenter = Math.floor(t.width / 2)),
              (t.yCenter = Math.floor((t.height - t.paddingTop) / 2)),
              (t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2);
          }
          determineDataLimits() {
            const { min: t, max: e } = this.getMinMax(!1);
            (this.min = m(t) && !isNaN(t) ? t : 0),
              (this.max = m(e) && !isNaN(e) ? e : 0),
              this.handleTickRangeOptions();
          }
          computeTickLimit() {
            return Math.ceil(this.drawingArea / Fr(this.options));
          }
          generateTickLabels(t) {
            const e = this;
            Dr.prototype.generateTickLabels.call(e, t),
              (e._pointLabels = e.getLabels().map((t, n) => {
                const i = x(e.options.pointLabels.callback, [t, n], e);
                return i || 0 === i ? i : '';
              }));
          }
          fit() {
            const t = this,
              e = t.options;
            e.display && e.pointLabels.display
              ? (function (t) {
                  const e = {
                      l: 0,
                      r: t.width,
                      t: 0,
                      b: t.height - t.paddingTop,
                    },
                    n = {};
                  let i, r, a;
                  const o = [],
                    s = [],
                    l = t.getLabels().length;
                  for (i = 0; i < l; i++) {
                    const l = t.options.pointLabels.setContext(t.getContext(i));
                    (s[i] = l.padding),
                      (a = t.getPointPosition(i, t.drawingArea + s[i]));
                    const d = oe(l.font);
                    (t.ctx.font = d.string),
                      (c = t.ctx),
                      (u = d.lineHeight),
                      (r = p((h = t._pointLabels[i]))
                        ? { w: Vt(c, c.font, h), h: h.length * u }
                        : { w: c.measureText(h).width, h: u }),
                      (o[i] = r);
                    const f = t.getIndexAngle(i),
                      m = Y(f),
                      g = Br(m, a.x, r.w, 0, 180),
                      y = Br(m, a.y, r.h, 90, 270);
                    g.start < e.l && ((e.l = g.start), (n.l = f)),
                      g.end > e.r && ((e.r = g.end), (n.r = f)),
                      y.start < e.t && ((e.t = y.start), (n.t = f)),
                      y.end > e.b && ((e.b = y.end), (n.b = f));
                  }
                  var c, u, h;
                  t._setReductions(t.drawingArea, e, n),
                    (t._pointLabelItems = []);
                  const d = t.options,
                    f = Fr(d),
                    m = t.getDistanceFromCenterForValue(
                      d.ticks.reverse ? t.min : t.max,
                    );
                  for (i = 0; i < l; i++) {
                    const e = 0 === i ? f / 2 : 0,
                      n = t.getPointPosition(i, m + e + s[i]),
                      r = Y(t.getIndexAngle(i)),
                      a = o[i];
                    jr(r, a, n);
                    const l = Ur(r);
                    let c;
                    c =
                      'left' === l
                        ? n.x
                        : 'center' === l
                        ? n.x - a.w / 2
                        : n.x - a.w;
                    const u = c + a.w;
                    t._pointLabelItems[i] = {
                      x: n.x,
                      y: n.y,
                      textAlign: l,
                      left: c,
                      top: n.y,
                      right: u,
                      bottom: n.y + a.h,
                    };
                  }
                })(t)
              : t.setCenterPoint(0, 0, 0, 0);
          }
          _setReductions(t, e, n) {
            const i = this;
            let r = e.l / Math.sin(n.l),
              a = Math.max(e.r - i.width, 0) / Math.sin(n.r),
              o = -e.t / Math.cos(n.t),
              s = -Math.max(e.b - (i.height - i.paddingTop), 0) / Math.cos(n.b);
            (r = Hr(r)),
              (a = Hr(a)),
              (o = Hr(o)),
              (s = Hr(s)),
              (i.drawingArea = Math.max(
                t / 2,
                Math.min(
                  Math.floor(t - (r + a) / 2),
                  Math.floor(t - (o + s) / 2),
                ),
              )),
              i.setCenterPoint(r, a, o, s);
          }
          setCenterPoint(t, e, n, i) {
            const r = this,
              a = r.width - e - r.drawingArea,
              o = t + r.drawingArea,
              s = n + r.drawingArea,
              l = r.height - r.paddingTop - i - r.drawingArea;
            (r.xCenter = Math.floor((o + a) / 2 + r.left)),
              (r.yCenter = Math.floor((s + l) / 2 + r.top + r.paddingTop));
          }
          getIndexAngle(t) {
            return Z(
              t * (I / this.getLabels().length) +
                X(this.options.startAngle || 0),
            );
          }
          getDistanceFromCenterForValue(t) {
            const e = this;
            if (d(t)) return NaN;
            const n = e.drawingArea / (e.max - e.min);
            return e.options.reverse ? (e.max - t) * n : (t - e.min) * n;
          }
          getValueForDistanceFromCenter(t) {
            if (d(t)) return NaN;
            const e = this,
              n = t / (e.drawingArea / (e.max - e.min));
            return e.options.reverse ? e.max - n : e.min + n;
          }
          getPointPosition(t, e) {
            const n = this.getIndexAngle(t) - z;
            return {
              x: Math.cos(n) * e + this.xCenter,
              y: Math.sin(n) * e + this.yCenter,
              angle: n,
            };
          }
          getPointPositionForValue(t, e) {
            return this.getPointPosition(
              t,
              this.getDistanceFromCenterForValue(e),
            );
          }
          getBasePosition(t) {
            return this.getPointPositionForValue(t || 0, this.getBaseValue());
          }
          getPointLabelPosition(t) {
            const {
              left: e,
              top: n,
              right: i,
              bottom: r,
            } = this._pointLabelItems[t];
            return { left: e, top: n, right: i, bottom: r };
          }
          drawBackground() {
            const t = this,
              {
                backgroundColor: e,
                grid: { circular: n },
              } = t.options;
            if (e) {
              const i = t.ctx;
              i.save(),
                i.beginPath(),
                Gr(
                  t,
                  t.getDistanceFromCenterForValue(t._endValue),
                  n,
                  t.getLabels().length,
                ),
                i.closePath(),
                (i.fillStyle = e),
                i.fill(),
                i.restore();
            }
          }
          drawGrid() {
            const t = this,
              e = t.ctx,
              n = t.options,
              { angleLines: i, grid: r } = n,
              a = t.getLabels().length;
            let o, s, l;
            if (
              (n.pointLabels.display &&
                (function (t, e) {
                  const {
                    ctx: n,
                    options: { pointLabels: i },
                  } = t;
                  for (let r = e - 1; r >= 0; r--) {
                    const e = i.setContext(t.getContext(r)),
                      a = oe(e.font),
                      {
                        x: o,
                        y: s,
                        textAlign: l,
                        left: c,
                        top: u,
                        right: h,
                        bottom: p,
                      } = t._pointLabelItems[r],
                      { backdropColor: f } = e;
                    if (!d(f)) {
                      const t = ae(e.backdropPadding);
                      (n.fillStyle = f),
                        n.fillRect(
                          c - t.left,
                          u - t.top,
                          h - c + t.width,
                          p - u + t.height,
                        );
                    }
                    te(n, t._pointLabels[r], o, s + a.lineHeight / 2, a, {
                      color: e.color,
                      textAlign: l,
                      textBaseline: 'middle',
                    });
                  }
                })(t, a),
              r.display &&
                t.ticks.forEach((e, n) => {
                  if (0 !== n) {
                    s = t.getDistanceFromCenterForValue(e.value);
                    const i = r.setContext(t.getContext(n - 1));
                    !(function (t, e, n, i) {
                      const r = t.ctx,
                        a = e.circular,
                        { color: o, lineWidth: s } = e;
                      (!a && !i) ||
                        !o ||
                        !s ||
                        n < 0 ||
                        (r.save(),
                        (r.strokeStyle = o),
                        (r.lineWidth = s),
                        r.setLineDash(e.borderDash),
                        (r.lineDashOffset = e.borderDashOffset),
                        r.beginPath(),
                        Gr(t, n, a, i),
                        r.closePath(),
                        r.stroke(),
                        r.restore());
                    })(t, i, s, a);
                  }
                }),
              i.display)
            ) {
              for (e.save(), o = t.getLabels().length - 1; o >= 0; o--) {
                const r = i.setContext(t.getContext(o)),
                  { color: a, lineWidth: c } = r;
                c &&
                  a &&
                  ((e.lineWidth = c),
                  (e.strokeStyle = a),
                  e.setLineDash(r.borderDash),
                  (e.lineDashOffset = r.borderDashOffset),
                  (s = t.getDistanceFromCenterForValue(
                    n.ticks.reverse ? t.min : t.max,
                  )),
                  (l = t.getPointPosition(o, s)),
                  e.beginPath(),
                  e.moveTo(t.xCenter, t.yCenter),
                  e.lineTo(l.x, l.y),
                  e.stroke());
              }
              e.restore();
            }
          }
          drawLabels() {
            const t = this,
              e = t.ctx,
              n = t.options,
              i = n.ticks;
            if (!i.display) return;
            const r = t.getIndexAngle(0);
            let a, o;
            e.save(),
              e.translate(t.xCenter, t.yCenter),
              e.rotate(r),
              (e.textAlign = 'center'),
              (e.textBaseline = 'middle'),
              t.ticks.forEach((r, s) => {
                if (0 === s && !n.reverse) return;
                const l = i.setContext(t.getContext(s)),
                  c = oe(l.font);
                if (
                  ((a = t.getDistanceFromCenterForValue(t.ticks[s].value)),
                  l.showLabelBackdrop)
                ) {
                  (o = e.measureText(r.label).width),
                    (e.fillStyle = l.backdropColor);
                  const t = ae(l.backdropPadding);
                  e.fillRect(
                    -o / 2 - t.left,
                    -a - c.size / 2 - t.top,
                    o + t.width,
                    c.size + t.height,
                  );
                }
                te(e, r.label, 0, -a, c, { color: l.color });
              }),
              e.restore();
          }
          drawTitle() {}
        }
        (Vr.id = 'radialLinear'),
          (Vr.defaults = {
            display: !0,
            animate: !0,
            position: 'chartArea',
            angleLines: {
              display: !0,
              lineWidth: 1,
              borderDash: [],
              borderDashOffset: 0,
            },
            grid: { circular: !1 },
            startAngle: 0,
            ticks: {
              showLabelBackdrop: !0,
              backdropColor: 'rgba(255,255,255,0.75)',
              backdropPadding: 2,
              callback: mi.formatters.numeric,
            },
            pointLabels: {
              backdropColor: void 0,
              backdropPadding: 2,
              display: !0,
              font: { size: 10 },
              callback: (t) => t,
              padding: 5,
            },
          }),
          (Vr.defaultRoutes = {
            'angleLines.color': 'borderColor',
            'pointLabels.color': 'color',
            'ticks.color': 'color',
          }),
          (Vr.descriptors = { angleLines: { _fallback: 'grid' } });
        const Wr = {
            millisecond: { common: !0, size: 1, steps: 1e3 },
            second: { common: !0, size: 1e3, steps: 60 },
            minute: { common: !0, size: 6e4, steps: 60 },
            hour: { common: !0, size: 36e5, steps: 24 },
            day: { common: !0, size: 864e5, steps: 30 },
            week: { common: !1, size: 6048e5, steps: 4 },
            month: { common: !0, size: 2628e6, steps: 12 },
            quarter: { common: !1, size: 7884e6, steps: 4 },
            year: { common: !0, size: 3154e7 },
          },
          Xr = Object.keys(Wr);
        function Yr(t, e) {
          return t - e;
        }
        function $r(t, e) {
          if (d(e)) return null;
          const n = t._adapter,
            i = t.options.time,
            { parser: r, round: a, isoWeekday: o } = i;
          let s = e;
          return (
            'function' == typeof r && (s = r(s)),
            m(s) || (s = 'string' == typeof r ? n.parse(s, r) : n.parse(s)),
            null === s
              ? null
              : (a &&
                  (s =
                    'week' !== a || (!H(o) && !0 !== o)
                      ? n.startOf(s, a)
                      : n.startOf(s, 'isoWeek', o)),
                +s)
          );
        }
        function Jr(t, e, n, i) {
          const r = Xr.length;
          for (let a = Xr.indexOf(t); a < r - 1; ++a) {
            const t = Wr[Xr[a]],
              r = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;
            if (t.common && Math.ceil((n - e) / (r * t.size)) <= i)
              return Xr[a];
          }
          return Xr[r - 1];
        }
        function Zr(t, e, n) {
          if (n) {
            if (n.length) {
              const { lo: i, hi: r } = le(n, e);
              t[n[i] >= e ? n[i] : n[r]] = !0;
            }
          } else t[e] = !0;
        }
        function Kr(t, e, n) {
          const i = [],
            r = {},
            a = e.length;
          let o, s;
          for (o = 0; o < a; ++o)
            (s = e[o]), (r[s] = o), i.push({ value: s, major: !1 });
          return 0 !== a && n
            ? (function (t, e, n, i) {
                const r = t._adapter,
                  a = +r.startOf(e[0].value, i),
                  o = e[e.length - 1].value;
                let s, l;
                for (s = a; s <= o; s = +r.add(s, 1, i))
                  (l = n[s]), l >= 0 && (e[l].major = !0);
                return e;
              })(t, i, r, n)
            : i;
        }
        class Qr extends qi {
          constructor(t) {
            super(t),
              (this._cache = { data: [], labels: [], all: [] }),
              (this._unit = 'day'),
              (this._majorUnit = void 0),
              (this._offsets = {}),
              (this._normalized = !1);
          }
          init(t, e) {
            const n = t.time || (t.time = {}),
              i = (this._adapter = new kn._date(t.adapters.date));
            T(n.displayFormats, i.formats()),
              super.init(t),
              (this._normalized = e.normalized);
          }
          parse(t, e) {
            return void 0 === t ? null : $r(this, t);
          }
          beforeLayout() {
            super.beforeLayout(),
              (this._cache = { data: [], labels: [], all: [] });
          }
          determineDataLimits() {
            const t = this,
              e = t.options,
              n = t._adapter,
              i = e.time.unit || 'day';
            let {
              min: r,
              max: a,
              minDefined: o,
              maxDefined: s,
            } = t.getUserBounds();
            function l(t) {
              o || isNaN(t.min) || (r = Math.min(r, t.min)),
                s || isNaN(t.max) || (a = Math.max(a, t.max));
            }
            (o && s) ||
              (l(t._getLabelBounds()),
              ('ticks' === e.bounds && 'labels' === e.ticks.source) ||
                l(t.getMinMax(!1))),
              (r = m(r) && !isNaN(r) ? r : +n.startOf(Date.now(), i)),
              (a = m(a) && !isNaN(a) ? a : +n.endOf(Date.now(), i) + 1),
              (t.min = Math.min(r, a - 1)),
              (t.max = Math.max(r + 1, a));
          }
          _getLabelBounds() {
            const t = this.getLabelTimestamps();
            let e = Number.POSITIVE_INFINITY,
              n = Number.NEGATIVE_INFINITY;
            return (
              t.length && ((e = t[0]), (n = t[t.length - 1])),
              { min: e, max: n }
            );
          }
          buildTicks() {
            const t = this,
              e = t.options,
              n = e.time,
              i = e.ticks,
              r =
                'labels' === i.source ? t.getLabelTimestamps() : t._generate();
            'ticks' === e.bounds &&
              r.length &&
              ((t.min = t._userMin || r[0]),
              (t.max = t._userMax || r[r.length - 1]));
            const a = t.min,
              o = (function (t, e, n) {
                let i = 0,
                  r = t.length;
                for (; i < r && t[i] < e; ) i++;
                for (; r > i && t[r - 1] > n; ) r--;
                return i > 0 || r < t.length ? t.slice(i, r) : t;
              })(r, a, t.max);
            return (
              (t._unit =
                n.unit ||
                (i.autoSkip
                  ? Jr(n.minUnit, t.min, t.max, t._getLabelCapacity(a))
                  : (function (t, e, n, i, r) {
                      for (let a = Xr.length - 1; a >= Xr.indexOf(n); a--) {
                        const n = Xr[a];
                        if (Wr[n].common && t._adapter.diff(r, i, n) >= e - 1)
                          return n;
                      }
                      return Xr[n ? Xr.indexOf(n) : 0];
                    })(t, o.length, n.minUnit, t.min, t.max))),
              (t._majorUnit =
                i.major.enabled && 'year' !== t._unit
                  ? (function (t) {
                      for (let e = Xr.indexOf(t) + 1, n = Xr.length; e < n; ++e)
                        if (Wr[Xr[e]].common) return Xr[e];
                    })(t._unit)
                  : void 0),
              t.initOffsets(r),
              e.reverse && o.reverse(),
              Kr(t, o, t._majorUnit)
            );
          }
          initOffsets(t) {
            const e = this;
            let n,
              i,
              r = 0,
              a = 0;
            e.options.offset &&
              t.length &&
              ((n = e.getDecimalForValue(t[0])),
              (r =
                1 === t.length ? 1 - n : (e.getDecimalForValue(t[1]) - n) / 2),
              (i = e.getDecimalForValue(t[t.length - 1])),
              (a =
                1 === t.length
                  ? i
                  : (i - e.getDecimalForValue(t[t.length - 2])) / 2));
            const o = t.length < 3 ? 0.5 : 0.25;
            (r = Q(r, 0, o)),
              (a = Q(a, 0, o)),
              (e._offsets = { start: r, end: a, factor: 1 / (r + 1 + a) });
          }
          _generate() {
            const t = this,
              e = t._adapter,
              n = t.min,
              i = t.max,
              r = t.options,
              a = r.time,
              o = a.unit || Jr(a.minUnit, n, i, t._getLabelCapacity(n)),
              s = y(a.stepSize, 1),
              l = 'week' === o && a.isoWeekday,
              c = H(l) || !0 === l,
              u = {};
            let h,
              d,
              p = n;
            if (
              (c && (p = +e.startOf(p, 'isoWeek', l)),
              (p = +e.startOf(p, c ? 'day' : o)),
              e.diff(i, n, o) > 1e5 * s)
            )
              throw new Error(
                n +
                  ' and ' +
                  i +
                  ' are too far apart with stepSize of ' +
                  s +
                  ' ' +
                  o,
              );
            const f = 'data' === r.ticks.source && t.getDataTimestamps();
            for (h = p, d = 0; h < i; h = +e.add(h, s, o), d++) Zr(u, h, f);
            return (
              (h !== i && 'ticks' !== r.bounds && 1 !== d) || Zr(u, h, f),
              Object.keys(u)
                .sort((t, e) => t - e)
                .map((t) => +t)
            );
          }
          getLabelForValue(t) {
            const e = this._adapter,
              n = this.options.time;
            return n.tooltipFormat
              ? e.format(t, n.tooltipFormat)
              : e.format(t, n.displayFormats.datetime);
          }
          _tickFormatFunction(t, e, n, i) {
            const r = this.options,
              a = r.time.displayFormats,
              o = this._unit,
              s = this._majorUnit,
              l = o && a[o],
              c = s && a[s],
              u = n[e],
              h = s && c && u && u.major,
              d = this._adapter.format(t, i || (h ? c : l)),
              p = r.ticks.callback;
            return p ? p(d, e, n) : d;
          }
          generateTickLabels(t) {
            let e, n, i;
            for (e = 0, n = t.length; e < n; ++e)
              (i = t[e]), (i.label = this._tickFormatFunction(i.value, e, t));
          }
          getDecimalForValue(t) {
            return null === t ? NaN : (t - this.min) / (this.max - this.min);
          }
          getPixelForValue(t) {
            const e = this._offsets,
              n = this.getDecimalForValue(t);
            return this.getPixelForDecimal((e.start + n) * e.factor);
          }
          getValueForPixel(t) {
            const e = this,
              n = e._offsets,
              i = e.getDecimalForPixel(t) / n.factor - n.end;
            return e.min + i * (e.max - e.min);
          }
          _getLabelSize(t) {
            const e = this.options.ticks,
              n = this.ctx.measureText(t).width,
              i = X(this.isHorizontal() ? e.maxRotation : e.minRotation),
              r = Math.cos(i),
              a = Math.sin(i),
              o = this._resolveTickFontOptions(0).size;
            return { w: n * r + o * a, h: n * a + o * r };
          }
          _getLabelCapacity(t) {
            const e = this,
              n = e.options.time,
              i = n.displayFormats,
              r = i[n.unit] || i.millisecond,
              a = e._tickFormatFunction(t, 0, Kr(e, [t], e._majorUnit), r),
              o = e._getLabelSize(a),
              s =
                Math.floor(e.isHorizontal() ? e.width / o.w : e.height / o.h) -
                1;
            return s > 0 ? s : 1;
          }
          getDataTimestamps() {
            const t = this;
            let e,
              n,
              i = t._cache.data || [];
            if (i.length) return i;
            const r = t.getMatchingVisibleMetas();
            if (t._normalized && r.length)
              return (t._cache.data = r[0].controller.getAllParsedValues(t));
            for (e = 0, n = r.length; e < n; ++e)
              i = i.concat(r[e].controller.getAllParsedValues(t));
            return (t._cache.data = t.normalize(i));
          }
          getLabelTimestamps() {
            const t = this,
              e = t._cache.labels || [];
            let n, i;
            if (e.length) return e;
            const r = t.getLabels();
            for (n = 0, i = r.length; n < i; ++n) e.push($r(t, r[n]));
            return (t._cache.labels = t._normalized ? e : t.normalize(e));
          }
          normalize(t) {
            return pe(t.sort(Yr));
          }
        }
        function ta(t, e, n) {
          let i, r, a, o;
          if (n)
            (i = Math.floor(e)), (r = Math.ceil(e)), (a = t[i]), (o = t[r]);
          else {
            const n = le(t, e);
            (a = n.lo), (o = n.hi), (i = t[a]), (r = t[o]);
          }
          const s = r - i;
          return s ? a + ((o - a) * (e - i)) / s : a;
        }
        (Qr.id = 'time'),
          (Qr.defaults = {
            bounds: 'data',
            adapters: {},
            time: {
              parser: !1,
              unit: !1,
              round: !1,
              isoWeekday: !1,
              minUnit: 'millisecond',
              displayFormats: {},
            },
            ticks: { source: 'auto', major: { enabled: !1 } },
          });
        class ea extends Qr {
          constructor(t) {
            super(t), (this._table = []), (this._maxIndex = void 0);
          }
          initOffsets() {
            const t = this,
              e = t._getTimestampsForTable();
            (t._table = t.buildLookupTable(e)),
              (t._maxIndex = t._table.length - 1),
              super.initOffsets(e);
          }
          buildLookupTable(t) {
            const { min: e, max: n } = this;
            if (!t.length)
              return [
                { time: e, pos: 0 },
                { time: n, pos: 1 },
              ];
            const i = [e];
            let r, a, o;
            for (r = 0, a = t.length; r < a; ++r)
              (o = t[r]), o > e && o < n && i.push(o);
            return i.push(n), i;
          }
          _getTimestampsForTable() {
            const t = this;
            let e = t._cache.all || [];
            if (e.length) return e;
            const n = t.getDataTimestamps(),
              i = t.getLabelTimestamps();
            return (
              (e =
                n.length && i.length
                  ? t.normalize(n.concat(i))
                  : n.length
                  ? n
                  : i),
              (e = t._cache.all = e),
              e
            );
          }
          getPixelForValue(t, e) {
            const n = this,
              i = n._offsets,
              r =
                n._normalized && n._maxIndex > 0 && !d(e)
                  ? e / n._maxIndex
                  : n.getDecimalForValue(t);
            return n.getPixelForDecimal((i.start + r) * i.factor);
          }
          getDecimalForValue(t) {
            return ta(this._table, t) / this._maxIndex;
          }
          getValueForPixel(t) {
            const e = this._offsets,
              n = this.getDecimalForPixel(t) / e.factor - e.end;
            return ta(this._table, n * this._maxIndex, !0);
          }
        }
        (ea.id = 'timeseries'), (ea.defaults = Qr.defaults);
        Yi.defaults.color = '#b0b0b0';
        var na = {
          y: {
            display: !0,
            ticks: { suggestedMin: 0 },
            gridLines: { color: '#606060', zeroLineColor: '#606060' },
          },
        };
        function ia(t, e) {
          var n = -1,
            i = Date.now(),
            r = {
              label: 'texture count',
              data: [{ x: 0, y: 0 }],
              borderColor: '#e7c9e5',
              borderWidth: 1.5,
              pointRadius: 1,
            },
            a = {
              label: 'geometry count',
              data: [{ x: 0, y: 0 }],
              borderColor: '#64a6bd',
              borderWidth: 1.5,
              pointRadius: 1,
            },
            o = ['0s'],
            s = new Yi(t, {
              type: 'line',
              data: { labels: o, datasets: [r, a] },
              options: { animation: { duration: 10 }, scales: na },
            });
          (this.update = function (t) {
            var l = Math.floor((Date.now() - i) / 1e3),
              c = ''.concat(l, 's');
            n > 0 && o[n] == c ? o.push('') : (o.push(c), (n = o.length - 1)),
              o.length > 60 && (o.shift(), n--);
            var u = e.info.memory;
            r.data.push({ x: l, y: u.textures }),
              a.data.push({ x: l, y: u.geometries }),
              r.data.length > 60 && (r.data.shift(), a.data.shift()),
              t && s.update();
          }),
            (this.resize = function () {
              s.resize();
            });
        }
        Yi.register(Tn, or, lr, Or, kr, xr, Mn);
        var ra = n(3),
          aa = n.n(ra),
          oa = n(4),
          sa = n.n(oa),
          la = n(6),
          ca = n.n(la),
          ua = n(7),
          ha = n.n(ua),
          da = n(2),
          pa = n.n(da);
        function fa(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return ma(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return ma(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function ma(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function ga(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = pa()(t);
            if (e) {
              var r = pa()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return ha()(this, n);
          };
        }
        var ya = new i.Font(
            JSON.parse(
              '{"glyphs":{"ο":{"x_min":41,"x_max":710,"ha":753,"o":"m 371 -15 q 131 78 222 -15 q 41 322 41 172 q 133 573 41 474 q 378 672 225 672 q 619 574 528 672 q 710 326 710 477 q 617 80 710 175 q 371 -15 525 -15 m 377 619 q 226 530 272 619 q 180 327 180 441 q 227 125 180 216 q 375 35 274 35 q 524 123 478 35 q 570 326 570 211 q 524 529 570 440 q 377 619 479 619 "},"S":{"x_min":50,"x_max":639,"ha":699,"o":"m 88 208 q 179 88 122 131 q 318 46 237 46 q 457 98 397 46 q 518 227 518 150 q 401 400 518 336 q 184 498 293 448 q 68 688 68 566 q 156 880 68 811 q 370 950 244 950 q 480 936 430 950 q 597 891 530 922 q 570 822 583 858 q 553 756 558 786 l 539 756 q 354 897 502 897 q 231 855 282 897 q 181 742 181 813 q 298 580 181 640 q 519 483 408 531 q 639 286 639 413 q 538 68 639 152 q 301 -15 438 -15 q 166 2 229 -15 q 50 59 104 19 q 68 135 62 104 q 75 205 75 166 l 88 208 "},"/":{"x_min":-36.03125,"x_max":404.15625,"ha":383,"o":"m -36 -125 l 340 1025 l 404 1024 l 28 -126 l -36 -125 "},"Τ":{"x_min":11,"x_max":713,"ha":725,"o":"m 11 839 l 15 884 l 11 932 q 194 927 72 932 q 361 922 316 922 q 544 927 421 922 q 713 932 668 932 q 707 883 707 911 q 707 861 707 870 q 713 834 707 852 q 609 850 666 843 q 504 857 552 857 l 428 857 q 426 767 428 830 q 424 701 424 704 l 428 220 q 442 0 428 122 q 362 8 401 3 q 323 5 344 8 q 282 0 301 2 q 289 132 282 40 q 296 259 296 225 l 296 683 l 296 857 q 11 839 164 857 "},"ϕ":{"x_min":41,"x_max":960,"ha":1006,"o":"m 441 -10 q 162 76 283 -10 q 41 316 41 163 q 162 562 41 470 q 441 654 283 654 q 434 838 441 719 q 427 971 427 957 q 464 965 443 968 q 503 962 485 962 q 540 965 519 962 q 578 970 560 968 q 563 654 563 824 q 839 567 719 654 q 960 324 960 481 q 841 79 960 169 q 563 -10 722 -10 q 570 -201 563 -68 q 578 -371 578 -334 q 505 -362 539 -362 q 465 -365 483 -362 q 427 -372 446 -368 q 434 -161 427 -297 q 441 -10 441 -26 m 563 39 q 757 118 690 39 q 824 330 824 198 q 750 523 824 445 q 564 601 677 601 l 563 319 l 563 39 m 441 319 l 441 601 q 253 523 326 601 q 180 330 180 446 q 245 117 180 195 q 439 39 310 39 l 441 319 "},"y":{"x_min":4.171875,"x_max":665.28125,"ha":664,"o":"m 4 654 l 86 647 l 165 654 q 202 536 188 577 q 241 431 215 495 l 363 129 l 473 413 q 552 654 519 537 q 606 647 583 647 q 665 654 633 647 q 416 125 531 388 q 223 -372 301 -137 l 187 -366 q 141 -366 163 -366 q 112 -372 122 -370 l 290 -22 q 4 654 170 294 "},"≈":{"x_min":118.0625,"x_max":1019.453125,"ha":1139,"o":"m 765 442 q 564 487 700 442 q 376 533 429 533 q 250 506 298 533 q 118 427 202 480 l 118 501 q 245 572 180 545 q 376 600 311 600 q 574 553 438 600 q 765 507 709 507 q 888 534 829 507 q 1019 614 947 562 l 1019 538 q 892 467 954 493 q 765 442 830 442 m 759 214 q 568 260 702 214 q 376 307 433 307 q 236 272 300 307 q 118 202 173 238 l 118 277 q 247 346 181 320 q 380 372 312 372 q 570 326 445 372 q 765 281 695 281 q 883 306 830 281 q 1019 388 936 331 l 1019 313 q 894 240 959 266 q 759 214 829 214 "},"Π":{"x_min":108,"x_max":927.453125,"ha":1036,"o":"m 432 846 l 263 846 q 260 634 263 781 q 257 475 257 486 q 262 236 257 395 q 268 0 268 77 q 229 3 255 0 q 188 8 202 8 q 149 3 177 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 711 126 620 q 108 932 119 803 q 285 926 166 932 q 464 921 405 921 q 695 926 541 921 q 927 932 849 932 q 915 793 921 871 q 909 659 909 716 l 909 504 q 917 245 909 427 q 926 0 926 62 q 887 4 913 0 q 847 8 860 8 q 810 5 827 8 q 768 0 792 2 q 773 259 768 94 q 778 469 778 423 l 778 731 l 773 846 l 432 846 "},"ΐ":{"x_min":-41,"x_max":384,"ha":342,"o":"m 105 333 l 105 520 q 104 566 105 544 q 97 654 103 588 q 141 647 131 648 q 166 647 152 647 q 234 654 196 647 q 225 555 226 599 q 224 437 224 510 l 224 406 q 229 194 224 337 q 234 0 234 51 q 202 3 217 1 q 166 5 186 5 q 128 3 149 5 q 97 0 108 1 q 101 165 97 51 q 105 333 105 279 m 18 865 q 61 846 43 865 q 80 804 80 828 q 61 761 80 779 q 18 743 43 743 q -22 761 -4 743 q -41 804 -41 779 q -22 846 -41 828 q 18 865 -4 865 m 172 929 q 189 969 179 956 q 225 982 199 982 q 256 971 243 982 q 270 941 270 961 q 257 904 270 919 l 149 743 l 117 743 l 172 929 m 324 865 q 366 846 348 865 q 384 804 384 828 q 366 761 384 779 q 324 743 348 743 q 281 761 298 743 q 265 804 265 779 q 281 846 265 828 q 324 865 298 865 "},"g":{"x_min":32,"x_max":672,"ha":688,"o":"m 81 123 q 112 201 81 169 q 193 252 144 233 l 193 262 q 97 329 130 277 q 64 447 64 380 q 141 610 64 549 q 323 672 218 672 q 421 661 357 672 q 500 650 486 651 l 672 654 l 672 582 q 599 592 635 587 q 537 597 563 597 q 607 458 607 548 q 527 294 607 356 q 342 232 447 232 q 291 235 319 232 q 255 239 262 239 q 208 220 228 239 q 188 173 188 201 q 221 120 188 136 q 296 104 254 104 l 427 104 q 603 56 534 104 q 672 -93 672 9 q 560 -299 672 -226 q 309 -372 448 -372 q 115 -327 199 -372 q 32 -183 32 -283 q 76 -62 32 -110 q 193 8 121 -13 q 112 51 143 25 q 81 123 81 77 m 332 278 q 439 332 401 278 q 478 457 478 386 q 441 575 478 525 q 338 625 404 625 q 232 570 271 625 q 194 447 194 515 q 230 328 194 379 q 332 278 266 278 m 337 -316 q 491 -270 423 -316 q 559 -141 559 -224 q 500 -29 559 -62 q 353 3 441 3 q 199 -36 263 3 q 136 -162 136 -76 q 195 -277 136 -238 q 337 -316 255 -316 "},"²":{"x_min":15.28125,"x_max":412.5,"ha":496,"o":"m 297 744 q 270 830 297 795 q 197 866 244 866 q 120 837 149 866 q 83 761 90 808 l 76 759 q 54 802 68 780 q 31 837 40 824 q 210 901 108 901 q 334 862 278 901 q 390 758 390 824 q 282 568 390 656 q 111 428 174 479 l 293 428 q 350 431 316 428 q 412 439 384 434 l 406 397 l 412 356 l 304 361 l 111 361 l 15 355 l 15 378 q 220 567 144 484 q 297 744 297 651 "},"Κ":{"x_min":108,"x_max":856.625,"ha":821,"o":"m 255 314 q 261 132 255 250 q 268 0 268 13 q 229 4 255 0 q 188 8 202 8 q 148 4 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 712 126 621 q 108 932 119 803 q 153 928 124 932 q 188 925 183 925 q 231 928 203 925 q 267 932 259 932 l 255 671 l 255 499 q 480 693 375 586 q 687 932 585 800 q 732 932 710 932 q 777 932 753 932 l 837 932 q 606 727 720 830 q 389 522 493 623 q 525 358 465 426 q 666 202 586 290 q 856 0 747 115 l 746 0 q 692 -1 716 0 q 644 -8 669 -2 q 571 92 610 44 q 477 204 532 140 l 255 459 l 255 314 "},"ë":{"x_min":40,"x_max":646.9375,"ha":681,"o":"m 406 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 313 335 315 335 l 179 331 q 235 127 179 212 q 406 42 291 42 m 219 929 q 271 906 249 929 q 294 854 294 884 q 273 800 294 822 q 221 778 252 778 q 166 800 190 778 q 143 854 143 822 q 165 906 143 884 q 219 929 187 929 m 460 929 q 513 906 492 929 q 534 854 534 884 q 513 799 534 820 q 461 778 493 778 q 407 800 429 778 q 385 854 385 822 q 407 906 385 884 q 460 929 429 929 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 "},"e":{"x_min":41,"x_max":645.15625,"ha":681,"o":"m 406 42 q 602 130 523 42 l 618 125 q 611 86 614 104 q 609 44 609 67 q 497 0 561 14 q 370 -15 434 -15 q 130 73 220 -15 q 41 311 41 161 q 127 563 41 455 q 356 672 214 672 q 563 592 482 672 q 645 385 645 512 l 643 331 l 313 335 l 179 331 q 235 126 179 210 q 406 42 291 42 m 511 392 l 513 436 q 470 563 513 509 q 356 618 427 618 q 230 553 268 618 q 179 388 191 488 l 511 392 "},"ό":{"x_min":41,"x_max":710,"ha":753,"o":"m 371 -15 q 131 78 222 -15 q 41 322 41 172 q 133 573 41 474 q 378 672 225 672 q 619 574 528 672 q 710 326 710 477 q 617 80 710 175 q 371 -15 525 -15 m 524 943 q 558 974 542 964 q 595 985 574 985 q 632 969 618 985 q 646 932 646 954 q 632 897 646 911 q 591 866 618 883 l 390 743 l 341 743 l 524 943 m 377 619 q 226 530 272 619 q 180 327 180 441 q 227 125 180 216 q 375 35 274 35 q 524 123 478 35 q 570 326 570 211 q 524 529 570 440 q 377 619 479 619 "},"J":{"x_min":-71,"x_max":277,"ha":385,"o":"m 118 -40 q 131 62 128 9 q 135 184 135 115 q 132 462 135 325 q 127 690 130 598 q 111 932 123 782 q 159 928 129 932 q 193 925 189 925 q 238 927 221 925 q 277 932 256 929 q 268 665 277 843 q 260 457 260 487 l 260 165 q 260 107 260 147 q 260 48 260 68 q 169 -155 260 -88 q -62 -222 79 -222 l -71 -180 q 50 -134 1 -166 q 118 -40 100 -102 "},"»":{"x_min":43,"x_max":543,"ha":607,"o":"m 196 322 l 43 607 l 81 645 l 303 322 l 81 0 l 43 37 l 196 322 m 436 322 l 283 607 l 322 645 l 543 322 l 322 0 l 283 37 l 436 322 "},"©":{"x_min":80,"x_max":1058,"ha":1139,"o":"m 816 905 q 992 726 927 841 q 1058 481 1058 611 q 912 138 1058 283 q 567 -6 766 -6 q 225 139 370 -6 q 80 481 80 284 q 224 826 80 681 q 569 971 368 971 q 816 905 698 971 m 569 918 q 263 788 392 918 q 134 481 134 659 q 261 175 134 306 q 566 45 389 45 q 872 174 741 45 q 1004 478 1004 304 q 947 699 1004 596 q 787 859 890 801 q 569 918 684 918 m 570 724 q 441 652 483 724 q 399 490 399 581 q 438 320 399 396 q 560 245 478 245 q 664 278 621 245 q 723 370 707 311 l 798 370 q 720 232 788 283 q 561 181 653 181 q 379 268 446 181 q 313 476 313 355 q 380 694 313 604 q 571 785 447 785 q 717 738 656 785 q 793 610 779 691 l 715 610 q 664 692 705 660 q 570 724 624 724 "},"ώ":{"x_min":39.71875,"x_max":1028.9375,"ha":1068,"o":"m 534 528 l 596 528 l 594 305 q 616 117 594 193 q 722 42 638 42 q 850 118 811 42 q 888 293 888 194 q 829 502 888 409 q 664 654 769 594 l 717 648 q 805 654 766 648 q 967 510 905 606 q 1028 304 1028 413 q 948 81 1028 177 q 744 -15 867 -15 q 622 16 678 -15 q 534 104 566 47 q 445 16 500 48 q 323 -15 389 -15 q 118 83 196 -15 q 39 311 39 182 q 100 511 39 419 q 262 654 161 604 q 303 650 278 651 q 349 648 327 648 l 402 654 q 238 501 296 593 q 179 291 179 409 q 218 116 179 191 q 348 42 257 42 q 419 68 390 42 q 461 138 448 94 q 472 216 469 175 q 475 303 475 257 q 472 420 475 353 q 469 529 470 486 l 534 528 m 681 943 q 714 974 699 964 q 751 985 730 985 q 788 969 774 985 q 802 932 802 954 q 787 896 802 912 q 746 866 773 880 l 547 743 l 498 743 l 681 943 "},"≥":{"x_min":176.1875,"x_max":963,"ha":1139,"o":"m 963 462 l 176 196 l 176 266 l 850 491 l 176 718 l 176 788 l 963 522 l 963 462 m 963 26 l 176 26 l 176 93 l 963 93 l 963 26 "},"^":{"x_min":0,"x_max":390,"ha":403,"o":"m 150 978 l 239 978 l 390 743 l 344 743 l 195 875 l 49 743 l 0 743 l 150 978 "},"«":{"x_min":48,"x_max":549.390625,"ha":607,"o":"m 152 326 l 309 42 l 268 3 l 48 326 l 268 649 l 309 611 l 152 326 m 394 326 l 549 42 l 509 3 l 288 326 l 509 649 l 549 611 l 394 326 "},"D":{"x_min":108,"x_max":991,"ha":1043,"o":"m 126 465 q 117 704 126 536 q 108 931 108 872 l 210 929 q 350 934 251 929 q 477 939 449 939 q 579 936 553 939 q 709 917 605 934 q 902 775 814 900 q 991 483 991 650 q 852 130 991 261 q 491 0 713 0 l 378 0 l 228 7 l 203 7 q 148 4 173 7 q 108 0 123 1 q 117 239 108 70 q 126 465 126 408 m 402 64 q 724 168 609 64 q 840 479 840 273 q 730 774 840 671 q 428 878 621 878 q 345 873 400 878 q 262 869 289 869 l 255 497 l 255 376 l 262 76 q 332 68 292 72 q 402 64 373 64 "},"w":{"x_min":4.171875,"x_max":1052.78125,"ha":1047,"o":"m 4 655 q 55 648 41 648 q 86 647 69 647 q 165 654 120 647 q 190 540 176 587 q 238 394 204 492 l 329 141 q 498 654 419 386 q 551 647 526 647 q 609 654 577 647 q 637 544 620 601 q 677 420 654 487 l 770 135 l 872 413 q 911 532 893 472 q 944 654 930 592 q 979 647 970 648 q 1000 647 988 647 q 1052 654 1022 647 q 961 457 1002 555 q 871 235 919 359 q 782 0 824 110 q 755 3 772 0 q 733 6 738 6 q 708 3 724 6 q 686 0 692 0 q 650 127 667 72 q 611 239 632 183 l 518 494 q 432 258 475 382 q 348 0 390 134 q 325 3 336 1 q 297 5 313 5 q 269 3 284 5 q 245 0 254 1 q 162 244 200 140 q 86 447 125 347 q 4 655 47 546 "},"$":{"x_min":89,"x_max":666,"ha":749,"o":"m 139 186 l 146 186 q 213 91 165 119 q 342 50 261 63 l 342 416 q 142 515 196 458 q 89 648 89 573 q 164 819 89 752 q 342 886 239 886 q 330 985 342 936 l 359 979 l 404 984 q 400 924 401 945 q 399 886 399 904 q 510 874 457 886 q 605 834 562 862 q 582 788 592 808 q 555 729 572 768 l 547 729 q 495 810 535 783 q 399 837 455 837 l 399 520 q 610 419 554 479 q 666 277 666 359 q 588 87 666 164 q 399 0 511 9 l 399 -32 q 399 -63 399 -48 q 405 -125 400 -78 l 368 -121 l 329 -125 l 342 0 q 210 13 273 0 q 98 58 147 27 l 139 186 m 342 836 q 237 787 278 826 q 196 686 196 748 q 237 588 196 626 q 342 537 279 551 l 342 836 m 553 231 q 513 337 553 300 q 399 402 473 375 l 399 51 q 512 113 471 66 q 553 231 553 159 "},"‧":{"x_min":134,"x_max":309,"ha":446,"o":"m 222 636 q 284 611 259 636 q 309 548 309 586 q 284 486 309 512 q 222 461 260 461 q 160 486 186 461 q 134 548 134 511 q 159 610 134 584 q 222 636 185 636 "},"\\\\":{"x_min":-36,"x_max":403.140625,"ha":383,"o":"m -36 1025 l 28 1025 l 403 -125 l 340 -125 l -36 1025 "},"Ι":{"x_min":109,"x_max":271,"ha":385,"o":"m 127 465 q 123 711 127 620 q 109 932 120 803 q 154 927 129 929 q 190 925 179 925 q 238 928 209 925 q 271 931 266 931 q 263 788 271 887 q 256 659 256 690 l 256 448 l 256 283 q 263 135 256 238 q 271 0 271 31 q 231 3 258 0 q 190 8 204 8 q 151 5 172 8 q 109 0 129 2 q 118 239 109 70 q 127 465 127 408 "},"Ύ":{"x_min":-1,"x_max":1204.5625,"ha":1165,"o":"m 758 177 l 758 386 q 651 570 717 458 q 543 750 585 681 q 431 931 501 819 q 483 928 449 931 q 522 925 518 925 q 572 927 550 925 q 606 931 593 930 q 666 800 633 866 q 735 676 699 734 l 849 475 q 968 688 910 575 q 1086 931 1027 801 l 1142 926 q 1174 927 1160 926 q 1204 931 1187 929 q 1014 627 1099 769 l 891 415 l 891 240 q 894 101 891 198 q 897 0 897 5 q 860 4 885 1 q 820 6 835 6 q 778 4 793 6 q 743 0 763 2 q 753 88 748 36 q 758 177 758 140 m 182 943 q 215 974 200 964 q 252 985 231 985 q 289 969 274 985 q 305 932 305 954 q 290 896 305 911 q 248 866 275 882 l 48 743 l -1 743 l 182 943 "},"’":{"x_min":90.28125,"x_max":305.5625,"ha":374,"o":"m 169 859 q 197 923 177 894 q 250 953 218 953 q 288 939 272 953 q 305 902 305 925 q 295 857 305 882 q 269 811 284 833 l 120 568 l 90 576 l 169 859 "},"Ν":{"x_min":98,"x_max":911.890625,"ha":1011,"o":"m 112 230 q 114 486 112 315 q 117 741 117 656 l 117 950 l 166 950 q 326 766 239 865 q 468 606 413 667 q 610 451 524 544 l 821 227 l 821 604 q 816 765 821 685 q 803 931 812 845 l 855 927 l 911 931 q 901 831 906 884 q 897 741 897 779 q 894 413 897 619 q 892 165 892 207 l 892 -15 l 849 -15 q 730 125 796 50 q 589 281 664 201 l 193 702 l 193 330 q 212 -1 193 169 l 149 2 l 98 -1 q 108 125 105 79 q 112 230 112 170 "},"-":{"x_min":58.328125,"x_max":388.890625,"ha":449,"o":"m 58 390 l 388 390 l 388 273 l 58 273 l 58 390 "},"Q":{"x_min":51,"x_max":1074.609375,"ha":1119,"o":"m 566 -14 q 194 113 338 -14 q 51 465 51 241 q 192 820 51 690 q 559 950 333 950 q 892 853 754 950 q 1047 654 1031 756 q 1065 525 1062 551 q 1068 462 1068 499 q 1065 405 1068 429 q 1050 305 1062 381 q 960 144 1038 229 q 748 6 881 59 l 930 -112 q 1004 -161 963 -136 q 1074 -200 1045 -186 q 1008 -228 1035 -214 q 951 -267 980 -243 q 876 -208 912 -234 q 803 -154 841 -182 l 606 -14 l 566 -14 m 202 468 q 290 163 202 283 q 559 43 379 43 q 826 163 738 43 q 915 468 915 284 q 825 770 915 651 q 559 889 735 889 q 348 826 429 889 q 225 638 267 763 q 202 468 202 552 "},"ς":{"x_min":44,"x_max":613.453125,"ha":644,"o":"m 305 -206 q 350 -218 325 -218 q 447 -177 407 -218 q 487 -79 487 -136 q 376 55 487 4 q 159 156 266 106 q 44 365 44 231 q 143 585 44 499 q 380 672 242 672 q 506 658 448 672 q 613 616 564 645 q 587 500 595 559 l 562 500 q 501 586 549 557 q 391 616 453 616 q 233 551 296 616 q 170 393 170 486 q 216 271 170 320 q 339 196 263 223 l 467 149 q 569 76 531 119 q 608 -27 608 34 q 522 -206 608 -136 q 321 -293 437 -276 l 305 -206 "},"M":{"x_min":55,"x_max":1165,"ha":1238,"o":"m 190 950 l 243 950 q 331 772 291 851 q 412 612 370 693 q 504 436 454 532 l 626 214 q 742 435 671 298 q 882 711 813 572 q 1001 950 952 850 l 1052 950 q 1082 649 1067 791 q 1118 341 1098 508 q 1165 0 1139 174 q 1121 8 1139 5 q 1088 11 1103 11 q 1049 6 1071 11 q 1008 0 1027 2 q 998 226 1008 109 q 974 461 989 343 q 944 695 959 579 l 748 312 q 610 0 665 152 l 594 1 l 576 0 q 227 685 402 364 l 188 307 q 172 128 175 179 q 168 0 168 77 q 138 4 157 1 q 110 6 118 6 q 81 4 93 6 q 55 0 68 2 q 121 333 89 168 q 171 652 152 498 q 190 950 190 805 "},"Ψ":{"x_min":73,"x_max":995.609375,"ha":1071,"o":"m 609 0 q 561 5 585 2 q 532 8 536 8 q 494 5 515 8 q 456 0 474 2 q 463 151 456 45 q 470 297 470 258 q 180 383 287 297 q 73 650 73 469 l 73 817 l 73 932 q 139 925 110 925 q 180 928 155 925 q 212 931 206 931 q 200 818 204 861 q 197 723 197 774 l 197 688 l 197 638 q 268 438 197 508 q 472 368 340 368 l 473 481 q 464 736 473 566 q 456 932 456 905 q 499 927 481 929 q 532 925 518 925 q 577 927 557 925 q 609 931 596 930 q 601 635 609 841 q 594 368 594 429 l 645 372 q 816 465 765 372 q 868 691 868 559 q 861 829 868 740 q 855 932 855 919 q 896 927 878 929 q 924 925 913 925 q 971 927 955 925 q 995 931 987 930 l 994 839 l 994 675 q 894 388 994 480 q 594 297 794 297 q 601 142 594 249 q 609 0 609 35 "},"C":{"x_min":51,"x_max":881.5625,"ha":913,"o":"m 828 737 q 552 889 733 889 q 295 768 383 889 q 207 469 207 647 q 299 177 207 305 q 551 50 391 50 q 710 86 637 50 q 855 189 783 122 l 870 183 q 858 122 862 147 q 855 69 855 97 q 521 -15 699 -15 q 180 116 309 -15 q 51 462 51 248 q 189 820 51 690 q 556 950 327 950 q 719 930 638 950 q 881 875 799 911 q 857 809 867 843 q 845 737 847 775 l 828 737 "},"œ":{"x_min":39,"x_max":1195.9375,"ha":1226,"o":"m 359 -15 q 125 76 212 -15 q 39 318 39 167 q 125 571 39 470 q 362 672 212 672 q 514 640 441 672 q 641 551 588 608 q 897 672 741 672 q 1110 593 1024 672 q 1195 390 1195 515 l 1193 331 q 1022 332 1108 331 q 851 334 935 333 l 708 331 q 765 124 708 206 q 944 42 822 42 q 1145 130 1068 42 l 1162 130 q 1155 85 1158 110 q 1151 47 1152 60 q 1036 0 1100 14 q 904 -15 973 -15 q 754 12 819 -15 q 641 106 689 40 q 514 14 584 44 q 359 -15 444 -15 m 376 625 q 224 534 270 625 q 179 328 179 443 q 224 124 179 215 q 369 34 269 34 q 521 127 470 34 q 573 328 573 221 q 526 534 573 443 q 376 625 480 625 m 1061 392 l 1061 423 q 1017 561 1061 504 q 894 618 973 618 q 756 549 805 618 q 708 390 708 480 l 1061 392 "},"!":{"x_min":136,"x_max":312,"ha":449,"o":"m 223 156 q 285 130 259 156 q 312 68 312 105 q 285 8 312 32 q 223 -15 259 -15 q 161 9 187 -15 q 136 68 136 33 q 160 130 136 105 q 223 156 185 156 m 150 752 l 144 841 q 161 919 144 888 q 223 950 178 950 q 282 925 260 950 q 304 863 304 901 q 299 808 304 845 q 295 752 295 770 l 246 250 q 223 250 238 250 q 199 250 206 250 l 150 752 "},"ç":{"x_min":34,"x_max":614.5625,"ha":644,"o":"m 607 119 l 592 41 q 490 -2 549 10 q 363 -15 431 -15 q 130 80 227 -15 q 34 313 34 175 q 132 576 34 480 q 397 672 231 672 q 511 659 456 672 q 614 617 565 647 q 597 558 604 587 q 584 492 589 528 l 570 492 q 507 587 547 553 q 406 622 467 622 q 234 534 293 622 q 176 329 176 447 q 238 126 176 211 q 414 42 300 42 q 592 124 521 42 l 607 119 m 202 -212 q 350 -246 273 -246 q 414 -232 388 -246 q 440 -186 440 -219 q 421 -142 440 -158 q 373 -126 402 -126 l 323 -126 l 323 0 l 367 0 l 367 -77 l 404 -73 q 495 -102 457 -73 q 533 -183 533 -132 q 494 -270 533 -237 q 402 -303 456 -303 q 286 -294 335 -303 q 184 -261 238 -286 l 202 -212 "},"{":{"x_min":116,"x_max":567.390625,"ha":683,"o":"m 491 909 q 421 874 445 909 q 397 792 397 839 l 397 744 l 397 583 q 368 434 397 493 q 263 354 339 376 q 367 272 338 332 q 397 125 397 212 l 397 -35 q 414 -149 397 -108 q 471 -197 431 -191 q 529 -204 511 -204 q 567 -204 548 -204 l 567 -276 q 387 -239 459 -276 q 315 -105 315 -203 l 315 -28 l 315 132 q 296 244 315 194 q 240 303 277 294 q 176 314 204 312 q 116 317 148 317 l 116 389 q 270 429 225 389 q 315 576 315 469 l 315 737 q 348 918 315 870 q 450 977 381 966 q 567 983 503 983 l 567 912 l 491 909 "},"X":{"x_min":0,"x_max":739,"ha":739,"o":"m 200 285 l 318 456 q 18 932 159 718 q 63 929 33 932 q 109 926 94 926 q 168 929 147 926 q 198 932 188 932 q 296 743 244 841 q 391 568 348 644 l 489 726 q 597 932 548 825 q 627 927 614 929 q 661 926 641 926 q 693 929 671 926 q 728 932 715 932 q 616 781 673 862 q 524 652 558 700 l 427 512 q 523 347 480 419 q 614 197 566 275 q 739 0 662 119 q 686 3 719 0 q 647 6 652 6 q 595 4 618 6 q 558 0 572 1 q 459 197 512 97 q 353 398 405 298 l 265 249 q 174 96 193 130 q 127 0 155 62 q 89 3 113 0 q 62 6 65 6 q 26 4 43 6 q 0 0 9 1 l 200 285 "},"ô":{"x_min":40,"x_max":712,"ha":753,"o":"m 371 -15 q 131 79 223 -15 q 40 322 40 173 q 133 572 40 473 q 380 672 227 672 q 621 575 530 672 q 712 327 712 479 q 619 80 712 175 q 371 -15 527 -15 m 332 978 l 421 978 l 572 743 l 525 743 l 376 875 l 229 743 l 180 743 l 332 978 m 377 622 q 227 532 274 622 q 180 327 180 442 q 227 125 180 216 q 375 35 274 35 q 524 124 478 35 q 570 327 570 214 q 524 531 570 441 q 377 622 479 622 "},"#":{"x_min":78,"x_max":972.4375,"ha":1050,"o":"m 497 647 l 675 647 l 791 969 l 877 968 l 761 647 l 972 647 l 948 576 l 736 576 l 671 390 l 896 390 l 873 319 l 644 319 l 531 0 l 446 0 l 559 319 l 382 319 l 266 0 l 182 0 l 294 319 l 78 319 l 102 390 l 320 390 l 386 576 l 151 576 l 176 647 l 410 647 l 526 969 l 610 969 l 497 647 m 472 576 l 407 390 l 587 390 l 650 576 l 472 576 "},"ι":{"x_min":96,"x_max":233.5,"ha":342,"o":"m 104 333 l 104 521 q 103 567 104 545 q 96 655 102 589 q 141 648 130 648 q 165 647 151 647 q 233 654 196 647 q 224 555 226 599 q 223 437 223 511 l 223 406 q 228 194 223 337 q 233 0 233 51 q 201 3 216 1 q 165 5 185 5 q 127 3 148 5 q 96 0 107 1 q 100 165 96 51 q 104 333 104 279 "},"Ά":{"x_min":12,"x_max":910.609375,"ha":896,"o":"m 328 639 l 458 950 q 489 944 464 947 q 522 950 507 944 q 655 613 602 745 q 770 331 709 480 q 910 0 832 181 q 859 3 891 0 q 823 6 827 6 q 772 4 795 6 q 735 0 749 1 q 672 195 692 135 q 613 353 652 255 l 449 358 l 285 353 l 233 205 q 173 0 194 94 l 116 5 q 76 2 91 5 q 55 0 62 0 q 146 211 101 105 q 229 404 192 317 q 328 639 266 490 m 195 943 q 228 974 213 964 q 265 985 244 985 q 302 969 287 985 q 318 932 318 954 q 303 896 318 911 q 261 866 288 882 l 61 743 l 12 743 l 195 943 m 450 419 l 585 425 l 451 761 l 318 425 l 450 419 "},")":{"x_min":65.671875,"x_max":332,"ha":449,"o":"m 332 376 q 271 81 332 217 q 96 -183 211 -54 q 65 -151 83 -164 q 193 104 155 -16 q 232 386 232 226 q 191 661 232 533 q 65 918 150 789 q 96 950 87 933 q 273 681 215 816 q 332 376 332 545 "},"ε":{"x_min":53,"x_max":567,"ha":628,"o":"m 506 516 q 433 591 467 566 q 353 616 400 616 q 261 580 298 616 q 225 492 225 545 q 268 406 225 437 q 372 375 311 375 l 418 375 l 417 349 l 417 310 l 343 317 q 236 282 280 317 q 193 183 193 247 q 238 77 193 117 q 352 38 284 38 q 460 66 410 38 q 543 144 510 94 q 553 99 547 121 q 567 54 558 76 q 452 2 515 19 q 321 -15 388 -15 q 134 31 216 -15 q 53 175 53 78 q 95 286 53 246 q 214 355 137 326 q 127 408 162 370 q 93 497 93 445 q 165 625 93 579 q 323 672 237 672 q 430 654 378 672 q 541 604 481 637 q 522 564 529 584 q 506 516 514 545 "},"Δ":{"x_min":0,"x_max":899,"ha":899,"o":"m 899 0 q 701 5 833 0 q 501 11 569 11 q 251 5 418 11 q 0 0 84 0 q 225 473 126 251 q 407 932 323 696 q 432 929 415 932 q 457 926 448 926 q 482 927 471 926 q 505 932 493 929 q 691 449 601 664 q 899 0 782 234 m 281 429 q 158 90 212 259 q 290 84 201 90 q 423 79 379 79 l 456 79 q 587 81 550 79 q 692 90 625 83 l 651 188 l 576 383 l 422 778 l 281 429 "},"â":{"x_min":43,"x_max":655.5,"ha":649,"o":"m 234 -15 q 98 33 153 -15 q 43 162 43 82 q 106 303 43 273 q 303 364 169 333 q 444 448 437 395 q 403 568 444 521 q 288 616 362 616 q 191 587 233 616 q 124 507 149 559 l 95 520 l 104 591 q 202 651 144 631 q 323 672 261 672 q 500 622 444 672 q 557 455 557 573 l 557 133 q 567 69 557 84 q 618 54 577 54 q 655 58 643 54 l 655 26 q 594 5 626 14 q 537 -6 562 -3 q 438 85 453 -6 q 342 10 388 35 q 234 -15 296 -15 m 279 978 l 368 978 l 522 743 l 471 743 l 323 875 l 176 743 l 126 743 l 279 978 m 176 186 q 204 98 176 133 q 284 64 232 64 q 390 107 342 64 q 438 212 438 151 l 438 345 q 239 293 303 319 q 176 186 176 268 "},"}":{"x_min":114,"x_max":567,"ha":683,"o":"m 369 576 q 405 438 369 487 q 527 389 441 389 l 567 389 l 567 317 q 415 278 461 317 q 369 132 369 239 l 369 -28 q 319 -229 369 -182 q 114 -276 270 -276 l 114 -204 q 252 -172 218 -204 q 286 -83 286 -141 l 286 -35 l 286 125 q 314 271 286 212 q 418 354 342 329 q 311 435 337 382 q 286 584 286 488 l 286 745 q 268 860 286 818 q 191 913 251 903 l 114 913 l 114 983 l 186 982 q 287 960 242 982 q 346 900 331 938 q 365 822 362 862 q 369 737 369 783 l 369 576 "},"‰":{"x_min":28,"x_max":1511,"ha":1536,"o":"m 799 0 q 647 62 708 0 q 586 218 586 124 q 647 372 586 309 q 799 436 709 436 q 949 373 888 436 q 1011 223 1011 311 q 995 130 1011 176 q 918 35 972 70 q 799 0 865 0 m 1298 0 q 1146 62 1206 0 q 1087 218 1087 124 q 1148 372 1087 308 q 1299 436 1209 436 q 1449 373 1388 436 q 1511 223 1511 311 q 1494 130 1511 169 q 1418 34 1472 69 q 1298 0 1365 0 m 241 448 q 89 510 150 448 q 28 663 28 573 q 89 820 28 755 q 241 885 151 885 q 391 823 329 885 q 453 672 453 761 q 434 580 453 620 q 359 483 412 518 q 241 448 307 448 m 863 1015 l 227 -125 l 158 -125 l 793 1015 l 863 1015 m 897 260 q 872 353 897 310 q 798 397 847 397 q 718 340 737 397 q 700 202 700 283 q 719 86 700 133 q 798 40 738 40 q 866 73 840 40 q 892 149 892 106 q 895 206 894 169 q 897 260 897 242 m 339 684 q 319 797 339 750 q 244 845 300 845 q 161 784 182 845 q 141 645 141 723 q 165 540 141 590 q 237 490 189 490 q 303 524 278 490 q 334 598 329 558 q 339 684 339 638 m 1397 260 q 1373 356 1397 315 q 1297 397 1349 397 q 1218 340 1237 397 q 1200 202 1200 283 q 1219 87 1200 134 q 1297 40 1238 40 q 1366 73 1340 40 q 1392 149 1392 106 q 1395 206 1394 169 q 1397 260 1397 242 "},"Ä":{"x_min":-16,"x_max":839.5625,"ha":826,"o":"m 258 638 l 389 951 q 420 945 395 948 q 453 951 438 945 q 570 651 500 826 q 688 360 640 477 q 839 0 736 242 q 788 3 820 0 q 752 6 756 6 q 702 3 728 6 q 665 0 675 0 q 599 204 615 158 q 542 357 584 251 l 378 357 l 214 357 l 161 207 q 130 109 147 170 q 102 0 113 47 l 45 5 q 20 4 29 5 q -16 0 10 4 q 72 203 29 105 q 169 427 115 301 q 258 638 222 552 m 293 1208 q 345 1186 325 1208 q 366 1133 366 1164 q 345 1080 366 1102 q 293 1058 324 1058 q 239 1080 261 1058 q 217 1133 217 1102 q 239 1185 217 1163 q 293 1208 261 1208 m 535 1208 q 587 1186 565 1208 q 609 1133 609 1164 q 587 1080 609 1103 q 535 1058 565 1058 q 481 1080 503 1058 q 459 1133 459 1102 q 481 1185 459 1163 q 535 1208 503 1208 m 378 421 l 515 425 l 381 762 l 247 425 l 378 421 "},"a":{"x_min":44,"x_max":653.734375,"ha":647,"o":"m 233 -15 q 99 33 154 -15 q 44 162 44 82 q 105 302 44 273 q 302 363 167 331 q 444 448 437 395 q 401 567 444 519 q 287 615 359 615 q 190 587 231 615 q 124 508 149 560 l 95 519 l 103 591 q 204 651 148 631 q 323 672 260 672 q 499 623 443 672 q 555 457 555 574 l 555 132 q 566 70 555 86 q 616 55 578 55 l 653 55 l 653 26 q 594 4 624 15 q 536 -6 564 -6 q 468 15 492 -6 q 436 83 445 38 q 341 9 387 34 q 233 -15 294 -15 m 175 185 q 204 99 175 135 q 282 63 234 63 q 389 106 343 63 q 436 211 436 150 l 436 344 q 239 294 304 320 q 175 185 175 268 "},"—":{"x_min":226.390625,"x_max":1138.890625,"ha":1367,"o":"m 226 375 l 1138 375 l 1138 292 l 226 292 l 226 375 "},"=":{"x_min":169.4375,"x_max":969.453125,"ha":1139,"o":"m 969 499 l 169 499 l 169 564 l 969 564 l 969 499 m 969 248 l 169 248 l 169 315 l 969 315 l 969 248 "},"N":{"x_min":98,"x_max":911.890625,"ha":1011,"o":"m 112 230 q 114 486 112 315 q 117 741 117 656 l 117 950 l 166 950 q 326 766 239 865 q 468 606 413 667 q 610 451 524 544 l 821 227 l 821 604 q 816 765 821 685 q 803 931 812 845 l 855 927 l 911 931 q 901 831 906 884 q 897 741 897 779 q 894 413 897 619 q 892 165 892 207 l 892 -15 l 849 -15 q 730 125 796 50 q 589 281 664 201 l 193 702 l 193 330 q 212 -1 193 169 l 149 2 l 98 -1 q 108 125 105 79 q 112 230 112 170 "},"ρ":{"x_min":65,"x_max":711,"ha":758,"o":"m 191 -99 q 195 -235 191 -145 q 199 -371 199 -325 q 161 -367 169 -367 q 134 -366 153 -366 q 96 -368 116 -366 q 65 -372 76 -370 q 70 -190 65 -311 q 76 -8 76 -69 q 73 166 76 67 q 70 329 71 265 q 148 578 70 484 q 380 672 226 672 q 617 573 524 672 q 711 329 711 474 q 625 84 711 184 q 396 -15 539 -15 q 285 7 334 -15 q 191 78 236 30 l 191 -99 m 377 619 q 231 533 271 619 q 191 327 191 447 q 241 103 191 169 q 376 38 292 38 q 525 125 479 38 q 571 326 571 212 q 525 529 571 440 q 377 619 480 619 "},"2":{"x_min":22,"x_max":622,"ha":749,"o":"m 449 648 q 410 789 449 727 q 298 851 371 851 q 173 802 219 851 q 128 676 128 753 l 118 673 q 84 740 100 712 q 47 799 69 768 q 313 911 158 911 q 507 844 426 911 q 589 667 589 777 q 527 479 589 555 q 315 258 466 404 l 169 118 l 442 118 q 531 123 485 118 q 622 136 576 129 q 617 102 619 117 q 616 68 616 87 q 617 37 616 54 q 622 0 619 20 q 438 4 562 0 q 252 8 315 8 q 142 7 195 8 q 22 0 88 6 l 22 40 q 234 238 155 158 q 380 430 312 319 q 449 648 449 541 "},"ü":{"x_min":90,"x_max":664,"ha":754,"o":"m 653 498 q 653 329 653 443 q 653 158 653 215 q 664 0 653 82 q 631 3 647 1 q 598 5 616 5 q 563 3 583 5 q 533 0 544 1 l 538 118 q 440 18 494 52 q 312 -15 385 -15 q 148 50 201 -15 q 96 229 96 115 l 96 354 l 96 516 l 90 655 q 120 650 103 651 q 158 648 136 648 q 192 650 175 648 q 227 656 210 651 q 220 446 227 592 q 213 247 213 300 q 247 115 213 163 q 362 68 281 68 q 477 113 428 68 q 531 217 525 159 q 538 340 538 274 q 533 520 538 394 q 528 655 528 647 q 558 650 542 651 q 596 648 574 648 q 629 650 612 648 q 663 656 646 651 q 653 498 653 574 m 253 929 q 307 906 285 929 q 330 854 330 884 q 309 800 330 822 q 257 778 288 778 q 202 800 225 778 q 180 854 180 823 q 200 906 180 884 q 253 929 221 929 m 498 929 q 549 906 527 929 q 572 854 572 884 q 551 799 572 820 q 499 778 531 778 q 444 800 466 778 q 422 854 422 822 q 444 906 422 884 q 498 929 466 929 "},"Z":{"x_min":6.9375,"x_max":801.390625,"ha":828,"o":"m 6 36 q 222 324 112 176 q 425 605 333 473 l 597 857 l 433 857 q 59 836 247 857 l 65 883 l 59 932 q 262 927 134 932 q 427 922 390 922 q 622 927 491 922 q 801 932 754 932 l 801 904 q 594 629 709 785 q 399 361 479 473 q 201 77 319 249 l 427 77 q 581 82 520 77 q 801 103 643 87 l 797 68 l 795 54 l 797 34 l 801 0 q 504 4 683 0 q 325 8 326 8 q 166 4 272 8 q 6 0 61 0 l 6 36 "},"u":{"x_min":90,"x_max":662.21875,"ha":754,"o":"m 653 497 l 653 156 q 654 83 653 122 q 661 -1 656 44 q 623 3 632 2 q 596 4 615 4 q 572 3 581 4 q 533 -1 563 2 l 536 117 q 439 18 491 51 q 313 -15 386 -15 q 147 48 199 -15 q 96 227 96 112 l 96 352 l 96 516 l 90 654 q 158 647 125 647 q 189 648 178 647 q 226 654 200 650 q 220 450 226 586 q 215 246 215 314 q 248 114 215 163 q 361 66 281 66 q 473 112 426 66 q 527 225 520 158 q 536 340 536 282 q 531 497 536 393 q 527 654 527 601 q 572 647 563 647 q 595 647 581 647 q 626 648 616 647 q 662 654 637 650 l 653 497 "},"k":{"x_min":97,"x_max":677.5625,"ha":683,"o":"m 104 656 q 100 873 104 741 q 97 1025 97 1005 q 164 1018 134 1018 q 231 1025 196 1018 q 227 825 231 962 q 223 622 223 687 l 223 377 l 245 377 q 507 654 391 506 q 563 647 538 647 q 616 647 589 647 q 648 652 638 651 l 349 398 l 548 165 q 608 93 577 127 q 677 19 638 59 l 677 0 q 628 3 659 0 q 591 6 597 6 q 544 3 567 6 q 510 0 520 0 q 438 101 473 54 q 360 197 402 148 l 269 308 l 252 324 l 223 326 q 227 164 223 272 q 231 0 231 55 q 200 4 215 2 q 164 5 185 5 q 127 3 146 5 q 97 0 108 1 q 100 386 97 151 q 104 656 104 620 "},"Η":{"x_min":109,"x_max":928.453125,"ha":1039,"o":"m 257 317 q 262 142 257 253 q 267 0 267 30 q 226 3 253 0 q 188 8 200 8 q 147 3 174 8 q 109 0 121 0 q 116 243 109 72 q 124 465 124 415 q 116 710 124 540 q 109 932 109 880 q 152 929 121 932 q 188 926 183 926 q 231 929 200 926 q 267 932 262 932 q 262 719 267 854 q 257 547 257 584 q 406 544 301 547 q 517 541 511 541 q 666 544 562 541 q 777 547 770 547 q 773 786 777 641 q 769 932 769 930 q 813 929 781 932 q 849 926 845 926 q 893 929 861 926 q 928 932 924 932 q 914 795 920 866 q 909 659 909 723 l 909 505 q 918 252 909 420 q 927 0 927 84 q 887 4 913 0 q 848 8 861 8 q 811 5 829 8 q 769 0 793 2 q 773 103 769 41 q 777 176 777 166 l 777 317 l 777 465 q 604 466 692 465 q 430 469 517 467 l 257 465 l 257 317 "},"Α":{"x_min":-15.28125,"x_max":838.890625,"ha":825,"o":"m 257 639 l 387 950 q 402 945 395 947 q 417 944 409 944 q 452 950 437 944 q 576 629 536 733 q 686 359 617 526 q 838 0 755 192 q 789 3 820 0 q 751 6 758 6 q 700 4 723 6 q 663 0 677 1 q 600 199 622 137 q 543 353 579 260 l 377 358 l 215 353 l 162 205 q 130 110 145 160 q 101 0 115 59 l 44 5 q 6 2 20 5 q -15 0 -8 0 q 76 211 30 105 q 158 404 121 318 q 257 639 195 490 m 378 419 l 513 425 l 379 761 l 246 425 l 378 419 "},"ß":{"x_min":94,"x_max":726,"ha":765,"o":"m 107 431 l 107 611 l 107 761 q 200 948 118 872 q 395 1025 283 1025 q 543 979 478 1025 q 608 852 608 933 q 530 709 608 783 q 453 586 453 636 q 589 457 453 547 q 726 259 726 368 q 648 64 726 143 q 453 -15 570 -15 q 379 -6 418 -15 q 309 15 339 1 l 334 128 l 348 127 q 405 70 368 91 q 485 49 442 49 q 583 92 544 49 q 622 193 622 135 q 484 365 622 280 q 347 525 347 450 q 433 667 347 561 q 520 838 520 773 q 483 939 520 899 q 386 979 446 979 q 269 924 313 979 q 226 795 226 870 l 226 629 l 226 344 q 229 141 226 265 q 233 1 233 18 q 196 4 219 1 q 166 8 173 8 q 123 5 142 8 q 94 1 105 2 q 100 250 94 91 q 107 431 107 409 "},"é":{"x_min":40,"x_max":646.9375,"ha":681,"o":"m 406 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 313 335 315 335 l 179 331 q 235 127 179 212 q 406 42 291 42 m 406 945 q 440 976 424 966 q 477 986 455 986 q 528 934 528 986 q 513 895 528 912 q 471 866 498 879 l 272 743 l 222 743 l 406 945 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 "},"s":{"x_min":68,"x_max":531,"ha":593,"o":"m 117 161 q 172 69 130 102 q 276 36 214 36 q 378 67 333 36 q 424 152 424 98 q 334 260 424 224 q 168 320 251 290 q 79 460 79 366 q 147 612 79 552 q 310 672 216 672 q 400 660 355 672 q 500 627 446 649 l 461 508 l 448 508 q 401 587 433 561 q 314 614 369 614 q 223 584 262 614 q 185 505 185 555 q 358 375 185 427 q 531 197 531 322 q 450 39 531 93 q 259 -15 369 -15 q 68 23 162 -15 l 103 161 l 117 161 "},"B":{"x_min":109,"x_max":751,"ha":801,"o":"m 127 559 q 109 931 127 759 l 203 929 q 338 932 244 929 q 438 935 432 935 q 629 883 549 935 q 709 726 709 832 q 638 579 709 633 q 464 504 567 524 q 673 438 595 490 q 751 268 751 387 q 639 66 751 133 q 382 0 528 0 l 232 6 q 162 3 211 6 q 109 0 113 0 q 118 287 109 86 q 127 559 127 488 m 256 257 l 256 149 l 261 61 l 337 57 q 526 108 450 57 q 602 266 602 159 q 523 428 602 386 q 312 471 444 471 l 256 471 l 256 257 m 569 706 q 507 834 569 788 q 361 879 446 879 l 261 875 q 252 709 252 798 l 252 522 q 476 558 384 522 q 569 706 569 595 "},"…":{"x_min":119,"x_max":1005,"ha":1160,"o":"m 191 130 q 244 108 223 130 q 266 55 266 87 q 244 5 266 25 q 191 -15 223 -15 q 139 4 160 -15 q 119 55 119 23 q 139 108 119 87 q 191 130 159 130 m 560 130 q 612 108 591 130 q 634 55 634 87 q 612 5 634 25 q 560 -15 591 -15 q 507 4 528 -15 q 487 55 487 23 q 507 109 487 88 q 560 130 528 130 m 930 130 q 983 108 962 130 q 1005 55 1005 87 q 983 5 1005 25 q 930 -15 962 -15 q 878 4 899 -15 q 858 55 858 23 q 878 108 858 87 q 930 130 898 130 "},"?":{"x_min":128,"x_max":520,"ha":601,"o":"m 307 156 q 367 130 342 156 q 392 68 392 105 q 367 7 392 30 q 307 -15 343 -15 q 244 8 269 -15 q 220 68 220 32 q 244 130 220 105 q 307 156 269 156 m 329 250 q 214 290 261 250 q 168 399 168 331 q 287 595 168 479 q 406 776 406 712 q 371 858 406 823 q 292 894 337 894 q 207 867 243 894 q 162 794 171 840 l 150 794 q 142 835 146 822 q 128 894 139 849 q 210 936 165 922 q 305 950 255 950 q 457 893 394 950 q 520 748 520 837 q 398 550 520 657 q 276 370 276 443 q 293 316 276 337 q 343 296 310 296 q 397 302 372 296 l 383 256 q 357 251 365 252 q 329 250 348 250 "},"H":{"x_min":108,"x_max":927.453125,"ha":1036,"o":"m 258 318 q 263 143 258 255 q 268 0 268 30 q 229 3 255 0 q 188 8 202 8 q 148 3 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 711 126 620 q 108 932 119 803 q 153 928 124 932 q 188 925 183 925 q 231 928 204 925 q 268 932 259 932 q 263 719 268 854 q 258 547 258 584 l 517 543 l 777 547 q 773 786 777 641 q 769 932 769 930 q 814 928 785 932 q 848 925 842 925 q 894 928 864 925 q 927 932 923 932 q 914 798 919 868 q 909 659 909 729 l 909 448 l 909 283 q 916 135 909 238 q 924 0 924 31 q 885 4 911 0 q 846 8 860 8 q 807 4 832 8 q 769 0 781 0 q 773 101 769 37 q 777 177 777 164 l 777 318 l 777 468 q 604 468 720 468 q 431 468 489 468 l 258 468 l 258 318 "},"ν":{"x_min":0,"x_max":632,"ha":654,"o":"m 319 8 q 296 5 309 8 q 272 0 283 2 q 200 206 234 120 q 0 654 165 291 q 84 647 45 647 q 113 647 98 647 q 168 654 127 648 q 252 402 204 529 l 360 131 q 469 358 440 267 q 499 520 499 448 q 492 579 499 543 q 477 641 486 615 q 552 649 527 645 q 613 661 576 652 q 628 611 625 623 q 632 576 632 598 q 621 501 632 536 q 560 373 611 466 q 461 190 509 280 q 372 0 412 99 q 345 3 363 0 q 319 8 327 8 "},"î":{"x_min":-25,"x_max":365.328125,"ha":340,"o":"m 104 144 l 104 522 l 97 655 q 138 650 113 651 q 167 649 162 649 q 233 655 206 649 q 225 506 225 581 q 229 254 225 423 q 233 0 233 84 q 201 3 216 1 q 164 5 186 5 q 127 3 146 5 q 97 0 108 1 l 104 144 m 125 978 l 214 978 l 365 743 l 319 743 l 170 875 l 24 743 l -25 743 l 125 978 "},"c":{"x_min":36,"x_max":613.78125,"ha":644,"o":"m 606 119 l 594 41 q 493 -3 548 7 q 365 -15 438 -15 q 131 79 227 -15 q 36 312 36 173 q 134 576 36 480 q 399 672 233 672 q 513 658 459 672 q 613 616 566 645 q 586 492 597 563 l 571 492 q 510 586 550 553 q 406 619 470 619 q 235 532 294 619 q 176 327 176 445 q 237 125 176 209 q 415 42 299 42 q 594 122 520 42 l 606 119 "},"¶":{"x_min":18,"x_max":531,"ha":590,"o":"m 298 968 l 531 968 l 531 910 l 473 910 l 473 4 l 415 4 l 415 910 l 305 910 l 305 4 l 247 4 l 247 558 q 99 602 163 558 q 27 690 36 645 q 18 744 18 734 q 90 896 18 824 q 298 968 163 968 "},"β":{"x_min":96,"x_max":737.671875,"ha":779,"o":"m 160 -365 q 129 -367 151 -365 q 96 -369 107 -369 q 100 -253 96 -325 q 104 -169 104 -182 l 104 101 l 104 565 q 168 898 104 771 q 419 1025 232 1025 q 605 960 525 1025 q 686 787 686 895 q 641 641 686 705 q 522 548 597 577 q 682 454 626 515 q 737 290 737 394 q 648 73 737 162 q 431 -15 559 -15 q 324 3 372 -15 q 226 61 276 22 q 224 -44 226 19 q 223 -110 223 -107 l 230 -369 q 193 -367 220 -369 q 160 -365 166 -365 m 356 564 q 507 618 458 564 q 557 779 557 673 q 520 917 557 859 q 407 975 483 975 q 279 906 323 975 q 234 752 234 838 q 232 613 234 701 q 230 506 230 524 l 226 355 l 230 230 q 275 94 230 147 q 406 41 321 41 q 552 116 504 41 q 600 297 600 192 q 550 443 600 386 q 412 499 500 499 q 361 497 384 499 q 327 493 337 494 l 329 516 l 329 565 l 356 564 "},"Μ":{"x_min":55,"x_max":1165,"ha":1238,"o":"m 190 950 l 243 950 q 331 772 291 851 q 412 612 370 693 q 504 436 454 532 l 626 214 q 742 435 671 298 q 882 711 813 572 q 1001 950 952 850 l 1052 950 q 1082 649 1067 791 q 1118 341 1098 508 q 1165 0 1139 174 q 1121 8 1139 5 q 1088 11 1103 11 q 1049 6 1071 11 q 1008 0 1027 2 q 998 226 1008 109 q 974 461 989 343 q 944 695 959 579 l 748 312 q 610 0 665 152 l 594 1 l 576 0 q 227 685 402 364 l 188 307 q 172 128 175 179 q 168 0 168 77 q 138 4 157 1 q 110 6 118 6 q 81 4 93 6 q 55 0 68 2 q 121 333 89 168 q 171 652 152 498 q 190 950 190 805 "},"Ό":{"x_min":-1,"x_max":1305,"ha":1356,"o":"m 288 465 q 429 820 288 690 q 796 950 570 950 q 1129 853 991 950 q 1284 654 1268 757 q 1302 525 1299 551 q 1305 462 1305 500 q 1302 402 1305 426 q 1284 277 1299 379 q 1131 80 1268 175 q 797 -15 993 -15 q 684 -10 733 -15 q 541 29 635 -5 q 367 186 447 64 q 288 465 288 308 m 182 943 q 215 974 200 964 q 251 985 230 985 q 289 969 274 985 q 304 932 304 954 q 290 896 304 911 q 247 866 275 882 l 48 743 l -1 743 l 182 943 m 439 468 q 527 162 439 282 q 796 42 616 42 q 1063 162 975 42 q 1152 468 1152 283 q 1062 770 1152 651 q 796 889 972 889 q 585 826 666 889 q 462 639 504 764 q 439 468 439 552 "},"Ή":{"x_min":-1.390625,"x_max":1233.046875,"ha":1341,"o":"m 564 316 q 569 142 564 254 q 574 0 574 30 q 535 4 561 0 q 494 8 508 8 q 454 4 480 8 q 414 0 427 0 q 423 239 414 70 q 432 465 432 408 q 428 711 432 620 q 414 931 425 802 q 459 928 430 931 q 494 924 489 924 q 537 928 510 924 q 574 931 565 931 q 569 719 574 854 q 564 547 564 584 l 823 543 l 1083 547 q 1078 786 1083 641 q 1074 931 1074 930 q 1119 928 1091 931 q 1153 924 1148 924 q 1199 928 1170 924 q 1233 931 1228 931 q 1221 798 1226 868 q 1217 659 1217 729 l 1215 448 l 1217 283 q 1225 135 1217 238 q 1233 0 1233 31 q 1194 4 1220 0 q 1154 8 1167 8 q 1113 4 1140 8 q 1075 0 1087 0 q 1078 100 1075 37 q 1082 176 1082 163 l 1083 316 l 1083 465 q 910 466 1026 465 q 737 468 795 468 l 564 465 l 564 316 m 181 943 q 215 974 200 964 q 251 985 230 985 q 288 969 273 985 q 304 932 304 954 q 289 896 304 911 q 247 866 275 882 l 47 743 l -1 743 l 181 943 "},"•":{"x_min":204.171875,"x_max":795.828125,"ha":1003,"o":"m 501 789 q 709 702 622 789 q 795 493 795 615 q 709 286 795 372 q 501 201 623 201 q 290 286 377 201 q 204 493 204 371 q 226 605 204 550 q 312 725 248 661 q 501 789 376 789 "},"¥":{"x_min":32,"x_max":699,"ha":750,"o":"m 313 278 q 176 273 268 278 q 50 268 83 268 l 50 335 q 147 332 82 335 q 246 329 213 329 l 313 329 l 313 436 l 176 436 l 50 432 l 50 495 q 182 492 90 495 q 281 490 275 490 l 126 743 l 32 888 l 91 883 l 191 887 q 225 814 208 845 q 287 699 241 783 l 397 512 q 477 653 433 570 q 592 887 521 736 l 643 883 l 699 887 l 625 773 l 554 655 l 454 490 q 593 492 496 490 q 697 495 690 495 l 697 431 l 434 436 l 434 330 l 572 329 q 636 332 595 329 q 697 335 678 335 l 697 268 l 568 278 l 434 278 q 434 143 434 208 q 442 0 435 77 l 365 5 l 299 0 q 310 131 307 54 q 313 278 313 208 "},"(":{"x_min":114,"x_max":380.5625,"ha":449,"o":"m 114 388 q 175 684 114 545 q 351 950 237 822 q 380 918 361 933 q 253 660 291 782 q 215 379 215 538 q 256 103 215 231 q 380 -151 297 -25 q 351 -183 361 -167 q 173 84 232 -50 q 114 388 114 219 "},"U":{"x_min":101,"x_max":919.0625,"ha":1015,"o":"m 181 926 q 228 929 195 926 q 263 932 262 932 q 251 804 255 853 q 248 697 248 755 l 248 457 q 315 134 248 212 q 515 57 382 57 q 733 129 654 57 q 813 334 813 201 l 813 458 l 813 655 q 810 797 813 733 q 798 931 807 862 q 827 927 813 929 q 859 926 841 926 q 888 929 868 926 q 919 932 907 932 q 905 779 909 853 q 902 600 902 705 l 902 366 q 793 81 902 178 q 492 -15 685 -15 q 211 66 307 -15 q 116 323 116 147 l 116 425 l 116 698 q 109 826 116 759 q 101 931 103 893 q 138 927 120 929 q 181 926 156 926 "},"γ":{"x_min":-12,"x_max":701,"ha":681,"o":"m 642 647 q 701 654 669 647 q 593 440 633 520 q 502 247 553 359 l 411 48 l 411 -90 q 415 -238 411 -138 q 419 -372 419 -337 l 372 -366 q 282 -372 325 -366 q 287 -195 282 -313 q 292 -33 292 -76 q 260 192 292 47 q 170 460 229 338 q 39 583 111 583 l -12 579 l -10 608 l -12 638 q 43 662 14 653 q 101 672 71 672 q 279 554 234 672 q 398 143 324 437 q 496 393 439 244 q 590 654 553 541 q 615 648 607 650 q 642 647 623 647 "},"α":{"x_min":41,"x_max":827.109375,"ha":846,"o":"m 705 352 q 803 -1 763 155 l 739 1 l 673 -1 l 632 172 q 521 36 593 87 q 356 -15 448 -15 q 129 81 217 -15 q 41 316 41 177 q 130 569 41 467 q 368 672 220 672 q 537 622 464 672 q 659 486 610 573 q 711 654 691 569 l 770 650 l 827 654 q 763 505 792 576 q 705 352 734 434 m 377 619 q 226 530 272 619 q 181 326 181 442 q 223 124 181 214 q 367 34 265 34 q 528 137 480 34 q 601 323 577 240 q 527 531 578 444 q 377 619 475 619 "},"F":{"x_min":108,"x_max":613.5625,"ha":671,"o":"m 258 316 q 263 142 258 254 q 268 0 268 30 q 229 3 255 0 q 188 8 202 8 q 148 3 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 711 126 620 q 108 932 119 802 l 358 928 l 613 931 l 610 886 l 613 836 q 505 855 549 851 q 388 860 460 860 l 260 860 l 258 671 l 258 528 l 398 528 q 587 541 480 528 l 584 497 l 587 451 l 394 463 l 258 463 l 258 316 "},"­":{"x_min":0,"x_max":683.328125,"ha":683,"o":"m 0 374 l 683 374 l 683 289 l 0 289 l 0 374 "},":":{"x_min":134,"x_max":309,"ha":446,"o":"m 222 636 q 284 611 259 636 q 309 548 309 586 q 284 486 309 512 q 222 461 260 461 q 160 486 186 461 q 134 548 134 511 q 159 610 134 584 q 222 636 185 636 m 221 156 q 283 131 257 156 q 309 69 309 107 q 284 8 309 32 q 221 -15 259 -15 q 159 9 185 -15 q 134 69 134 33 q 159 131 134 107 q 221 156 185 156 "},"Χ":{"x_min":0,"x_max":739,"ha":739,"o":"m 200 285 l 318 456 q 18 932 159 718 q 63 929 33 932 q 109 926 94 926 q 168 929 147 926 q 198 932 188 932 q 296 743 244 841 q 391 568 348 644 l 489 726 q 597 932 548 825 q 627 927 614 929 q 661 926 641 926 q 693 929 671 926 q 728 932 715 932 q 616 781 673 862 q 524 652 558 700 l 427 512 q 523 347 480 419 q 614 197 566 275 q 739 0 662 119 q 686 3 719 0 q 647 6 652 6 q 595 4 618 6 q 558 0 572 1 q 459 197 512 97 q 353 398 405 298 l 265 249 q 174 96 193 130 q 127 0 155 62 q 89 3 113 0 q 62 6 65 6 q 26 4 43 6 q 0 0 9 1 l 200 285 "},"*":{"x_min":94,"x_max":580,"ha":675,"o":"m 336 940 q 367 944 349 940 q 389 948 385 948 q 368 850 375 902 q 362 747 362 799 q 522 873 442 800 q 548 812 539 829 q 580 778 556 796 q 386 702 485 750 q 476 661 427 680 q 575 629 524 643 q 521 535 539 587 q 441 604 478 573 q 362 661 403 634 q 369 564 362 615 q 391 459 377 513 q 360 463 379 459 q 336 467 340 467 q 306 463 325 467 q 282 459 288 459 q 304 568 296 522 q 313 661 313 615 q 152 535 221 602 q 128 589 138 569 q 97 630 117 608 q 185 661 140 643 q 287 704 231 679 q 189 746 234 728 q 94 777 145 763 q 125 818 113 795 q 150 873 137 841 q 227 805 184 839 q 313 747 269 771 q 309 810 313 784 q 282 950 305 836 q 310 942 297 945 q 336 940 324 940 "},"°":{"x_min":176,"x_max":508,"ha":683,"o":"m 176 889 q 228 1010 176 961 q 355 1060 280 1060 q 460 1011 413 1060 q 508 904 508 962 q 455 785 508 839 q 337 731 402 731 q 222 776 269 731 q 176 889 176 821 m 241 880 q 266 805 241 836 q 336 775 292 775 q 413 811 386 775 q 441 899 441 847 q 417 985 441 952 q 343 1018 393 1018 q 281 995 307 1018 q 247 940 254 973 q 241 880 241 906 "},"V":{"x_min":0,"x_max":852.78125,"ha":853,"o":"m 190 477 l 74 759 l 0 932 l 83 926 q 134 929 98 926 q 173 931 170 931 q 206 829 187 884 q 248 704 224 773 l 308 548 l 454 153 l 586 502 q 729 931 666 713 l 790 927 l 852 931 q 643 467 748 720 q 470 0 538 215 q 445 4 457 1 q 418 6 432 6 q 384 3 399 6 q 366 0 368 0 q 279 256 331 123 q 190 477 226 389 "},"Ξ":{"x_min":58.328125,"x_max":818.0625,"ha":878,"o":"m 437 821 q 258 817 377 821 q 77 813 138 813 q 84 851 83 838 q 84 872 84 864 q 77 932 84 900 q 256 928 137 932 q 437 924 376 924 q 618 928 497 924 q 797 932 738 932 l 791 872 q 794 842 791 861 q 797 813 797 822 q 619 817 738 813 q 437 821 500 821 m 470 430 q 335 425 440 430 q 183 421 230 421 q 187 456 186 433 q 188 481 188 480 q 183 543 188 515 q 304 538 215 543 q 437 533 394 533 q 572 538 481 533 q 694 543 662 543 l 687 482 l 694 421 q 572 425 650 421 q 470 430 494 430 m 437 8 q 250 4 376 8 q 58 0 123 0 l 63 63 l 58 129 q 268 124 134 129 q 437 119 401 119 q 636 124 502 119 q 818 129 769 129 l 813 63 l 818 0 q 627 4 754 0 q 437 8 501 8 "}," ":{"x_min":0,"x_max":0,"ha":375},"Ϋ":{"x_min":-26,"x_max":746,"ha":708,"o":"m 299 177 l 299 387 q 190 577 235 501 q 87 747 146 652 q -26 931 29 841 q 23 929 -13 931 q 65 926 61 926 q 110 929 78 926 q 146 931 143 931 q 208 800 175 866 q 278 676 241 734 l 391 475 q 627 931 519 693 l 683 927 q 721 929 701 927 q 746 931 741 931 q 652 786 702 866 q 557 627 602 705 l 432 415 l 432 241 q 435 97 432 184 q 439 0 439 10 q 395 4 414 2 q 361 6 376 6 q 320 4 336 6 q 286 0 304 2 q 294 88 290 36 q 299 177 299 141 m 233 1208 q 286 1187 265 1208 q 307 1133 307 1166 q 285 1080 307 1103 q 233 1058 263 1058 q 179 1080 202 1058 q 157 1133 157 1103 q 179 1186 157 1164 q 233 1208 202 1208 m 475 1208 q 528 1186 506 1208 q 550 1133 550 1164 q 528 1080 550 1103 q 475 1058 506 1058 q 422 1080 444 1058 q 400 1133 400 1102 q 421 1186 400 1164 q 475 1208 443 1208 "},"0":{"x_min":48,"x_max":699,"ha":749,"o":"m 372 909 q 621 773 544 909 q 699 451 699 637 q 627 116 699 252 q 372 -19 556 -19 q 120 114 193 -19 q 48 444 48 247 q 120 774 48 639 q 372 909 193 909 m 187 365 q 226 137 187 238 q 373 37 266 37 q 457 62 421 37 q 519 142 494 88 q 552 271 545 196 q 559 455 559 346 q 526 736 559 622 q 371 851 493 851 q 245 783 280 851 q 198 647 210 716 q 187 444 187 577 l 187 365 "},"”":{"x_min":104.171875,"x_max":570.828125,"ha":625,"o":"m 184 858 q 211 924 193 898 q 265 951 230 951 q 320 903 316 951 q 310 856 320 881 q 283 812 300 831 l 136 568 l 104 576 l 184 858 m 433 858 q 468 928 452 905 q 516 951 483 951 q 555 938 540 951 q 570 903 570 926 q 561 859 570 881 q 536 812 552 837 l 387 568 l 355 576 l 433 858 "},"@":{"x_min":78,"x_max":1289,"ha":1367,"o":"m 906 640 l 970 640 l 876 266 l 864 203 q 886 157 864 172 q 940 142 908 142 q 1136 262 1062 142 q 1211 513 1211 383 q 1067 801 1211 693 q 735 909 923 909 q 324 753 495 909 q 154 362 154 598 q 301 1 154 135 q 679 -132 448 -132 q 904 -99 791 -132 q 1105 -6 1016 -67 l 1129 -43 q 923 -150 1033 -113 q 694 -188 812 -188 q 258 -43 439 -188 q 78 350 78 100 q 273 791 78 614 q 737 969 469 969 q 1122 843 955 969 q 1289 507 1289 717 q 1187 214 1289 346 q 930 82 1086 82 q 835 103 879 82 q 792 170 792 124 l 792 203 q 709 116 762 150 q 595 82 655 82 q 439 139 493 82 q 386 302 386 197 q 471 553 386 441 q 692 665 556 665 q 797 639 754 665 q 864 556 840 613 l 906 640 m 849 477 q 796 572 835 535 q 701 609 758 609 q 529 511 592 609 q 467 297 467 413 q 503 184 467 230 q 605 139 540 139 q 733 188 679 139 q 807 313 787 238 l 849 477 "},"Ί":{"x_min":-1.390625,"x_max":580.0625,"ha":690,"o":"m 433 465 q 429 711 433 620 q 414 931 426 802 q 461 927 435 929 q 498 925 487 925 q 546 928 517 925 q 580 931 575 931 q 572 788 580 887 q 564 659 564 690 l 562 448 l 564 283 q 572 135 564 238 q 580 0 580 31 q 539 4 567 0 q 498 8 512 8 q 457 5 480 8 q 414 0 435 2 q 423 239 414 70 q 433 465 433 408 m 181 943 q 215 974 200 964 q 251 985 230 985 q 288 969 273 985 q 304 932 304 954 q 289 896 304 911 q 247 866 275 882 l 47 743 l -1 743 l 181 943 "},"ö":{"x_min":40,"x_max":712,"ha":753,"o":"m 371 -15 q 131 79 223 -15 q 40 322 40 173 q 133 572 40 473 q 380 672 227 672 q 621 575 530 672 q 712 327 712 479 q 619 80 712 175 q 371 -15 527 -15 m 253 929 q 307 906 285 929 q 330 854 330 884 q 309 800 330 822 q 257 778 288 778 q 202 800 225 778 q 180 854 180 823 q 200 906 180 884 q 253 929 221 929 m 498 929 q 549 906 527 929 q 572 854 572 884 q 551 799 572 820 q 499 778 531 778 q 444 800 466 778 q 422 854 422 822 q 444 906 422 884 q 498 929 466 929 m 377 622 q 227 532 274 622 q 180 327 180 442 q 227 125 180 216 q 375 35 274 35 q 524 124 478 35 q 570 327 570 214 q 524 531 570 441 q 377 622 479 622 "},"i":{"x_min":91.765625,"x_max":244,"ha":342,"o":"m 100 144 l 100 520 l 93 654 q 161 648 130 648 q 194 649 182 648 q 229 654 207 650 q 221 579 224 616 q 219 505 219 543 q 224 240 219 417 q 229 0 229 63 q 197 3 212 1 q 161 5 181 5 q 116 2 131 5 q 91 0 100 0 l 100 144 m 168 963 q 223 940 202 963 q 244 881 244 917 q 222 831 244 849 q 168 813 200 813 q 115 833 137 813 q 93 885 93 853 q 113 941 93 919 q 168 963 134 963 "},"Β":{"x_min":109,"x_max":751,"ha":801,"o":"m 127 559 q 109 931 127 759 l 203 929 q 338 932 244 929 q 438 935 432 935 q 629 883 549 935 q 709 726 709 832 q 638 579 709 633 q 464 504 567 524 q 673 438 595 490 q 751 268 751 387 q 639 66 751 133 q 382 0 528 0 l 232 6 q 162 3 211 6 q 109 0 113 0 q 118 287 109 86 q 127 559 127 488 m 256 257 l 256 149 l 261 61 l 337 57 q 526 108 450 57 q 602 266 602 159 q 523 428 602 386 q 312 471 444 471 l 256 471 l 256 257 m 569 706 q 507 834 569 788 q 361 879 446 879 l 261 875 q 252 709 252 798 l 252 522 q 476 558 384 522 q 569 706 569 595 "},"≤":{"x_min":176,"x_max":962.703125,"ha":1139,"o":"m 288 491 l 962 266 l 962 196 l 176 462 l 176 521 l 962 788 l 962 718 l 288 491 m 962 26 l 176 26 l 176 93 l 962 93 l 962 26 "},"υ":{"x_min":79,"x_max":703,"ha":774,"o":"m 703 397 q 596 110 703 236 q 332 -15 489 -15 q 145 54 211 -15 q 79 244 79 123 l 83 430 q 81 542 83 486 q 79 654 80 598 l 146 650 l 217 654 q 209 503 217 608 q 202 366 202 398 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 133 476 43 q 571 341 571 223 q 548 493 571 418 q 488 645 526 568 q 550 648 529 645 q 627 659 571 650 q 703 397 703 538 "},"]":{"x_min":83,"x_max":332,"ha":449,"o":"m 209 -154 l 83 -158 l 85 -129 l 85 -98 q 183 -104 128 -104 l 229 -104 l 232 386 l 232 880 l 185 880 q 134 877 162 880 q 83 872 107 874 l 85 903 l 85 932 l 205 929 l 332 929 q 326 852 332 909 q 321 766 321 794 l 321 455 l 321 2 l 332 -158 l 209 -154 "},"m":{"x_min":91,"x_max":1075,"ha":1167,"o":"m 101 155 l 101 494 q 98 568 101 529 q 91 654 96 606 q 155 647 123 647 l 221 654 l 216 537 q 317 638 261 604 q 450 672 373 672 q 629 547 581 672 q 733 639 677 606 q 860 672 789 672 q 1018 606 968 672 q 1069 429 1069 540 l 1069 298 l 1069 136 l 1075 0 q 1038 3 1063 0 q 1006 6 1013 6 q 968 3 992 6 q 938 0 943 0 q 944 203 938 68 q 950 406 950 338 q 918 536 950 486 q 810 587 887 587 q 699 540 745 587 q 648 452 653 493 q 642 376 643 410 q 641 326 641 342 l 641 314 q 644 132 641 258 q 647 0 647 6 q 607 4 621 2 q 581 5 593 5 q 542 2 570 5 q 514 0 515 0 q 519 168 514 55 q 524 321 524 280 l 524 406 q 490 534 524 482 q 383 587 457 587 q 273 541 314 587 q 223 436 231 496 q 216 314 216 376 q 219 133 216 244 q 222 0 222 22 q 183 3 207 0 q 154 6 159 6 q 117 4 134 6 q 91 0 100 1 l 101 155 "},"χ":{"x_min":-1,"x_max":725.390625,"ha":713,"o":"m 500 426 q 554 536 528 476 q 607 654 580 595 l 675 650 l 725 652 q 623 507 672 586 q 519 330 573 427 l 444 197 q 575 -85 507 55 q 719 -371 643 -227 q 665 -371 701 -371 q 611 -371 629 -371 l 560 -371 q 444 -115 497 -230 q 358 72 392 -1 l 255 -95 q 178 -237 208 -174 q 125 -371 147 -299 l 62 -371 l 0 -371 q 125 -192 68 -278 q 240 -5 182 -106 l 324 136 l 201 402 q 146 519 174 460 q 43 587 103 587 l -1 584 l -1 638 q 128 672 57 672 q 222 627 181 672 q 292 522 264 583 l 359 374 l 411 260 l 500 426 "},"8":{"x_min":59,"x_max":689,"ha":749,"o":"m 110 696 q 187 853 110 797 q 370 909 264 909 q 558 854 480 909 q 636 694 636 800 q 589 575 636 621 q 467 510 543 529 l 467 499 q 630 413 572 475 q 689 247 689 351 q 597 51 689 120 q 374 -18 505 -18 q 149 48 239 -18 q 59 247 59 115 q 118 414 59 347 q 281 499 178 480 l 281 510 q 157 570 205 521 q 110 696 110 619 m 371 531 q 472 577 437 531 q 507 693 507 624 q 470 810 507 764 q 366 856 433 856 q 271 807 305 856 q 238 693 238 758 q 271 578 238 625 q 371 531 305 531 m 373 31 q 505 97 461 31 q 550 255 550 164 q 506 415 550 348 q 373 482 462 482 q 239 416 283 482 q 195 255 195 351 q 240 96 195 162 q 373 31 285 31 "},"ί":{"x_min":96,"x_max":429.34375,"ha":342,"o":"m 104 333 l 104 520 q 103 566 104 544 q 96 654 102 588 q 141 647 130 648 q 165 647 151 647 q 233 654 196 647 q 224 555 226 599 q 223 437 223 511 l 223 406 q 228 194 223 337 q 233 0 233 51 q 201 3 216 1 q 165 5 185 5 q 127 3 148 5 q 96 0 107 1 q 100 165 96 51 q 104 333 104 279 m 308 943 q 341 974 326 964 q 377 985 357 985 q 415 969 401 985 q 429 932 429 954 q 414 896 429 912 q 373 866 400 880 l 174 743 l 125 743 l 308 943 "},"Ζ":{"x_min":6.9375,"x_max":801.390625,"ha":828,"o":"m 6 36 q 222 324 112 176 q 425 605 333 473 l 597 857 l 433 857 q 59 836 247 857 l 65 883 l 59 932 q 262 927 134 932 q 427 922 390 922 q 622 927 491 922 q 801 932 754 932 l 801 904 q 594 629 709 785 q 399 361 479 473 q 201 77 319 249 l 427 77 q 581 82 520 77 q 801 103 643 87 l 797 68 l 795 54 l 797 34 l 801 0 q 504 4 683 0 q 325 8 326 8 q 166 4 272 8 q 6 0 61 0 l 6 36 "},"R":{"x_min":109,"x_max":806.234375,"ha":785,"o":"m 261 0 q 223 3 248 0 q 185 8 198 8 q 148 5 168 8 q 109 0 127 2 q 118 306 109 90 q 127 598 127 523 q 122 761 127 672 q 109 931 117 849 l 203 929 l 409 935 q 618 882 529 935 q 708 719 708 830 q 634 559 708 615 q 442 473 560 503 q 620 240 533 355 q 806 0 708 124 l 732 5 l 610 0 q 449 240 529 127 q 283 455 369 353 l 251 455 l 251 307 q 256 138 251 245 q 261 0 261 31 m 570 699 q 504 835 570 791 q 344 879 439 879 l 261 875 q 253 772 255 834 q 251 701 251 709 l 251 504 q 479 542 388 504 q 570 699 570 581 "},"×":{"x_min":203.984375,"x_max":938.015625,"ha":1139,"o":"m 892 775 l 938 729 l 616 406 l 938 86 l 892 38 l 571 361 l 247 38 l 203 86 l 525 407 l 204 729 l 247 775 l 570 453 l 892 775 "},"o":{"x_min":41,"x_max":710,"ha":753,"o":"m 371 -15 q 131 78 222 -15 q 41 322 41 172 q 133 573 41 474 q 378 672 225 672 q 619 574 528 672 q 710 326 710 477 q 617 80 710 175 q 371 -15 525 -15 m 377 619 q 226 530 272 619 q 180 327 180 441 q 227 125 180 216 q 375 35 274 35 q 524 123 478 35 q 570 326 570 211 q 524 529 570 440 q 377 619 479 619 "},"5":{"x_min":75,"x_max":654,"ha":749,"o":"m 116 201 q 176 77 131 120 q 303 35 221 35 q 454 98 396 35 q 512 255 512 161 q 457 407 512 346 q 313 469 403 469 q 170 417 227 469 l 150 428 l 158 526 q 158 662 158 570 q 158 801 158 754 l 147 888 l 383 879 l 412 879 q 628 887 520 879 q 624 848 626 870 q 622 818 622 826 l 626 760 l 425 761 l 227 761 q 221 631 227 717 q 216 500 216 544 q 375 536 296 536 q 572 465 491 536 q 654 279 654 394 q 550 60 654 139 q 304 -18 447 -18 q 179 -6 231 -18 q 75 34 127 4 q 101 201 87 118 l 116 201 "},"7":{"x_min":122.609375,"x_max":729.5625,"ha":749,"o":"m 461 553 l 586 770 l 362 770 q 129 755 232 770 q 133 786 132 769 q 135 820 135 804 q 128 888 135 853 l 408 883 l 729 887 l 729 871 q 463 429 582 641 q 251 0 344 216 l 194 8 q 153 5 169 8 q 122 0 137 2 q 214 146 179 91 q 333 339 249 201 q 461 553 417 477 "},"K":{"x_min":108,"x_max":856.625,"ha":821,"o":"m 255 314 q 261 132 255 250 q 268 0 268 13 q 229 4 255 0 q 188 8 202 8 q 148 4 174 8 q 108 0 121 0 q 117 239 108 70 q 126 465 126 408 q 122 712 126 621 q 108 932 119 803 q 153 928 124 932 q 188 925 183 925 q 231 928 203 925 q 267 932 259 932 l 255 671 l 255 499 q 480 693 375 586 q 687 932 585 800 q 732 932 710 932 q 777 932 753 932 l 837 932 q 606 727 720 830 q 389 522 493 623 q 525 358 465 426 q 666 202 586 290 q 856 0 747 115 l 746 0 q 692 -1 716 0 q 644 -8 669 -2 q 571 92 610 44 q 477 204 532 140 l 255 459 l 255 314 "},",":{"x_min":40.28125,"x_max":272.21875,"ha":374,"o":"m 131 75 q 160 147 144 120 q 213 175 176 175 q 272 119 272 175 q 259 67 272 91 q 231 18 245 43 l 73 -243 l 40 -231 l 131 75 "},"d":{"x_min":55,"x_max":676,"ha":758,"o":"m 668 762 l 672 137 l 676 -1 q 638 3 653 1 q 611 5 623 5 q 574 2 597 5 q 547 -1 551 -1 l 557 119 q 336 -15 484 -15 q 127 86 200 -15 q 55 330 55 187 q 127 569 55 467 q 332 672 199 672 q 457 643 402 672 q 551 556 513 615 l 551 756 l 551 789 l 551 818 q 542 1025 551 927 q 609 1018 576 1018 q 639 1019 628 1018 q 675 1025 651 1020 l 668 762 m 374 57 q 515 139 473 57 q 557 332 557 222 q 513 522 557 437 q 374 607 470 607 q 236 522 278 607 q 194 332 194 438 q 235 141 194 225 q 374 57 277 57 "},"¨":{"x_min":83.71875,"x_max":550.390625,"ha":625,"o":"m 471 659 q 441 593 458 618 q 389 568 424 568 q 350 579 365 568 q 335 613 335 591 q 346 660 335 633 q 371 706 358 687 l 519 950 l 550 940 l 471 659 m 221 659 q 192 593 211 618 q 137 568 174 568 q 83 613 83 568 q 93 658 83 637 q 119 706 103 680 l 268 950 l 300 940 l 221 659 "},"E":{"x_min":108,"x_max":613.5625,"ha":686,"o":"m 126 465 q 122 711 126 620 q 108 932 119 802 l 353 928 l 610 931 l 606 884 l 610 836 q 508 853 562 847 q 408 860 453 860 l 260 860 l 258 671 l 258 528 l 398 528 q 587 541 480 528 l 584 497 l 587 451 l 394 463 l 258 463 l 258 316 l 264 73 q 456 76 380 73 q 613 94 531 80 l 610 47 l 613 0 l 358 4 l 108 0 q 117 239 108 70 q 126 465 126 408 "},"Y":{"x_min":-28,"x_max":746,"ha":707,"o":"m 297 177 l 297 386 q 191 570 256 458 q 84 750 125 682 q -28 932 42 819 q 24 928 -9 932 q 63 925 59 925 q 112 927 91 925 q 146 932 134 930 q 207 800 174 866 q 275 676 239 735 l 389 475 q 509 688 451 575 q 627 932 567 801 l 683 926 q 715 927 701 926 q 746 932 729 929 q 555 627 640 769 l 432 415 l 432 240 q 435 101 432 198 q 438 0 438 5 q 401 4 426 1 q 361 6 376 6 q 319 4 334 6 q 284 0 304 2 q 292 88 288 36 q 297 177 297 140 "},"\\"":{"x_min":64,"x_max":315,"ha":379,"o":"m 133 587 l 64 587 l 64 957 l 133 957 l 133 587 m 315 587 l 247 587 l 247 957 l 315 957 l 315 587 "},"ê":{"x_min":40,"x_max":646.9375,"ha":681,"o":"m 406 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 314 335 315 335 l 179 331 q 235 127 179 212 q 406 42 291 42 m 296 978 l 386 978 l 537 743 l 488 743 l 340 875 l 193 743 l 143 743 l 296 978 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 "},"δ":{"x_min":41,"x_max":670,"ha":710,"o":"m 102 840 q 185 981 102 937 q 375 1025 268 1025 q 497 1010 436 1025 q 621 968 559 995 q 595 876 604 923 q 500 947 547 923 q 393 972 453 972 q 280 937 328 972 q 233 840 233 902 q 272 742 233 794 q 434 627 312 691 q 613 504 556 563 q 670 305 670 445 q 581 75 670 165 q 350 -15 492 -15 q 125 73 210 -15 q 41 305 41 162 q 113 526 41 430 q 306 622 186 622 q 145 726 189 674 q 102 840 102 779 m 356 576 q 221 492 261 576 q 181 302 181 409 q 223 118 181 203 q 356 34 265 34 q 490 116 450 34 q 530 307 530 198 q 489 492 530 409 q 356 576 449 576 "},"έ":{"x_min":53,"x_max":598.828125,"ha":628,"o":"m 506 516 q 433 591 467 566 q 353 616 400 616 q 261 580 298 616 q 225 492 225 545 q 268 406 225 437 q 372 375 311 375 l 418 375 l 417 352 l 417 313 l 343 317 q 237 282 281 317 q 193 185 193 247 q 238 78 193 118 q 352 38 284 38 q 460 66 410 38 q 543 144 510 94 q 553 99 547 121 q 567 54 558 76 q 452 2 515 19 q 321 -15 388 -15 q 134 31 216 -15 q 53 176 53 78 q 96 286 53 246 q 214 355 139 326 q 127 408 162 370 q 93 497 93 445 q 165 625 93 579 q 323 672 237 672 q 430 654 378 672 q 541 604 481 637 q 522 564 529 584 q 506 516 514 545 m 476 944 q 510 975 494 965 q 547 986 526 986 q 584 970 569 986 q 598 933 598 954 q 584 898 598 912 q 541 867 569 884 l 342 744 l 293 744 l 476 944 "},"ω":{"x_min":39.71875,"x_max":1028.9375,"ha":1068,"o":"m 535 526 l 596 528 l 594 305 q 616 117 594 193 q 722 42 638 42 q 850 118 811 42 q 888 293 888 194 q 829 502 888 409 q 664 654 769 594 l 717 648 q 805 654 766 648 q 967 510 905 606 q 1028 304 1028 413 q 948 81 1028 177 q 744 -15 867 -15 q 622 16 678 -15 q 534 104 566 47 q 445 16 500 48 q 323 -15 389 -15 q 118 83 196 -15 q 39 311 39 182 q 100 511 39 419 q 262 654 161 604 q 303 650 278 651 q 349 648 327 648 l 402 654 q 238 501 296 593 q 179 291 179 409 q 218 116 179 191 q 348 42 257 42 q 419 68 390 42 q 461 137 448 94 q 472 216 469 175 q 475 303 475 257 q 472 419 475 353 q 469 528 470 485 l 535 526 "},"´":{"x_min":90.28125,"x_max":305.5625,"ha":374,"o":"m 169 859 q 197 923 177 894 q 250 953 218 953 q 288 939 272 953 q 305 902 305 925 q 295 857 305 882 q 269 811 284 833 l 120 568 l 90 576 l 169 859 "},"±":{"x_min":169,"x_max":969,"ha":1139,"o":"m 602 549 l 969 549 l 969 482 l 602 482 l 602 247 l 534 247 l 534 482 l 169 482 l 169 549 l 534 549 l 534 779 l 602 779 l 602 549 m 969 33 l 169 33 l 169 100 l 969 100 l 969 33 "},"|":{"x_min":305,"x_max":376,"ha":683,"o":"m 376 448 l 305 448 l 305 956 l 376 956 l 376 448 m 376 -233 l 305 -233 l 305 272 l 376 272 l 376 -233 "},"ϋ":{"x_min":79,"x_max":703,"ha":774,"o":"m 703 395 q 595 110 703 236 q 332 -15 488 -15 q 145 54 211 -15 q 79 244 79 123 l 83 429 q 81 542 83 486 q 79 654 80 598 l 146 650 l 217 654 q 209 502 217 608 q 202 365 202 397 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 132 476 43 q 571 340 571 222 q 548 493 571 418 q 488 645 526 568 q 550 647 529 645 q 627 658 571 650 q 703 395 703 537 m 227 928 q 281 907 259 928 q 304 853 304 886 q 283 800 304 822 q 230 778 262 778 q 175 800 197 778 q 153 853 153 822 q 174 906 153 884 q 227 928 195 928 m 469 928 q 523 906 501 928 q 545 853 545 884 q 524 799 545 821 q 472 778 504 778 q 418 800 440 778 q 396 853 396 822 q 416 905 396 883 q 469 928 437 928 "},"§":{"x_min":64,"x_max":620,"ha":675,"o":"m 114 36 l 128 36 q 198 -76 148 -33 q 319 -120 247 -120 q 430 -78 384 -120 q 476 27 476 -37 q 369 169 476 116 q 170 252 269 210 q 64 419 64 312 q 91 522 64 476 q 171 609 119 568 q 122 739 122 669 q 195 896 122 837 q 369 956 268 956 q 473 940 422 956 q 576 894 523 925 q 559 864 568 882 q 521 775 551 846 l 508 775 q 445 871 483 839 q 343 903 407 903 q 251 867 289 903 q 213 777 213 832 q 318 644 213 694 q 514 563 415 604 q 620 408 620 507 q 592 299 620 348 q 515 213 565 251 q 560 143 544 179 q 576 65 576 108 q 494 -112 576 -46 q 298 -178 412 -178 q 179 -163 239 -178 q 76 -119 120 -148 q 97 -42 86 -89 q 114 36 108 4 m 138 479 q 257 340 138 396 q 478 238 376 285 q 524 285 508 261 q 541 342 541 310 q 384 490 541 423 q 197 587 228 556 q 156 532 175 563 q 138 479 138 501 "},"b":{"x_min":78,"x_max":703,"ha":758,"o":"m 152 1018 q 219 1025 181 1018 q 212 916 214 966 q 210 788 210 866 l 210 755 l 210 555 q 419 672 283 672 q 629 569 555 672 q 703 322 703 466 q 630 79 703 173 q 414 -15 558 -15 q 296 8 350 -15 q 193 79 242 31 q 160 49 175 64 q 120 -1 145 33 l 78 -1 q 87 106 82 43 q 92 213 92 169 l 92 545 q 88 784 92 625 q 85 1025 85 944 q 152 1018 119 1018 m 383 605 q 243 520 285 605 q 202 323 202 435 q 245 133 202 218 q 383 48 288 48 q 522 132 480 48 q 564 326 564 217 q 522 519 564 434 q 383 605 480 605 "},"q":{"x_min":54,"x_max":675,"ha":758,"o":"m 608 -368 q 579 -368 591 -368 q 540 -373 567 -369 q 549 -213 548 -312 q 551 -101 551 -115 l 551 99 q 339 -15 476 -15 q 130 82 207 -15 q 54 316 54 180 q 125 564 54 456 q 333 672 197 672 q 464 636 407 672 q 557 535 520 601 q 546 655 557 594 q 586 649 576 650 q 611 648 597 648 q 674 655 640 648 l 671 433 q 669 163 671 298 q 666 -106 668 27 l 675 -373 q 643 -369 658 -370 q 608 -368 627 -368 m 373 48 q 515 134 473 48 q 557 331 557 220 q 511 514 557 433 q 372 596 466 596 q 234 512 276 596 q 193 322 193 429 q 236 133 193 218 q 373 48 279 48 "},"Ω":{"x_min":8,"x_max":1119.125,"ha":1129,"o":"m 449 0 q 318 4 410 0 q 223 8 227 8 l 10 0 l 13 47 q 11 74 13 59 q 8 95 9 88 q 119 88 69 90 q 249 86 169 86 q 103 261 152 170 q 55 473 55 352 q 200 822 55 694 q 567 950 345 950 q 931 823 791 950 q 1072 473 1072 697 q 1025 261 1072 350 q 878 86 978 173 q 992 91 902 86 q 1119 96 1083 96 l 1114 33 l 1117 0 l 906 8 q 778 4 867 8 q 682 0 688 0 l 682 72 q 864 215 807 122 q 921 451 921 309 q 834 764 921 639 q 565 889 747 889 q 296 767 384 889 q 209 454 209 645 q 268 217 209 319 q 449 72 327 115 l 449 0 "},"ύ":{"x_min":79,"x_max":703,"ha":774,"o":"m 703 395 q 595 110 703 236 q 332 -15 488 -15 q 145 54 211 -15 q 79 244 79 123 l 83 429 q 81 541 83 484 q 79 652 80 597 l 146 648 l 217 652 q 209 502 217 606 q 202 365 202 397 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 132 476 43 q 571 340 571 222 q 548 491 571 416 q 488 644 526 566 q 550 646 529 644 q 627 656 571 648 q 703 395 703 536 m 499 941 q 532 972 517 962 q 568 983 547 983 q 606 967 592 983 q 620 930 620 952 q 605 894 620 910 q 564 865 590 878 l 365 741 l 316 741 l 499 941 "},"Ö":{"x_min":51,"x_max":1069,"ha":1121,"o":"m 51 465 q 191 819 51 688 q 559 950 332 950 q 891 852 750 950 q 1046 659 1031 755 q 1065 535 1062 562 q 1069 462 1069 508 q 1066 395 1069 416 q 1047 275 1063 373 q 894 80 1031 176 q 562 -15 756 -15 q 451 -8 503 -15 q 304 31 399 -2 q 130 187 209 65 q 51 465 51 308 m 439 1208 q 491 1186 470 1208 q 513 1133 513 1164 q 491 1080 513 1103 q 439 1058 470 1058 q 385 1080 409 1058 q 362 1133 362 1102 q 384 1186 362 1164 q 439 1208 407 1208 m 682 1208 q 735 1186 713 1208 q 757 1133 757 1164 q 735 1080 757 1103 q 682 1058 713 1058 q 628 1079 650 1058 q 607 1133 607 1101 q 628 1186 607 1164 q 682 1208 650 1208 m 204 469 q 292 162 204 283 q 559 42 380 42 q 827 162 739 42 q 916 469 916 283 q 825 767 916 648 q 559 887 735 887 q 349 825 430 887 q 226 638 267 763 q 204 469 204 558 "},"z":{"x_min":15.28125,"x_max":606.9375,"ha":647,"o":"m 15 29 q 164 224 88 124 q 302 416 240 323 l 418 586 l 270 586 q 181 581 218 586 q 62 565 145 577 l 68 609 l 62 654 q 181 648 115 650 q 330 646 248 646 l 363 646 l 393 646 q 606 654 500 646 l 606 626 q 453 428 545 549 q 317 246 361 306 q 194 68 273 185 l 343 68 q 456 72 400 68 q 594 86 513 77 l 588 42 l 594 0 l 280 8 q 148 4 237 8 q 15 0 59 0 l 15 29 "},"™":{"x_min":176,"x_max":918,"ha":1139,"o":"m 463 930 l 346 930 l 346 614 l 293 614 l 293 930 l 176 930 l 176 969 l 463 969 l 463 930 m 736 690 l 840 968 l 918 969 l 918 614 l 871 614 l 871 927 l 752 614 l 719 614 l 594 930 l 594 614 l 548 614 l 548 969 l 625 969 l 736 690 "},"ή":{"x_min":91,"x_max":662,"ha":754,"o":"m 594 -365 q 557 -366 577 -365 q 526 -369 537 -368 q 531 -189 526 -310 q 537 -7 537 -68 l 537 406 q 503 536 537 485 q 391 587 469 587 q 255 508 290 587 q 220 315 220 430 q 222 133 220 259 q 224 1 224 8 l 158 6 l 91 1 l 101 156 l 101 495 q 97 584 101 527 q 93 655 93 640 q 119 650 105 652 q 155 648 134 648 q 185 650 175 648 q 221 655 195 651 l 220 538 q 321 637 265 602 q 452 672 378 672 q 604 603 552 672 q 656 430 656 535 l 656 329 l 656 -186 q 659 -293 656 -227 q 662 -370 662 -359 q 630 -366 645 -368 q 594 -365 614 -365 m 481 944 q 515 975 499 965 q 552 986 531 986 q 589 970 575 986 q 603 933 603 955 q 589 898 603 912 q 547 868 575 884 l 348 744 l 298 744 l 481 944 "},"Θ":{"x_min":51,"x_max":1068,"ha":1119,"o":"m 51 465 q 193 820 51 690 q 562 950 335 950 q 893 852 755 950 q 1047 653 1031 755 q 1065 525 1062 551 q 1068 462 1068 500 q 1065 402 1068 426 q 1047 280 1062 379 q 892 83 1033 182 q 560 -15 751 -15 q 435 -7 480 -15 q 299 32 390 0 q 130 187 209 65 q 51 465 51 308 m 202 468 q 290 163 202 283 q 559 43 379 43 q 826 163 738 43 q 915 468 915 283 q 826 770 915 652 q 559 889 738 889 q 254 720 306 889 q 202 468 202 552 m 560 507 q 683 510 608 507 q 768 514 758 514 l 765 465 l 765 429 q 648 432 730 429 q 558 435 566 435 q 440 432 523 435 q 351 429 357 429 l 353 470 l 353 514 q 474 510 400 514 q 560 507 549 507 "},"®":{"x_min":80,"x_max":1058,"ha":1139,"o":"m 816 905 q 992 726 927 841 q 1058 481 1058 611 q 912 138 1058 283 q 567 -6 766 -6 q 225 139 370 -6 q 80 481 80 284 q 224 826 80 681 q 569 971 368 971 q 816 905 698 971 m 569 918 q 263 788 392 918 q 134 481 134 659 q 261 175 134 306 q 566 45 389 45 q 872 174 741 45 q 1004 478 1004 304 q 947 699 1004 596 q 787 859 890 801 q 569 918 684 918 m 815 619 q 776 521 815 562 q 681 468 738 480 l 809 209 l 709 208 l 592 456 l 462 457 l 462 209 l 376 209 l 376 771 l 581 771 q 745 737 676 771 q 815 619 815 704 m 462 714 l 462 513 l 566 513 q 682 532 635 513 q 729 611 729 551 q 681 692 729 671 q 564 714 634 714 l 462 714 "},"É":{"x_min":109,"x_max":614.5625,"ha":685,"o":"m 124 465 q 116 710 124 540 q 109 932 109 880 l 353 929 l 610 929 q 607 904 607 918 q 607 884 607 891 l 610 838 q 407 860 506 860 l 259 860 l 257 670 l 257 530 l 397 530 q 586 542 492 530 q 584 518 584 530 q 584 499 584 506 q 586 450 584 465 q 487 458 542 454 q 393 463 432 463 l 257 463 l 257 318 l 262 74 q 452 77 381 74 q 614 94 524 80 l 613 47 l 614 0 l 356 0 l 109 0 q 116 243 109 72 q 124 465 124 415 m 426 1225 q 461 1255 445 1244 q 499 1267 478 1267 q 536 1251 522 1267 q 549 1212 549 1236 q 533 1176 549 1192 q 492 1147 517 1160 l 292 1024 l 242 1024 l 426 1225 "},"~":{"x_min":284,"x_max":1080,"ha":1368,"o":"m 850 650 q 667 750 761 650 q 511 850 573 850 q 396 793 431 850 q 362 650 362 737 l 284 650 q 339 846 284 768 q 508 924 395 924 q 697 824 606 924 q 853 725 788 725 q 969 779 936 725 q 1002 924 1002 834 l 1080 924 q 1023 727 1080 805 q 850 650 966 650 "},"Ε":{"x_min":108,"x_max":613.5625,"ha":686,"o":"m 126 465 q 122 711 126 620 q 108 932 119 802 l 353 928 l 610 931 l 606 884 l 610 836 q 508 853 562 847 q 408 860 453 860 l 260 860 l 258 671 l 258 528 l 398 528 q 587 541 480 528 l 584 497 l 587 451 l 394 463 l 258 463 l 258 316 l 264 73 q 456 76 380 73 q 613 94 531 80 l 610 47 l 613 0 l 358 4 l 108 0 q 117 239 108 70 q 126 465 126 408 "},"³":{"x_min":48,"x_max":424,"ha":496,"o":"m 159 636 l 156 663 q 178 661 167 661 q 200 661 189 661 q 280 690 248 661 q 312 767 312 719 q 212 869 312 869 q 143 846 168 869 q 107 781 117 823 l 102 779 q 84 812 93 795 q 66 845 75 830 q 134 886 98 871 q 212 901 171 901 q 341 873 284 901 q 398 778 398 845 q 355 691 398 724 q 252 643 313 658 q 373 610 322 643 q 424 509 424 577 q 353 385 424 427 q 196 343 283 343 q 48 373 117 343 q 57 422 52 391 q 66 469 63 454 l 75 469 q 120 399 88 425 q 199 374 153 374 q 294 409 254 374 q 334 499 334 444 q 299 588 334 553 q 207 623 264 623 q 179 620 193 623 q 156 617 166 618 l 159 636 "},"[":{"x_min":116,"x_max":364.609375,"ha":449,"o":"m 127 2 l 127 386 l 127 769 l 116 932 l 235 929 l 364 929 l 363 908 l 363 872 q 263 880 313 880 l 216 880 l 216 387 l 216 -105 l 264 -105 q 329 -102 308 -105 q 364 -98 351 -99 l 363 -123 l 363 -158 l 237 -154 l 116 -158 q 121 -81 116 -138 q 127 2 127 -24 "},"L":{"x_min":108,"x_max":627.453125,"ha":629,"o":"m 126 465 q 122 712 126 621 q 108 932 119 803 q 149 930 126 932 q 188 926 173 927 q 233 929 202 926 q 268 932 265 932 q 263 797 268 883 q 258 684 258 711 q 261 332 258 577 q 264 73 264 86 l 402 73 q 512 78 458 73 q 627 94 566 84 l 624 47 l 627 0 l 358 4 l 108 0 q 117 239 108 70 q 126 465 126 408 "},"σ":{"x_min":41,"x_max":802.109375,"ha":806,"o":"m 625 644 l 802 651 l 797 611 l 802 566 l 626 573 q 690 464 671 527 q 710 327 710 402 q 616 81 710 177 q 371 -15 522 -15 q 131 78 222 -15 q 41 322 41 172 q 131 572 41 472 q 371 672 221 672 q 439 665 403 672 q 508 653 475 659 q 569 645 541 646 q 625 644 597 644 m 376 619 q 226 530 272 619 q 181 326 181 442 q 224 124 181 213 q 369 35 268 35 q 522 123 474 35 q 570 326 570 211 q 524 529 570 440 q 376 619 479 619 "},"ζ":{"x_min":75,"x_max":675,"ha":683,"o":"m 642 987 l 642 949 q 425 760 524 860 q 260 545 326 661 q 194 303 194 428 q 194 278 194 289 q 202 215 194 267 q 335 141 210 163 q 558 116 447 128 q 675 -7 675 91 q 643 -109 675 -65 q 544 -232 612 -154 l 500 -205 q 565 -113 555 -131 q 576 -66 576 -94 q 552 -20 576 -37 q 292 22 509 2 q 75 240 75 41 q 143 487 75 357 q 297 719 212 616 q 508 949 383 821 l 359 949 q 252 945 301 949 q 130 933 204 941 l 134 977 l 130 1025 q 272 1021 186 1025 q 372 1018 358 1018 q 526 1021 429 1018 q 643 1025 623 1025 l 642 987 "},"θ":{"x_min":48,"x_max":699,"ha":749,"o":"m 375 909 q 621 773 544 909 q 699 456 699 638 q 627 118 699 255 q 372 -19 556 -19 q 120 114 193 -19 q 48 444 48 247 q 122 773 48 638 q 375 909 196 909 m 184 383 q 221 136 184 242 q 374 31 259 31 q 534 137 505 31 q 564 424 564 244 l 408 428 l 184 423 l 184 383 m 371 858 q 257 804 300 858 q 196 673 214 751 q 186 581 189 630 q 184 483 184 532 l 322 478 q 461 480 364 478 q 564 483 558 483 q 528 747 564 637 q 371 858 493 858 "},"Ο":{"x_min":51,"x_max":1068,"ha":1119,"o":"m 51 465 q 192 820 51 690 q 559 950 333 950 q 892 853 754 950 q 1047 654 1031 757 q 1065 525 1062 551 q 1068 462 1068 500 q 1065 402 1068 426 q 1047 277 1062 379 q 894 80 1031 175 q 560 -15 756 -15 q 447 -10 496 -15 q 304 29 398 -5 q 130 186 210 64 q 51 465 51 308 m 202 468 q 290 162 202 282 q 559 42 379 42 q 826 162 738 42 q 915 468 915 283 q 825 770 915 651 q 559 889 735 889 q 348 826 429 889 q 225 639 267 764 q 202 468 202 552 "},"Γ":{"x_min":108,"x_max":627.453125,"ha":629,"o":"m 448 932 l 627 932 q 623 902 624 921 q 621 874 621 883 l 627 836 q 402 863 512 863 l 264 863 q 261 586 264 779 q 258 379 258 393 q 263 181 258 313 q 268 0 268 48 l 187 5 l 108 0 q 121 209 117 106 q 126 427 126 311 q 117 686 126 504 q 108 932 108 869 l 448 932 "}," ":{"x_min":0,"x_max":0,"ha":375},"%":{"x_min":28,"x_max":1011,"ha":1032,"o":"m 799 0 q 647 62 708 0 q 586 218 586 124 q 647 372 586 309 q 799 436 709 436 q 949 373 888 436 q 1011 223 1011 311 q 995 130 1011 176 q 918 35 972 70 q 799 0 865 0 m 863 1015 l 227 -125 l 158 -125 l 793 1015 l 863 1015 m 241 451 q 89 513 150 451 q 28 668 28 576 q 89 823 28 759 q 241 888 150 888 q 391 825 330 888 q 453 673 453 762 q 434 581 453 623 q 359 486 412 521 q 241 451 307 451 m 897 260 q 872 353 897 310 q 798 397 847 397 q 718 340 737 397 q 700 202 700 283 q 719 86 700 133 q 798 40 738 40 q 866 73 840 40 q 892 149 892 106 q 895 206 894 169 q 897 260 897 242 m 339 689 q 312 812 339 775 q 240 849 285 849 q 160 788 179 849 q 141 648 141 728 q 164 541 141 590 q 240 493 188 493 q 307 527 281 493 q 334 602 334 561 q 339 689 339 641 "},"P":{"x_min":109,"x_max":722,"ha":736,"o":"m 127 559 q 109 931 127 759 l 231 927 q 337 931 270 927 q 416 935 403 935 q 632 874 543 935 q 722 694 722 814 q 616 493 722 564 q 371 422 510 422 l 252 422 q 257 200 252 348 q 262 0 262 52 q 224 3 249 0 q 185 8 199 8 q 147 5 168 8 q 109 0 127 2 q 118 287 109 85 q 127 559 127 488 m 576 684 q 515 826 576 773 q 364 879 455 879 l 262 875 q 254 781 257 827 q 252 688 252 735 l 252 476 q 507 530 439 476 q 576 684 576 584 "},"Ώ":{"x_min":-1,"x_max":1355.953125,"ha":1365,"o":"m 685 0 q 555 4 646 0 q 460 8 464 8 l 247 0 l 250 47 q 248 74 250 59 q 244 95 246 88 q 355 88 305 90 q 486 86 405 86 q 340 261 389 170 q 292 473 292 352 q 437 822 292 694 q 804 950 582 950 q 1168 823 1028 950 q 1309 473 1309 697 q 1262 261 1309 350 q 1115 86 1215 173 q 1229 91 1139 86 q 1355 96 1319 96 l 1351 33 l 1354 0 l 1143 8 q 1014 4 1104 8 q 918 0 924 0 l 918 72 q 1100 215 1043 122 q 1158 451 1158 309 q 1071 764 1158 639 q 802 889 984 889 q 533 767 621 889 q 446 454 446 645 q 505 217 446 319 q 685 72 564 115 l 685 0 m 182 943 q 215 974 200 964 q 251 985 230 985 q 289 969 274 985 q 304 932 304 954 q 290 896 304 911 q 247 866 275 882 l 48 743 l -1 743 l 182 943 "},"Έ":{"x_min":-1.390625,"x_max":920.015625,"ha":992,"o":"m 432 465 q 428 711 432 620 q 414 932 425 802 l 660 928 l 917 932 l 912 884 l 917 836 q 814 853 868 847 q 714 860 760 860 l 567 860 l 564 671 l 564 528 l 704 528 q 893 541 786 528 l 890 497 l 893 451 l 700 462 l 564 462 l 564 317 l 570 74 q 762 77 686 74 q 920 94 838 80 l 917 47 l 920 0 l 664 4 l 414 0 q 423 239 414 70 q 432 465 432 408 m 181 943 q 215 974 200 964 q 251 985 230 985 q 288 969 273 985 q 304 932 304 954 q 289 896 304 911 q 247 866 275 882 l 47 743 l -1 743 l 181 943 "},"_":{"x_min":0,"x_max":683.328125,"ha":683,"o":"m 683 -322 l 0 -322 l 0 -256 l 683 -256 l 683 -322 "},"Ϊ":{"x_min":-3,"x_max":388,"ha":386,"o":"m 126 465 q 118 710 126 540 q 111 932 111 880 q 156 929 123 932 q 192 926 190 926 q 238 929 205 926 q 276 932 271 932 q 265 697 276 863 q 255 465 255 530 q 265 230 255 397 q 276 0 276 63 q 233 3 260 0 q 192 8 205 8 q 153 5 176 8 q 111 0 131 2 q 118 243 111 72 q 126 465 126 415 m 73 1208 q 124 1186 102 1208 q 146 1133 146 1164 q 123 1081 146 1105 q 73 1058 101 1058 q 19 1080 42 1058 q -3 1133 -3 1103 q 19 1185 -3 1163 q 73 1208 41 1208 m 313 1208 q 366 1186 344 1208 q 388 1133 388 1164 q 365 1080 388 1103 q 313 1058 342 1058 q 260 1080 283 1058 q 238 1133 238 1103 q 260 1185 238 1163 q 313 1208 282 1208 "},"+":{"x_min":169,"x_max":970,"ha":1139,"o":"m 603 441 l 970 441 l 970 374 l 603 374 l 603 0 l 536 0 l 536 374 l 169 374 l 169 441 l 536 441 l 536 816 l 603 816 l 603 441 "},"½":{"x_min":83,"x_max":1094.125,"ha":1172,"o":"m 250 743 l 245 836 q 181 804 205 818 q 120 768 156 791 q 104 788 117 775 q 83 808 91 801 q 200 851 141 825 q 327 913 259 877 l 336 911 q 331 724 336 850 q 326 551 326 598 l 326 391 q 301 394 319 391 q 280 397 283 397 q 254 394 271 397 q 233 391 238 391 q 246 551 242 473 q 250 743 250 629 m 859 1015 l 929 1015 l 312 -124 l 243 -124 l 859 1015 m 982 363 q 959 443 982 413 q 887 478 936 473 q 821 458 852 478 q 784 407 790 439 l 778 377 l 773 376 q 728 448 753 416 q 899 513 801 513 q 1019 476 967 513 q 1072 374 1072 439 q 955 189 1072 285 q 806 67 838 93 l 978 67 q 1094 79 1039 67 q 1090 63 1092 76 q 1088 41 1088 49 q 1094 3 1088 18 q 981 3 1056 3 q 867 3 906 3 q 791 3 842 3 q 714 3 739 3 l 714 25 q 913 198 844 125 q 982 363 982 270 "},"Ρ":{"x_min":109,"x_max":722,"ha":736,"o":"m 127 559 q 109 931 127 759 l 231 927 q 337 931 270 927 q 416 935 403 935 q 632 874 543 935 q 722 694 722 814 q 616 493 722 564 q 371 422 510 422 l 252 422 q 257 200 252 348 q 262 0 262 52 q 224 3 249 0 q 185 8 199 8 q 147 5 168 8 q 109 0 127 2 q 118 287 109 85 q 127 559 127 488 m 576 684 q 515 826 576 773 q 364 879 455 879 l 262 875 q 254 781 257 827 q 252 688 252 735 l 252 476 q 507 530 439 476 q 576 684 576 584 "},"\'":{"x_min":88.890625,"x_max":306.9375,"ha":374,"o":"m 169 858 q 196 923 177 896 q 250 951 215 951 q 289 937 272 951 q 306 903 306 923 q 295 858 306 883 q 269 812 284 833 l 122 568 l 88 576 l 169 858 "},"T":{"x_min":11,"x_max":713,"ha":725,"o":"m 11 839 l 15 884 l 11 932 q 194 927 72 932 q 361 922 316 922 q 544 927 421 922 q 713 932 668 932 q 707 883 707 911 q 707 861 707 870 q 713 834 707 852 q 609 850 666 843 q 504 857 552 857 l 428 857 q 426 767 428 830 q 424 701 424 704 l 428 220 q 442 0 428 122 q 362 8 401 3 q 323 5 344 8 q 282 0 301 2 q 289 132 282 40 q 296 259 296 225 l 296 683 l 296 857 q 11 839 164 857 "},"Φ":{"x_min":50,"x_max":1068,"ha":1119,"o":"m 637 -25 q 559 -15 591 -15 q 527 -17 544 -15 q 483 -25 509 -19 l 487 68 q 181 179 313 68 q 50 465 50 291 q 172 744 50 647 q 487 865 295 842 l 483 958 q 522 952 502 955 q 559 950 543 950 q 596 952 576 950 q 637 958 616 955 l 631 865 q 942 758 816 865 q 1068 465 1068 651 q 944 184 1068 286 q 631 68 820 83 l 637 -25 m 501 502 q 497 677 501 570 q 494 800 494 784 q 278 698 354 786 q 203 466 203 611 q 282 231 203 331 q 494 132 361 132 q 497 363 494 225 q 501 502 501 501 m 915 466 q 839 706 915 612 q 626 800 764 800 q 622 636 626 738 q 618 470 618 533 q 622 301 618 408 q 626 132 626 194 q 839 226 764 132 q 915 466 915 320 "},"j":{"x_min":-55,"x_max":248,"ha":342,"o":"m 113 391 q 106 543 113 444 q 100 654 100 641 q 144 648 135 648 q 167 648 153 648 q 202 649 189 648 q 241 654 214 650 q 237 507 241 595 q 234 405 234 419 l 234 -13 l 234 -109 q 154 -303 234 -234 q -55 -372 74 -372 l -55 -333 q 78 -267 44 -323 q 113 -103 113 -212 l 113 -26 l 113 391 m 171 963 q 226 940 205 963 q 248 881 248 917 q 226 831 248 849 q 171 813 204 813 q 116 833 139 813 q 94 885 94 853 q 115 941 94 919 q 171 963 136 963 "},"Σ":{"x_min":44.4375,"x_max":790.28125,"ha":825,"o":"m 729 883 l 733 835 q 272 855 519 855 q 544 500 391 691 q 372 312 446 399 q 219 119 297 224 l 455 119 q 638 124 522 119 q 790 129 755 129 l 784 86 l 783 68 l 784 42 q 785 25 784 33 q 790 0 786 17 q 558 4 694 0 q 416 8 422 8 q 230 4 350 8 q 44 0 111 0 l 44 50 q 169 182 105 109 q 307 344 232 255 l 406 468 q 242 689 314 594 q 76 899 170 785 l 76 932 q 231 929 123 932 q 345 926 340 926 q 568 929 412 926 q 733 932 723 932 l 729 883 "},"1":{"x_min":72,"x_max":472,"ha":749,"o":"m 334 626 q 331 722 334 655 q 329 793 329 788 q 228 737 278 765 q 133 673 177 709 q 102 713 124 688 q 72 743 80 737 q 274 827 177 780 q 458 935 372 875 l 472 929 q 463 552 472 804 q 455 259 455 300 l 459 0 q 421 5 441 2 q 384 8 401 8 q 349 5 367 8 q 312 0 330 2 q 329 289 324 133 q 334 626 334 445 "},"ä":{"x_min":43,"x_max":655.5,"ha":649,"o":"m 234 -15 q 98 33 153 -15 q 43 162 43 82 q 106 303 43 273 q 303 364 169 333 q 444 448 437 395 q 403 568 444 521 q 288 616 362 616 q 191 587 233 616 q 124 507 149 559 l 95 520 l 104 591 q 202 651 144 631 q 323 672 261 672 q 500 622 444 672 q 557 455 557 573 l 557 133 q 567 69 557 84 q 618 54 577 54 q 655 58 643 54 l 655 26 q 594 5 626 14 q 537 -6 562 -3 q 438 85 453 -6 q 342 10 388 35 q 234 -15 296 -15 m 203 929 q 254 906 232 929 q 277 854 277 884 q 256 799 277 820 q 204 778 236 778 q 149 800 173 778 q 126 854 126 822 q 148 906 126 884 q 203 929 170 929 m 444 929 q 498 906 476 929 q 521 854 521 884 q 500 800 521 822 q 447 778 479 778 q 392 800 415 778 q 370 854 370 823 q 392 906 370 884 q 444 929 414 929 m 176 186 q 204 98 176 133 q 284 64 232 64 q 390 107 342 64 q 438 212 438 151 l 438 345 q 239 293 303 319 q 176 186 176 268 "},"<":{"x_min":176,"x_max":961.109375,"ha":1139,"o":"m 279 406 l 960 130 l 961 56 l 176 379 l 176 432 l 960 756 l 960 682 l 279 406 "},"£":{"x_min":65,"x_max":728.890625,"ha":749,"o":"m 67 47 l 65 98 l 116 101 q 203 168 176 112 q 231 292 231 224 q 227 375 231 330 q 221 444 223 420 q 139 441 171 444 q 76 432 107 439 l 78 479 l 76 503 q 105 495 92 498 q 134 493 117 493 l 219 493 q 212 550 214 522 q 209 609 209 578 q 304 825 209 742 q 537 909 399 909 q 633 896 592 909 q 723 864 673 884 q 666 731 694 809 l 656 731 q 605 825 641 791 q 512 859 570 859 q 383 796 427 859 q 340 646 340 734 l 345 493 l 366 493 q 523 502 450 493 l 521 466 l 526 434 q 438 441 493 439 q 345 444 383 444 l 345 378 q 310 238 345 302 q 213 107 275 173 q 527 113 421 107 q 728 134 633 119 l 721 66 q 728 0 721 34 q 542 3 666 0 q 358 8 419 8 q 176 3 285 8 q 65 0 67 0 l 67 47 "},"¹":{"x_min":82,"x_max":347,"ha":496,"o":"m 255 731 l 255 833 l 123 759 q 104 780 120 763 q 82 801 87 797 q 208 850 148 822 q 337 917 269 878 l 347 912 q 341 721 347 848 q 336 529 336 593 l 336 356 q 311 358 327 356 q 289 361 295 361 q 264 358 280 361 q 242 356 248 356 q 251 498 247 407 q 255 731 255 590 "},"t":{"x_min":18,"x_max":415.21875,"ha":425,"o":"m 18 586 l 22 630 l 18 654 q 133 643 80 643 q 131 732 133 669 q 129 799 129 796 q 199 827 163 811 q 263 863 234 843 q 252 758 255 811 q 250 643 250 705 q 334 645 310 643 q 401 654 358 647 l 398 618 l 401 586 q 248 594 323 594 l 243 258 l 243 162 q 272 76 243 109 q 353 43 301 43 q 387 44 369 43 q 415 48 405 46 l 415 4 q 349 -10 378 -5 q 290 -15 319 -15 q 174 18 221 -15 q 123 118 128 51 l 123 200 l 129 387 l 133 594 q 84 592 113 594 q 18 586 55 590 "},"λ":{"x_min":2.78125,"x_max":652.78125,"ha":657,"o":"m 302 670 q 227 871 262 803 q 111 940 193 940 q 78 937 94 940 q 20 924 62 934 l 20 978 q 96 1012 59 1000 q 170 1025 133 1025 q 329 947 287 1025 q 427 692 372 869 q 538 340 481 515 q 652 1 594 166 l 579 5 l 504 0 q 336 573 423 305 q 218 301 272 438 q 111 0 163 163 l 61 6 q 27 3 48 6 q 2 0 5 0 q 302 670 165 329 "},"ù":{"x_min":90,"x_max":664,"ha":754,"o":"m 653 498 q 653 329 653 443 q 653 158 653 215 q 664 0 653 81 q 631 3 647 1 q 598 5 616 5 q 563 3 583 5 q 533 0 544 1 l 538 118 q 440 18 494 52 q 312 -15 385 -15 q 148 50 201 -15 q 96 229 96 115 l 96 354 l 96 516 l 90 655 q 120 650 103 651 q 158 648 136 648 q 192 650 175 648 q 227 655 210 651 q 220 445 227 591 q 213 247 213 299 q 247 115 213 163 q 362 68 281 68 q 477 113 428 68 q 531 217 525 159 q 538 340 538 274 q 533 520 538 394 q 528 655 528 647 q 561 650 548 651 q 596 648 574 648 q 663 655 628 648 q 653 498 653 573 m 445 743 l 244 866 q 205 896 223 877 q 187 934 187 915 q 202 970 187 955 q 238 986 217 986 q 277 973 256 986 q 309 945 298 961 l 496 743 l 445 743 "},"W":{"x_min":0,"x_max":1306.953125,"ha":1307,"o":"m 0 932 q 47 927 31 929 q 76 926 62 926 q 121 929 88 926 q 155 931 154 931 q 262 547 200 750 l 380 171 q 470 437 415 272 q 552 693 525 602 q 619 931 580 784 l 672 926 q 700 928 684 926 q 726 931 716 930 q 825 604 787 727 q 883 419 862 482 q 969 171 904 357 l 1087 522 q 1143 720 1120 623 q 1187 931 1166 816 q 1221 929 1197 931 q 1247 926 1245 926 q 1280 928 1262 926 q 1306 931 1298 930 q 1131 467 1218 716 q 990 0 1045 217 q 963 4 980 1 q 937 7 947 7 q 904 3 925 7 q 880 0 883 0 q 761 385 831 184 l 641 733 l 491 287 q 402 0 438 133 q 370 3 391 0 q 344 7 350 7 q 315 4 327 7 q 287 0 302 2 q 206 296 252 142 q 122 568 161 450 q 0 932 83 686 "},"ï":{"x_min":-25,"x_max":365.328125,"ha":340,"o":"m 104 144 l 104 522 l 97 655 q 138 650 113 651 q 167 648 162 648 q 233 655 206 648 q 225 506 225 581 q 229 254 225 423 q 233 0 233 84 q 201 3 216 1 q 164 5 186 5 q 128 3 143 5 q 97 0 113 1 l 104 144 m 50 929 q 102 906 80 929 q 125 854 125 884 q 104 799 125 820 q 52 778 84 778 q -2 800 19 778 q -25 854 -25 822 q -4 906 -25 884 q 50 929 16 929 m 290 929 q 343 906 320 929 q 365 854 365 884 q 345 799 365 820 q 294 778 324 778 q 238 800 260 778 q 216 854 216 822 q 237 906 216 884 q 290 929 258 929 "},">":{"x_min":176.390625,"x_max":963,"ha":1139,"o":"m 963 379 l 176 56 l 176 130 l 858 406 l 176 682 l 176 756 l 962 432 l 963 379 "},"v":{"x_min":0,"x_max":658.328125,"ha":654,"o":"m 0 655 q 54 648 38 648 q 86 647 69 647 q 113 647 100 647 q 168 654 127 648 q 252 402 204 529 l 358 134 l 470 436 q 543 654 508 533 q 570 650 554 651 q 600 648 586 648 q 636 648 618 648 q 658 654 652 652 q 506 340 577 502 q 372 0 436 177 q 347 5 362 2 q 319 8 333 8 q 296 5 309 8 q 272 0 283 2 q 200 206 234 120 q 0 655 165 292 "},"τ":{"x_min":30,"x_max":677,"ha":701,"o":"m 423 573 l 419 303 q 423 146 419 250 q 428 0 428 42 q 394 4 410 2 q 359 5 378 5 q 333 4 343 5 q 289 0 323 4 l 298 194 l 294 573 q 156 553 207 573 q 57 472 105 534 q 30 559 49 522 q 149 626 82 609 q 307 644 216 644 l 510 644 q 604 647 545 644 q 677 651 664 651 l 671 610 q 677 566 671 586 q 527 569 618 566 q 423 573 436 573 "},"û":{"x_min":90,"x_max":664,"ha":754,"o":"m 653 498 q 653 328 653 442 q 653 158 653 215 q 664 0 653 81 q 631 3 647 1 q 598 5 616 5 q 563 3 583 5 q 533 0 544 1 l 538 118 q 440 18 494 52 q 312 -15 385 -15 q 148 50 201 -15 q 96 229 96 115 l 96 354 l 96 516 l 90 655 q 120 650 103 651 q 158 648 136 648 q 192 649 175 648 q 227 655 210 651 q 220 445 227 591 q 213 247 213 299 q 247 115 213 163 q 362 68 281 68 q 477 113 428 68 q 531 217 525 159 q 538 340 538 274 q 533 520 538 394 q 528 655 528 647 q 558 650 542 651 q 596 648 574 648 q 629 649 612 648 q 663 655 646 651 q 653 498 653 573 m 332 978 l 421 978 l 572 743 l 525 743 l 376 875 l 227 743 l 180 743 l 332 978 "},"ξ":{"x_min":64,"x_max":654,"ha":656,"o":"m 562 861 q 502 941 539 911 q 414 972 465 972 q 299 917 342 972 q 256 788 256 862 q 312 650 256 701 q 458 599 369 599 l 526 599 l 524 563 l 524 528 q 480 533 503 532 q 427 535 457 535 q 271 494 337 535 q 197 408 205 454 q 187 347 188 361 q 186 326 186 333 q 186 294 186 300 q 190 282 187 287 q 238 200 201 229 q 335 153 276 171 l 494 118 q 610 73 567 100 q 654 -13 654 46 q 628 -103 654 -60 q 511 -238 602 -146 l 466 -210 q 541 -121 530 -139 q 553 -75 553 -103 q 393 16 553 -18 q 149 92 234 50 q 64 276 64 133 q 130 462 64 379 q 299 575 197 544 q 175 652 222 600 q 128 780 128 704 q 213 954 128 883 q 405 1025 298 1025 q 507 1009 458 1025 q 609 965 555 994 q 585 914 600 945 q 562 861 571 883 "},"&":{"x_min":76,"x_max":917.671875,"ha":975,"o":"m 360 -18 q 160 41 245 -18 q 76 211 76 101 q 137 382 76 315 q 314 515 199 448 q 249 618 273 569 q 225 722 225 668 q 287 872 225 812 q 441 932 349 932 q 581 891 520 932 q 643 777 643 851 q 588 640 643 701 q 453 532 533 579 q 568 390 509 459 q 690 253 627 321 q 815 530 792 379 l 829 530 l 887 466 q 814 327 856 396 q 727 209 772 259 q 807 115 760 169 q 917 0 853 61 q 855 1 896 0 q 791 2 813 2 l 739 0 l 649 110 q 515 15 586 48 q 360 -18 445 -18 m 341 475 q 234 380 267 419 q 201 273 201 340 q 258 125 201 190 q 401 61 316 61 q 508 86 458 61 q 606 154 559 111 l 341 475 m 547 770 q 524 854 547 823 q 454 886 502 886 q 363 851 402 886 q 325 769 325 817 q 344 685 325 718 q 422 575 363 652 q 514 661 481 615 q 547 770 547 708 "},"Λ":{"x_min":0,"x_max":852.78125,"ha":853,"o":"m 662 452 l 778 172 l 852 0 l 769 5 q 734 4 747 5 q 679 0 722 4 q 647 102 661 55 q 605 226 633 148 l 547 383 l 401 777 l 266 429 q 191 213 226 319 q 125 0 157 108 l 62 2 l 0 0 q 205 459 95 191 q 380 932 315 726 q 404 927 393 929 q 431 926 416 926 q 459 929 441 926 q 487 932 477 932 q 548 743 511 850 q 662 452 586 637 "},"I":{"x_min":109,"x_max":271,"ha":385,"o":"m 127 465 q 123 711 127 620 q 109 932 120 803 q 154 927 129 929 q 190 925 179 925 q 238 928 209 925 q 271 931 266 931 q 263 788 271 887 q 256 659 256 690 l 256 448 l 256 283 q 263 135 256 238 q 271 0 271 31 q 231 3 258 0 q 190 8 204 8 q 151 5 172 8 q 109 0 129 2 q 118 239 109 70 q 127 465 127 408 "},"G":{"x_min":51,"x_max":942,"ha":1001,"o":"m 581 -15 q 198 107 345 -15 q 51 459 51 229 q 196 815 51 680 q 566 950 342 950 q 755 929 659 950 q 930 869 852 909 q 906 802 916 836 q 895 737 897 769 l 874 737 q 739 855 808 818 q 571 893 670 893 q 305 770 406 893 q 204 479 204 647 q 298 168 204 291 q 577 46 393 46 q 689 56 640 46 q 790 94 738 66 q 794 184 790 123 q 798 251 798 246 q 794 337 798 280 q 790 423 790 394 q 830 417 821 418 q 863 416 838 416 q 901 419 880 416 q 941 425 923 422 l 936 236 q 939 121 936 201 q 942 37 942 41 q 757 -1 843 11 q 581 -15 672 -15 "},"ΰ":{"x_min":79,"x_max":703,"ha":774,"o":"m 703 395 q 595 110 703 236 q 332 -15 488 -15 q 145 54 211 -15 q 79 244 79 123 l 83 430 q 81 542 83 486 q 79 654 80 598 l 146 650 l 217 654 q 209 502 217 608 q 202 365 202 397 l 202 261 q 240 105 202 168 q 369 43 279 43 q 523 132 476 43 q 571 340 571 222 q 548 493 571 418 q 488 645 526 568 q 550 647 529 645 q 627 658 571 650 q 703 395 703 537 m 209 865 q 250 846 232 865 q 269 804 269 828 q 251 761 269 780 q 209 743 234 743 q 166 761 184 743 q 148 804 148 779 q 166 846 148 828 q 209 865 184 865 m 361 929 q 378 969 368 956 q 414 982 388 982 q 458 941 458 982 q 446 904 458 919 l 338 743 l 306 743 l 361 929 m 513 865 q 555 846 537 865 q 573 804 573 828 q 555 761 573 779 q 513 743 537 743 q 470 761 487 743 q 454 804 454 779 q 470 846 454 828 q 513 865 487 865 "},"`":{"x_min":86.5,"x_max":303.171875,"ha":374,"o":"m 222 659 q 194 595 214 622 q 140 568 175 568 q 86 613 86 568 q 96 660 86 636 q 122 706 107 684 l 271 950 l 303 940 l 222 659 "},"Υ":{"x_min":-28,"x_max":746,"ha":707,"o":"m 297 177 l 297 386 q 191 570 256 458 q 84 750 125 682 q -28 932 42 819 q 24 928 -9 932 q 63 925 59 925 q 112 927 91 925 q 146 932 134 930 q 207 800 174 866 q 275 676 239 735 l 389 475 q 509 688 451 575 q 627 932 567 801 l 683 926 q 715 927 701 926 q 746 932 729 929 q 555 627 640 769 l 432 415 l 432 240 q 435 101 432 198 q 438 0 438 5 q 401 4 426 1 q 361 6 376 6 q 319 4 334 6 q 284 0 304 2 q 292 88 288 36 q 297 177 297 140 "},"r":{"x_min":89,"x_max":465.390625,"ha":488,"o":"m 99 120 l 99 400 l 99 433 q 91 654 99 548 q 125 648 114 650 q 162 647 136 647 q 232 654 195 647 q 223 588 226 626 q 220 516 220 550 q 313 628 264 589 q 437 668 362 668 l 465 668 l 459 604 l 465 537 q 427 544 448 541 q 383 551 407 548 q 256 482 292 551 q 220 312 220 413 q 222 131 220 256 q 225 0 225 6 l 157 6 l 89 0 l 99 120 "},"x":{"x_min":1,"x_max":635,"ha":632,"o":"m 264 316 l 158 461 q 78 563 120 508 q 5 655 36 619 q 97 647 51 647 q 141 649 120 647 q 177 654 162 651 q 249 538 214 592 q 334 415 284 484 q 420 533 377 473 q 501 654 464 592 q 523 650 508 652 q 550 647 539 648 q 616 654 582 647 l 371 365 q 477 210 434 267 q 635 0 519 152 q 587 3 616 0 q 551 6 558 6 q 501 4 523 6 q 465 0 479 1 q 380 140 407 98 q 295 264 352 183 q 172 84 194 117 q 123 0 151 51 l 66 5 q 33 2 55 5 q 1 0 10 0 q 131 154 63 72 q 264 316 199 236 "},"è":{"x_min":40,"x_max":646.9375,"ha":681,"o":"m 407 42 q 602 130 523 42 l 621 130 q 613 93 617 112 q 609 47 609 73 q 496 0 558 14 q 369 -15 435 -15 q 130 73 220 -15 q 40 311 40 162 q 126 562 40 456 q 355 669 212 669 q 564 590 481 669 q 646 386 646 512 l 644 331 q 438 333 562 331 q 313 335 315 335 l 179 331 q 235 127 179 212 q 407 42 291 42 m 407 743 l 208 866 q 166 895 183 880 q 149 934 149 911 q 167 967 149 949 q 202 986 185 986 q 243 969 220 986 q 273 945 266 952 l 457 743 l 407 743 m 513 392 l 513 437 q 470 563 513 509 q 356 618 427 618 q 233 552 271 618 q 183 390 195 487 l 513 392 "},"μ":{"x_min":84,"x_max":669.109375,"ha":754,"o":"m 331 -15 q 265 -7 292 -15 q 210 19 238 0 l 208 -128 q 211 -266 208 -178 q 214 -373 214 -354 q 183 -369 198 -370 q 150 -368 168 -368 q 114 -370 133 -368 q 84 -373 95 -372 q 89 -165 84 -304 q 94 43 94 -26 q 89 363 94 149 q 84 655 84 578 q 150 647 118 647 q 219 654 180 647 q 213 495 219 601 q 208 334 208 390 q 232 155 208 227 q 339 75 256 83 q 471 112 419 75 q 531 212 523 150 q 539 332 539 273 q 536 518 539 388 q 533 655 533 648 q 600 647 568 647 q 669 654 629 647 q 660 477 662 566 q 658 257 658 389 q 660 113 658 171 q 669 -1 662 55 l 602 4 l 537 -1 l 539 106 q 449 17 502 50 q 331 -15 397 -15 "},"÷":{"x_min":169,"x_max":969,"ha":1139,"o":"m 641 643 q 618 593 641 615 q 566 571 596 571 q 518 592 538 571 q 498 643 498 613 q 518 692 498 670 q 567 715 539 715 q 610 703 579 715 q 641 643 641 691 m 969 374 l 169 374 l 169 441 l 969 441 l 969 374 m 641 170 q 619 120 641 141 q 570 100 598 100 q 519 120 540 100 q 498 170 498 141 q 518 221 498 199 q 568 243 538 243 q 604 235 584 243 q 632 214 624 227 q 641 170 641 201 "},"h":{"x_min":92,"x_max":665,"ha":758,"o":"m 102 136 l 102 859 q 100 934 102 894 q 94 1025 98 975 q 136 1018 126 1019 q 158 1018 146 1018 q 226 1025 188 1018 q 222 957 223 1001 q 221 888 221 913 l 221 868 l 221 543 q 322 637 264 602 q 450 672 380 672 q 608 606 558 672 q 659 429 659 541 l 659 298 l 659 136 l 665 0 q 633 3 648 1 q 597 5 617 5 q 560 3 580 5 q 529 0 540 1 q 534 202 529 68 q 540 405 540 337 q 503 533 540 481 q 394 586 467 586 q 256 508 291 586 q 221 313 221 430 q 224 133 221 244 q 227 0 227 22 q 188 3 211 0 q 161 6 164 6 q 123 4 137 6 q 92 0 108 2 l 102 136 "},".":{"x_min":100,"x_max":274,"ha":374,"o":"m 187 156 q 248 130 223 156 q 274 68 274 105 q 248 8 274 32 q 187 -15 223 -15 q 125 8 150 -15 q 100 68 100 32 q 125 130 100 105 q 187 156 150 156 "},"φ":{"x_min":39,"x_max":965,"ha":1006,"o":"m 578 -371 q 505 -362 539 -362 q 465 -365 483 -362 q 427 -372 446 -368 q 433 -163 427 -298 q 440 -11 440 -29 q 156 76 274 -11 q 39 327 39 163 q 145 571 39 486 q 410 656 252 656 q 412 635 411 645 q 413 615 413 625 q 235 516 292 580 q 179 327 179 451 q 247 118 179 197 q 442 39 316 39 l 444 197 l 444 311 q 444 400 444 340 q 444 491 444 461 q 514 619 452 570 q 657 668 577 668 q 879 568 794 668 q 965 332 965 469 q 850 84 965 169 q 563 -14 735 0 q 570 -203 563 -71 q 578 -371 578 -334 m 826 347 q 794 534 826 451 q 677 617 763 617 q 592 572 621 617 q 563 470 563 527 l 559 350 l 563 39 q 759 126 693 39 q 826 347 826 213 "},";":{"x_min":72.609375,"x_max":312,"ha":446,"o":"m 224 636 q 287 611 262 636 q 312 548 312 586 q 287 486 312 511 q 224 461 262 461 q 162 486 188 461 q 137 548 137 512 q 162 611 137 586 q 224 636 187 636 m 164 75 q 198 157 182 140 q 244 175 214 175 q 304 119 304 175 q 296 75 304 93 q 262 18 287 56 l 103 -243 l 72 -231 l 164 75 "},"f":{"x_min":12,"x_max":432.546875,"ha":397,"o":"m 127 324 l 127 597 q 66 595 92 597 q 12 588 39 594 l 14 626 l 12 654 q 79 648 38 649 q 127 647 121 647 q 192 901 127 777 q 378 1025 257 1025 q 409 1022 400 1025 q 432 1015 418 1019 l 415 896 q 371 911 395 905 q 325 918 347 918 q 252 886 278 918 q 227 805 227 855 q 235 713 227 760 q 246 647 243 665 q 330 650 276 647 q 396 654 384 654 q 391 642 393 647 q 389 633 389 637 l 388 622 l 389 610 q 396 589 389 609 q 323 595 357 594 q 246 597 289 597 l 246 366 q 250 183 246 305 q 254 0 254 60 q 213 3 238 0 q 183 6 187 6 q 144 4 161 6 q 116 0 127 1 q 121 160 116 52 q 127 324 127 269 "},"“":{"x_min":83.71875,"x_max":550.390625,"ha":625,"o":"m 471 659 q 441 593 458 618 q 389 568 424 568 q 350 579 365 568 q 335 613 335 591 q 346 660 335 633 q 371 706 358 687 l 519 950 l 550 940 l 471 659 m 221 659 q 192 593 211 618 q 137 568 174 568 q 83 613 83 568 q 93 658 83 637 q 119 706 103 680 l 268 950 l 300 940 l 221 659 "},"A":{"x_min":-15.28125,"x_max":838.890625,"ha":825,"o":"m 257 639 l 387 950 q 402 945 395 947 q 417 944 409 944 q 452 950 437 944 q 576 629 536 733 q 686 359 617 526 q 838 0 755 192 q 789 3 820 0 q 751 6 758 6 q 700 4 723 6 q 663 0 677 1 q 600 199 622 137 q 543 353 579 260 l 377 358 l 215 353 l 162 205 q 130 110 145 160 q 101 0 115 59 l 44 5 q 6 2 20 5 q -15 0 -8 0 q 76 211 30 105 q 158 404 121 318 q 257 639 195 490 m 378 419 l 513 425 l 379 761 l 246 425 l 378 419 "},"6":{"x_min":64,"x_max":692,"ha":749,"o":"m 464 859 q 267 730 324 859 q 210 442 210 602 q 315 514 262 488 q 431 540 367 540 q 618 462 545 540 q 692 270 692 385 q 604 65 692 145 q 390 -15 516 -15 q 142 93 221 -15 q 64 377 64 201 q 167 745 64 581 q 462 909 270 909 q 524 905 501 909 q 579 890 547 902 l 574 827 q 521 851 547 844 q 464 859 495 859 m 554 258 q 510 409 554 347 q 380 471 466 471 q 255 409 300 471 q 210 264 210 348 q 253 105 210 172 q 384 39 297 39 q 485 73 441 39 q 540 148 529 108 q 552 206 551 187 q 554 258 554 225 "},"‘":{"x_min":86.5,"x_max":303.171875,"ha":374,"o":"m 224 659 q 193 594 212 620 q 140 568 174 568 q 86 615 86 568 q 98 660 86 633 q 122 708 110 687 l 271 951 l 303 942 l 224 659 "},"ϊ":{"x_min":-29,"x_max":362,"ha":342,"o":"m 104 333 l 104 520 q 103 566 104 544 q 96 654 102 588 q 140 647 130 648 q 165 647 151 647 q 232 654 195 647 q 224 555 225 599 q 223 437 223 511 l 223 406 q 228 194 223 337 q 233 0 233 51 q 201 3 216 1 q 165 5 185 5 q 127 3 148 5 q 96 0 107 1 q 100 165 96 51 q 104 333 104 279 m 45 928 q 99 907 77 928 q 122 853 122 886 q 101 800 122 822 q 48 778 80 778 q -6 800 15 778 q -29 853 -29 822 q -7 906 -29 884 q 45 928 13 928 m 286 928 q 340 906 318 928 q 362 853 362 884 q 341 799 362 821 q 289 778 321 778 q 235 800 257 778 q 213 853 213 822 q 233 905 213 883 q 286 928 254 928 "},"π":{"x_min":19,"x_max":957,"ha":989,"o":"m 702 5 l 635 0 q 639 114 635 44 q 643 196 643 185 l 643 575 l 508 575 l 373 575 l 369 284 q 373 143 369 236 q 377 0 377 50 q 345 3 360 1 q 309 5 329 5 q 271 3 292 5 q 239 0 250 1 l 248 196 l 243 575 q 130 553 171 575 q 43 472 89 532 q 19 559 35 519 q 139 627 71 611 q 305 644 207 644 l 658 644 l 852 644 l 957 651 l 951 610 l 957 566 l 769 575 l 765 310 q 769 154 765 257 q 773 0 773 51 q 739 3 755 1 q 702 5 724 5 "},"ά":{"x_min":41,"x_max":827.109375,"ha":846,"o":"m 705 352 q 803 -1 763 155 l 739 1 l 673 -1 l 632 172 q 521 36 593 87 q 356 -15 448 -15 q 129 81 217 -15 q 41 316 41 177 q 130 569 41 467 q 368 672 220 672 q 537 622 464 672 q 659 486 610 573 q 711 654 691 569 l 770 650 l 827 654 q 763 505 792 576 q 705 352 734 434 m 518 943 q 552 974 536 964 q 589 985 568 985 q 626 969 611 985 q 641 932 641 953 q 627 897 641 911 q 585 866 613 883 l 384 743 l 335 743 l 518 943 m 377 619 q 226 530 272 619 q 181 326 181 442 q 223 124 181 214 q 367 34 265 34 q 528 137 480 34 q 601 323 577 240 q 527 531 578 444 q 377 619 475 619 "},"O":{"x_min":51,"x_max":1068,"ha":1119,"o":"m 51 465 q 192 820 51 690 q 559 950 333 950 q 892 853 754 950 q 1047 654 1031 757 q 1065 525 1062 551 q 1068 462 1068 500 q 1065 402 1068 426 q 1047 277 1062 379 q 894 80 1031 175 q 560 -15 756 -15 q 447 -10 496 -15 q 304 29 398 -5 q 130 186 210 64 q 51 465 51 308 m 202 468 q 290 162 202 282 q 559 42 379 42 q 826 162 738 42 q 915 468 915 283 q 825 770 915 651 q 559 889 735 889 q 348 826 429 889 q 225 639 267 764 q 202 468 202 552 "},"n":{"x_min":89,"x_max":661,"ha":754,"o":"m 99 155 l 99 495 q 97 569 99 530 q 91 655 95 608 q 153 648 122 648 l 219 656 l 218 539 q 319 635 260 599 q 451 672 378 672 q 591 624 528 672 q 654 501 654 576 l 654 299 l 654 136 l 661 0 q 629 3 644 1 q 593 5 613 5 q 556 3 576 5 q 525 0 536 1 q 530 222 525 80 q 535 406 535 364 q 501 536 535 485 q 389 587 467 587 q 253 508 288 587 q 218 313 218 430 q 220 132 218 258 q 222 0 222 6 q 184 3 208 0 q 155 6 159 6 q 117 3 141 6 q 89 0 93 0 l 99 155 "},"3":{"x_min":75,"x_max":644,"ha":749,"o":"m 241 465 l 238 512 l 294 510 q 424 554 375 510 q 474 680 474 599 q 434 805 474 754 q 322 856 394 856 q 220 818 257 856 q 164 711 183 780 l 153 706 q 127 767 136 747 q 99 819 118 788 q 220 886 162 863 q 348 909 278 909 q 526 857 450 909 q 603 706 603 805 q 542 564 603 617 q 383 479 482 511 q 567 423 490 479 q 644 262 644 366 q 542 55 644 129 q 302 -18 441 -18 q 183 -6 240 -18 q 75 32 127 5 q 99 189 91 116 l 113 188 q 182 73 136 115 q 302 31 229 31 q 448 92 392 31 q 505 246 505 154 q 451 389 505 333 q 312 446 398 446 q 238 435 279 446 l 241 465 "},"9":{"x_min":57,"x_max":688,"ha":749,"o":"m 261 38 q 475 166 405 38 q 546 451 546 295 q 442 378 494 403 q 325 354 389 354 q 132 428 208 354 q 57 617 57 502 q 148 828 57 748 q 372 909 240 909 q 612 801 536 909 q 688 520 688 693 q 574 143 688 305 q 252 -18 461 -18 q 186 -14 211 -18 q 127 0 161 -11 l 113 90 q 180 51 143 64 q 261 38 218 38 m 372 419 q 501 482 457 419 q 546 634 546 545 q 504 790 546 725 q 373 855 462 855 q 238 791 284 855 q 193 637 193 727 q 238 482 193 545 q 372 419 284 419 "},"l":{"x_min":100,"x_max":237.5,"ha":342,"o":"m 107 118 l 107 881 q 104 965 107 915 q 101 1025 101 1016 q 169 1018 138 1018 q 237 1025 203 1018 q 228 872 230 948 q 226 684 226 797 l 226 512 l 232 111 l 237 0 q 205 3 220 1 q 169 5 189 5 q 131 3 152 5 q 100 0 111 1 l 107 118 "},"κ":{"x_min":97,"x_max":677.5625,"ha":683,"o":"m 104 365 q 100 531 104 428 q 97 655 97 634 q 164 647 134 647 q 231 654 196 647 q 227 516 231 608 q 223 377 223 425 l 258 377 q 386 498 323 431 q 528 654 449 565 q 588 647 563 647 q 640 647 613 647 q 672 652 662 651 l 358 387 l 548 165 q 608 93 577 127 q 677 19 638 59 l 677 0 q 628 3 659 0 q 591 6 596 6 q 544 3 567 6 q 510 0 520 0 q 437 100 477 47 q 360 196 398 153 l 269 308 l 252 323 l 223 326 q 227 163 223 274 q 231 0 231 52 l 164 5 l 97 0 q 100 208 97 77 q 104 365 104 339 "},"4":{"x_min":39,"x_max":691.78125,"ha":749,"o":"m 453 252 l 177 257 l 39 253 l 39 291 q 204 522 111 392 q 345 721 297 653 q 475 906 394 789 l 527 906 l 581 906 q 575 805 581 872 q 569 705 569 739 l 569 343 l 598 343 q 644 344 620 343 q 690 350 667 345 l 683 297 q 686 270 683 287 q 691 244 689 254 q 568 253 629 253 l 568 137 l 569 0 l 505 6 l 437 0 q 450 120 447 51 q 453 252 453 190 m 453 767 l 344 626 q 230 465 298 562 q 144 343 162 368 l 453 343 l 453 767 "},"p":{"x_min":83,"x_max":702,"ha":758,"o":"m 91 -106 q 89 202 91 47 q 87 513 88 358 l 83 655 q 109 650 95 652 q 146 648 124 648 q 177 650 165 648 q 213 655 188 651 q 202 535 202 591 q 297 637 246 602 q 425 672 349 672 q 630 567 558 672 q 702 322 702 463 q 629 84 702 183 q 423 -15 556 -15 q 210 99 287 -15 l 210 -101 q 214 -244 210 -148 q 219 -373 219 -340 q 185 -369 201 -370 q 151 -368 170 -368 q 130 -368 138 -368 q 83 -373 123 -368 q 87 -240 83 -329 q 91 -106 91 -151 m 384 596 q 245 514 289 596 q 202 328 202 433 q 244 134 202 220 q 383 48 286 48 q 520 131 478 48 q 563 322 563 215 q 519 509 563 423 q 384 596 475 596 "},"ψ":{"x_min":78,"x_max":1002,"ha":1038,"o":"m 78 294 l 82 477 l 82 654 l 145 650 l 215 654 q 209 517 215 605 q 203 421 203 430 l 203 341 q 264 117 203 197 q 465 38 325 38 l 468 260 q 461 535 468 342 q 455 786 455 729 q 496 779 479 782 q 526 776 513 776 q 566 780 545 776 q 600 786 587 784 q 591 496 600 690 q 583 270 583 302 l 587 38 q 791 132 715 38 q 867 357 867 227 q 824 641 867 506 q 885 645 857 641 q 960 656 912 648 q 1002 419 1002 544 q 891 118 1002 231 q 587 -13 780 5 l 591 -221 l 600 -372 q 561 -365 578 -367 q 526 -363 543 -363 q 491 -366 511 -363 q 455 -372 471 -369 q 461 -162 455 -302 q 468 -13 468 -22 q 194 64 310 -13 q 78 294 78 142 "},"Ü":{"x_min":101,"x_max":919.0625,"ha":1015,"o":"m 182 927 l 262 931 q 250 805 253 854 q 247 697 247 757 l 247 457 q 314 136 247 212 q 516 60 381 60 q 733 130 654 60 q 813 336 813 201 l 813 458 l 813 657 q 799 931 813 802 l 859 927 l 919 931 q 905 770 909 863 q 901 600 901 677 l 901 366 q 792 82 901 179 q 491 -15 684 -15 q 211 66 307 -15 q 116 325 116 148 l 116 426 l 116 698 q 112 805 116 757 q 101 931 109 854 l 182 927 m 410 1208 q 462 1186 442 1208 q 483 1133 483 1164 q 460 1081 483 1105 q 410 1058 438 1058 q 356 1080 379 1058 q 334 1133 334 1103 q 356 1185 334 1163 q 410 1208 378 1208 m 650 1208 q 704 1187 682 1208 q 727 1133 727 1166 q 704 1080 727 1103 q 650 1058 681 1058 q 598 1078 620 1058 q 576 1133 576 1099 q 598 1185 576 1163 q 650 1208 620 1208 "},"à":{"x_min":43,"x_max":655.5,"ha":649,"o":"m 234 -15 q 98 33 153 -15 q 43 162 43 82 q 106 303 43 273 q 303 364 169 333 q 444 448 437 395 q 403 568 444 521 q 288 616 362 616 q 191 587 233 616 q 124 507 149 559 l 95 520 l 104 591 q 202 651 144 631 q 323 672 261 672 q 500 622 444 672 q 557 455 557 573 l 557 133 q 567 69 557 84 q 618 54 577 54 q 655 58 643 54 l 655 26 q 594 5 626 14 q 537 -6 562 -3 q 438 85 453 -6 q 342 10 388 35 q 234 -15 296 -15 m 392 743 l 191 866 q 152 896 170 877 q 133 934 133 915 q 148 970 133 955 q 186 986 163 986 q 222 972 200 986 q 254 945 245 958 l 442 743 l 392 743 m 176 186 q 204 98 176 133 q 284 64 232 64 q 390 107 342 64 q 438 212 438 151 l 438 345 q 239 293 303 319 q 176 186 176 268 "},"η":{"x_min":91,"x_max":662,"ha":754,"o":"m 594 -365 q 557 -366 577 -365 q 526 -369 537 -368 q 531 -189 526 -310 q 537 -7 537 -68 l 537 406 q 503 536 537 485 q 391 587 469 587 q 255 508 290 587 q 220 315 220 430 q 222 133 220 259 q 224 1 224 8 l 158 6 l 91 1 l 101 156 l 101 495 q 97 584 101 527 q 93 655 93 640 q 119 650 105 652 q 155 648 134 648 q 185 650 175 648 q 221 655 195 651 l 220 538 q 321 637 265 602 q 452 672 378 672 q 604 603 552 672 q 656 430 656 535 l 656 329 l 656 -186 q 659 -293 656 -227 q 662 -370 662 -359 q 630 -366 645 -368 q 594 -365 614 -365 "}},"cssFontWeight":"normal","ascender":1267,"underlinePosition":-133,"cssFontStyle":"normal","boundingBox":{"yMin":-373.75,"xMin":-71,"yMax":1267,"xMax":1511},"resolution":1000,"original_font_information":{"postscript_name":"Optimer-Regular","version_string":"Version 1.00 2004 initial release","vendor_url":"http://www.magenta.gr/","full_font_name":"Optimer","font_family_name":"Optimer","copyright":"Copyright (c) Magenta Ltd., 2004","description":"","trademark":"","designer":"","designer_url":"","unique_font_identifier":"Magenta Ltd.:Optimer:22-10-104","license_url":"http://www.ellak.gr/fonts/MgOpen/license.html","license_description":"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\\"Fonts\\") and associated documentation files (the \\"Font Software\\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \\r\\n\\r\\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\\r\\n\\r\\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \\"MgOpen\\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\\r\\n\\r\\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \\"MgOpen\\" name.\\r\\n\\r\\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \\r\\n\\r\\nTHE FONT SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","manufacturer_name":"Magenta Ltd.","font_sub_family_name":"Regular"},"descender":-374,"familyName":"Optimer","lineHeight":1640,"underlineThickness":20}',
            ),
          ),
          va = new i.MeshBasicMaterial({ color: new i.Color(1, 0, 0) }),
          xa = (function (t) {
            ca()(n, t);
            var e = ga(n);
            function n(t, r, a) {
              var o;
              if (
                (aa()(this, n),
                (a =
                  a ||
                  new i.Color(Math.random(), Math.random(), Math.random())),
                ((o = e.call(this, t.box3D, a.getHex())).obb = t),
                (o.material.linewidth = 2),
                (o.frustumCulled = !1),
                (o.matrixAutoUpdate = !1),
                (o.rotationAutoUpdate = !1),
                r)
              ) {
                var s = new i.TextGeometry(r, { font: ya, curveSegments: 1 });
                (o.textMesh = new i.Mesh(s, va)),
                  o.textMesh.rotateZ(0.5 * Math.PI),
                  o.textMesh.scale.set(0.001, 0.001, 0.001),
                  o.textMesh.position.set(0.9, 0.5, 1),
                  (o.textMesh.frustumCulled = !1),
                  o.add(o.textMesh);
              }
              return o.updateMatrixWorld(!0), o;
            }
            return (
              sa()(n, [
                {
                  key: 'removeChildren',
                  value: function () {
                    if (
                      (this.material.dispose(),
                      this.geometry.dispose(),
                      this.textMesh)
                    ) {
                      if (Array.isArray(this.textMesh.material)) {
                        var t,
                          e = fa(this.textMesh.material);
                        try {
                          for (e.s(); !(t = e.n()).done; ) {
                            t.value.dispose();
                          }
                        } catch (t) {
                          e.e(t);
                        } finally {
                          e.f();
                        }
                      } else this.textMesh.material.dispose();
                      this.textMesh.geometry.dispose(), delete this.textMesh;
                    }
                  },
                },
                {
                  key: 'updateMatrixWorld',
                  value: function () {
                    var t =
                      arguments.length > 0 &&
                      void 0 !== arguments[0] &&
                      arguments[0];
                    this.obb.box3D.isEmpty() ||
                      (this.quaternion.copy(this.obb.quaternion),
                      this.obb.box3D
                        .getCenter(this.position)
                        .applyQuaternion(this.quaternion)
                        .add(this.obb.position),
                      this.obb.box3D.getSize(this.scale),
                      this.scale.multiplyScalar(0.5),
                      this.updateMatrix(),
                      i.Object3D.prototype.updateMatrixWorld.call(this, t));
                  },
                },
              ]),
              n
            );
          })(i.Box3Helper);
        function ba(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return _a(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return _a(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function _a(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function wa(t, e, n) {
          var s = this;
          n ||
            (((n = document.createElement('div')).id = 'chart-div'),
            (n.style.cssText =
              'z-index: 10; position: absolute; bottom: 0; left: 0; width: 100vw; height: 30%; background-color: '.concat(
                '#404040',
                '; display: none',
              )),
            document.body.appendChild(n)),
            (this.chartDivContainer = n);
          var l = this.createChartContainer('three-info').getContext('2d');
          (this.charts = []),
            this.charts.push(new ia(l, t.mainLoop.gfxEngine.renderer));
          var c = this.charts,
            u = t.tileLayer,
            h = new r.a(t.referenceCrs, 0, 0, 0),
            d = new r.a('EPSG:4326', 0, 0, 0);
          var p,
            f,
            m,
            g,
            y = e.addFolder('Debug Tools'),
            v = {
              displayCharts: !1,
              eventsDebug: !1,
              debugCameraWindow: !1,
              freeze: !1,
            },
            x = function () {
              p = Date.now();
            },
            b = function () {
              var t,
                e,
                i = Date.now() - p;
              (t = i),
                (e = 'none' != n.style.display),
                c.forEach(function (n) {
                  return n.update(e, t);
                });
            };
          y
            .add(v, 'displayCharts')
            .name('Display charts')
            .onChange(function (e) {
              e
                ? (t.addFrameRequester(a.a.UPDATE_START, x),
                  t.addFrameRequester(a.a.UPDATE_END, b),
                  (n.style.display = 'flex'))
                : (t.removeFrameRequester(a.a.UPDATE_START, x),
                  t.removeFrameRequester(a.a.UPDATE_END, b),
                  (n.style.display = 'none')),
                s.updateChartDivSize(),
                t.notifyChange();
            }),
            y
              .add(v, 'debugCameraWindow')
              .name('debug Camera')
              .onChange(function (e) {
                e
                  ? t.addFrameRequester(a.a.AFTER_RENDER, O)
                  : t.removeFrameRequester(a.a.AFTER_RENDER, O),
                  t.notifyChange();
              }),
            y
              .add(v, 'freeze')
              .name('freeze update')
              .onChange(function (e) {
                (u.frozen = e), t.notifyChange();
              });
          var _ = t.controls;
          h.crs = t.referenceCrs;
          var w = new i.Vector3(),
            M =
              _ && _.getCameraTargetPosition
                ? _.getCameraTargetPosition
                : function () {
                    return t.camera.camera3D.position;
                  },
            q = function (e) {
              t.getPickingPositionFromDepth(t.eventToViewCoords(e), w)
                ? (h.setFromVector3(w).as('EPSG:4326', d),
                  (v.latitude = ''.concat(d.y.toFixed(6))),
                  (v.longitude = ''.concat(d.x.toFixed(6))))
                : ((v.latitude = '---------'), (v.longitude = '---------')),
                f.updateDisplay(),
                m.updateDisplay();
            };
          y.add(v, 'eventsDebug')
            .name('Debug event')
            .onChange(function (e) {
              e
                ? ((g = y.addFolder('Events')).open(),
                  h.setFromVector3(M()).as('EPSG:4326', d),
                  (v.latitude = ''.concat(d.y.toFixed(6))),
                  (v.longitude = ''.concat(d.x.toFixed(6))),
                  (f = g.add(v, 'latitude')),
                  (m = g.add(v, 'longitude')),
                  t.domElement.addEventListener('mousemove', q))
                : (t.domElement.removeEventListener('mousemove', q),
                  y.removeFolder('Events'));
            });
          var S = new i.CameraHelper(t.camera.camera3D),
            T = t.camera.camera3D.clone();
          (T.fov *= 1.5), T.updateProjectionMatrix();
          var E = t.mainLoop.gfxEngine,
            A = E.renderer,
            L = 1e11,
            R = t.getLayerById('atmosphere');
          R && (L = R.fog.distance), (S.visible = !1), t.scene.add(S);
          var C = new o.a(),
            P = new xa(C, '', new i.Color('#64a6bd'));
          function k(t) {
            t.material && L && (t.material.fogDistance = L);
          }
          (P.visible = !1), t.scene.add(C), t.scene.add(P);
          var I = new i.Color(),
            D = new i.Vector3();
          function O() {
            if (v.debugCameraWindow && T) {
              var e = { x: 0.25 * E.width, y: 0.25 * E.height };
              T.aspect = e.x / e.y;
              var i = t.camera.camera3D,
                a = new r.a(t.referenceCrs, i.position).as(u.extent.crs),
                o = t.tileLayer.info.displayed.extent;
              C.setFromExtent(o), (P.visible = !0), P.updateMatrixWorld(!0);
              var s = 1.5 * a.z;
              if (
                ((a.z = s),
                a.as(t.referenceCrs).toVector3(T.position),
                i.worldToLocal(T.position),
                (T.position.z += s),
                i.localToWorld(T.position),
                D.copy(t.camera.camera3D.position),
                i.worldToLocal(D),
                (D.z -= 1.5 * s),
                i.localToWorld(D),
                T.lookAt(D),
                S.update(),
                T.updateProjectionMatrix(),
                R)
              ) {
                (R.object3d.visible = !1), (L = 1e11);
                var l,
                  c = ba(u.level0Nodes);
                try {
                  for (c.s(); !(l = c.n()).done; ) {
                    l.value.traverseVisible(k);
                  }
                } catch (t) {
                  c.e(t);
                } finally {
                  c.f();
                }
              }
              var h = v.displayCharts
                ? Math.round(
                    (parseFloat(n.style.height.replace('%', '')) * E.height) /
                      100,
                  ) + 3
                : 0;
              if (
                ((S.visible = !0),
                S.updateMatrixWorld(!0),
                A.getClearColor(I),
                A.setViewport(E.width - e.x, h, e.x, e.y),
                A.setScissor(E.width - e.x, h, e.x, e.y),
                A.setScissorTest(!0),
                A.setClearColor('#404040'),
                A.clear(),
                A.render(t.scene, T),
                A.setScissorTest(!1),
                A.setClearColor(I),
                A.setViewport(0, 0, E.width, E.height),
                (S.visible = !1),
                (P.visible = !1),
                R && (R.object3d.visible = !0),
                R)
              ) {
                L = R.fog.distance;
                var d,
                  p = ba(u.level0Nodes);
                try {
                  for (p.s(); !(d = p.n()).done; ) {
                    d.value.traverseVisible(k);
                  }
                } catch (t) {
                  p.e(t);
                } finally {
                  p.f();
                }
              }
            }
          }
        }
        (wa.prototype.createChartContainer = function (t) {
          var e = document.createElement('div');
          (e.style.cssText = 'background-color: '.concat(
            '#404040',
            '; flex: auto;',
          )),
            this.chartDivContainer.appendChild(e);
          var n = document.createElement('canvas');
          return (n.height = '20rem'), (n.id = t), e.appendChild(n), n;
        }),
          (wa.prototype.updateChartDivSize = function () {
            var t,
              e = 0,
              n = ba(this.chartDivContainer.getElementsByTagName('div'));
            try {
              for (n.s(); !(t = n.n()).done; ) {
                'none' !== t.value.style.display && e++;
              }
            } catch (t) {
              n.e(t);
            } finally {
              n.f();
            }
            var i,
              r = Math.floor(100 / e),
              a = ba(this.chartDivContainer.getElementsByTagName('div'));
            try {
              for (a.s(); !(i = a.n()).done; ) {
                var o = i.value;
                'none' !== o.style.display &&
                  (o.style.width = ''.concat(r, '%'));
              }
            } catch (t) {
              a.e(t);
            } finally {
              a.f();
            }
            this.charts.forEach(function (t) {
              t.resize(), t.update();
            });
          });
        var Ma = wa,
          qa = n(94);
        function Sa(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return Ta(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return Ta(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function Ta(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        var Ea = {
            initTools: function (t, e, n) {
              var i = function () {
                return t.notifyChange(e, !0);
              };
              (e.debugUI = n.addFolder(''.concat(e.id))),
                e.debugUI.add(e, 'visible').name('Visible').onChange(i),
                e.debugUI
                  .add(e, 'sseThreshold')
                  .name('SSE threshold')
                  .onChange(i),
                e.debugUI
                  .add(e, 'octreeDepthLimit', -1, 20)
                  .name('Depth limit')
                  .onChange(i),
                e.debugUI
                  .add(e, 'pointBudget', 1, 15e6)
                  .name('Max point count')
                  .onChange(i),
                e.debugUI
                  .add(e.object3d.position, 'z', -50, 50)
                  .name('Z translation')
                  .onChange(function () {
                    e.object3d.updateMatrixWorld(), t.notifyChange(e);
                  }),
                (e.dbgStickyNode = ''),
                (e.dbgDisplaySticky = !1),
                (e.dbgDisplayChildren = !0),
                (e.dbgDisplayParents = !0);
              var r = e.debugUI.addFolder('Styling');
              null != e.material.mode &&
                (r
                  .add(e.material, 'mode', qa.a)
                  .name('Display mode')
                  .onChange(i),
                r
                  .add(e, 'maxIntensityRange', 0, 1)
                  .name('Intensity max')
                  .onChange(i)),
                r.add(e, 'opacity', 0, 1).name('Layer Opacity').onChange(i),
                r.add(e, 'pointSize', 0, 15).name('Point Size').onChange(i),
                null != e.material.picking &&
                  r
                    .add(e.material, 'picking')
                    .name('Display picking id')
                    .onChange(i);
              var a = e.debugUI.addFolder('Debug');
              a
                .add(e.bboxes, 'visible')
                .name('Display Bounding Boxes')
                .onChange(i),
                a.add(e, 'dbgStickyNode').name('Sticky node name').onChange(i),
                a
                  .add(e, 'dbgDisplaySticky')
                  .name('Display sticky node')
                  .onChange(i),
                a
                  .add(e, 'dbgDisplayChildren')
                  .name('Display children of sticky node')
                  .onChange(i),
                a
                  .add(e, 'dbgDisplayParents')
                  .name('Display parents of sticky node')
                  .onChange(i);
              t.addFrameRequester('before_layer_update', function () {
                if (e.dbgStickyNode.length) {
                  e.displayedCount = 0;
                  var t,
                    n = e.dbgStickyNode.split(','),
                    i = Sa(e.group.children);
                  try {
                    var r = function () {
                      var i = t.value;
                      (i.visible = n.some(function (t) {
                        return (
                          (n = t),
                          (r = i.owner.name),
                          (e.dbgDisplaySticky && n === r) ||
                            (e.dbgDisplayParents && n.startsWith(r)) ||
                            (e.dbgDisplayChildren && r.startsWith(n))
                        );
                        var n, r;
                      })),
                        i.boxHelper && (i.boxHelper.visible = i.visible),
                        i.visible &&
                          (e.displayedCount +=
                            i.geometry.attributes.position.count);
                    };
                    for (i.s(); !(t = i.n()).done; ) r();
                  } catch (t) {
                    i.e(t);
                  } finally {
                    i.f();
                  }
                }
              });
            },
          },
          Aa = n(46),
          La = n(52),
          Ra = n(51),
          Ca = n(59);
        function Pa(t, e) {
          var n = 0,
            i = Date.now(),
            r = {
              label: 'Update 1st level',
              data: [{ x: 0, y: 0 }],
              borderColor: '#e7c9e5',
              borderWidth: 1.5,
              pointRadius: 1,
            },
            a = {
              label: 'Update duration (ms)',
              data: [{ x: 0, y: 0 }],
              borderColor: '#64a6bd',
              borderWidth: 1.5,
              pointRadius: 1,
            },
            o = ['0s'],
            s = new Yi(t, {
              type: 'line',
              data: { labels: o, datasets: [r, a] },
              options: { animation: { duration: 10 }, scales: na },
            });
          (this.update = function (t, l) {
            var c = Math.floor((Date.now() - i) / 1e3),
              u = ''.concat(c, 's');
            n > 0 && o[n] == u ? o.push('') : (o.push(u), (n = o.length - 1)),
              o.length > 60 && (o.shift(), n--),
              r.data.push({ x: 0, y: e._latestUpdateStartingLevel }),
              a.data.push({ x: 0, y: l }),
              r.data.length > 60 && (r.data.shift(), a.data.shift()),
              t && s.update();
          }),
            (this.resize = function () {
              s.resize();
            });
        }
        function ka(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return Ia(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return Ia(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function Ia(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function Da(t, e) {
          var n = [],
            i = [],
            r = [],
            a = new Yi(t, {
              type: 'bar',
              data: {
                labels: n,
                datasets: [
                  {
                    label: 'Visible node per level',
                    data: i,
                    backgroundColor: '#e7c9e5',
                  },
                  {
                    label: 'Diplayed node per level',
                    data: r,
                    backgroundColor: '#64a6bd',
                  },
                ],
              },
              options: { scales: na },
            });
          (this.update = function (t) {
            var o = {};
            for (var s in ((function t(n, i) {
              if (
                n &&
                n.visible &&
                (n.level >= 0 &&
                  n.layer === e &&
                  (i[n.level] ? (i[n.level][0] += 1) : (i[n.level] = [1, 0]),
                  n.material.visible && (i[n.level][1] += 1)),
                n.children)
              ) {
                var r,
                  a = ka(n.children);
                try {
                  for (a.s(); !(r = a.n()).done; ) {
                    t(r.value, i);
                  }
                } catch (t) {
                  a.e(t);
                } finally {
                  a.f();
                }
              }
            })(e.object3d, o),
            (n.length = 0),
            (i.length = 0),
            o))
              ({}.hasOwnProperty.call(o, s) &&
                ((n[s] = ''.concat(s)), (i[s] = o[s][0]), (r[s] = o[s][1])));
            t && a.update();
          }),
            (this.resize = function () {
              a.resize();
            });
        }
        function Oa(t, e, n) {
          t.defineLayerProperty(e, n, function () {
            (t.parent ? t.parent.object3d : t.object3d).traverse(function (n) {
              n.layer == t && n.material
                ? (n.material[e] = t[e])
                : n.content &&
                  n.content.layer == t &&
                  n.content.traverse(function (n) {
                    n.material && (n.material[e] = t[e]);
                  });
            });
          });
        }
        var Na,
          za = {
            addWireFrameCheckbox: function (t, e, n) {
              t.add(n, 'wireframe')
                .name('Wireframe')
                .onChange(function () {
                  return e.notifyChange(n);
                });
            },
            addMaterialSize: function (t, e, n, i, r) {
              Oa(n, 'size', 1),
                t
                  .add(n, 'size', i, r)
                  .name('Size')
                  .onChange(function () {
                    return e.notifyChange(n);
                  });
            },
            addMaterialLineWidth: function (t, e, n, i, r) {
              Oa(n, 'linewidth', 1),
                t
                  .add(n, 'linewidth', i, r)
                  .name('Line Width')
                  .onChange(function () {
                    return e.notifyChange(n);
                  });
            },
            createGeometryDebugUI: function (t, e, n) {
              var i = t.addFolder('Layer '.concat(n.id));
              return (
                i
                  .add(n, 'visible')
                  .name('Visible')
                  .onChange(function () {
                    return e.notifyChange(n);
                  }),
                i
                  .add(n, 'opacity', 0, 1)
                  .name('Opacity')
                  .onChange(function () {
                    return e.notifyChange(n);
                  }),
                i
              );
            },
          };
        function Fa(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return Ba(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return Ba(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function Ba(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function Ua(t, e, n, i) {
          e.traverse(function (t) {
            t.material && t.layer === n && i(t.material);
          }),
            t.notifyChange();
        }
        function ja(t, e) {
          var n =
            !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          Na &&
            ((Na.material.overlayAlpha = 0),
            (Na.material.showOutline = t.tileLayer.showOutline),
            t.notifyChange(Na));
          var i = t.tileLayer.pickObjectsAt(t, e);
          return (
            (Na = i.length ? i[0].object : void 0) &&
              (n && console.info(Na),
              (Na.material.overlayAlpha = 0.5),
              (Na.material.showOutline = !0),
              t.notifyChange(Na)),
            Na
          );
        }
        function Ga(t, e, n, r) {
          var o =
            arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          if (e.isDebugMode || o) {
            (r = r || new Ma(e, t)), (n = n || e.tileLayer);
            var s = za.createGeometryDebugUI(t, e, n),
              l = ''.concat(n.id, '-nb-objects'),
              c = r.createChartContainer(l),
              u = ''.concat(n.id, '-nb-visible'),
              h = r.createChartContainer(u);
            r.charts.push(new Pa(c.getContext('2d'), n)),
              r.charts.push(new Da(h.getContext('2d'), n)),
              (n.showOutline = !1),
              (n.wireframe = !1);
            var d = { objectChart: !0, visibilityChart: !0, sseHelper: !1 };
            s
              .add(n, 'showOutline')
              .name('Show tiles')
              .onChange(function (t) {
                (n.showOutline = t),
                  Ua(e, n.object3d, n, function (e) {
                    e.showOutline = t;
                  });
              }),
              s
                .add(n, 'wireframe')
                .name('Wireframe')
                .onChange(function () {
                  e.notifyChange(n);
                }),
              s
                .add(d, 'objectChart')
                .name('Object chart')
                .onChange(function (t) {
                  (document.getElementById(l).parentNode.style.display = t
                    ? 'block'
                    : 'none'),
                    r.updateChartDivSize(),
                    r.charts.forEach(function (t) {
                      return t.update();
                    });
                }),
              s
                .add(d, 'visibilityChart')
                .name('Visibility chart')
                .onChange(function (t) {
                  (document.getElementById(u).parentNode.style.display = t
                    ? 'block'
                    : 'none'),
                    r.updateChartDivSize(),
                    r.charts.forEach(function (t) {
                      return t.update();
                    });
                });
            var p = ''.concat(n.id, '_obb_debug'),
              f = ''.concat(n.id, '_sb_debug'),
              m = new i.SphereGeometry(1, 16, 16),
              g = new Ra.a(p, new i.Object3D(), {
                update: S,
                visible: !1,
                cacheLifeTime: 1 / 0,
                source: !1,
              });
            La.b.prototype.addLayer.call(e, g, n).then(function (t) {
              s.add(t, 'visible')
                .name('Bounding boxes')
                .onChange(function () {
                  e.notifyChange(t);
                });
            });
            var y = new Ra.a(f, new i.Object3D(), {
              update: S,
              visible: !1,
              cacheLifeTime: 1 / 0,
              source: !1,
            });
            La.b.prototype.addLayer.call(e, y, n).then(function (t) {
              s.add(t, 'visible')
                .name('Bounding Spheres')
                .onChange(function () {
                  e.notifyChange(t);
                });
            });
            var v = document.getElementById('viewerDiv'),
              x = document.createElement('span');
            (x.className = 'circleBase'), v.appendChild(x);
            var b,
              _ = new i.Vector3(),
              w = function () {
                Aa.a.update(), e.notifyChange();
              },
              M = function () {
                Aa.a.removeAll(),
                  e._frameRequesters[a.a.BEFORE_RENDER].includes(w) &&
                    e.removeFrameRequester(a.a.BEFORE_RENDER, w);
              };
            s.add(d, 'sseHelper')
              .name('Sse helper')
              .onChange(function (t) {
                t
                  ? window.addEventListener('mousemove', T, !1)
                  : ((x.style.display = 'none'),
                    M(),
                    window.removeEventListener('mousemove', T));
              });
            var q = null;
            window.addEventListener('mousedown', function (t) {
              83 == q && ja(e, t);
            }),
              window.addEventListener('keydown', function (t) {
                q = t.which;
              }),
              window.addEventListener('keyup', function () {
                q = null;
              });
          }
          function S(t, e, n) {
            var r = t.camera.camera3D.layers.test({
              mask: 1 << e.threejsLayer,
            });
            if (n.parent && r) {
              var a = n.children.filter(function (t) {
                return t.layer && t.layer.id == e.id;
              })[0];
              if (n.material && n.material.visible) {
                if (!a) {
                  var o = t.view.getLayerById(e.id).threejsLayer;
                  if (e.id == p)
                    (a = new xa(n.obb, 'id:'.concat(n.id))).children[0] &&
                      a.children[0].layers.set(o);
                  else if (e.id == f) {
                    var s = new i.Color(
                        Math.random(),
                        Math.random(),
                        Math.random(),
                      ),
                      l = new i.MeshBasicMaterial({
                        color: s.getHex(),
                        wireframe: !0,
                      });
                    (a = new i.Mesh(m, l)).position.copy(
                      n.boundingSphere.center,
                    ),
                      a.scale.multiplyScalar(n.boundingSphere.radius);
                  }
                  a.layers.set(o),
                    (a.layer = e),
                    n.add(a),
                    a.updateMatrixWorld(!0);
                  var c = n.material.addEventListener('hidden', function () {
                    n.material.removeEventListener(c);
                    for (var t = n.children.length; t--; ) {
                      var e = n.children[t];
                      if (e.layer === f) {
                        if (e.dispose) e.dispose();
                        else if (Array.isArray(e.material)) {
                          var i,
                            r = Fa(e.material);
                          try {
                            for (r.s(); !(i = r.n()).done; ) {
                              i.value.dispose();
                            }
                          } catch (t) {
                            r.e(t);
                          } finally {
                            r.f();
                          }
                        } else e.material.dispose();
                        n.children.splice(t, 1);
                      }
                    }
                  });
                }
                e.id == f &&
                  (a.position.copy(n.boundingSphere.center),
                  a.scale.set(1, 1, 1).multiplyScalar(n.boundingSphere.radius)),
                  a.updateMatrixWorld(!0),
                  (a.visible = !0);
              } else a && (a.visible = !1);
            } else Ca.a.removeChildrenAndCleanupRecursively(e, n);
          }
          function T(t) {
            var n = ja(e, t, !1);
            if (n) {
              (x.style.display = 'table-cell'),
                _.copy(n.boundingSphere.center).applyMatrix4(n.matrixWorld);
              var i = _.project(e.camera.camera3D),
                r = e.normalizedToViewCoords(i),
                o = n.screenSize;
              if (b != n) {
                var s = Number(x.style.width.replace('px', ''));
                (b = n),
                  M(),
                  new Aa.a.Tween({ size: s })
                    .to({ size: o }, 500)
                    .easing(Aa.a.Easing.Sinusoidal.In)
                    .easing(Aa.a.Easing.Exponential.Out)
                    .onUpdate(function (t) {
                      (x.style['line-height'] = ''.concat(t.size, 'px')),
                        (x.style.width = ''.concat(t.size, 'px')),
                        (x.style.height = ''.concat(t.size, 'px')),
                        (x.innerHTML = ''.concat(Math.floor(t.size), ' px')),
                        (x.style.left = ''.concat(r.x - 0.5 * t.size, 'px')),
                        (x.style.top = ''.concat(r.y - 0.5 * t.size, 'px'));
                    })
                    .onComplete(M)
                    .start(),
                  e.addFrameRequester(a.a.BEFORE_RENDER, w);
              }
            } else x.style.display = 'none';
          }
        }
        var Ha = new i.Mesh();
        function Va(t, e, n) {
          var r = za.createGeometryDebugUI(t, e, n),
            a = new i.Group();
          e.scene.add(a), za.addWireFrameCheckbox(r, e, n);
          var o = ''.concat(n.id, '_obb_debug'),
            s = new Ra.a(o, new i.Object3D(), {
              update: function (t, e, r) {
                if (
                  t.camera.camera3D.layers.test({ mask: 1 << e.threejsLayer })
                ) {
                  var o = r.userData.metadata,
                    s = r.userData.obb;
                  if (r.visible && o.boundingVolume) {
                    if (!s) {
                      if (o.boundingVolume.region)
                        (s = new xa(
                          o.boundingVolume.region,
                          'id:'.concat(r.id),
                        )),
                          a.add(s),
                          s.updateMatrixWorld(!0);
                      else if (o.boundingVolume.box)
                        (Ha.geometry.boundingBox = o.boundingVolume.box),
                          ((s = new i.BoxHelper(Ha)).material.linewidth = 2);
                      else if (o.boundingVolume.sphere) {
                        var l = new i.SphereGeometry(
                            o.boundingVolume.sphere.radius,
                            32,
                            32,
                          ),
                          c = new i.MeshBasicMaterial({ wireframe: !0 });
                        (s = new i.Mesh(l, c)).position.copy(
                          o.boundingVolume.sphere.center,
                        );
                      }
                      if (s) {
                        s.layer = e;
                        var u = e.threejsLayer;
                        s.layers.set(u),
                          s.children.length && s.children[0].layers.set(u),
                          (r.userData.obb = s),
                          s.updateMatrixWorld();
                      }
                      if (s && !o.boundingVolume.region) {
                        var h = n.tileset.asset.gltfUpAxis;
                        void 0 === h || 'Y' === h
                          ? (s.rotation.x = 0.5 * -Math.PI)
                          : 'X' === h && (s.rotation.z = 0.5 * -Math.PI),
                          r.parent.add(s),
                          s.updateMatrix(),
                          s.updateMatrixWorld(!0);
                      }
                    }
                    s &&
                      ((s.visible = !0),
                      'function' == typeof s.setMaterialVisibility &&
                        s.setMaterialVisibility(!0));
                  } else
                    s &&
                      ((s.visible = !1),
                      'function' == typeof s.setMaterialVisibility &&
                        s.setMaterialVisibility(!1));
                }
              },
              visible: !1,
              cacheLifeTime: 1 / 0,
              source: !1,
            });
          La.b.prototype.addLayer.call(e, s, n).then(function (t) {
            r.add(t, 'visible')
              .name('Bounding boxes')
              .onChange(function () {
                e.notifyChange(e.camera.camera3D);
              });
          }),
            r
              .add(n, 'sseThreshold', 0, 100)
              .name('sseThreshold')
              .onChange(function () {
                e.notifyChange(e.camera.camera3D);
              });
        }
      },
      69: function (t, e) {
        var n;
        n = (function () {
          return this;
        })();
        try {
          n = n || new Function('return this')();
        } catch (t) {
          'object' == typeof window && (n = window);
        }
        t.exports = n;
      },
      7: function (t, e, n) {
        var i = n(54).default,
          r = n(5);
        (t.exports = function (t, e) {
          return !e || ('object' !== i(e) && 'function' != typeof e) ? r(t) : e;
        }),
          (t.exports.default = t.exports),
          (t.exports.__esModule = !0);
      },
      74: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(36),
          l = n(75),
          c = (function () {
            function t(e, n, i, a) {
              r()(this, t),
                (this.type = l.a.batchtable),
                (this.batchLength = i);
              var o = e;
              n > 0 &&
                (console.warn('Binary batch table content not supported yet.'),
                (o = e.slice(0, e.byteLength - n)));
              var c = s.a.decode(new Uint8Array(o)),
                u = JSON.parse(c);
              u.extensions &&
                ((this.extensions = a.parseExtensions(u.extensions, this.type)),
                delete u.extensions),
                (this.content = u);
            }
            return (
              o()(t, [
                {
                  key: 'getInfoById',
                  value: function (t) {
                    if (t < 0 && t < this.batchLength)
                      throw new Error(
                        'Batch Id ('
                          .concat(t, ') must be between 0 and\n            ')
                          .concat(
                            this.batchLength,
                            ' to access feature properties from the batch\n            table.',
                          ),
                      );
                    var e = { batchTable: {} };
                    for (var n in this.content)
                      Object.prototype.hasOwnProperty.call(this.content, n) &&
                        (e.batchTable[n] = this.content[n][t]);
                    if (this.extensions)
                      for (var i in ((e.extensions = {}), this.extensions))
                        Object.prototype.hasOwnProperty.call(
                          this.extensions,
                          i,
                        ) &&
                          (e.extensions[i] = this.extensions[i].getInfoById(t));
                    return e;
                  },
                },
              ]),
              t
            );
          })();
        e.a = c;
      },
      75: function (t, e, n) {
        'use strict';
        e.a = {
          tileset: 'tileset',
          batchtable: 'batchtable',
          boundingVolume: 'boundingVolume',
        };
      },
      77: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = 0,
          l = 1,
          c = 2,
          u = 3,
          h = 4,
          d = [1, 3, 7, 60],
          p = (function () {
            function t() {
              r()(this, t),
                (this.state = s),
                (this.lastErrorTimestamp = 0),
                (this.errorCount = 0),
                (this.failureParams = { lowestLevelError: 1 / 0 });
            }
            return (
              o()(t, [
                {
                  key: 'canTryUpdate',
                  value: function () {
                    var t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : Date.now();
                    switch (this.state) {
                      case s:
                        return !0;
                      case u:
                      case l:
                      case h:
                        return !1;
                      case c:
                      default:
                        var e = 1e3 * this.secondsUntilNextTry();
                        return e <= t - this.lastErrorTimestamp;
                    }
                  },
                },
                {
                  key: 'secondsUntilNextTry',
                  value: function () {
                    if (this.state !== c) return 0;
                    var t = Math.max(
                      0,
                      Math.min(this.errorCount, d.length) - 1,
                    );
                    return d[t];
                  },
                },
                {
                  key: 'newTry',
                  value: function () {
                    this.state = l;
                  },
                },
                {
                  key: 'success',
                  value: function () {
                    (this.lastErrorTimestamp = 0), (this.state = s);
                  },
                },
                {
                  key: 'noMoreUpdatePossible',
                  value: function () {
                    this.state = h;
                  },
                },
                {
                  key: 'noData',
                  value: function (t) {
                    (this.state = s),
                      (this.failureParams.lowestLevelError = Math.min(
                        t.targetLevel,
                        this.failureParams.lowestLevelError,
                      ));
                  },
                },
                {
                  key: 'failure',
                  value: function (t, e, n) {
                    n &&
                      null != n.targetLevel &&
                      (this.failureParams.lowestLevelError = Math.min(
                        n.targetLevel,
                        this.failureParams.lowestLevelError,
                      )),
                      (this.lastErrorTimestamp = t),
                      (this.state = e ? u : c),
                      this.errorCount++;
                  },
                },
                {
                  key: 'inError',
                  value: function () {
                    return this.state == u || this.state == c;
                  },
                },
              ]),
              t
            );
          })();
        e.a = p;
      },
      8: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(0),
          l = n(30),
          c = n(10),
          u = n(33);
        l.default.defs(
          'EPSG:4978',
          '+proj=geocent +datum=WGS84 +units=m +no_defs',
        );
        var h = new u.a(),
          d = {};
        function p(t, e) {
          return (
            d[t] || (d[t] = {}),
            d[t][e] || (d[t][e] = Object(l.default)(t, e)),
            d[t][e]
          );
        }
        var f = (function () {
          function t(e) {
            var n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : 0,
              a =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : 0;
            r()(this, t),
              (this.isCoordinates = !0),
              c.a.isValid(e),
              (this.crs = e),
              (this.x = 0),
              (this.y = 0),
              (this.z = 0),
              (this._normal = new s.Vector3()),
              n.length > 0
                ? this.setFromArray(n)
                : n.isVector3 || n.isCoordinates
                ? this.setFromVector3(n)
                : this.setFromValues(n, i, a),
              (this._normalNeedsUpdate = !0);
          }
          return (
            o()(t, [
              {
                key: 'setFromValues',
                value: function () {
                  var t =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : 0,
                    e =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : 0,
                    n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : 0;
                  return (
                    (this.x = null == t ? 0 : t),
                    (this.y = null == e ? 0 : e),
                    (this.z = null == n ? 0 : n),
                    (this._normalNeedsUpdate = !0),
                    this
                  );
                },
              },
              {
                key: 'setFromArray',
                value: function (t) {
                  var e =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : 0;
                  return this.setFromValues(t[e], t[e + 1], t[e + 2]);
                },
              },
              {
                key: 'setFromVector3',
                value: function (t) {
                  return this.setFromValues(t.x, t.y, t.z);
                },
              },
              {
                key: 'clone',
                value: function () {
                  return new t(this.crs, this);
                },
              },
              {
                key: 'copy',
                value: function (t) {
                  return (this.crs = t.crs), this.setFromVector3(t);
                },
              },
              {
                key: 'longitude',
                get: function () {
                  return this.x;
                },
              },
              {
                key: 'latitude',
                get: function () {
                  return this.y;
                },
              },
              {
                key: 'altitude',
                get: function () {
                  return this.z;
                },
                set: function (t) {
                  this.z = t;
                },
              },
              {
                key: 'geodesicNormal',
                get: function () {
                  return (
                    this._normalNeedsUpdate &&
                      ((this._normalNeedsUpdate = !1),
                      c.a.is4326(this.crs)
                        ? h.geodeticSurfaceNormalCartographic(
                            this,
                            this._normal,
                          )
                        : 'EPSG:4978' == this.crs
                        ? h.geodeticSurfaceNormal(this, this._normal)
                        : this._normal.set(0, 0, 1)),
                    this._normal
                  );
                },
              },
              {
                key: 'toVector3',
                value: function () {
                  var t =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : new s.Vector3();
                  return t.copy(this);
                },
              },
              {
                key: 'applyMatrix4',
                value: function (t) {
                  return s.Vector3.prototype.applyMatrix4.call(this, t);
                },
              },
              {
                key: 'as',
                value: function (e) {
                  var n =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : new t(e);
                  return (
                    this.crs == e
                      ? n.copy(this)
                      : (c.a.is4326(this.crs) &&
                          'EPSG:3857' == e &&
                          (this.y = s.MathUtils.clamp(
                            this.y,
                            -89.999999,
                            89.999999,
                          )),
                        n.setFromArray(
                          p(this.crs, e).forward([this.x, this.y, this.z]),
                        )),
                    (n.crs = e),
                    n
                  );
                },
              },
            ]),
            t
          );
        })();
        e.a = f;
      },
      84: function (t, e, n) {
        'use strict';
        n.d(e, 'c', function () {
          return v;
        }),
          n.d(e, 'd', function () {
            return x;
          }),
          n.d(e, 'b', function () {
            return _;
          });
        var i = n(54),
          r = n.n(i),
          a = n(0),
          o = n(31),
          s = (function () {
            function t(t) {
              a.Loader.call(this, t),
                (this.dracoLoader = null),
                (this.ktx2Loader = null),
                (this.meshoptDecoder = null),
                (this.pluginCallbacks = []),
                this.register(function (t) {
                  return new s(t);
                }),
                this.register(function (t) {
                  return new c(t);
                }),
                this.register(function (t) {
                  return new u(t);
                }),
                this.register(function (t) {
                  return new l(t);
                }),
                this.register(function (t) {
                  return new i(t);
                }),
                this.register(function (t) {
                  return new h(t);
                });
            }
            function e() {
              var t = {};
              return {
                get: function (e) {
                  return t[e];
                },
                add: function (e, n) {
                  t[e] = n;
                },
                remove: function (e) {
                  delete t[e];
                },
                removeAll: function () {
                  t = {};
                },
              };
            }
            t.prototype = Object.assign(Object.create(a.Loader.prototype), {
              constructor: t,
              load: function (t, e, n, i) {
                var r,
                  o = this;
                (r =
                  '' !== this.resourcePath
                    ? this.resourcePath
                    : '' !== this.path
                    ? this.path
                    : a.LoaderUtils.extractUrlBase(t)),
                  this.manager.itemStart(t);
                var s = function (e) {
                    i ? i(e) : console.error(e),
                      o.manager.itemError(t),
                      o.manager.itemEnd(t);
                  },
                  l = new a.FileLoader(this.manager);
                l.setPath(this.path),
                  l.setResponseType('arraybuffer'),
                  l.setRequestHeader(this.requestHeader),
                  l.setWithCredentials(this.withCredentials),
                  l.load(
                    t,
                    function (n) {
                      try {
                        o.parse(
                          n,
                          r,
                          function (n) {
                            e(n), o.manager.itemEnd(t);
                          },
                          s,
                        );
                      } catch (t) {
                        s(t);
                      }
                    },
                    n,
                    s,
                  );
              },
              setDRACOLoader: function (t) {
                return (this.dracoLoader = t), this;
              },
              setDDSLoader: function () {
                throw new Error(
                  'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
                );
              },
              setKTX2Loader: function (t) {
                return (this.ktx2Loader = t), this;
              },
              setMeshoptDecoder: function (t) {
                return (this.meshoptDecoder = t), this;
              },
              register: function (t) {
                return (
                  -1 === this.pluginCallbacks.indexOf(t) &&
                    this.pluginCallbacks.push(t),
                  this
                );
              },
              unregister: function (t) {
                return (
                  -1 !== this.pluginCallbacks.indexOf(t) &&
                    this.pluginCallbacks.splice(
                      this.pluginCallbacks.indexOf(t),
                      1,
                    ),
                  this
                );
              },
              parse: function (t, e, i, r) {
                var s,
                  l = {},
                  c = {};
                if ('string' == typeof t) s = t;
                else if (
                  a.LoaderUtils.decodeText(new Uint8Array(t, 0, 4)) === d
                ) {
                  try {
                    l[n.KHR_BINARY_GLTF] = new m(t);
                  } catch (t) {
                    return void (r && r(t));
                  }
                  s = l[n.KHR_BINARY_GLTF].content;
                } else s = a.LoaderUtils.decodeText(new Uint8Array(t));
                var u = JSON.parse(s);
                if (void 0 === u.asset || u.asset.version[0] < 2)
                  r &&
                    r(
                      new Error(
                        'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.',
                      ),
                    );
                else {
                  var h = new H(u, {
                    path: e || this.resourcePath || '',
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder,
                  });
                  h.fileLoader.setRequestHeader(this.requestHeader);
                  for (var p = 0; p < this.pluginCallbacks.length; p++) {
                    var f = this.pluginCallbacks[p](h);
                    (c[f.name] = f), (l[f.name] = !0);
                  }
                  if (u.extensionsUsed)
                    for (p = 0; p < u.extensionsUsed.length; ++p) {
                      var v = u.extensionsUsed[p],
                        _ = u.extensionsRequired || [];
                      switch (v) {
                        case n.KHR_MATERIALS_UNLIT:
                          l[v] = new o();
                          break;
                        case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                          l[v] = new x();
                          break;
                        case n.KHR_DRACO_MESH_COMPRESSION:
                          l[v] = new g(u, this.dracoLoader);
                          break;
                        case n.KHR_TEXTURE_TRANSFORM:
                          l[v] = new y();
                          break;
                        case n.KHR_MESH_QUANTIZATION:
                          l[v] = new b();
                          break;
                        default:
                          _.indexOf(v) >= 0 &&
                            void 0 === c[v] &&
                            console.warn(
                              'THREE.GLTFLoader: Unknown extension "' +
                                v +
                                '".',
                            );
                      }
                    }
                  h.setExtensions(l), h.setPlugins(c), h.parse(i, r);
                }
              },
            });
            var n = {
              KHR_BINARY_GLTF: 'KHR_binary_glTF',
              KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
              KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
              KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
              KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                'KHR_materials_pbrSpecularGlossiness',
              KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
              KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
              KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
              KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
              KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
              EXT_TEXTURE_WEBP: 'EXT_texture_webp',
              EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
            };
            function i(t) {
              (this.parser = t),
                (this.name = n.KHR_LIGHTS_PUNCTUAL),
                (this.cache = { refs: {}, uses: {} });
            }
            function o() {
              this.name = n.KHR_MATERIALS_UNLIT;
            }
            function s(t) {
              (this.parser = t), (this.name = n.KHR_MATERIALS_CLEARCOAT);
            }
            function l(t) {
              (this.parser = t), (this.name = n.KHR_MATERIALS_TRANSMISSION);
            }
            function c(t) {
              (this.parser = t), (this.name = n.KHR_TEXTURE_BASISU);
            }
            function u(t) {
              (this.parser = t),
                (this.name = n.EXT_TEXTURE_WEBP),
                (this.isSupported = null);
            }
            function h(t) {
              (this.name = n.EXT_MESHOPT_COMPRESSION), (this.parser = t);
            }
            (i.prototype._markDefs = function () {
              for (
                var t = this.parser,
                  e = this.parser.json.nodes || [],
                  n = 0,
                  i = e.length;
                n < i;
                n++
              ) {
                var r = e[n];
                r.extensions &&
                  r.extensions[this.name] &&
                  void 0 !== r.extensions[this.name].light &&
                  t._addNodeRef(this.cache, r.extensions[this.name].light);
              }
            }),
              (i.prototype._loadLight = function (t) {
                var e = this.parser,
                  n = 'light:' + t,
                  i = e.cache.get(n);
                if (i) return i;
                var r,
                  o = e.json,
                  s = (((o.extensions && o.extensions[this.name]) || {})
                    .lights || [])[t],
                  l = new a.Color(16777215);
                void 0 !== s.color && l.fromArray(s.color);
                var c = void 0 !== s.range ? s.range : 0;
                switch (s.type) {
                  case 'directional':
                    (r = new a.DirectionalLight(l)).target.position.set(
                      0,
                      0,
                      -1,
                    ),
                      r.add(r.target);
                    break;
                  case 'point':
                    (r = new a.PointLight(l)).distance = c;
                    break;
                  case 'spot':
                    ((r = new a.SpotLight(l)).distance = c),
                      (s.spot = s.spot || {}),
                      (s.spot.innerConeAngle =
                        void 0 !== s.spot.innerConeAngle
                          ? s.spot.innerConeAngle
                          : 0),
                      (s.spot.outerConeAngle =
                        void 0 !== s.spot.outerConeAngle
                          ? s.spot.outerConeAngle
                          : Math.PI / 4),
                      (r.angle = s.spot.outerConeAngle),
                      (r.penumbra =
                        1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
                      r.target.position.set(0, 0, -1),
                      r.add(r.target);
                    break;
                  default:
                    throw new Error(
                      'THREE.GLTFLoader: Unexpected light type: ' + s.type,
                    );
                }
                return (
                  r.position.set(0, 0, 0),
                  (r.decay = 2),
                  void 0 !== s.intensity && (r.intensity = s.intensity),
                  (r.name = e.createUniqueName(s.name || 'light_' + t)),
                  (i = Promise.resolve(r)),
                  e.cache.add(n, i),
                  i
                );
              }),
              (i.prototype.createNodeAttachment = function (t) {
                var e = this,
                  n = this.parser,
                  i = n.json.nodes[t],
                  r = ((i.extensions && i.extensions[this.name]) || {}).light;
                return void 0 === r
                  ? null
                  : this._loadLight(r).then(function (t) {
                      return n._getNodeRef(e.cache, r, t);
                    });
              }),
              (o.prototype.getMaterialType = function () {
                return a.MeshBasicMaterial;
              }),
              (o.prototype.extendParams = function (t, e, n) {
                var i = [];
                (t.color = new a.Color(1, 1, 1)), (t.opacity = 1);
                var r = e.pbrMetallicRoughness;
                if (r) {
                  if (Array.isArray(r.baseColorFactor)) {
                    var o = r.baseColorFactor;
                    t.color.fromArray(o), (t.opacity = o[3]);
                  }
                  void 0 !== r.baseColorTexture &&
                    i.push(n.assignTexture(t, 'map', r.baseColorTexture));
                }
                return Promise.all(i);
              }),
              (s.prototype.getMaterialType = function (t) {
                var e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name]
                  ? a.MeshPhysicalMaterial
                  : null;
              }),
              (s.prototype.extendMaterialParams = function (t, e) {
                var n = this.parser,
                  i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                  return Promise.resolve();
                var r = [],
                  o = i.extensions[this.name];
                if (
                  (void 0 !== o.clearcoatFactor &&
                    (e.clearcoat = o.clearcoatFactor),
                  void 0 !== o.clearcoatTexture &&
                    r.push(
                      n.assignTexture(e, 'clearcoatMap', o.clearcoatTexture),
                    ),
                  void 0 !== o.clearcoatRoughnessFactor &&
                    (e.clearcoatRoughness = o.clearcoatRoughnessFactor),
                  void 0 !== o.clearcoatRoughnessTexture &&
                    r.push(
                      n.assignTexture(
                        e,
                        'clearcoatRoughnessMap',
                        o.clearcoatRoughnessTexture,
                      ),
                    ),
                  void 0 !== o.clearcoatNormalTexture &&
                    (r.push(
                      n.assignTexture(
                        e,
                        'clearcoatNormalMap',
                        o.clearcoatNormalTexture,
                      ),
                    ),
                    void 0 !== o.clearcoatNormalTexture.scale))
                ) {
                  var s = o.clearcoatNormalTexture.scale;
                  e.clearcoatNormalScale = new a.Vector2(s, -s);
                }
                return Promise.all(r);
              }),
              (l.prototype.getMaterialType = function (t) {
                var e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name]
                  ? a.MeshPhysicalMaterial
                  : null;
              }),
              (l.prototype.extendMaterialParams = function (t, e) {
                var n = this.parser,
                  i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                  return Promise.resolve();
                var r = [],
                  a = i.extensions[this.name];
                return (
                  void 0 !== a.transmissionFactor &&
                    (e.transmission = a.transmissionFactor),
                  void 0 !== a.transmissionTexture &&
                    r.push(
                      n.assignTexture(
                        e,
                        'transmissionMap',
                        a.transmissionTexture,
                      ),
                    ),
                  Promise.all(r)
                );
              }),
              (c.prototype.loadTexture = function (t) {
                var e = this.parser,
                  n = e.json,
                  i = n.textures[t];
                if (!i.extensions || !i.extensions[this.name]) return null;
                var r = i.extensions[this.name],
                  a = n.images[r.source],
                  o = e.options.ktx2Loader;
                if (!o) {
                  if (
                    n.extensionsRequired &&
                    n.extensionsRequired.indexOf(this.name) >= 0
                  )
                    throw new Error(
                      'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures',
                    );
                  return null;
                }
                return e.loadTextureImage(t, a, o);
              }),
              (u.prototype.loadTexture = function (t) {
                var e = this.name,
                  n = this.parser,
                  i = n.json,
                  r = i.textures[t];
                if (!r.extensions || !r.extensions[e]) return null;
                var a = r.extensions[e],
                  o = i.images[a.source],
                  s = n.textureLoader;
                if (o.uri) {
                  var l = n.options.manager.getHandler(o.uri);
                  null !== l && (s = l);
                }
                return this.detectSupport().then(function (r) {
                  if (r) return n.loadTextureImage(t, o, s);
                  if (
                    i.extensionsRequired &&
                    i.extensionsRequired.indexOf(e) >= 0
                  )
                    throw new Error(
                      'THREE.GLTFLoader: WebP required by asset but unsupported.',
                    );
                  return n.loadTexture(t);
                });
              }),
              (u.prototype.detectSupport = function () {
                return (
                  this.isSupported ||
                    (this.isSupported = new Promise(function (t) {
                      var e = new Image();
                      (e.src =
                        'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
                        (e.onload = e.onerror =
                          function () {
                            t(1 === e.height);
                          });
                    })),
                  this.isSupported
                );
              }),
              (h.prototype.loadBufferView = function (t) {
                var e = this.parser.json,
                  n = e.bufferViews[t];
                if (n.extensions && n.extensions[this.name]) {
                  var i = n.extensions[this.name],
                    r = this.parser.getDependency('buffer', i.buffer),
                    a = this.parser.options.meshoptDecoder;
                  if (!a || !a.supported) {
                    if (
                      e.extensionsRequired &&
                      e.extensionsRequired.indexOf(this.name) >= 0
                    )
                      throw new Error(
                        'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files',
                      );
                    return null;
                  }
                  return Promise.all([r, a.ready]).then(function (t) {
                    var e = i.byteOffset || 0,
                      n = i.byteLength || 0,
                      r = i.count,
                      o = i.byteStride,
                      s = new ArrayBuffer(r * o),
                      l = new Uint8Array(t[0], e, n);
                    return (
                      a.decodeGltfBuffer(
                        new Uint8Array(s),
                        r,
                        o,
                        l,
                        i.mode,
                        i.filter,
                      ),
                      s
                    );
                  });
                }
                return null;
              });
            var d = 'glTF',
              p = 1313821514,
              f = 5130562;
            function m(t) {
              (this.name = n.KHR_BINARY_GLTF),
                (this.content = null),
                (this.body = null);
              var e = new DataView(t, 0, 12);
              if (
                ((this.header = {
                  magic: a.LoaderUtils.decodeText(
                    new Uint8Array(t.slice(0, 4)),
                  ),
                  version: e.getUint32(4, !0),
                  length: e.getUint32(8, !0),
                }),
                this.header.magic !== d)
              )
                throw new Error(
                  'THREE.GLTFLoader: Unsupported glTF-Binary header.',
                );
              if (this.header.version < 2)
                throw new Error(
                  'THREE.GLTFLoader: Legacy binary file detected.',
                );
              for (
                var i = this.header.length - 12, r = new DataView(t, 12), o = 0;
                o < i;

              ) {
                var s = r.getUint32(o, !0);
                o += 4;
                var l = r.getUint32(o, !0);
                if (((o += 4), l === p)) {
                  var c = new Uint8Array(t, 12 + o, s);
                  this.content = a.LoaderUtils.decodeText(c);
                } else if (l === f) {
                  var u = 12 + o;
                  this.body = t.slice(u, u + s);
                }
                o += s;
              }
              if (null === this.content)
                throw new Error('THREE.GLTFLoader: JSON content not found.');
            }
            function g(t, e) {
              if (!e)
                throw new Error(
                  'THREE.GLTFLoader: No DRACOLoader instance provided.',
                );
              (this.name = n.KHR_DRACO_MESH_COMPRESSION),
                (this.json = t),
                (this.dracoLoader = e),
                this.dracoLoader.preload();
            }
            function y() {
              this.name = n.KHR_TEXTURE_TRANSFORM;
            }
            function v(t) {
              a.MeshStandardMaterial.call(this),
                (this.isGLTFSpecularGlossinessMaterial = !0);
              var e = [
                  '#ifdef USE_SPECULARMAP',
                  '\tuniform sampler2D specularMap;',
                  '#endif',
                ].join('\n'),
                n = [
                  '#ifdef USE_GLOSSINESSMAP',
                  '\tuniform sampler2D glossinessMap;',
                  '#endif',
                ].join('\n'),
                i = [
                  'vec3 specularFactor = specular;',
                  '#ifdef USE_SPECULARMAP',
                  '\tvec4 texelSpecular = texture2D( specularMap, vUv );',
                  '\ttexelSpecular = sRGBToLinear( texelSpecular );',
                  '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
                  '\tspecularFactor *= texelSpecular.rgb;',
                  '#endif',
                ].join('\n'),
                r = [
                  'float glossinessFactor = glossiness;',
                  '#ifdef USE_GLOSSINESSMAP',
                  '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',
                  '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
                  '\tglossinessFactor *= texelGlossiness.a;',
                  '#endif',
                ].join('\n'),
                o = [
                  'PhysicalMaterial material;',
                  'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
                  'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
                  'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
                  'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
                  'material.specularRoughness += geometryRoughness;',
                  'material.specularRoughness = min( material.specularRoughness, 1.0 );',
                  'material.specularColor = specularFactor;',
                ].join('\n'),
                s = {
                  specular: { value: new a.Color().setHex(16777215) },
                  glossiness: { value: 1 },
                  specularMap: { value: null },
                  glossinessMap: { value: null },
                };
              (this._extraUniforms = s),
                (this.onBeforeCompile = function (t) {
                  for (var a in s) t.uniforms[a] = s[a];
                  t.fragmentShader = t.fragmentShader
                    .replace(
                      'uniform float roughness;',
                      'uniform vec3 specular;',
                    )
                    .replace(
                      'uniform float metalness;',
                      'uniform float glossiness;',
                    )
                    .replace('#include <roughnessmap_pars_fragment>', e)
                    .replace('#include <metalnessmap_pars_fragment>', n)
                    .replace('#include <roughnessmap_fragment>', i)
                    .replace('#include <metalnessmap_fragment>', r)
                    .replace('#include <lights_physical_fragment>', o);
                }),
                Object.defineProperties(this, {
                  specular: {
                    get: function () {
                      return s.specular.value;
                    },
                    set: function (t) {
                      s.specular.value = t;
                    },
                  },
                  specularMap: {
                    get: function () {
                      return s.specularMap.value;
                    },
                    set: function (t) {
                      (s.specularMap.value = t),
                        t
                          ? (this.defines.USE_SPECULARMAP = '')
                          : delete this.defines.USE_SPECULARMAP;
                    },
                  },
                  glossiness: {
                    get: function () {
                      return s.glossiness.value;
                    },
                    set: function (t) {
                      s.glossiness.value = t;
                    },
                  },
                  glossinessMap: {
                    get: function () {
                      return s.glossinessMap.value;
                    },
                    set: function (t) {
                      (s.glossinessMap.value = t),
                        t
                          ? ((this.defines.USE_GLOSSINESSMAP = ''),
                            (this.defines.USE_UV = ''))
                          : (delete this.defines.USE_GLOSSINESSMAP,
                            delete this.defines.USE_UV);
                    },
                  },
                }),
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this.setValues(t);
            }
            function x() {
              return {
                name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                specularGlossinessParams: [
                  'color',
                  'map',
                  'lightMap',
                  'lightMapIntensity',
                  'aoMap',
                  'aoMapIntensity',
                  'emissive',
                  'emissiveIntensity',
                  'emissiveMap',
                  'bumpMap',
                  'bumpScale',
                  'normalMap',
                  'normalMapType',
                  'displacementMap',
                  'displacementScale',
                  'displacementBias',
                  'specularMap',
                  'specular',
                  'glossinessMap',
                  'glossiness',
                  'alphaMap',
                  'envMap',
                  'envMapIntensity',
                  'refractionRatio',
                ],
                getMaterialType: function () {
                  return v;
                },
                extendParams: function (t, e, n) {
                  var i = e.extensions[this.name];
                  (t.color = new a.Color(1, 1, 1)), (t.opacity = 1);
                  var r = [];
                  if (Array.isArray(i.diffuseFactor)) {
                    var o = i.diffuseFactor;
                    t.color.fromArray(o), (t.opacity = o[3]);
                  }
                  if (
                    (void 0 !== i.diffuseTexture &&
                      r.push(n.assignTexture(t, 'map', i.diffuseTexture)),
                    (t.emissive = new a.Color(0, 0, 0)),
                    (t.glossiness =
                      void 0 !== i.glossinessFactor ? i.glossinessFactor : 1),
                    (t.specular = new a.Color(1, 1, 1)),
                    Array.isArray(i.specularFactor) &&
                      t.specular.fromArray(i.specularFactor),
                    void 0 !== i.specularGlossinessTexture)
                  ) {
                    var s = i.specularGlossinessTexture;
                    r.push(n.assignTexture(t, 'glossinessMap', s)),
                      r.push(n.assignTexture(t, 'specularMap', s));
                  }
                  return Promise.all(r);
                },
                createMaterial: function (t) {
                  var e = new v(t);
                  return (
                    (e.fog = !0),
                    (e.color = t.color),
                    (e.map = void 0 === t.map ? null : t.map),
                    (e.lightMap = null),
                    (e.lightMapIntensity = 1),
                    (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
                    (e.aoMapIntensity = 1),
                    (e.emissive = t.emissive),
                    (e.emissiveIntensity = 1),
                    (e.emissiveMap =
                      void 0 === t.emissiveMap ? null : t.emissiveMap),
                    (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
                    (e.bumpScale = 1),
                    (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
                    (e.normalMapType = a.TangentSpaceNormalMap),
                    t.normalScale && (e.normalScale = t.normalScale),
                    (e.displacementMap = null),
                    (e.displacementScale = 1),
                    (e.displacementBias = 0),
                    (e.specularMap =
                      void 0 === t.specularMap ? null : t.specularMap),
                    (e.specular = t.specular),
                    (e.glossinessMap =
                      void 0 === t.glossinessMap ? null : t.glossinessMap),
                    (e.glossiness = t.glossiness),
                    (e.alphaMap = null),
                    (e.envMap = void 0 === t.envMap ? null : t.envMap),
                    (e.envMapIntensity = 1),
                    (e.refractionRatio = 0.98),
                    e
                  );
                },
              };
            }
            function b() {
              this.name = n.KHR_MESH_QUANTIZATION;
            }
            function _(t, e, n, i) {
              a.Interpolant.call(this, t, e, n, i);
            }
            (g.prototype.decodePrimitive = function (t, e) {
              var n = this.json,
                i = this.dracoLoader,
                r = t.extensions[this.name].bufferView,
                a = t.extensions[this.name].attributes,
                o = {},
                s = {},
                l = {};
              for (var c in a) {
                var u = k[c] || c.toLowerCase();
                o[u] = a[c];
              }
              for (c in t.attributes) {
                u = k[c] || c.toLowerCase();
                if (void 0 !== a[c]) {
                  var h = n.accessors[t.attributes[c]],
                    d = L[h.componentType];
                  (l[u] = d), (s[u] = !0 === h.normalized);
                }
              }
              return e.getDependency('bufferView', r).then(function (t) {
                return new Promise(function (e) {
                  i.decodeDracoFile(
                    t,
                    function (t) {
                      for (var n in t.attributes) {
                        var i = t.attributes[n],
                          r = s[n];
                        void 0 !== r && (i.normalized = r);
                      }
                      e(t);
                    },
                    o,
                    l,
                  );
                });
              });
            }),
              (y.prototype.extendTexture = function (t, e) {
                return (
                  (t = t.clone()),
                  void 0 !== e.offset && t.offset.fromArray(e.offset),
                  void 0 !== e.rotation && (t.rotation = e.rotation),
                  void 0 !== e.scale && t.repeat.fromArray(e.scale),
                  void 0 !== e.texCoord &&
                    console.warn(
                      'THREE.GLTFLoader: Custom UV sets in "' +
                        this.name +
                        '" extension not yet supported.',
                    ),
                  (t.needsUpdate = !0),
                  t
                );
              }),
              (v.prototype = Object.create(a.MeshStandardMaterial.prototype)),
              (v.prototype.constructor = v),
              (v.prototype.copy = function (t) {
                return (
                  a.MeshStandardMaterial.prototype.copy.call(this, t),
                  (this.specularMap = t.specularMap),
                  this.specular.copy(t.specular),
                  (this.glossinessMap = t.glossinessMap),
                  (this.glossiness = t.glossiness),
                  delete this.metalness,
                  delete this.roughness,
                  delete this.metalnessMap,
                  delete this.roughnessMap,
                  this
                );
              }),
              (_.prototype = Object.create(a.Interpolant.prototype)),
              (_.prototype.constructor = _),
              (_.prototype.copySampleValue_ = function (t) {
                for (
                  var e = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = 0;
                  r !== i;
                  r++
                )
                  e[r] = n[t * i * 3 + i + r];
                return e;
              }),
              (_.prototype.beforeStart_ = _.prototype.copySampleValue_),
              (_.prototype.afterEnd_ = _.prototype.copySampleValue_),
              (_.prototype.interpolate_ = function (t, e, n, i) {
                for (
                  var r = this.resultBuffer,
                    a = this.sampleValues,
                    o = this.valueSize,
                    s = 3 * o,
                    l = i - e,
                    c = (n - e) / l,
                    u = c * c,
                    h = u * c,
                    d = t * s,
                    p = d - s,
                    f = -2 * h + 3 * u,
                    m = h - u,
                    g = 0;
                  g !== o;
                  g++
                ) {
                  var y = a[p + g + o],
                    v = a[p + g + 2 * o] * l,
                    x = a[d + g + o],
                    b = a[d + g] * l;
                  r[g] = (1 - f) * y + (m - u + c) * v + f * x + m * b;
                }
                return r;
              });
            var w = 0,
              M = 1,
              q = 2,
              S = 3,
              T = 4,
              E = 5,
              A = 6,
              L = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array,
              },
              R = {
                9728: a.NearestFilter,
                9729: a.LinearFilter,
                9984: a.NearestMipmapNearestFilter,
                9985: a.LinearMipmapNearestFilter,
                9986: a.NearestMipmapLinearFilter,
                9987: a.LinearMipmapLinearFilter,
              },
              C = {
                33071: a.ClampToEdgeWrapping,
                33648: a.MirroredRepeatWrapping,
                10497: a.RepeatWrapping,
              },
              P = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16,
              },
              k = {
                POSITION: 'position',
                NORMAL: 'normal',
                TANGENT: 'tangent',
                TEXCOORD_0: 'uv',
                TEXCOORD_1: 'uv2',
                COLOR_0: 'color',
                WEIGHTS_0: 'skinWeight',
                JOINTS_0: 'skinIndex',
                _BATCHID: '_BATCHID',
              },
              I = {
                scale: 'scale',
                translation: 'position',
                rotation: 'quaternion',
                weights: 'morphTargetInfluences',
              },
              D = {
                CUBICSPLINE: void 0,
                LINEAR: a.InterpolateLinear,
                STEP: a.InterpolateDiscrete,
              },
              O = 'OPAQUE',
              N = 'MASK',
              z = 'BLEND';
            function F(t, e) {
              return 'string' != typeof t || '' === t
                ? ''
                : (/^https?:\/\//i.test(e) &&
                    /^\//.test(t) &&
                    (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
                  /^(https?:)?\/\//i.test(t) ||
                  /^data:.*,.*$/i.test(t) ||
                  /^blob:.*$/i.test(t)
                    ? t
                    : e + t);
            }
            function B(t, e, n) {
              for (var i in n.extensions)
                void 0 === t[i] &&
                  ((e.userData.gltfExtensions =
                    e.userData.gltfExtensions || {}),
                  (e.userData.gltfExtensions[i] = n.extensions[i]));
            }
            function U(t, e) {
              void 0 !== e.extras &&
                ('object' === r()(e.extras)
                  ? Object.assign(t.userData, e.extras)
                  : console.warn(
                      'THREE.GLTFLoader: Ignoring primitive type .extras, ' +
                        e.extras,
                    ));
            }
            function j(t, e) {
              if ((t.updateMorphTargets(), void 0 !== e.weights))
                for (var n = 0, i = e.weights.length; n < i; n++)
                  t.morphTargetInfluences[n] = e.weights[n];
              if (e.extras && Array.isArray(e.extras.targetNames)) {
                var r = e.extras.targetNames;
                if (t.morphTargetInfluences.length === r.length) {
                  t.morphTargetDictionary = {};
                  for (n = 0, i = r.length; n < i; n++)
                    t.morphTargetDictionary[r[n]] = n;
                } else
                  console.warn(
                    'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.',
                  );
              }
            }
            function G(t) {
              for (
                var e = '', n = Object.keys(t).sort(), i = 0, r = n.length;
                i < r;
                i++
              )
                e += n[i] + ':' + t[n[i]] + ';';
              return e;
            }
            function H(t, n) {
              (this.json = t || {}),
                (this.extensions = {}),
                (this.plugins = {}),
                (this.options = n || {}),
                (this.cache = new e()),
                (this.associations = new Map()),
                (this.primitiveCache = {}),
                (this.meshCache = { refs: {}, uses: {} }),
                (this.cameraCache = { refs: {}, uses: {} }),
                (this.lightCache = { refs: {}, uses: {} }),
                (this.nodeNamesUsed = {}),
                'undefined' != typeof createImageBitmap &&
                !1 === /Firefox/.test(navigator.userAgent)
                  ? (this.textureLoader = new a.ImageBitmapLoader(
                      this.options.manager,
                    ))
                  : (this.textureLoader = new a.TextureLoader(
                      this.options.manager,
                    )),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                (this.fileLoader = new a.FileLoader(this.options.manager)),
                this.fileLoader.setResponseType('arraybuffer'),
                'use-credentials' === this.options.crossOrigin &&
                  this.fileLoader.setWithCredentials(!0);
            }
            function V(t, e, n) {
              var i = e.attributes,
                r = [];
              function o(e, i) {
                return n.getDependency('accessor', e).then(function (e) {
                  t.setAttribute(i, e);
                });
              }
              for (var s in i) {
                var l = k[s] || s.toLowerCase();
                l in t.attributes || r.push(o(i[s], l));
              }
              if (void 0 !== e.indices && !t.index) {
                var c = n
                  .getDependency('accessor', e.indices)
                  .then(function (e) {
                    t.setIndex(e);
                  });
                r.push(c);
              }
              return (
                U(t, e),
                (function (t, e, n) {
                  var i = e.attributes,
                    r = new a.Box3();
                  if (void 0 !== i.POSITION) {
                    var o = (f = n.json.accessors[i.POSITION]).min,
                      s = f.max;
                    if (void 0 !== o && void 0 !== s) {
                      r.set(
                        new a.Vector3(o[0], o[1], o[2]),
                        new a.Vector3(s[0], s[1], s[2]),
                      );
                      var l = e.targets;
                      if (void 0 !== l) {
                        for (
                          var c = new a.Vector3(),
                            u = new a.Vector3(),
                            h = 0,
                            d = l.length;
                          h < d;
                          h++
                        ) {
                          var p = l[h];
                          if (void 0 !== p.POSITION) {
                            var f;
                            (o = (f = n.json.accessors[p.POSITION]).min),
                              (s = f.max);
                            void 0 !== o && void 0 !== s
                              ? (u.setX(
                                  Math.max(Math.abs(o[0]), Math.abs(s[0])),
                                ),
                                u.setY(
                                  Math.max(Math.abs(o[1]), Math.abs(s[1])),
                                ),
                                u.setZ(
                                  Math.max(Math.abs(o[2]), Math.abs(s[2])),
                                ),
                                c.max(u))
                              : console.warn(
                                  'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
                                );
                          }
                        }
                        r.expandByVector(c);
                      }
                      t.boundingBox = r;
                      var m = new a.Sphere();
                      r.getCenter(m.center),
                        (m.radius = r.min.distanceTo(r.max) / 2),
                        (t.boundingSphere = m);
                    } else
                      console.warn(
                        'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
                      );
                  }
                })(t, e, n),
                Promise.all(r).then(function () {
                  return void 0 !== e.targets
                    ? (function (t, e, n) {
                        for (
                          var i = !1, r = !1, a = 0, o = e.length;
                          a < o;
                          a++
                        ) {
                          if (
                            (void 0 !== (c = e[a]).POSITION && (i = !0),
                            void 0 !== c.NORMAL && (r = !0),
                            i && r)
                          )
                            break;
                        }
                        if (!i && !r) return Promise.resolve(t);
                        var s = [],
                          l = [];
                        for (a = 0, o = e.length; a < o; a++) {
                          var c = e[a];
                          if (i) {
                            var u =
                              void 0 !== c.POSITION
                                ? n.getDependency('accessor', c.POSITION)
                                : t.attributes.position;
                            s.push(u);
                          }
                          if (r) {
                            u =
                              void 0 !== c.NORMAL
                                ? n.getDependency('accessor', c.NORMAL)
                                : t.attributes.normal;
                            l.push(u);
                          }
                        }
                        return Promise.all([
                          Promise.all(s),
                          Promise.all(l),
                        ]).then(function (e) {
                          var n = e[0],
                            a = e[1];
                          return (
                            i && (t.morphAttributes.position = n),
                            r && (t.morphAttributes.normal = a),
                            (t.morphTargetsRelative = !0),
                            t
                          );
                        });
                      })(t, e.targets, n)
                    : t;
                })
              );
            }
            function W(t, e) {
              var n = t.getIndex();
              if (null === n) {
                var i = [],
                  r = t.getAttribute('position');
                if (void 0 === r)
                  return (
                    console.error(
                      'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',
                    ),
                    t
                  );
                for (var o = 0; o < r.count; o++) i.push(o);
                t.setIndex(i), (n = t.getIndex());
              }
              var s = n.count - 2,
                l = [];
              if (e === a.TriangleFanDrawMode)
                for (o = 1; o <= s; o++)
                  l.push(n.getX(0)), l.push(n.getX(o)), l.push(n.getX(o + 1));
              else
                for (o = 0; o < s; o++)
                  o % 2 == 0
                    ? (l.push(n.getX(o)),
                      l.push(n.getX(o + 1)),
                      l.push(n.getX(o + 2)))
                    : (l.push(n.getX(o + 2)),
                      l.push(n.getX(o + 1)),
                      l.push(n.getX(o)));
              l.length / 3 !== s &&
                console.error(
                  'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.',
                );
              var c = t.clone();
              return c.setIndex(l), c;
            }
            return (
              (H.prototype.setExtensions = function (t) {
                this.extensions = t;
              }),
              (H.prototype.setPlugins = function (t) {
                this.plugins = t;
              }),
              (H.prototype.parse = function (t, e) {
                var n = this,
                  i = this.json,
                  r = this.extensions;
                this.cache.removeAll(),
                  this._invokeAll(function (t) {
                    return t._markDefs && t._markDefs();
                  }),
                  Promise.all(
                    this._invokeAll(function (t) {
                      return t.beforeRoot && t.beforeRoot();
                    }),
                  )
                    .then(function () {
                      return Promise.all([
                        n.getDependencies('scene'),
                        n.getDependencies('animation'),
                        n.getDependencies('camera'),
                      ]);
                    })
                    .then(function (e) {
                      var a = {
                        scene: e[0][i.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: i.asset,
                        parser: n,
                        userData: {},
                      };
                      B(r, a, i),
                        U(a, i),
                        Promise.all(
                          n._invokeAll(function (t) {
                            return t.afterRoot && t.afterRoot(a);
                          }),
                        ).then(function () {
                          t(a);
                        });
                    })
                    .catch(e);
              }),
              (H.prototype._markDefs = function () {
                for (
                  var t = this.json.nodes || [],
                    e = this.json.skins || [],
                    n = this.json.meshes || [],
                    i = 0,
                    r = e.length;
                  i < r;
                  i++
                )
                  for (var a = e[i].joints, o = 0, s = a.length; o < s; o++)
                    t[a[o]].isBone = !0;
                for (var l = 0, c = t.length; l < c; l++) {
                  var u = t[l];
                  void 0 !== u.mesh &&
                    (this._addNodeRef(this.meshCache, u.mesh),
                    void 0 !== u.skin && (n[u.mesh].isSkinnedMesh = !0)),
                    void 0 !== u.camera &&
                      this._addNodeRef(this.cameraCache, u.camera);
                }
              }),
              (H.prototype._addNodeRef = function (t, e) {
                void 0 !== e &&
                  (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
                  t.refs[e]++);
              }),
              (H.prototype._getNodeRef = function (t, e, n) {
                if (t.refs[e] <= 1) return n;
                var i = n.clone();
                return (i.name += '_instance_' + t.uses[e]++), i;
              }),
              (H.prototype._invokeOne = function (t) {
                var e = Object.values(this.plugins);
                e.push(this);
                for (var n = 0; n < e.length; n++) {
                  var i = t(e[n]);
                  if (i) return i;
                }
              }),
              (H.prototype._invokeAll = function (t) {
                var e = Object.values(this.plugins);
                e.unshift(this);
                for (var n = [], i = 0; i < e.length; i++) {
                  var r = t(e[i]);
                  r && n.push(r);
                }
                return n;
              }),
              (H.prototype.getDependency = function (t, e) {
                var n = t + ':' + e,
                  i = this.cache.get(n);
                if (!i) {
                  switch (t) {
                    case 'scene':
                      i = this.loadScene(e);
                      break;
                    case 'node':
                      i = this.loadNode(e);
                      break;
                    case 'mesh':
                      i = this._invokeOne(function (t) {
                        return t.loadMesh && t.loadMesh(e);
                      });
                      break;
                    case 'accessor':
                      i = this.loadAccessor(e);
                      break;
                    case 'bufferView':
                      i = this._invokeOne(function (t) {
                        return t.loadBufferView && t.loadBufferView(e);
                      });
                      break;
                    case 'buffer':
                      i = this.loadBuffer(e);
                      break;
                    case 'material':
                      i = this._invokeOne(function (t) {
                        return t.loadMaterial && t.loadMaterial(e);
                      });
                      break;
                    case 'texture':
                      i = this._invokeOne(function (t) {
                        return t.loadTexture && t.loadTexture(e);
                      });
                      break;
                    case 'skin':
                      i = this.loadSkin(e);
                      break;
                    case 'animation':
                      i = this.loadAnimation(e);
                      break;
                    case 'camera':
                      i = this.loadCamera(e);
                      break;
                    default:
                      throw new Error('Unknown type: ' + t);
                  }
                  this.cache.add(n, i);
                }
                return i;
              }),
              (H.prototype.getDependencies = function (t) {
                var e = this.cache.get(t);
                if (!e) {
                  var n = this,
                    i = this.json[t + ('mesh' === t ? 'es' : 's')] || [];
                  (e = Promise.all(
                    i.map(function (e, i) {
                      return n.getDependency(t, i);
                    }),
                  )),
                    this.cache.add(t, e);
                }
                return e;
              }),
              (H.prototype.loadBuffer = function (t) {
                var e = this.json.buffers[t],
                  i = this.fileLoader;
                if (e.type && 'arraybuffer' !== e.type)
                  throw new Error(
                    'THREE.GLTFLoader: ' +
                      e.type +
                      ' buffer type is not supported.',
                  );
                if (void 0 === e.uri && 0 === t)
                  return Promise.resolve(
                    this.extensions[n.KHR_BINARY_GLTF].body,
                  );
                var r = this.options;
                return new Promise(function (t, n) {
                  i.load(F(e.uri, r.path), t, void 0, function () {
                    n(
                      new Error(
                        'THREE.GLTFLoader: Failed to load buffer "' +
                          e.uri +
                          '".',
                      ),
                    );
                  });
                });
              }),
              (H.prototype.loadBufferView = function (t) {
                var e = this.json.bufferViews[t];
                return this.getDependency('buffer', e.buffer).then(function (
                  t,
                ) {
                  var n = e.byteLength || 0,
                    i = e.byteOffset || 0;
                  return t.slice(i, i + n);
                });
              }),
              (H.prototype.loadAccessor = function (t) {
                var e = this,
                  n = this.json,
                  i = this.json.accessors[t];
                if (void 0 === i.bufferView && void 0 === i.sparse)
                  return Promise.resolve(null);
                var r = [];
                return (
                  void 0 !== i.bufferView
                    ? r.push(this.getDependency('bufferView', i.bufferView))
                    : r.push(null),
                  void 0 !== i.sparse &&
                    (r.push(
                      this.getDependency(
                        'bufferView',
                        i.sparse.indices.bufferView,
                      ),
                    ),
                    r.push(
                      this.getDependency(
                        'bufferView',
                        i.sparse.values.bufferView,
                      ),
                    )),
                  Promise.all(r).then(function (t) {
                    var r,
                      o,
                      s = t[0],
                      l = P[i.type],
                      c = L[i.componentType],
                      u = c.BYTES_PER_ELEMENT,
                      h = i.byteOffset || 0,
                      d =
                        void 0 !== i.bufferView
                          ? n.bufferViews[i.bufferView].byteStride
                          : void 0,
                      p = !0 === i.normalized;
                    if (d && d !== u * l) {
                      var f = Math.floor(h / d),
                        m =
                          'InterleavedBuffer:' +
                          i.bufferView +
                          ':' +
                          i.componentType +
                          ':' +
                          f +
                          ':' +
                          i.count,
                        g = e.cache.get(m);
                      g ||
                        ((r = new c(s, f * d, (i.count * d) / u)),
                        (g = new a.InterleavedBuffer(r, d / u)),
                        e.cache.add(m, g)),
                        (o = new a.InterleavedBufferAttribute(
                          g,
                          l,
                          (h % d) / u,
                          p,
                        ));
                    } else (r = null === s ? new c(i.count * l) : new c(s, h, i.count * l)), (o = new a.BufferAttribute(r, l, p));
                    if (void 0 !== i.sparse) {
                      var y = P.SCALAR,
                        v = L[i.sparse.indices.componentType],
                        x = i.sparse.indices.byteOffset || 0,
                        b = i.sparse.values.byteOffset || 0,
                        _ = new v(t[1], x, i.sparse.count * y),
                        w = new c(t[2], b, i.sparse.count * l);
                      null !== s &&
                        (o = new a.BufferAttribute(
                          o.array.slice(),
                          o.itemSize,
                          o.normalized,
                        ));
                      for (var M = 0, q = _.length; M < q; M++) {
                        var S = _[M];
                        if (
                          (o.setX(S, w[M * l]),
                          l >= 2 && o.setY(S, w[M * l + 1]),
                          l >= 3 && o.setZ(S, w[M * l + 2]),
                          l >= 4 && o.setW(S, w[M * l + 3]),
                          l >= 5)
                        )
                          throw new Error(
                            'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.',
                          );
                      }
                    }
                    return o;
                  })
                );
              }),
              (H.prototype.loadTexture = function (t) {
                var e = this.json,
                  n = this.options,
                  i = e.textures[t],
                  r = e.images[i.source],
                  a = this.textureLoader;
                if (r.uri) {
                  var o = n.manager.getHandler(r.uri);
                  null !== o && (a = o);
                }
                return this.loadTextureImage(t, r, a);
              }),
              (H.prototype.loadTextureImage = function (t, e, n) {
                var i = this,
                  r = this.json,
                  o = this.options,
                  s = r.textures[t],
                  l = self.URL || self.webkitURL,
                  c = e.uri,
                  u = !1,
                  h = !0;
                if (
                  ('image/jpeg' === e.mimeType && (h = !1),
                  void 0 !== e.bufferView)
                )
                  c = i
                    .getDependency('bufferView', e.bufferView)
                    .then(function (t) {
                      if ('image/png' === e.mimeType) {
                        var n = new DataView(t, 25, 1).getUint8(0, !1);
                        h = 6 === n || 4 === n || 3 === n;
                      }
                      u = !0;
                      var i = new Blob([t], { type: e.mimeType });
                      return (c = l.createObjectURL(i));
                    });
                else if (void 0 === e.uri)
                  throw new Error(
                    'THREE.GLTFLoader: Image ' +
                      t +
                      ' is missing URI and bufferView',
                  );
                return Promise.resolve(c)
                  .then(function (t) {
                    return new Promise(function (e, i) {
                      var r = e;
                      !0 === n.isImageBitmapLoader &&
                        (r = function (t) {
                          e(new a.CanvasTexture(t));
                        }),
                        n.load(F(t, o.path), r, void 0, i);
                    });
                  })
                  .then(function (e) {
                    !0 === u && l.revokeObjectURL(c),
                      (e.flipY = !1),
                      s.name && (e.name = s.name),
                      h || (e.format = a.RGBFormat);
                    var n = (r.samplers || {})[s.sampler] || {};
                    return (
                      (e.magFilter = R[n.magFilter] || a.LinearFilter),
                      (e.minFilter =
                        R[n.minFilter] || a.LinearMipmapLinearFilter),
                      (e.wrapS = C[n.wrapS] || a.RepeatWrapping),
                      (e.wrapT = C[n.wrapT] || a.RepeatWrapping),
                      i.associations.set(e, { type: 'textures', index: t }),
                      e
                    );
                  });
              }),
              (H.prototype.assignTexture = function (t, e, i) {
                var r = this;
                return this.getDependency('texture', i.index).then(function (
                  a,
                ) {
                  if (
                    (void 0 === i.texCoord ||
                      0 == i.texCoord ||
                      ('aoMap' === e && 1 == i.texCoord) ||
                      console.warn(
                        'THREE.GLTFLoader: Custom UV set ' +
                          i.texCoord +
                          ' for texture ' +
                          e +
                          ' not yet supported.',
                      ),
                    r.extensions[n.KHR_TEXTURE_TRANSFORM])
                  ) {
                    var o =
                      void 0 !== i.extensions
                        ? i.extensions[n.KHR_TEXTURE_TRANSFORM]
                        : void 0;
                    if (o) {
                      var s = r.associations.get(a);
                      (a = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(
                        a,
                        o,
                      )),
                        r.associations.set(a, s);
                    }
                  }
                  t[e] = a;
                });
              }),
              (H.prototype.assignFinalMaterial = function (t) {
                var e = t.geometry,
                  n = t.material,
                  i = void 0 !== e.attributes.tangent,
                  r = void 0 !== e.attributes.color,
                  o = void 0 === e.attributes.normal,
                  s = !0 === t.isSkinnedMesh,
                  l = Object.keys(e.morphAttributes).length > 0,
                  c = l && void 0 !== e.morphAttributes.normal;
                if (t.isPoints) {
                  var u = 'PointsMaterial:' + n.uuid,
                    h = this.cache.get(u);
                  h ||
                    ((h = new a.PointsMaterial()),
                    a.Material.prototype.copy.call(h, n),
                    h.color.copy(n.color),
                    (h.map = n.map),
                    (h.sizeAttenuation = !1),
                    this.cache.add(u, h)),
                    (n = h);
                } else if (t.isLine) {
                  u = 'LineBasicMaterial:' + n.uuid;
                  var d = this.cache.get(u);
                  d ||
                    ((d = new a.LineBasicMaterial()),
                    a.Material.prototype.copy.call(d, n),
                    d.color.copy(n.color),
                    this.cache.add(u, d)),
                    (n = d);
                }
                if (i || r || o || s || l) {
                  u = 'ClonedMaterial:' + n.uuid + ':';
                  n.isGLTFSpecularGlossinessMaterial &&
                    (u += 'specular-glossiness:'),
                    s && (u += 'skinning:'),
                    i && (u += 'vertex-tangents:'),
                    r && (u += 'vertex-colors:'),
                    o && (u += 'flat-shading:'),
                    l && (u += 'morph-targets:'),
                    c && (u += 'morph-normals:');
                  var p = this.cache.get(u);
                  p ||
                    ((p = n.clone()),
                    s && (p.skinning = !0),
                    r && (p.vertexColors = !0),
                    o && (p.flatShading = !0),
                    l && (p.morphTargets = !0),
                    c && (p.morphNormals = !0),
                    i &&
                      ((p.vertexTangents = !0),
                      p.normalScale && (p.normalScale.y *= -1),
                      p.clearcoatNormalScale &&
                        (p.clearcoatNormalScale.y *= -1)),
                    this.cache.add(u, p),
                    this.associations.set(p, this.associations.get(n))),
                    (n = p);
                }
                n.aoMap &&
                  void 0 === e.attributes.uv2 &&
                  void 0 !== e.attributes.uv &&
                  e.setAttribute('uv2', e.attributes.uv),
                  (t.material = n);
              }),
              (H.prototype.getMaterialType = function () {
                return a.MeshStandardMaterial;
              }),
              (H.prototype.loadMaterial = function (t) {
                var e,
                  i = this,
                  r = this.json,
                  o = this.extensions,
                  s = r.materials[t],
                  l = {},
                  c = s.extensions || {},
                  u = [];
                if (c[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                  var h = o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                  (e = h.getMaterialType()), u.push(h.extendParams(l, s, i));
                } else if (c[n.KHR_MATERIALS_UNLIT]) {
                  var d = o[n.KHR_MATERIALS_UNLIT];
                  (e = d.getMaterialType()), u.push(d.extendParams(l, s, i));
                } else {
                  var p = s.pbrMetallicRoughness || {};
                  if (
                    ((l.color = new a.Color(1, 1, 1)),
                    (l.opacity = 1),
                    Array.isArray(p.baseColorFactor))
                  ) {
                    var f = p.baseColorFactor;
                    l.color.fromArray(f), (l.opacity = f[3]);
                  }
                  void 0 !== p.baseColorTexture &&
                    u.push(i.assignTexture(l, 'map', p.baseColorTexture)),
                    (l.metalness =
                      void 0 !== p.metallicFactor ? p.metallicFactor : 1),
                    (l.roughness =
                      void 0 !== p.roughnessFactor ? p.roughnessFactor : 1),
                    void 0 !== p.metallicRoughnessTexture &&
                      (u.push(
                        i.assignTexture(
                          l,
                          'metalnessMap',
                          p.metallicRoughnessTexture,
                        ),
                      ),
                      u.push(
                        i.assignTexture(
                          l,
                          'roughnessMap',
                          p.metallicRoughnessTexture,
                        ),
                      )),
                    (e = this._invokeOne(function (e) {
                      return e.getMaterialType && e.getMaterialType(t);
                    })),
                    u.push(
                      Promise.all(
                        this._invokeAll(function (e) {
                          return (
                            e.extendMaterialParams &&
                            e.extendMaterialParams(t, l)
                          );
                        }),
                      ),
                    );
                }
                !0 === s.doubleSided && (l.side = a.DoubleSide);
                var m = s.alphaMode || O;
                return (
                  m === z
                    ? ((l.transparent = !0), (l.depthWrite = !1))
                    : ((l.transparent = !1),
                      m === N &&
                        (l.alphaTest =
                          void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
                  void 0 !== s.normalTexture &&
                    e !== a.MeshBasicMaterial &&
                    (u.push(i.assignTexture(l, 'normalMap', s.normalTexture)),
                    (l.normalScale = new a.Vector2(1, -1)),
                    void 0 !== s.normalTexture.scale &&
                      l.normalScale.set(
                        s.normalTexture.scale,
                        -s.normalTexture.scale,
                      )),
                  void 0 !== s.occlusionTexture &&
                    e !== a.MeshBasicMaterial &&
                    (u.push(i.assignTexture(l, 'aoMap', s.occlusionTexture)),
                    void 0 !== s.occlusionTexture.strength &&
                      (l.aoMapIntensity = s.occlusionTexture.strength)),
                  void 0 !== s.emissiveFactor &&
                    e !== a.MeshBasicMaterial &&
                    (l.emissive = new a.Color().fromArray(s.emissiveFactor)),
                  void 0 !== s.emissiveTexture &&
                    e !== a.MeshBasicMaterial &&
                    u.push(
                      i.assignTexture(l, 'emissiveMap', s.emissiveTexture),
                    ),
                  Promise.all(u).then(function () {
                    var r;
                    return (
                      (r =
                        e === v
                          ? o[
                              n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                            ].createMaterial(l)
                          : new e(l)),
                      s.name && (r.name = s.name),
                      r.map && (r.map.encoding = a.sRGBEncoding),
                      r.emissiveMap &&
                        (r.emissiveMap.encoding = a.sRGBEncoding),
                      U(r, s),
                      i.associations.set(r, { type: 'materials', index: t }),
                      s.extensions && B(o, r, s),
                      r
                    );
                  })
                );
              }),
              (H.prototype.createUniqueName = function (t) {
                for (
                  var e = a.PropertyBinding.sanitizeNodeName(t || ''),
                    n = e,
                    i = 1;
                  this.nodeNamesUsed[n];
                  ++i
                )
                  n = e + '_' + i;
                return (this.nodeNamesUsed[n] = !0), n;
              }),
              (H.prototype.loadGeometries = function (t) {
                var e = this,
                  i = this.extensions,
                  r = this.primitiveCache;
                function o(t) {
                  return i[n.KHR_DRACO_MESH_COMPRESSION]
                    .decodePrimitive(t, e)
                    .then(function (n) {
                      return V(n, t, e);
                    });
                }
                for (var s, l, c = [], u = 0, h = t.length; u < h; u++) {
                  var d,
                    p = t[u],
                    f =
                      ((l = void 0),
                      (l =
                        (s = p).extensions &&
                        s.extensions[n.KHR_DRACO_MESH_COMPRESSION])
                        ? 'draco:' +
                          l.bufferView +
                          ':' +
                          l.indices +
                          ':' +
                          G(l.attributes)
                        : s.indices + ':' + G(s.attributes) + ':' + s.mode),
                    m = r[f];
                  if (m) c.push(m.promise);
                  else
                    (d =
                      p.extensions && p.extensions[n.KHR_DRACO_MESH_COMPRESSION]
                        ? o(p)
                        : V(new a.BufferGeometry(), p, e)),
                      (r[f] = { primitive: p, promise: d }),
                      c.push(d);
                }
                return Promise.all(c);
              }),
              (H.prototype.loadMesh = function (t) {
                for (
                  var e,
                    n = this,
                    i = this.json,
                    r = this.extensions,
                    o = i.meshes[t],
                    s = o.primitives,
                    l = [],
                    c = 0,
                    u = s.length;
                  c < u;
                  c++
                ) {
                  var h =
                    void 0 === s[c].material
                      ? (void 0 === (e = this.cache).DefaultMaterial &&
                          (e.DefaultMaterial = new a.MeshStandardMaterial({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: a.FrontSide,
                          })),
                        e.DefaultMaterial)
                      : this.getDependency('material', s[c].material);
                  l.push(h);
                }
                return (
                  l.push(n.loadGeometries(s)),
                  Promise.all(l).then(function (e) {
                    for (
                      var i = e.slice(0, e.length - 1),
                        l = e[e.length - 1],
                        c = [],
                        u = 0,
                        h = l.length;
                      u < h;
                      u++
                    ) {
                      var d,
                        p = l[u],
                        f = s[u],
                        m = i[u];
                      if (
                        f.mode === T ||
                        f.mode === E ||
                        f.mode === A ||
                        void 0 === f.mode
                      )
                        !0 !==
                          (d =
                            !0 === o.isSkinnedMesh
                              ? new a.SkinnedMesh(p, m)
                              : new a.Mesh(p, m)).isSkinnedMesh ||
                          d.geometry.attributes.skinWeight.normalized ||
                          d.normalizeSkinWeights(),
                          f.mode === E
                            ? (d.geometry = W(
                                d.geometry,
                                a.TriangleStripDrawMode,
                              ))
                            : f.mode === A &&
                              (d.geometry = W(
                                d.geometry,
                                a.TriangleFanDrawMode,
                              ));
                      else if (f.mode === M) d = new a.LineSegments(p, m);
                      else if (f.mode === S) d = new a.Line(p, m);
                      else if (f.mode === q) d = new a.LineLoop(p, m);
                      else {
                        if (f.mode !== w)
                          throw new Error(
                            'THREE.GLTFLoader: Primitive mode unsupported: ' +
                              f.mode,
                          );
                        d = new a.Points(p, m);
                      }
                      Object.keys(d.geometry.morphAttributes).length > 0 &&
                        j(d, o),
                        (d.name = n.createUniqueName(o.name || 'mesh_' + t)),
                        U(d, o),
                        f.extensions && B(r, d, f),
                        n.assignFinalMaterial(d),
                        c.push(d);
                    }
                    if (1 === c.length) return c[0];
                    var g = new a.Group();
                    for (u = 0, h = c.length; u < h; u++) g.add(c[u]);
                    return g;
                  })
                );
              }),
              (H.prototype.loadCamera = function (t) {
                var e,
                  n = this.json.cameras[t],
                  i = n[n.type];
                if (i)
                  return (
                    'perspective' === n.type
                      ? (e = new a.PerspectiveCamera(
                          a.MathUtils.radToDeg(i.yfov),
                          i.aspectRatio || 1,
                          i.znear || 1,
                          i.zfar || 2e6,
                        ))
                      : 'orthographic' === n.type &&
                        (e = new a.OrthographicCamera(
                          -i.xmag,
                          i.xmag,
                          i.ymag,
                          -i.ymag,
                          i.znear,
                          i.zfar,
                        )),
                    n.name && (e.name = this.createUniqueName(n.name)),
                    U(e, n),
                    Promise.resolve(e)
                  );
                console.warn('THREE.GLTFLoader: Missing camera parameters.');
              }),
              (H.prototype.loadSkin = function (t) {
                var e = this.json.skins[t],
                  n = { joints: e.joints };
                return void 0 === e.inverseBindMatrices
                  ? Promise.resolve(n)
                  : this.getDependency('accessor', e.inverseBindMatrices).then(
                      function (t) {
                        return (n.inverseBindMatrices = t), n;
                      },
                    );
              }),
              (H.prototype.loadAnimation = function (t) {
                for (
                  var e = this.json.animations[t],
                    n = [],
                    i = [],
                    r = [],
                    o = [],
                    s = [],
                    l = 0,
                    c = e.channels.length;
                  l < c;
                  l++
                ) {
                  var u = e.channels[l],
                    h = e.samplers[u.sampler],
                    d = u.target,
                    p = void 0 !== d.node ? d.node : d.id,
                    f =
                      void 0 !== e.parameters ? e.parameters[h.input] : h.input,
                    m =
                      void 0 !== e.parameters
                        ? e.parameters[h.output]
                        : h.output;
                  n.push(this.getDependency('node', p)),
                    i.push(this.getDependency('accessor', f)),
                    r.push(this.getDependency('accessor', m)),
                    o.push(h),
                    s.push(d);
                }
                return Promise.all([
                  Promise.all(n),
                  Promise.all(i),
                  Promise.all(r),
                  Promise.all(o),
                  Promise.all(s),
                ]).then(function (n) {
                  for (
                    var i = n[0],
                      r = n[1],
                      o = n[2],
                      s = n[3],
                      l = n[4],
                      c = [],
                      u = 0,
                      h = i.length;
                    u < h;
                    u++
                  ) {
                    var d = i[u],
                      p = r[u],
                      f = o[u],
                      m = s[u],
                      g = l[u];
                    if (void 0 !== d) {
                      var y;
                      switch (
                        (d.updateMatrix(), (d.matrixAutoUpdate = !0), I[g.path])
                      ) {
                        case I.weights:
                          y = a.NumberKeyframeTrack;
                          break;
                        case I.rotation:
                          y = a.QuaternionKeyframeTrack;
                          break;
                        case I.position:
                        case I.scale:
                        default:
                          y = a.VectorKeyframeTrack;
                      }
                      var v = d.name ? d.name : d.uuid,
                        x =
                          void 0 !== m.interpolation
                            ? D[m.interpolation]
                            : a.InterpolateLinear,
                        b = [];
                      I[g.path] === I.weights
                        ? d.traverse(function (t) {
                            !0 === t.isMesh &&
                              t.morphTargetInfluences &&
                              b.push(t.name ? t.name : t.uuid);
                          })
                        : b.push(v);
                      var w = f.array;
                      if (f.normalized) {
                        var M;
                        if (w.constructor === Int8Array) M = 1 / 127;
                        else if (w.constructor === Uint8Array) M = 1 / 255;
                        else if (w.constructor == Int16Array) M = 1 / 32767;
                        else {
                          if (w.constructor !== Uint16Array)
                            throw new Error(
                              'THREE.GLTFLoader: Unsupported output accessor component type.',
                            );
                          M = 1 / 65535;
                        }
                        for (
                          var q = new Float32Array(w.length),
                            S = 0,
                            T = w.length;
                          S < T;
                          S++
                        )
                          q[S] = w[S] * M;
                        w = q;
                      }
                      for (S = 0, T = b.length; S < T; S++) {
                        var E = new y(b[S] + '.' + I[g.path], p.array, w, x);
                        'CUBICSPLINE' === m.interpolation &&
                          ((E.createInterpolant = function (t) {
                            return new _(
                              this.times,
                              this.values,
                              this.getValueSize() / 3,
                              t,
                            );
                          }),
                          (E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                            !0)),
                          c.push(E);
                      }
                    }
                  }
                  var A = e.name ? e.name : 'animation_' + t;
                  return new a.AnimationClip(A, void 0, c);
                });
              }),
              (H.prototype.loadNode = function (t) {
                var e,
                  n = this.json,
                  i = this.extensions,
                  r = this,
                  o = n.nodes[t],
                  s = o.name ? r.createUniqueName(o.name) : '';
                return ((e = []),
                void 0 !== o.mesh &&
                  e.push(
                    r.getDependency('mesh', o.mesh).then(function (t) {
                      var e = r._getNodeRef(r.meshCache, o.mesh, t);
                      return (
                        void 0 !== o.weights &&
                          e.traverse(function (t) {
                            if (t.isMesh)
                              for (var e = 0, n = o.weights.length; e < n; e++)
                                t.morphTargetInfluences[e] = o.weights[e];
                          }),
                        e
                      );
                    }),
                  ),
                void 0 !== o.camera &&
                  e.push(
                    r.getDependency('camera', o.camera).then(function (t) {
                      return r._getNodeRef(r.cameraCache, o.camera, t);
                    }),
                  ),
                r
                  ._invokeAll(function (e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t);
                  })
                  .forEach(function (t) {
                    e.push(t);
                  }),
                Promise.all(e)).then(function (e) {
                  var n;
                  if (
                    (n =
                      !0 === o.isBone
                        ? new a.Bone()
                        : e.length > 1
                        ? new a.Group()
                        : 1 === e.length
                        ? e[0]
                        : new a.Object3D()) !== e[0]
                  )
                    for (var l = 0, c = e.length; l < c; l++) n.add(e[l]);
                  if (
                    (o.name && ((n.userData.name = o.name), (n.name = s)),
                    U(n, o),
                    o.extensions && B(i, n, o),
                    void 0 !== o.matrix)
                  ) {
                    var u = new a.Matrix4();
                    u.fromArray(o.matrix), n.applyMatrix4(u);
                  } else void 0 !== o.translation && n.position.fromArray(o.translation), void 0 !== o.rotation && n.quaternion.fromArray(o.rotation), void 0 !== o.scale && n.scale.fromArray(o.scale);
                  return r.associations.set(n, { type: 'nodes', index: t }), n;
                });
              }),
              (H.prototype.loadScene = (function () {
                function t(e, n, i, r) {
                  var o = i.nodes[e];
                  return r
                    .getDependency('node', e)
                    .then(function (t) {
                      return void 0 === o.skin
                        ? t
                        : r
                            .getDependency('skin', o.skin)
                            .then(function (t) {
                              for (
                                var n = [], i = 0, a = (e = t).joints.length;
                                i < a;
                                i++
                              )
                                n.push(r.getDependency('node', e.joints[i]));
                              return Promise.all(n);
                            })
                            .then(function (n) {
                              return (
                                t.traverse(function (t) {
                                  if (t.isMesh) {
                                    for (
                                      var i = [], r = [], o = 0, s = n.length;
                                      o < s;
                                      o++
                                    ) {
                                      var l = n[o];
                                      if (l) {
                                        i.push(l);
                                        var c = new a.Matrix4();
                                        void 0 !== e.inverseBindMatrices &&
                                          c.fromArray(
                                            e.inverseBindMatrices.array,
                                            16 * o,
                                          ),
                                          r.push(c);
                                      } else
                                        console.warn(
                                          'THREE.GLTFLoader: Joint "%s" could not be found.',
                                          e.joints[o],
                                        );
                                    }
                                    t.bind(new a.Skeleton(i, r), t.matrixWorld);
                                  }
                                }),
                                t
                              );
                            });
                      var e;
                    })
                    .then(function (e) {
                      n.add(e);
                      var a = [];
                      if (o.children)
                        for (
                          var s = o.children, l = 0, c = s.length;
                          l < c;
                          l++
                        ) {
                          var u = s[l];
                          a.push(t(u, e, i, r));
                        }
                      return Promise.all(a);
                    });
                }
                return function (e) {
                  var n = this.json,
                    i = this.extensions,
                    r = this.json.scenes[e],
                    o = new a.Group();
                  r.name && (o.name = this.createUniqueName(r.name)),
                    U(o, r),
                    r.extensions && B(i, o, r);
                  for (
                    var s = r.nodes || [], l = [], c = 0, u = s.length;
                    c < u;
                    c++
                  )
                    l.push(t(s[c], o, n, this));
                  return Promise.all(l).then(function () {
                    return o;
                  });
                };
              })()),
              t
            );
          })(),
          l = function (t) {
            a.Loader.call(this, t),
              (this.decoderPath = ''),
              (this.decoderConfig = {}),
              (this.decoderBinary = null),
              (this.decoderPending = null),
              (this.workerLimit = 4),
              (this.workerPool = []),
              (this.workerNextTaskID = 1),
              (this.workerSourceURL = ''),
              (this.defaultAttributeIDs = {
                position: 'POSITION',
                normal: 'NORMAL',
                color: 'COLOR',
                uv: 'TEX_COORD',
              }),
              (this.defaultAttributeTypes = {
                position: 'Float32Array',
                normal: 'Float32Array',
                color: 'Float32Array',
                uv: 'Float32Array',
              });
          };
        (l.prototype = Object.assign(Object.create(a.Loader.prototype), {
          constructor: l,
          setDecoderPath: function (t) {
            return (this.decoderPath = t), this;
          },
          setDecoderConfig: function (t) {
            return (this.decoderConfig = t), this;
          },
          setWorkerLimit: function (t) {
            return (this.workerLimit = t), this;
          },
          setVerbosity: function () {
            console.warn(
              'THREE.DRACOLoader: The .setVerbosity() method has been removed.',
            );
          },
          setDrawMode: function () {
            console.warn(
              'THREE.DRACOLoader: The .setDrawMode() method has been removed.',
            );
          },
          setSkipDequantization: function () {
            console.warn(
              'THREE.DRACOLoader: The .setSkipDequantization() method has been removed.',
            );
          },
          load: function (t, e, n, i) {
            var r = this,
              o = new a.FileLoader(this.manager);
            o.setPath(this.path),
              o.setResponseType('arraybuffer'),
              o.setRequestHeader(this.requestHeader),
              o.setWithCredentials(this.withCredentials),
              o.load(
                t,
                function (t) {
                  var n = {
                    attributeIDs: r.defaultAttributeIDs,
                    attributeTypes: r.defaultAttributeTypes,
                    useUniqueIDs: !1,
                  };
                  r.decodeGeometry(t, n).then(e).catch(i);
                },
                n,
                i,
              );
          },
          decodeDracoFile: function (t, e, n, i) {
            var r = {
              attributeIDs: n || this.defaultAttributeIDs,
              attributeTypes: i || this.defaultAttributeTypes,
              useUniqueIDs: !!n,
            };
            this.decodeGeometry(t, r).then(e);
          },
          decodeGeometry: function (t, e) {
            var n = this;
            for (var i in e.attributeTypes) {
              var r = e.attributeTypes[i];
              void 0 !== r.BYTES_PER_ELEMENT && (e.attributeTypes[i] = r.name);
            }
            var a,
              o = JSON.stringify(e);
            if (l.taskCache.has(t)) {
              var s = l.taskCache.get(t);
              if (s.key === o) return s.promise;
              if (0 === t.byteLength)
                throw new Error(
                  'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.',
                );
            }
            var c = this.workerNextTaskID++,
              u = t.byteLength,
              h = this._getWorker(c, u)
                .then(function (n) {
                  return (
                    (a = n),
                    new Promise(function (n, i) {
                      (a._callbacks[c] = { resolve: n, reject: i }),
                        a.postMessage(
                          { type: 'decode', id: c, taskConfig: e, buffer: t },
                          [t],
                        );
                    })
                  );
                })
                .then(function (t) {
                  return n._createGeometry(t.geometry);
                });
            return (
              h
                .catch(function () {
                  return !0;
                })
                .then(function () {
                  a && c && n._releaseTask(a, c);
                }),
              l.taskCache.set(t, { key: o, promise: h }),
              h
            );
          },
          _createGeometry: function (t) {
            var e = new a.BufferGeometry();
            t.index && e.setIndex(new a.BufferAttribute(t.index.array, 1));
            for (var n = 0; n < t.attributes.length; n++) {
              var i = t.attributes[n],
                r = i.name,
                o = i.array,
                s = i.itemSize;
              e.setAttribute(r, new a.BufferAttribute(o, s));
            }
            return e;
          },
          _loadLibrary: function (t, e) {
            var n = new a.FileLoader(this.manager);
            return (
              n.setPath(this.decoderPath),
              n.setResponseType(e),
              n.setWithCredentials(this.withCredentials),
              new Promise(function (e, i) {
                n.load(t, e, void 0, i);
              })
            );
          },
          preload: function () {
            return this._initDecoder(), this;
          },
          _initDecoder: function () {
            var t = this;
            if (this.decoderPending) return this.decoderPending;
            var e =
                'object' !==
                  ('undefined' == typeof WebAssembly
                    ? 'undefined'
                    : r()(WebAssembly)) || 'js' === this.decoderConfig.type,
              n = [];
            return (
              e
                ? n.push(this._loadLibrary('draco_decoder.js', 'text'))
                : (n.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
                  n.push(
                    this._loadLibrary('draco_decoder.wasm', 'arraybuffer'),
                  )),
              (this.decoderPending = Promise.all(n).then(function (n) {
                var i = n[0];
                e || (t.decoderConfig.wasmBinary = n[1]);
                var r = l.DRACOWorker.toString(),
                  a = [
                    '/* draco decoder */',
                    i,
                    '',
                    '/* worker */',
                    r.substring(r.indexOf('{') + 1, r.lastIndexOf('}')),
                  ].join('\n');
                t.workerSourceURL = URL.createObjectURL(new Blob([a]));
              })),
              this.decoderPending
            );
          },
          _getWorker: function (t, e) {
            var n = this;
            return this._initDecoder().then(function () {
              var i;
              n.workerPool.length < n.workerLimit
                ? (((i = new Worker(n.workerSourceURL))._callbacks = {}),
                  (i._taskCosts = {}),
                  (i._taskLoad = 0),
                  i.postMessage({
                    type: 'init',
                    decoderConfig: n.decoderConfig,
                  }),
                  (i.onmessage = function (t) {
                    var e = t.data;
                    switch (e.type) {
                      case 'decode':
                        i._callbacks[e.id].resolve(e);
                        break;
                      case 'error':
                        i._callbacks[e.id].reject(e);
                        break;
                      default:
                        console.error(
                          'THREE.DRACOLoader: Unexpected message, "' +
                            e.type +
                            '"',
                        );
                    }
                  }),
                  n.workerPool.push(i))
                : n.workerPool.sort(function (t, e) {
                    return t._taskLoad > e._taskLoad ? -1 : 1;
                  });
              return (
                ((i = n.workerPool[n.workerPool.length - 1])._taskCosts[t] = e),
                (i._taskLoad += e),
                i
              );
            });
          },
          _releaseTask: function (t, e) {
            (t._taskLoad -= t._taskCosts[e]),
              delete t._callbacks[e],
              delete t._taskCosts[e];
          },
          debug: function () {
            console.log(
              'Task load: ',
              this.workerPool.map(function (t) {
                return t._taskLoad;
              }),
            );
          },
          dispose: function () {
            for (var t = 0; t < this.workerPool.length; ++t)
              this.workerPool[t].terminate();
            return (this.workerPool.length = 0), this;
          },
        })),
          (l.DRACOWorker = function () {
            var t, e;
            function n(t, e, n, i, r, a) {
              var o = a.num_components(),
                s = n.num_points() * o,
                l = s * r.BYTES_PER_ELEMENT,
                c = (function (t, e) {
                  switch (e) {
                    case Float32Array:
                      return t.DT_FLOAT32;
                    case Int8Array:
                      return t.DT_INT8;
                    case Int16Array:
                      return t.DT_INT16;
                    case Int32Array:
                      return t.DT_INT32;
                    case Uint8Array:
                      return t.DT_UINT8;
                    case Uint16Array:
                      return t.DT_UINT16;
                    case Uint32Array:
                      return t.DT_UINT32;
                  }
                })(t, r),
                u = t._malloc(l);
              e.GetAttributeDataArrayForAllPoints(n, a, c, l, u);
              var h = new r(t.HEAPF32.buffer, u, s).slice();
              return t._free(u), { name: i, array: h, itemSize: o };
            }
            onmessage = function (i) {
              var r = i.data;
              switch (r.type) {
                case 'init':
                  (t = r.decoderConfig),
                    (e = new Promise(function (e) {
                      (t.onModuleLoaded = function (t) {
                        e({ draco: t });
                      }),
                        DracoDecoderModule(t);
                    }));
                  break;
                case 'decode':
                  var a = r.buffer,
                    o = r.taskConfig;
                  e.then(function (t) {
                    var e = t.draco,
                      i = new e.Decoder(),
                      s = new e.DecoderBuffer();
                    s.Init(new Int8Array(a), a.byteLength);
                    try {
                      var l = (function (t, e, i, r) {
                          var a,
                            o,
                            s = r.attributeIDs,
                            l = r.attributeTypes,
                            c = e.GetEncodedGeometryType(i);
                          if (c === t.TRIANGULAR_MESH)
                            (a = new t.Mesh()),
                              (o = e.DecodeBufferToMesh(i, a));
                          else {
                            if (c !== t.POINT_CLOUD)
                              throw new Error(
                                'THREE.DRACOLoader: Unexpected geometry type.',
                              );
                            (a = new t.PointCloud()),
                              (o = e.DecodeBufferToPointCloud(i, a));
                          }
                          if (!o.ok() || 0 === a.ptr)
                            throw new Error(
                              'THREE.DRACOLoader: Decoding failed: ' +
                                o.error_msg(),
                            );
                          var u = { index: null, attributes: [] };
                          for (var h in s) {
                            var d,
                              p,
                              f = self[l[h]];
                            if (r.useUniqueIDs)
                              (p = s[h]), (d = e.GetAttributeByUniqueId(a, p));
                            else {
                              if (-1 === (p = e.GetAttributeId(a, t[s[h]])))
                                continue;
                              d = e.GetAttribute(a, p);
                            }
                            u.attributes.push(n(t, e, a, h, f, d));
                          }
                          c === t.TRIANGULAR_MESH &&
                            (u.index = (function (t, e, n) {
                              var i = 3 * n.num_faces(),
                                r = 4 * i,
                                a = t._malloc(r);
                              e.GetTrianglesUInt32Array(n, r, a);
                              var o = new Uint32Array(
                                t.HEAPF32.buffer,
                                a,
                                i,
                              ).slice();
                              return t._free(a), { array: o, itemSize: 1 };
                            })(t, e, a));
                          return t.destroy(a), u;
                        })(e, i, s, o),
                        c = l.attributes.map(function (t) {
                          return t.array.buffer;
                        });
                      l.index && c.push(l.index.array.buffer),
                        self.postMessage(
                          { type: 'decode', id: r.id, geometry: l },
                          c,
                        );
                    } catch (t) {
                      console.error(t),
                        self.postMessage({
                          type: 'error',
                          id: r.id,
                          error: t.message,
                        });
                    } finally {
                      e.destroy(s), e.destroy(i);
                    }
                  });
              }
            };
          }),
          (l.taskCache = new WeakMap()),
          (l.setDecoderPath = function () {
            console.warn(
              'THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.',
            );
          }),
          (l.setDecoderConfig = function () {
            console.warn(
              'THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.',
            );
          }),
          (l.releaseDecoderModule = function () {
            console.warn(
              'THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.',
            );
          }),
          (l.getDecoderModule = function () {
            console.warn(
              'THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.',
            );
          });
        var c = {};
        c.LegacyGLTFLoader = (function () {
          function t(t) {
            a.Loader.call(this, t);
          }
          function e() {
            var t = {};
            return {
              get: function (e) {
                return t[e];
              },
              add: function (e, n) {
                t[e] = n;
              },
              remove: function (e) {
                delete t[e];
              },
              removeAll: function () {
                t = {};
              },
              update: function (e, n) {
                for (var i in t) {
                  var r = t[i];
                  r.update && r.update(e, n);
                }
              },
            };
          }
          function n(t, e) {
            var n = {},
              i = t.material.uniforms;
            for (var r in i) {
              var o = i[r];
              if (o.semantic) {
                var s = o.node,
                  l = t;
                s && (l = e[s]),
                  (n[r] = {
                    semantic: o.semantic,
                    sourceNode: l,
                    targetNode: t,
                    uniform: o,
                  });
              }
            }
            (this.boundUniforms = n), (this._m4 = new a.Matrix4());
          }
          (t.prototype = Object.assign(Object.create(a.Loader.prototype), {
            constructor: t,
            load: function (t, e, n, i) {
              var r,
                o = this;
              r =
                '' !== this.resourcePath
                  ? this.resourcePath
                  : '' !== this.path
                  ? this.path
                  : a.LoaderUtils.extractUrlBase(t);
              var s = new a.FileLoader(o.manager);
              s.setPath(this.path),
                s.setResponseType('arraybuffer'),
                s.load(
                  t,
                  function (t) {
                    o.parse(t, r, e);
                  },
                  n,
                  i,
                );
            },
            parse: function (t, e, n) {
              var l,
                c = {};
              a.LoaderUtils.decodeText(new Uint8Array(t, 0, 4)) === o.magic
                ? ((c[i.KHR_BINARY_GLTF] = new s(t)),
                  (l = c[i.KHR_BINARY_GLTF].content))
                : (l = a.LoaderUtils.decodeText(new Uint8Array(t)));
              var u = JSON.parse(l);
              u.extensionsUsed &&
                u.extensionsUsed.indexOf(i.KHR_MATERIALS_COMMON) >= 0 &&
                (c[i.KHR_MATERIALS_COMMON] = new r(u)),
                new T(u, c, {
                  crossOrigin: this.crossOrigin,
                  manager: this.manager,
                  path: e || this.resourcePath || '',
                }).parse(function (t, e, i, r) {
                  n({ scene: t, scenes: e, cameras: i, animations: r });
                });
            },
          })),
            (t.Shaders = {
              update: function () {
                console.warn(
                  'threeExamples.LegacyGLTFLoader.Shaders has been deprecated, and now updates automatically.',
                );
              },
            }),
            (n.prototype.update = function (t, e) {
              var n = this.boundUniforms;
              for (var i in n) {
                var r = n[i];
                switch (r.semantic) {
                  case 'MODELVIEW':
                    r.uniform.value.multiplyMatrices(
                      e.matrixWorldInverse,
                      r.sourceNode.matrixWorld,
                    );
                    break;
                  case 'MODELVIEWINVERSETRANSPOSE':
                    var a = r.uniform.value;
                    this._m4.multiplyMatrices(
                      e.matrixWorldInverse,
                      r.sourceNode.matrixWorld,
                    ),
                      a.getNormalMatrix(this._m4);
                    break;
                  case 'PROJECTION':
                    r.uniform.value.copy(e.projectionMatrix);
                    break;
                  case 'JOINTMATRIX':
                    for (var o = r.uniform.value, s = 0; s < o.length; s++)
                      o[s]
                        .getInverse(r.sourceNode.matrixWorld)
                        .multiply(r.targetNode.skeleton.bones[s].matrixWorld)
                        .multiply(r.targetNode.skeleton.boneInverses[s])
                        .multiply(r.targetNode.bindMatrix);
                    break;
                  default:
                    console.warn('Unhandled shader semantic: ' + r.semantic);
                }
              }
            }),
            (t.Animations = {
              update: function () {
                console.warn(
                  'threeExamples.LegacyGLTFLoader.Animation has been deprecated. Use THREE.AnimationMixer instead.',
                );
              },
            });
          var i = {
            KHR_BINARY_GLTF: 'KHR_binary_glTF',
            KHR_MATERIALS_COMMON: 'KHR_materials_common',
          };
          function r(t) {
            (this.name = i.KHR_MATERIALS_COMMON), (this.lights = {});
            var e =
              ((t.extensions && t.extensions[i.KHR_MATERIALS_COMMON]) || {})
                .lights || {};
            for (var n in e) {
              var r,
                o = e[n],
                s = o[o.type],
                l = new a.Color().fromArray(s.color);
              switch (o.type) {
                case 'directional':
                  (r = new a.DirectionalLight(l)).position.set(0, 0, 1);
                  break;
                case 'point':
                  r = new a.PointLight(l);
                  break;
                case 'spot':
                  (r = new a.SpotLight(l)).position.set(0, 0, 1);
                  break;
                case 'ambient':
                  r = new a.AmbientLight(l);
              }
              r && (this.lights[n] = r);
            }
          }
          var o = { magic: 'glTF', version: 1, contentFormat: 0 };
          function s(t) {
            this.name = i.KHR_BINARY_GLTF;
            var e = new DataView(t, 0, 20),
              n = {
                magic: a.LoaderUtils.decodeText(new Uint8Array(t.slice(0, 4))),
                version: e.getUint32(4, !0),
                length: e.getUint32(8, !0),
                contentLength: e.getUint32(12, !0),
                contentFormat: e.getUint32(16, !0),
              };
            for (var r in o) {
              var s = o[r];
              if (n[r] !== s)
                throw new Error(
                  'Unsupported glTF-Binary header: Expected "%s" to be "%s".',
                  r,
                  s,
                );
            }
            var l = new Uint8Array(t, 20, n.contentLength);
            (this.header = n),
              (this.content = a.LoaderUtils.decodeText(l)),
              (this.body = t.slice(20 + n.contentLength, n.length));
          }
          s.prototype.loadShader = function (t, e) {
            var n = e[t.extensions[i.KHR_BINARY_GLTF].bufferView],
              r = new Uint8Array(n);
            return a.LoaderUtils.decodeText(r);
          };
          var l = {
              FLOAT: 5126,
              FLOAT_MAT3: 35675,
              FLOAT_MAT4: 35676,
              FLOAT_VEC2: 35664,
              FLOAT_VEC3: 35665,
              FLOAT_VEC4: 35666,
              LINEAR: 9729,
              REPEAT: 10497,
              SAMPLER_2D: 35678,
              TRIANGLES: 4,
              LINES: 1,
              UNSIGNED_BYTE: 5121,
              UNSIGNED_SHORT: 5123,
              VERTEX_SHADER: 35633,
              FRAGMENT_SHADER: 35632,
            },
            c = {
              5126: Number,
              35675: a.Matrix3,
              35676: a.Matrix4,
              35664: a.Vector2,
              35665: a.Vector3,
              35666: a.Vector4,
              35678: a.Texture,
            },
            u = {
              5120: Int8Array,
              5121: Uint8Array,
              5122: Int16Array,
              5123: Uint16Array,
              5125: Uint32Array,
              5126: Float32Array,
            },
            h = {
              9728: a.NearestFilter,
              9729: a.LinearFilter,
              9984: a.NearestMipmapNearestFilter,
              9985: a.LinearMipmapNearestFilter,
              9986: a.NearestMipmapLinearFilter,
              9987: a.LinearMipmapLinearFilter,
            },
            d = {
              33071: a.ClampToEdgeWrapping,
              33648: a.MirroredRepeatWrapping,
              10497: a.RepeatWrapping,
            },
            p = {
              6406: a.AlphaFormat,
              6407: a.RGBFormat,
              6408: a.RGBAFormat,
              6409: a.LuminanceFormat,
              6410: a.LuminanceAlphaFormat,
            },
            f = {
              5121: a.UnsignedByteType,
              32819: a.UnsignedShort4444Type,
              32820: a.UnsignedShort5551Type,
              33635: a.UnsignedShort565Type,
            },
            m = { 1028: a.BackSide, 1029: a.FrontSide },
            g = {
              512: a.NeverDepth,
              513: a.LessDepth,
              514: a.EqualDepth,
              515: a.LessEqualDepth,
              516: a.GreaterEqualDepth,
              517: a.NotEqualDepth,
              518: a.GreaterEqualDepth,
              519: a.AlwaysDepth,
            },
            y = {
              32774: a.AddEquation,
              32778: a.SubtractEquation,
              32779: a.ReverseSubtractEquation,
            },
            v = {
              0: a.ZeroFactor,
              1: a.OneFactor,
              768: a.SrcColorFactor,
              769: a.OneMinusSrcColorFactor,
              770: a.SrcAlphaFactor,
              771: a.OneMinusSrcAlphaFactor,
              772: a.DstAlphaFactor,
              773: a.OneMinusDstAlphaFactor,
              774: a.DstColorFactor,
              775: a.OneMinusDstColorFactor,
              776: a.SrcAlphaSaturateFactor,
            },
            x = {
              SCALAR: 1,
              VEC2: 2,
              VEC3: 3,
              VEC4: 4,
              MAT2: 4,
              MAT3: 9,
              MAT4: 16,
            },
            b = {
              scale: 'scale',
              translation: 'position',
              rotation: 'quaternion',
            },
            _ = { LINEAR: a.InterpolateLinear, STEP: a.InterpolateDiscrete },
            w = {
              2884: 'CULL_FACE',
              2929: 'DEPTH_TEST',
              3042: 'BLEND',
              3089: 'SCISSOR_TEST',
              32823: 'POLYGON_OFFSET_FILL',
              32926: 'SAMPLE_ALPHA_TO_COVERAGE',
            };
          function M(t, e, n) {
            if (!t) return Promise.resolve();
            var i,
              r = [];
            if ('[object Array]' === Object.prototype.toString.call(t)) {
              i = [];
              for (var a = t.length, o = 0; o < a; o++) {
                (l = e.call(n || this, t[o], o)) &&
                  (r.push(l),
                  l instanceof Promise
                    ? l.then(
                        function (t, e) {
                          i[t] = e;
                        }.bind(this, o),
                      )
                    : (i[o] = l));
              }
            } else
              for (var s in ((i = {}), t)) {
                var l;
                if (t.hasOwnProperty(s))
                  (l = e.call(n || this, t[s], s)) &&
                    (r.push(l),
                    l instanceof Promise
                      ? l.then(
                          function (t, e) {
                            i[t] = e;
                          }.bind(this, s),
                        )
                      : (i[s] = l));
              }
            return Promise.all(r).then(function () {
              return i;
            });
          }
          function q(t, e) {
            return 'string' != typeof t || '' === t
              ? ''
              : /^(https?:)?\/\//i.test(t) ||
                /^data:.*,.*$/i.test(t) ||
                /^blob:.*$/i.test(t)
              ? t
              : (e || '') + t;
          }
          function S(t) {
            (this.isDeferredShaderMaterial = !0), (this.params = t);
          }
          function T(t, n, i) {
            (this.json = t || {}),
              (this.extensions = n || {}),
              (this.options = i || {}),
              (this.cache = new e());
          }
          return (
            (S.prototype.create = function () {
              var t = a.UniformsUtils.clone(this.params.uniforms);
              for (var e in this.params.uniforms) {
                var n = this.params.uniforms[e];
                n.value instanceof a.Texture &&
                  ((t[e].value = n.value), (t[e].value.needsUpdate = !0)),
                  (t[e].semantic = n.semantic),
                  (t[e].node = n.node);
              }
              return (
                (this.params.uniforms = t), new a.RawShaderMaterial(this.params)
              );
            }),
            (T.prototype._withDependencies = function (t) {
              for (var e = {}, n = 0; n < t.length; n++) {
                var i = t[n],
                  r = 'load' + i.charAt(0).toUpperCase() + i.slice(1),
                  a = this.cache.get(i);
                if (void 0 !== a) e[i] = a;
                else if (this[r]) {
                  var o = this[r]();
                  this.cache.add(i, o), (e[i] = o);
                }
              }
              return M(e, function (t) {
                return t;
              });
            }),
            (T.prototype.parse = function (t) {
              var e = this.json;
              this.cache.removeAll(),
                this._withDependencies([
                  'scenes',
                  'cameras',
                  'animations',
                ]).then(function (n) {
                  var i = [];
                  for (var r in n.scenes) i.push(n.scenes[r]);
                  var a = void 0 !== e.scene ? n.scenes[e.scene] : i[0],
                    o = [];
                  for (var r in n.cameras) {
                    var s = n.cameras[r];
                    o.push(s);
                  }
                  var l = [];
                  for (var r in n.animations) l.push(n.animations[r]);
                  t(a, i, o, l);
                });
            }),
            (T.prototype.loadShaders = function () {
              var t = this.json,
                e = this.extensions,
                n = this.options;
              return this._withDependencies(['bufferViews']).then(function (r) {
                return M(t.shaders, function (t) {
                  return t.extensions && t.extensions[i.KHR_BINARY_GLTF]
                    ? e[i.KHR_BINARY_GLTF].loadShader(t, r.bufferViews)
                    : new Promise(function (e) {
                        var i = new a.FileLoader(n.manager);
                        i.setResponseType('text'),
                          i.load(q(t.uri, n.path), function (t) {
                            e(t);
                          });
                      });
                });
              });
            }),
            (T.prototype.loadBuffers = function () {
              var t = this.json,
                e = this.extensions,
                n = this.options;
              return M(t.buffers, function (t, r) {
                return 'binary_glTF' === r
                  ? e[i.KHR_BINARY_GLTF].body
                  : 'arraybuffer' === t.type || void 0 === t.type
                  ? new Promise(function (e) {
                      var i = new a.FileLoader(n.manager);
                      i.setResponseType('arraybuffer'),
                        i.load(q(t.uri, n.path), function (t) {
                          e(t);
                        });
                    })
                  : void console.warn(
                      'threeExamples.LegacyGLTFLoader: ' +
                        t.type +
                        ' buffer type is not supported',
                    );
              });
            }),
            (T.prototype.loadBufferViews = function () {
              var t = this.json;
              return this._withDependencies(['buffers']).then(function (e) {
                return M(t.bufferViews, function (t) {
                  var n = e.buffers[t.buffer],
                    i = void 0 !== t.byteLength ? t.byteLength : 0;
                  return n.slice(t.byteOffset, t.byteOffset + i);
                });
              });
            }),
            (T.prototype.loadAccessors = function () {
              var t = this.json;
              return this._withDependencies(['bufferViews']).then(function (e) {
                return M(t.accessors, function (t) {
                  var n = e.bufferViews[t.bufferView],
                    i = x[t.type],
                    r = u[t.componentType],
                    o = r.BYTES_PER_ELEMENT;
                  if (t.byteStride && t.byteStride !== o * i) {
                    var s = new r(n),
                      l = new a.InterleavedBuffer(s, t.byteStride / o);
                    return new a.InterleavedBufferAttribute(
                      l,
                      i,
                      t.byteOffset / o,
                    );
                  }
                  return (
                    (s = new r(n, t.byteOffset, t.count * i)),
                    new a.BufferAttribute(s, i)
                  );
                });
              });
            }),
            (T.prototype.loadTextures = function () {
              var t = this.json,
                e = this.options;
              return this._withDependencies(['bufferViews']).then(function (n) {
                return M(t.textures, function (r) {
                  if (r.source)
                    return new Promise(function (o) {
                      var s = t.images[r.source],
                        l = s.uri,
                        c = !1;
                      if (s.extensions && s.extensions[i.KHR_BINARY_GLTF]) {
                        var u = s.extensions[i.KHR_BINARY_GLTF],
                          m = n.bufferViews[u.bufferView],
                          g = new Blob([m], { type: u.mimeType });
                        (l = URL.createObjectURL(g)), (c = !0);
                      }
                      var y = e.manager.getHandler(l);
                      null === y && (y = new a.TextureLoader(e.manager)),
                        y.setCrossOrigin(e.crossOrigin),
                        y.load(
                          q(l, e.path),
                          function (e) {
                            if (
                              (c && URL.revokeObjectURL(l),
                              (e.flipY = !1),
                              void 0 !== r.name && (e.name = r.name),
                              (e.format =
                                void 0 !== r.format
                                  ? p[r.format]
                                  : a.RGBAFormat),
                              void 0 !== r.internalFormat &&
                                e.format !== p[r.internalFormat] &&
                                console.warn(
                                  "threeExamples.LegacyGLTFLoader: Three.js doesn't support texture internalFormat which is different from texture format. internalFormat will be forced to be the same value as format.",
                                ),
                              (e.type =
                                void 0 !== r.type
                                  ? f[r.type]
                                  : a.UnsignedByteType),
                              r.sampler)
                            ) {
                              var n = t.samplers[r.sampler];
                              (e.magFilter = h[n.magFilter] || a.LinearFilter),
                                (e.minFilter =
                                  h[n.minFilter] ||
                                  a.NearestMipmapLinearFilter),
                                (e.wrapS = d[n.wrapS] || a.RepeatWrapping),
                                (e.wrapT = d[n.wrapT] || a.RepeatWrapping);
                            }
                            o(e);
                          },
                          void 0,
                          function () {
                            c && URL.revokeObjectURL(l), o();
                          },
                        );
                    });
                });
              });
            }),
            (T.prototype.loadMaterials = function () {
              var t = this.json;
              return this._withDependencies(['shaders', 'textures']).then(
                function (e) {
                  return M(t.materials, function (n) {
                    var r,
                      o,
                      s = {},
                      u = {};
                    if (
                      (n.extensions &&
                        n.extensions[i.KHR_MATERIALS_COMMON] &&
                        (o = n.extensions[i.KHR_MATERIALS_COMMON]),
                      o)
                    ) {
                      var h = [
                        'ambient',
                        'emission',
                        'transparent',
                        'transparency',
                        'doubleSided',
                      ];
                      switch (o.technique) {
                        case 'BLINN':
                        case 'PHONG':
                          (r = a.MeshPhongMaterial),
                            h.push('diffuse', 'specular', 'shininess');
                          break;
                        case 'LAMBERT':
                          (r = a.MeshLambertMaterial), h.push('diffuse');
                          break;
                        case 'CONSTANT':
                        default:
                          r = a.MeshBasicMaterial;
                      }
                      h.forEach(function (t) {
                        void 0 !== o.values[t] && (s[t] = o.values[t]);
                      }),
                        (o.doubleSided || s.doubleSided) &&
                          (u.side = a.DoubleSide),
                        (o.transparent || s.transparent) &&
                          ((u.transparent = !0),
                          (u.opacity =
                            void 0 !== s.transparency ? s.transparency : 1));
                    } else if (void 0 === n.technique)
                      (r = a.MeshPhongMaterial), Object.assign(s, n.values);
                    else {
                      r = S;
                      var d = t.techniques[n.technique];
                      u.uniforms = {};
                      var p = t.programs[d.program];
                      if (p) {
                        (u.fragmentShader = e.shaders[p.fragmentShader]),
                          u.fragmentShader ||
                            (console.warn(
                              'ERROR: Missing fragment shader definition:',
                              p.fragmentShader,
                            ),
                            (r = a.MeshPhongMaterial));
                        var f = e.shaders[p.vertexShader];
                        f ||
                          (console.warn(
                            'ERROR: Missing vertex shader definition:',
                            p.vertexShader,
                          ),
                          (r = a.MeshPhongMaterial)),
                          (u.vertexShader = (function (t, e) {
                            var n = {};
                            for (var i in e.attributes) {
                              var r = e.attributes[i],
                                a = (h = e.parameters[r]).type,
                                o = h.semantic;
                              n[i] = { type: a, semantic: o };
                            }
                            var s = e.parameters,
                              l = e.attributes,
                              c = {};
                            for (var i in n) {
                              var u = s[(r = l[i])];
                              (o = u.semantic) && (c[i] = u);
                            }
                            for (var r in c) {
                              o = (h = c[r]).semantic;
                              var h,
                                d = new RegExp('\\b' + r + '\\b', 'g');
                              switch (o) {
                                case 'POSITION':
                                  t = t.replace(d, 'position');
                                  break;
                                case 'NORMAL':
                                  t = t.replace(d, 'normal');
                                  break;
                                case 'TEXCOORD_0':
                                case 'TEXCOORD0':
                                case 'TEXCOORD':
                                  t = t.replace(d, 'uv');
                                  break;
                                case 'TEXCOORD_1':
                                  t = t.replace(d, 'uv2');
                                  break;
                                case 'COLOR_0':
                                case 'COLOR0':
                                case 'COLOR':
                                  t = t.replace(d, 'color');
                                  break;
                                case 'WEIGHT':
                                  t = t.replace(d, 'skinWeight');
                                  break;
                                case 'JOINT':
                                  t = t.replace(d, 'skinIndex');
                              }
                            }
                            return t;
                          })(f, d));
                        var x = d.uniforms;
                        for (var b in x) {
                          var _ = x[b],
                            M = d.parameters[_],
                            q = M.type;
                          if (!c[q])
                            throw new Error(
                              'Unknown shader uniform param type: ' + q,
                            );
                          var T,
                            E = M.count;
                          void 0 !== n.values && (T = n.values[_]);
                          var A = new c[q](),
                            L = M.semantic,
                            R = M.node;
                          switch (q) {
                            case l.FLOAT:
                              (A = M.value),
                                'transparency' == _ && (u.transparent = !0),
                                void 0 !== T && (A = T);
                              break;
                            case l.FLOAT_VEC2:
                            case l.FLOAT_VEC3:
                            case l.FLOAT_VEC4:
                            case l.FLOAT_MAT3:
                              M && M.value && A.fromArray(M.value),
                                T && A.fromArray(T);
                              break;
                            case l.FLOAT_MAT2:
                              console.warn(
                                'FLOAT_MAT2 is not a supported uniform type',
                              );
                              break;
                            case l.FLOAT_MAT4:
                              if (E) {
                                A = new Array(E);
                                for (var C = 0; C < E; C++) A[C] = new c[q]();
                                if (M && M.value) {
                                  var P = M.value;
                                  A.fromArray(P);
                                }
                                T && A.fromArray(T);
                              } else {
                                if (M && M.value) {
                                  var k = M.value;
                                  A.fromArray(k);
                                }
                                T && A.fromArray(T);
                              }
                              break;
                            case l.SAMPLER_2D:
                              A =
                                void 0 !== T
                                  ? e.textures[T]
                                  : void 0 !== M.value
                                  ? e.textures[M.value]
                                  : null;
                          }
                          u.uniforms[b] = { value: A, semantic: L, node: R };
                        }
                        for (
                          var I = d.states || {},
                            D = I.enable || [],
                            O = I.functions || {},
                            N = !1,
                            z = !1,
                            F = !1,
                            B = 0,
                            U = D.length;
                          B < U;
                          B++
                        ) {
                          var j = D[B];
                          switch (w[j]) {
                            case 'CULL_FACE':
                              N = !0;
                              break;
                            case 'DEPTH_TEST':
                              z = !0;
                              break;
                            case 'BLEND':
                              F = !0;
                              break;
                            case 'SCISSOR_TEST':
                            case 'POLYGON_OFFSET_FILL':
                            case 'SAMPLE_ALPHA_TO_COVERAGE':
                              break;
                            default:
                              throw new Error(
                                'Unknown technique.states.enable: ' + j,
                              );
                          }
                        }
                        (u.side = N
                          ? void 0 !== O.cullFace
                            ? m[O.cullFace]
                            : a.FrontSide
                          : a.DoubleSide),
                          (u.depthTest = z),
                          (u.depthFunc =
                            void 0 !== O.depthFunc
                              ? g[O.depthFunc]
                              : a.LessDepth),
                          (u.depthWrite =
                            void 0 === O.depthMask || O.depthMask[0]),
                          (u.blending = F ? a.CustomBlending : a.NoBlending),
                          (u.transparent = F);
                        var G = O.blendEquationSeparate;
                        void 0 !== G
                          ? ((u.blendEquation = y[G[0]]),
                            (u.blendEquationAlpha = y[G[1]]))
                          : ((u.blendEquation = a.AddEquation),
                            (u.blendEquationAlpha = a.AddEquation));
                        var H = O.blendFuncSeparate;
                        void 0 !== H
                          ? ((u.blendSrc = v[H[0]]),
                            (u.blendDst = v[H[1]]),
                            (u.blendSrcAlpha = v[H[2]]),
                            (u.blendDstAlpha = v[H[3]]))
                          : ((u.blendSrc = a.OneFactor),
                            (u.blendDst = a.ZeroFactor),
                            (u.blendSrcAlpha = a.OneFactor),
                            (u.blendDstAlpha = a.ZeroFactor));
                      }
                    }
                    Array.isArray(s.diffuse)
                      ? (u.color = new a.Color().fromArray(s.diffuse))
                      : 'string' == typeof s.diffuse &&
                        (u.map = e.textures[s.diffuse]),
                      delete u.diffuse,
                      'string' == typeof s.reflective &&
                        (u.envMap = e.textures[s.reflective]),
                      'string' == typeof s.bump &&
                        (u.bumpMap = e.textures[s.bump]),
                      Array.isArray(s.emission)
                        ? r === a.MeshBasicMaterial
                          ? (u.color = new a.Color().fromArray(s.emission))
                          : (u.emissive = new a.Color().fromArray(s.emission))
                        : 'string' == typeof s.emission &&
                          (r === a.MeshBasicMaterial
                            ? (u.map = e.textures[s.emission])
                            : (u.emissiveMap = e.textures[s.emission])),
                      Array.isArray(s.specular)
                        ? (u.specular = new a.Color().fromArray(s.specular))
                        : 'string' == typeof s.specular &&
                          (u.specularMap = e.textures[s.specular]),
                      void 0 !== s.shininess && (u.shininess = s.shininess);
                    var V = new r(u);
                    return void 0 !== n.name && (V.name = n.name), V;
                  });
                },
              );
            }),
            (T.prototype.loadMeshes = function () {
              var t = this.json;
              return this._withDependencies(['accessors', 'materials']).then(
                function (e) {
                  return M(t.meshes, function (n) {
                    var i = new a.Group();
                    void 0 !== n.name && (i.name = n.name),
                      n.extras && (i.userData = n.extras);
                    var r = n.primitives || [];
                    for (var o in r) {
                      var s = r[o];
                      if (s.mode === l.TRIANGLES || void 0 === s.mode) {
                        var c = new a.BufferGeometry(),
                          u = s.attributes;
                        for (var h in u) {
                          if (!(g = u[h])) return;
                          var d = e.accessors[g];
                          switch (h) {
                            case 'POSITION':
                              c.setAttribute('position', d);
                              break;
                            case 'NORMAL':
                              c.setAttribute('normal', d);
                              break;
                            case 'TEXCOORD_0':
                            case 'TEXCOORD0':
                            case 'TEXCOORD':
                              c.setAttribute('uv', d);
                              break;
                            case 'TEXCOORD_1':
                              c.setAttribute('uv2', d);
                              break;
                            case 'COLOR_0':
                            case 'COLOR0':
                            case 'COLOR':
                              c.setAttribute('color', d);
                              break;
                            case 'WEIGHT':
                              c.setAttribute('skinWeight', d);
                              break;
                            case 'JOINT':
                              c.setAttribute('skinIndex', d);
                              break;
                            default:
                              if (!s.material) break;
                              if (!(m = t.materials[s.material]).technique)
                                break;
                              var p =
                                t.techniques[m.technique].parameters || {};
                              for (var f in p)
                                p[f].semantic === h && c.setAttribute(f, d);
                          }
                        }
                        s.indices && c.setIndex(e.accessors[s.indices]);
                        var m =
                          void 0 !== e.materials
                            ? e.materials[s.material]
                            : new a.MeshPhongMaterial({
                                color: 0,
                                emissive: 8947848,
                                specular: 0,
                                shininess: 0,
                                transparent: !1,
                                depthTest: !0,
                                side: a.FrontSide,
                              });
                        ((y = new a.Mesh(c, m)).castShadow = !0),
                          (y.name = '0' === o ? i.name : i.name + o),
                          s.extras && (y.userData = s.extras),
                          i.add(y);
                      } else if (s.mode === l.LINES) {
                        (c = new a.BufferGeometry()), (u = s.attributes);
                        for (var h in u) {
                          var g;
                          if (!(g = u[h])) return;
                          d = e.accessors[g];
                          switch (h) {
                            case 'POSITION':
                              c.setAttribute('position', d);
                              break;
                            case 'COLOR_0':
                            case 'COLOR0':
                            case 'COLOR':
                              c.setAttribute('color', d);
                          }
                        }
                        var y;
                        m = e.materials[s.material];
                        s.indices
                          ? (c.setIndex(e.accessors[s.indices]),
                            (y = new a.LineSegments(c, m)))
                          : (y = new a.Line(c, m)),
                          (y.name = '0' === o ? i.name : i.name + o),
                          s.extras && (y.userData = s.extras),
                          i.add(y);
                      } else
                        console.warn(
                          'Only triangular and line primitives are supported',
                        );
                    }
                    return i;
                  });
                },
              );
            }),
            (T.prototype.loadCameras = function () {
              return M(this.json.cameras, function (t) {
                if ('perspective' == t.type && t.perspective) {
                  var e = t.perspective.yfov,
                    n =
                      void 0 !== t.perspective.aspectRatio
                        ? t.perspective.aspectRatio
                        : 1,
                    i = new a.PerspectiveCamera(
                      a.MathUtils.radToDeg(e * n),
                      n,
                      t.perspective.znear || 1,
                      t.perspective.zfar || 2e6,
                    );
                  return (
                    void 0 !== t.name && (i.name = t.name),
                    t.extras && (i.userData = t.extras),
                    i
                  );
                }
                if ('orthographic' == t.type && t.orthographic) {
                  i = new a.OrthographicCamera(
                    window.innerWidth / -2,
                    window.innerWidth / 2,
                    window.innerHeight / 2,
                    window.innerHeight / -2,
                    t.orthographic.znear,
                    t.orthographic.zfar,
                  );
                  return (
                    void 0 !== t.name && (i.name = t.name),
                    t.extras && (i.userData = t.extras),
                    i
                  );
                }
              });
            }),
            (T.prototype.loadSkins = function () {
              var t = this.json;
              return this._withDependencies(['accessors']).then(function (e) {
                return M(t.skins, function (t) {
                  var n = new a.Matrix4();
                  return (
                    void 0 !== t.bindShapeMatrix &&
                      n.fromArray(t.bindShapeMatrix),
                    {
                      bindShapeMatrix: n,
                      jointNames: t.jointNames,
                      inverseBindMatrices: e.accessors[t.inverseBindMatrices],
                    }
                  );
                });
              });
            }),
            (T.prototype.loadAnimations = function () {
              var t = this.json;
              return this._withDependencies(['accessors', 'nodes']).then(
                function (e) {
                  return M(t.animations, function (t, n) {
                    var i = [];
                    for (var r in t.channels) {
                      var o = t.channels[r],
                        s = t.samplers[o.sampler];
                      if (s) {
                        var l = o.target,
                          c = l.id,
                          u =
                            void 0 !== t.parameters
                              ? t.parameters[s.input]
                              : s.input,
                          h =
                            void 0 !== t.parameters
                              ? t.parameters[s.output]
                              : s.output,
                          d = e.accessors[u],
                          p = e.accessors[h],
                          f = e.nodes[c];
                        if (f) {
                          f.updateMatrix(), (f.matrixAutoUpdate = !0);
                          var m =
                              b[l.path] === b.rotation
                                ? a.QuaternionKeyframeTrack
                                : a.VectorKeyframeTrack,
                            g = f.name ? f.name : f.uuid,
                            y =
                              void 0 !== s.interpolation
                                ? _[s.interpolation]
                                : a.InterpolateLinear;
                          i.push(
                            new m(
                              g + '.' + b[l.path],
                              a.AnimationUtils.arraySlice(d.array, 0),
                              a.AnimationUtils.arraySlice(p.array, 0),
                              y,
                            ),
                          );
                        }
                      }
                    }
                    c = void 0 !== t.name ? t.name : 'animation_' + n;
                    return new a.AnimationClip(c, void 0, i);
                  });
                },
              );
            }),
            (T.prototype.loadNodes = function () {
              var t = this.json,
                e = this.extensions,
                n = this;
              return M(t.nodes, function (t) {
                var e,
                  n = new a.Matrix4();
                return (
                  t.jointName
                    ? (((e = new a.Bone()).name =
                        void 0 !== t.name ? t.name : t.jointName),
                      (e.jointName = t.jointName))
                    : ((e = new a.Object3D()),
                      void 0 !== t.name && (e.name = t.name)),
                  t.extras && (e.userData = t.extras),
                  void 0 !== t.matrix
                    ? (n.fromArray(t.matrix), e.applyMatrix4(n))
                    : (void 0 !== t.translation &&
                        e.position.fromArray(t.translation),
                      void 0 !== t.rotation &&
                        e.quaternion.fromArray(t.rotation),
                      void 0 !== t.scale && e.scale.fromArray(t.scale)),
                  e
                );
              }).then(function (r) {
                return n
                  ._withDependencies(['meshes', 'skins', 'cameras'])
                  .then(function (n) {
                    return M(r, function (o, s) {
                      var l = t.nodes[s];
                      if (void 0 !== l.meshes)
                        for (var c in l.meshes) {
                          var u = l.meshes[c],
                            h = n.meshes[u];
                          if (void 0 !== h)
                            for (var d in h.children) {
                              var p,
                                f = h.children[d],
                                m = f.material,
                                g = f.geometry,
                                y = f.userData,
                                v = f.name;
                              switch (
                                (m.isDeferredShaderMaterial
                                  ? (m = x = m.create())
                                  : (x = m),
                                f.type)
                              ) {
                                case 'LineSegments':
                                  f = new a.LineSegments(g, x);
                                  break;
                                case 'LineLoop':
                                  f = new a.LineLoop(g, x);
                                  break;
                                case 'Line':
                                  f = new a.Line(g, x);
                                  break;
                                default:
                                  f = new a.Mesh(g, x);
                              }
                              if (
                                ((f.castShadow = !0),
                                (f.userData = y),
                                (f.name = v),
                                l.skin && (p = n.skins[l.skin]),
                                p)
                              ) {
                                var x,
                                  b = function (t) {
                                    for (
                                      var e = Object.keys(r),
                                        n = 0,
                                        i = e.length;
                                      n < i;
                                      n++
                                    ) {
                                      var a = r[e[n]];
                                      if (a.jointName === t) return a;
                                    }
                                    return null;
                                  };
                                ((x = m).skinning = !0),
                                  ((f = new a.SkinnedMesh(g, x)).castShadow =
                                    !0),
                                  (f.userData = y),
                                  (f.name = v);
                                for (
                                  var _ = [],
                                    w = [],
                                    M = 0,
                                    q = p.jointNames.length;
                                  M < q;
                                  M++
                                ) {
                                  var S = p.jointNames[M],
                                    T = b(S);
                                  if (T) {
                                    _.push(T);
                                    var E = p.inverseBindMatrices.array,
                                      A = new a.Matrix4().fromArray(E, 16 * M);
                                    w.push(A);
                                  } else
                                    console.warn(
                                      "WARNING: joint: '" +
                                        S +
                                        "' could not be found",
                                    );
                                }
                                f.bind(new a.Skeleton(_, w), p.bindShapeMatrix);
                                var L = function (e, n, i) {
                                  var a = e[i];
                                  if (void 0 !== a)
                                    for (var o = 0, s = a.length; o < s; o++) {
                                      var l = a[o],
                                        c = r[l],
                                        u = t.nodes[l];
                                      void 0 !== c &&
                                        !0 === c.isBone &&
                                        void 0 !== u &&
                                        (n.add(c), L(u, c, 'children'));
                                    }
                                };
                                L(l, f, 'skeletons');
                              }
                              o.add(f);
                            }
                          else
                            console.warn(
                              'LegacyGLTFLoader: Couldn\'t find node "' +
                                u +
                                '".',
                            );
                        }
                      if (void 0 !== l.camera) {
                        var R = n.cameras[l.camera];
                        o.add(R);
                      }
                      if (
                        l.extensions &&
                        l.extensions[i.KHR_MATERIALS_COMMON] &&
                        l.extensions[i.KHR_MATERIALS_COMMON].light
                      ) {
                        var C =
                          e[i.KHR_MATERIALS_COMMON].lights[
                            l.extensions[i.KHR_MATERIALS_COMMON].light
                          ];
                        o.add(C);
                      }
                      return o;
                    });
                  });
              });
            }),
            (T.prototype.loadScenes = function () {
              var t = this.json;
              function e(n, i, r) {
                var a = r[n];
                i.add(a);
                var o = t.nodes[n];
                if (o.children)
                  for (var s = o.children, l = 0, c = s.length; l < c; l++) {
                    e(s[l], a, r);
                  }
              }
              return this._withDependencies(['nodes']).then(function (i) {
                return M(t.scenes, function (t) {
                  var r = new a.Scene();
                  void 0 !== t.name && (r.name = t.name),
                    t.extras && (r.userData = t.extras);
                  for (var o = t.nodes || [], s = 0, l = o.length; s < l; s++) {
                    e(o[s], r, i.nodes);
                  }
                  return (
                    r.traverse(function (t) {
                      t.material &&
                        t.material.isRawShaderMaterial &&
                        ((t.gltfShader = new n(t, i.nodes)),
                        (t.onBeforeRender = function (t, e, n) {
                          this.gltfShader.update(e, n);
                        }));
                    }),
                    r
                  );
                });
              });
            }),
            t
          );
        })();
        var u = c.LegacyGLTFLoader,
          h = n(62),
          d = n(36),
          p = n(74);
        function f(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return m(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return m(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function m(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        var g = new a.Matrix4().makeRotationX(Math.PI / 2),
          y = new a.Matrix4().makeRotationZ(-Math.PI / 2),
          v = new s(),
          x = new u();
        function b(t) {
          var e = [
            'MODELVIEW',
            'MODELVIEWINVERSETRANSPOSE',
            'PROJECTION',
            'JOINTMATRIX',
          ];
          if (t.gltfShader) {
            var n = [];
            for (var i in t.gltfShader.boundUniforms) n.push(i);
            for (var r = 0, a = n; r < a.length; r++) {
              var o = a[r],
                s = t.gltfShader.boundUniforms[o].semantic;
              e.includes(s) || delete t.gltfShader.boundUniforms[o];
            }
          }
        }
        function _(t, e) {
          if (!t) throw new Error('Path to draco folder is mandatory');
          var n = new l();
          n.setDecoderPath(t), e && n.setDecoderConfig(e), v.setDRACOLoader(n);
        }
        e.a = {
          parse: function (t, e) {
            var n = e.gltfUpAxis,
              i = e.urlBase;
            if (!t) throw new Error('No array buffer provided.');
            var s = new DataView(t, 4),
              l = 0,
              c = {};
            if (((c.magic = d.a.decode(new Uint8Array(t, 0, 4))), c.magic)) {
              (c.version = s.getUint32(l, !0)),
                (l += Uint32Array.BYTES_PER_ELEMENT),
                (c.byteLength = s.getUint32(l, !0)),
                (l += Uint32Array.BYTES_PER_ELEMENT),
                (c.FTJSONLength = s.getUint32(l, !0)),
                (l += Uint32Array.BYTES_PER_ELEMENT),
                (c.FTBinaryLength = s.getUint32(l, !0)),
                (l += Uint32Array.BYTES_PER_ELEMENT),
                (c.BTJSONLength = s.getUint32(l, !0)),
                (l += Uint32Array.BYTES_PER_ELEMENT),
                (c.BTBinaryLength = s.getUint32(l, !0));
              var u = (l += Uint32Array.BYTES_PER_ELEMENT) + 4,
                m = [],
                _ = {},
                w = new a.Vector3();
              if (c.FTJSONLength > 0) {
                var M = u,
                  q = t.slice(M, c.FTJSONLength + M),
                  S = d.a.decode(new Uint8Array(q));
                (_ = JSON.parse(S)).RTC_CENTER
                  ? w.fromArray(_.RTC_CENTER)
                  : w.set(0, 0, 0);
              }
              if (
                (c.FTBinaryLength > 0 &&
                  console.warn(
                    '3D Tiles feature table binary not supported yet.',
                  ),
                c.BTJSONLength > 0)
              ) {
                var T = u + c.FTJSONLength + c.FTBinaryLength,
                  E = t.slice(T, c.BTJSONLength + T);
                m.push(
                  new p.a(
                    E,
                    c.BTBinaryLength,
                    _.BATCH_LENGTH,
                    e.registeredExtensions,
                  ),
                );
              } else m.push(Promise.resolve({}));
              var A =
                  u +
                  c.FTJSONLength +
                  c.FTBinaryLength +
                  c.BTJSONLength +
                  c.BTBinaryLength,
                L = t.slice(A),
                R = new DataView(L, 0, 20);
              return (
                m.push(
                  new Promise(function (t) {
                    var a = function (i) {
                      var a,
                        s = f(i.scenes);
                      try {
                        for (s.s(); !(a = s.n()).done; ) {
                          a.value.traverse(b);
                        }
                      } catch (t) {
                        s.e(t);
                      } finally {
                        s.f();
                      }
                      void 0 === n || 'Y' === n
                        ? i.scene.applyMatrix4(g)
                        : 'X' === n && i.scene.applyMatrix4(y),
                        i.scene.position.copy(w);
                      var l = new Uint8Array(L, 20, R.getUint32(12, !0)),
                        c = d.a.decode(new Uint8Array(l)),
                        u = JSON.parse(c);
                      u.extensions &&
                        u.extensions.CESIUM_RTC &&
                        (i.scene.position.fromArray(
                          u.extensions.CESIUM_RTC.center,
                        ),
                        i.scene.updateMatrixWorld(!0)),
                        i.scene.traverse(function (t) {
                          if (((t.frustumCulled = !1), t.material)) {
                            if (e.overrideMaterials) {
                              if (Array.isArray(t.material)) {
                                var n,
                                  i = f(t.material);
                                try {
                                  for (i.s(); !(n = i.n()).done; ) {
                                    n.value.dispose();
                                  }
                                } catch (t) {
                                  i.e(t);
                                } finally {
                                  i.f();
                                }
                              } else t.material.dispose();
                              'object' === r()(e.overrideMaterials) &&
                              e.overrideMaterials.isMaterial
                                ? (t.material = e.overrideMaterials)
                                : (t.material.depthWrite = !0);
                            } else
                              o.a.isLogDepthBufferSupported() &&
                                t.material.isRawShaderMaterial &&
                                !e.doNotPatchMaterial &&
                                (h.a.patchMaterialForLogDepthSupport(
                                  t.material,
                                ),
                                console.warn(
                                  'b3dm shader has been patched to add log depth buffer support',
                                ));
                            (t.material.transparent = e.opacity < 1),
                              (t.material.opacity = e.opacity);
                          }
                        }),
                        t(i);
                    };
                    1 === R.getUint32(4, !0)
                      ? x.parse(L, i, a)
                      : v.parse(L, i, a);
                  }),
                ),
                Promise.all(m).then(function (t) {
                  return { gltf: t[1], batchTable: t[0] };
                })
              );
            }
            throw new Error('Invalid b3dm file.');
          },
        };
      },
      85: function (t, e, n) {
        !(function (t) {
          'use strict';
          function e(t) {
            return (
              t && t.normalize && t.normalize(), (t && t.textContent) || ''
            );
          }
          function n(t, e) {
            const n = t.getElementsByTagName(e);
            return n.length ? n[0] : null;
          }
          function i(t) {
            const i = {};
            if (t) {
              const r = n(t, 'line');
              if (r) {
                const t = e(n(r, 'color')),
                  a = parseFloat(e(n(r, 'opacity'))),
                  o = parseFloat(e(n(r, 'width')));
                t && (i.stroke = t),
                  isNaN(a) || (i['stroke-opacity'] = a),
                  isNaN(o) || (i['stroke-width'] = (96 * o) / 25.4);
              }
            }
            return i;
          }
          function r(t, i) {
            const r = {};
            let a, o;
            for (o = 0; o < i.length; o++)
              (a = n(t, i[o])), a && (r[i[o]] = e(a));
            return r;
          }
          function a(t) {
            const n = r(t, ['name', 'cmt', 'desc', 'type', 'time', 'keywords']),
              i = t.getElementsByTagNameNS(
                'http://www.garmin.com/xmlschemas/GpxExtensions/v3',
                '*',
              );
            for (let r = 0; r < i.length; r++) {
              const a = i[r];
              a.parentNode.parentNode === t &&
                (n[a.tagName.replace(':', '_')] = e(a));
            }
            const a = t.getElementsByTagName('link');
            a.length && (n.links = []);
            for (let t = 0; t < a.length; t++)
              n.links.push(
                Object.assign(
                  { href: a[t].getAttribute('href') },
                  r(a[t], ['text', 'type']),
                ),
              );
            return n;
          }
          function o(t) {
            const i = [
                parseFloat(t.getAttribute('lon')),
                parseFloat(t.getAttribute('lat')),
              ],
              r = n(t, 'ele'),
              a = n(t, 'gpxtpx:hr') || n(t, 'hr'),
              o = n(t, 'time');
            let s;
            r && ((s = parseFloat(e(r))), isNaN(s) || i.push(s));
            const l = {
              coordinates: i,
              time: o ? e(o) : null,
              extendedValues: [],
            };
            a && l.extendedValues.push(['heartRate', parseFloat(e(a))]);
            const c = n(t, 'extensions');
            if (null !== c)
              for (const t of ['speed', 'course', 'hAcc', 'vAcc']) {
                const i = parseFloat(e(n(c, t)));
                isNaN(i) || l.extendedValues.push([t, i]);
              }
            return l;
          }
          function s(t) {
            const e = l(t, 'rtept');
            if (e)
              return {
                type: 'Feature',
                properties: Object.assign(a(t), i(n(t, 'extensions')), {
                  _gpxType: 'rte',
                }),
                geometry: { type: 'LineString', coordinates: e.line },
              };
          }
          function l(t, e) {
            const n = t.getElementsByTagName(e);
            if (n.length < 2) return;
            const i = [],
              r = [],
              a = {};
            for (let t = 0; t < n.length; t++) {
              const e = o(n[t]);
              i.push(e.coordinates), e.time && r.push(e.time);
              for (let i = 0; i < e.extendedValues.length; i++) {
                const [r, o] = e.extendedValues[i],
                  s = r + 's';
                a[s] || (a[s] = Array(n.length).fill(null)), (a[s][t] = o);
              }
            }
            return { line: i, times: r, extendedValues: a };
          }
          function c(t) {
            const e = t.getElementsByTagName('trkseg'),
              r = [],
              o = [],
              s = [];
            for (let t = 0; t < e.length; t++) {
              const n = l(e[t], 'trkpt');
              n && (s.push(n), n.times && n.times.length && o.push(n.times));
            }
            if (0 === s.length) return;
            const c = s.length > 1,
              u = Object.assign(
                a(t),
                i(n(t, 'extensions')),
                { _gpxType: 'trk' },
                o.length
                  ? { coordinateProperties: { times: c ? o : o[0] } }
                  : {},
              );
            for (let t = 0; t < s.length; t++) {
              const e = s[t];
              r.push(e.line);
              for (const [n, i] of Object.entries(e.extendedValues)) {
                let e = u;
                'heartRates' === n &&
                  (u.coordinateProperties || (u.coordinateProperties = {}),
                  (e = u.coordinateProperties)),
                  c
                    ? (e[n] ||
                        (e[n] = s.map((t) =>
                          new Array(t.line.length).fill(null),
                        )),
                      (e[n][t] = i))
                    : (e[n] = i);
              }
            }
            return {
              type: 'Feature',
              properties: u,
              geometry: c
                ? { type: 'MultiLineString', coordinates: r }
                : { type: 'LineString', coordinates: r[0] },
            };
          }
          function* u(t) {
            const e = t.getElementsByTagName('trk'),
              n = t.getElementsByTagName('rte'),
              i = t.getElementsByTagName('wpt');
            for (let t = 0; t < e.length; t++) {
              const n = c(e[t]);
              n && (yield n);
            }
            for (let t = 0; t < n.length; t++) {
              const e = s(n[t]);
              e && (yield e);
            }
            for (let t = 0; t < i.length; t++)
              yield ((l = i[t]),
              {
                type: 'Feature',
                properties: Object.assign(a(l), r(l, ['sym'])),
                geometry: { type: 'Point', coordinates: o(l).coordinates },
              });
            var l;
          }
          const h = [
              ['heartRate', 'heartRates'],
              ['Cadence', 'cadences'],
              ['Speed', 'speeds'],
              ['Watts', 'watts'],
            ],
            d = [
              ['TotalTimeSeconds', 'totalTimeSeconds'],
              ['DistanceMeters', 'distanceMeters'],
              ['MaximumSpeed', 'maxSpeed'],
              ['AverageHeartRateBpm', 'avgHeartRate'],
              ['MaximumHeartRateBpm', 'maxHeartRate'],
              ['AvgSpeed', 'avgSpeed'],
              ['AvgWatts', 'avgWatts'],
              ['MaxWatts', 'maxWatts'],
            ];
          function p(t, i) {
            const r = [];
            for (const [a, o] of i) {
              let i = n(t, a);
              if (!i) {
                const e = t.getElementsByTagNameNS(
                  'http://www.garmin.com/xmlschemas/ActivityExtension/v2',
                  a,
                );
                e.length && (i = e[0]);
              }
              const s = parseFloat(e(i));
              isNaN(s) || r.push([o, s]);
            }
            return r;
          }
          function f(t) {
            const i = e(n(t, 'LongitudeDegrees')),
              r = e(n(t, 'LatitudeDegrees'));
            if (!i.length || !r.length) return null;
            const a = [parseFloat(i), parseFloat(r)],
              o = n(t, 'AltitudeMeters'),
              s = n(t, 'HeartRateBpm'),
              l = n(t, 'Time');
            let c;
            return (
              o && ((c = parseFloat(e(o))), isNaN(c) || a.push(c)),
              {
                coordinates: a,
                time: l ? e(l) : null,
                heartRate: s ? parseFloat(e(s)) : null,
                extensions: p(t, h),
              }
            );
          }
          function m(t, e) {
            const n = t.getElementsByTagName(e),
              i = [],
              r = [],
              a = [];
            if (n.length < 2) return null;
            const o = { extendedProperties: {} };
            for (let t = 0; t < n.length; t++) {
              const e = f(n[t]);
              if (null !== e) {
                i.push(e.coordinates),
                  e.time && r.push(e.time),
                  e.heartRate && a.push(e.heartRate);
                for (const [i, r] of e.extensions)
                  o.extendedProperties[i] ||
                    (o.extendedProperties[i] = Array(n.length).fill(null)),
                    (o.extendedProperties[i][t] = r);
              }
            }
            return Object.assign(o, { line: i, times: r, heartRates: a });
          }
          function g(t) {
            const e = t.getElementsByTagName('Track'),
              n = [],
              i = [],
              r = [],
              a = [];
            let o;
            const s = (function (t) {
              const e = {};
              for (const [n, i] of t) e[n] = i;
              return e;
            })(p(t, d));
            for (let t = 0; t < e.length; t++)
              (o = m(e[t], 'Trackpoint')),
                o &&
                  (n.push(o.line),
                  o.times.length && i.push(o.times),
                  o.heartRates.length && r.push(o.heartRates),
                  a.push(o.extendedProperties));
            for (let t = 0; t < a.length; t++) {
              const i = a[t];
              for (const r in i)
                1 === e.length
                  ? (s[r] = o.extendedProperties[r])
                  : (s[r] || (s[r] = n.map((t) => Array(t.length).fill(null))),
                    (s[r][t] = i[r]));
            }
            if (0 !== n.length)
              return (
                (i.length || r.length) &&
                  (s.coordinateProperties = Object.assign(
                    i.length ? { times: 1 === n.length ? i[0] : i } : {},
                    r.length ? { heartRates: 1 === n.length ? r[0] : r } : {},
                  )),
                {
                  type: 'Feature',
                  properties: s,
                  geometry: {
                    type: 1 === n.length ? 'LineString' : 'MultiLineString',
                    coordinates: 1 === n.length ? n[0] : n,
                  },
                }
              );
          }
          function* y(t) {
            const e = t.getElementsByTagName('Lap');
            for (let t = 0; t < e.length; t++) {
              const n = g(e[t]);
              n && (yield n);
            }
          }
          const v = /\s*/g,
            x = /^\s*|\s*$/g,
            b = /\s+/;
          function _(t) {
            if (!t || !t.length) return 0;
            let e = 0;
            for (let n = 0; n < t.length; n++)
              e = ((e << 5) - e + t.charCodeAt(n)) | 0;
            return e;
          }
          function w(t) {
            return t.replace(v, '').split(',').map(parseFloat);
          }
          function M(t) {
            return t.replace(x, '').split(b).map(w);
          }
          function q(t) {
            if (void 0 !== t.xml) return t.xml;
            if (t.tagName) {
              let e = t.tagName;
              for (let n = 0; n < t.attributes.length; n++)
                e += t.attributes[n].name + t.attributes[n].value;
              for (let n = 0; n < t.childNodes.length; n++)
                e += q(t.childNodes[n]);
              return e;
            }
            return '#text' === t.nodeName
              ? (t.nodeValue || t.value || '').trim()
              : '#cdata-section' === t.nodeName
              ? t.nodeValue
              : '';
          }
          const S = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'];
          function T(t, i, r) {
            let a = e(n(i, 'color')) || '';
            const o = 'stroke' == r || 'fill' === r ? r : r + '-color';
            '#' === a.substr(0, 1) && (a = a.substr(1)),
              6 === a.length || 3 === a.length
                ? (t[o] = a)
                : 8 === a.length &&
                  ((t[r + '-opacity'] = parseInt(a.substr(0, 2), 16) / 255),
                  (t[o] =
                    '#' + a.substr(6, 2) + a.substr(4, 2) + a.substr(2, 2)));
          }
          function E(t, i, r, a) {
            const o = parseFloat(e(n(i, r)));
            isNaN(o) || (t[a] = o);
          }
          function A(t) {
            let n = t.getElementsByTagName('coord');
            const i = [],
              r = [];
            0 === n.length && (n = t.getElementsByTagName('gx:coord'));
            for (let t = 0; t < n.length; t++)
              i.push(e(n[t]).split(' ').map(parseFloat));
            const a = t.getElementsByTagName('when');
            for (let t = 0; t < a.length; t++) r.push(e(a[t]));
            return { coords: i, times: r };
          }
          function L(t, i, r, a) {
            const o = (function t(i) {
              let r, a, o, s, l;
              const c = [],
                u = [];
              if (n(i, 'MultiGeometry')) return t(n(i, 'MultiGeometry'));
              if (n(i, 'MultiTrack')) return t(n(i, 'MultiTrack'));
              if (n(i, 'gx:MultiTrack')) return t(n(i, 'gx:MultiTrack'));
              for (o = 0; o < S.length; o++)
                if (((a = i.getElementsByTagName(S[o])), a))
                  for (s = 0; s < a.length; s++)
                    if (((r = a[s]), 'Point' === S[o]))
                      c.push({
                        type: 'Point',
                        coordinates: w(e(n(r, 'coordinates'))),
                      });
                    else if ('LineString' === S[o])
                      c.push({
                        type: 'LineString',
                        coordinates: M(e(n(r, 'coordinates'))),
                      });
                    else if ('Polygon' === S[o]) {
                      const t = r.getElementsByTagName('LinearRing'),
                        i = [];
                      for (l = 0; l < t.length; l++)
                        i.push(M(e(n(t[l], 'coordinates'))));
                      c.push({ type: 'Polygon', coordinates: i });
                    } else if ('Track' === S[o] || 'gx:Track' === S[o]) {
                      const t = A(r);
                      c.push({ type: 'LineString', coordinates: t.coords }),
                        t.times.length && u.push(t.times);
                    }
              return { geoms: c, coordTimes: u };
            })(t);
            let s;
            const l = {},
              c = e(n(t, 'name')),
              u = e(n(t, 'address'));
            let h = e(n(t, 'styleUrl'));
            const d = e(n(t, 'description')),
              p = n(t, 'TimeSpan'),
              f = n(t, 'TimeStamp'),
              m = n(t, 'ExtendedData');
            let g = n(t, 'IconStyle'),
              y = n(t, 'LabelStyle'),
              v = n(t, 'LineStyle'),
              x = n(t, 'PolyStyle');
            const b = n(t, 'visibility');
            if ((c && (l.name = c), u && (l.address = u), h)) {
              '#' !== h[0] && (h = '#' + h),
                (l.styleUrl = h),
                i[h] && (l.styleHash = i[h]),
                r[h] &&
                  ((l.styleMapHash = r[h]), (l.styleHash = i[r[h].normal]));
              const t = a[l.styleHash];
              t &&
                (g || (g = n(t, 'IconStyle')),
                y || (y = n(t, 'LabelStyle')),
                v || (v = n(t, 'LineStyle')),
                x || (x = n(t, 'PolyStyle')));
            }
            if ((d && (l.description = d), p)) {
              const t = e(n(p, 'begin')),
                i = e(n(p, 'end'));
              l.timespan = { begin: t, end: i };
            }
            if ((f && (l.timestamp = e(n(f, 'when'))), g)) {
              T(l, g, 'icon'),
                E(l, g, 'scale', 'icon-scale'),
                E(l, g, 'heading', 'icon-heading');
              const t = n(g, 'hotSpot');
              if (t) {
                const e = parseFloat(t.getAttribute('x')),
                  n = parseFloat(t.getAttribute('y'));
                isNaN(e) || isNaN(n) || (l['icon-offset'] = [e, n]);
              }
              const i = n(g, 'Icon');
              if (i) {
                const t = e(n(i, 'href'));
                t && (l.icon = t);
              }
            }
            if (
              (y && (T(l, y, 'label'), E(l, y, 'scale', 'label-scale')),
              v && (T(l, v, 'stroke'), E(l, v, 'width', 'stroke-width')),
              x)
            ) {
              T(l, x, 'fill');
              const t = e(n(x, 'fill')),
                i = e(n(x, 'outline'));
              t && (l['fill-opacity'] = '1' === t ? l['fill-opacity'] || 1 : 0),
                i &&
                  (l['stroke-opacity'] =
                    '1' === i ? l['stroke-opacity'] || 1 : 0);
            }
            if (m) {
              const t = m.getElementsByTagName('Data'),
                i = m.getElementsByTagName('SimpleData');
              for (s = 0; s < t.length; s++)
                l[t[s].getAttribute('name')] = e(n(t[s], 'value'));
              for (s = 0; s < i.length; s++)
                l[i[s].getAttribute('name')] = e(i[s]);
            }
            b && (l.visibility = e(b)),
              o.coordTimes.length &&
                (l.coordinateProperties = {
                  times:
                    1 === o.coordTimes.length ? o.coordTimes[0] : o.coordTimes,
                });
            const _ = {
              type: 'Feature',
              geometry:
                0 === o.geoms.length
                  ? null
                  : 1 === o.geoms.length
                  ? o.geoms[0]
                  : { type: 'GeometryCollection', geometries: o.geoms },
              properties: l,
            };
            return t.getAttribute('id') && (_.id = t.getAttribute('id')), _;
          }
          function* R(t) {
            const i = {},
              r = {},
              a = {},
              o = t.getElementsByTagName('Placemark'),
              s = t.getElementsByTagName('Style'),
              l = t.getElementsByTagName('StyleMap');
            for (let t = 0; t < s.length; t++) {
              const e = _(q(s[t])).toString(16);
              (i['#' + s[t].getAttribute('id')] = e), (r[e] = s[t]);
            }
            for (let t = 0; t < l.length; t++) {
              i['#' + l[t].getAttribute('id')] = _(q(l[t])).toString(16);
              const r = l[t].getElementsByTagName('Pair'),
                o = {};
              for (let t = 0; t < r.length; t++)
                o[e(n(r[t], 'key'))] = e(n(r[t], 'styleUrl'));
              a['#' + l[t].getAttribute('id')] = o;
            }
            for (let t = 0; t < o.length; t++) {
              const e = L(o[t], i, a, r);
              e && (yield e);
            }
          }
          (t.gpx = function (t) {
            return { type: 'FeatureCollection', features: Array.from(u(t)) };
          }),
            (t.gpxGen = u),
            (t.kml = function (t) {
              return { type: 'FeatureCollection', features: Array.from(R(t)) };
            }),
            (t.kmlGen = R),
            (t.tcx = function (t) {
              return { type: 'FeatureCollection', features: Array.from(y(t)) };
            }),
            (t.tcxGen = y),
            Object.defineProperty(t, '__esModule', { value: !0 });
        })(e);
      },
      86: function (t, e, n) {
        'use strict';
        var i = n(3),
          r = n.n(i),
          a = n(4),
          o = n.n(a),
          s = n(5),
          l = n.n(s),
          c = n(18),
          u = n.n(c),
          h = n(6),
          d = n.n(h),
          p = n(7),
          f = n.n(p),
          m = n(2),
          g = n.n(m),
          y = n(0),
          v = n(113),
          x = n(115),
          b = n(8),
          _ = n(10);
        function w(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = g()(t);
            if (e) {
              var r = g()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return f()(this, n);
          };
        }
        var M,
          q = new x.a({ crs: 'EPSG:4978', uvCount: 1 }),
          S = new y.Vector3(),
          T = new y.Vector2(),
          E = new y.Vector3(),
          A = new b.a('EPSG:4326', 0, 0, 0),
          L = (function (t) {
            d()(n, t);
            var e = w(n);
            function n() {
              var t,
                i =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : new y.Vector3(1 / 0, 1 / 0, 1 / 0),
                a =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : new y.Vector3(-1 / 0, -1 / 0, -1 / 0);
              return (
                r()(this, n),
                ((t = e.call(this)).box3D = new y.Box3(i.clone(), a.clone())),
                (t.natBox = t.box3D.clone()),
                (t.z = { min: 0, max: 0, scale: 1 }),
                f()(t, l()(t))
              );
            }
            return (
              o()(n, [
                {
                  key: 'clone',
                  value: function () {
                    return new n().copy(this);
                  },
                },
                {
                  key: 'copy',
                  value: function (t) {
                    return (
                      u()(g()(n.prototype), 'copy', this).call(this, t),
                      this.box3D.copy(t.box3D),
                      this.natBox.copy(t.natBox),
                      (this.z.min = t.z.min),
                      (this.z.max = t.z.max),
                      (this.z.scale = t.z.scale),
                      this
                    );
                  },
                },
                {
                  key: 'update',
                  value: function () {
                    this.updateMatrixWorld(!0);
                  },
                },
                {
                  key: 'updateZ',
                  value: function (t, e) {
                    var n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : this.z.scale;
                    (this.z = {
                      min: t,
                      max: e,
                      scale: n,
                      delta: Math.abs(e - t) * n,
                    }),
                      (this.box3D.min.z = this.natBox.min.z + t * n),
                      (this.box3D.max.z = this.natBox.max.z + e * n);
                  },
                },
                {
                  key: 'updateScaleZ',
                  value: function (t) {
                    t > 0 && this.updateZ(this.z.min, this.z.max, t);
                  },
                },
                {
                  key: 'isSphereAboveXYBox',
                  value: function (t) {
                    var e = this.worldToLocal(t.center),
                      n = Math.max(
                        this.box3D.min.x,
                        Math.min(e.x, this.box3D.max.x),
                      ),
                      i = Math.max(
                        this.box3D.min.y,
                        Math.min(e.y, this.box3D.max.y),
                      );
                    return (
                      Math.sqrt((n - e.x) * (n - e.x) + (i - e.y) * (i - e.y)) <
                      t.radius
                    );
                  },
                },
                {
                  key: 'setFromExtent',
                  value: function (t) {
                    var e =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : t.min || 0,
                      n =
                        arguments.length > 2 && void 0 !== arguments[2]
                          ? arguments[2]
                          : t.max || 0;
                    if ('EPSG:4326' == t.crs) {
                      var i = q.computeSharableExtent(t),
                        r = i.sharableExtent,
                        a = i.quaternion,
                        o = i.position,
                        s = Math.max(Math.floor(r.dimensions(T).x / 90 + 1), 2),
                        l = new v.a({
                          extent: r,
                          level: 0,
                          segment: s,
                          disableSkirt: !0,
                          builder: q,
                        });
                      M.box3D.copy(l.boundingBox),
                        M.natBox.copy(l.boundingBox),
                        this.copy(M),
                        this.updateZ(e, n),
                        this.position.copy(o),
                        this.quaternion.copy(a),
                        this.updateMatrixWorld(!0);
                    } else {
                      if (_.a.isTms(t.crs) || !_.a.isMetricUnit(t.crs))
                        throw new Error('Unsupported extent crs');
                      t.center(A).toVector3(this.position),
                        t.dimensions(T),
                        S.set(T.x, T.y, Math.abs(n - e)),
                        this.box3D.setFromCenterAndSize(E, S),
                        this.updateMatrixWorld(!0);
                    }
                    return this;
                  },
                },
              ]),
              n
            );
          })(y.Object3D);
        (M = new L()), (e.a = L);
      },
      87: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return T;
        }),
          n.d(e, 'b', function () {
            return L;
          }),
          n.d(e, 'c', function () {
            return R;
          });
        var i = n(18),
          r = n.n(i),
          a = n(3),
          o = n.n(a),
          s = n(4),
          l = n.n(s),
          c = n(6),
          u = n.n(c),
          h = n(7),
          d = n.n(h),
          p = n(2),
          f = n.n(p),
          m = n(0),
          g = n(29),
          y = n(22),
          v = n.n(y),
          x = n(37);
        function b(t, e, n) {
          var i = t.image,
            r = i.width,
            a = i.height,
            o = i.data;
          if (!o) return { min: null, max: null };
          var s = (function (t, e, n) {
              var i = e.x,
                r = e.y,
                a = e.z,
                o = [
                  Object(x.b)({ noDataValue: n }, t, i, r),
                  Object(x.b)({ noDataValue: n }, t, i + a, r),
                  Object(x.b)({ noDataValue: n }, t, i + a, r + a),
                  Object(x.b)({ noDataValue: n }, t, i, r + a),
                ].filter(function (t) {
                  return null != t && t > -10;
                });
              if (o.length)
                return {
                  min: Math.min.apply(Math, v()(o)),
                  max: Math.max.apply(Math, v()(o)),
                };
            })(t, e, n) || { max: -1 / 0, min: 1 / 0 },
            l = s.min,
            c = s.max,
            u = Math.floor(e.z * r);
          if (u > 2)
            for (
              var h = Math.floor(e.z * a),
                d = Math.floor(e.x * r),
                p = Math.floor(e.y * a),
                f = Math.max(Math.floor(u / 32), 2),
                m = p;
              m < p + h;
              m += f
            )
              for (var g = m * (r || 0) + d, y = g + u; g < y; g += f) {
                var b = o[g];
                b > -10 &&
                  b != n &&
                  ((c = Math.max(c, b)), (l = Math.min(l, b)));
              }
          return c === -1 / 0 || l === 1 / 0
            ? { min: null, max: null }
            : { min: l, max: c };
        }
        function _(t, e, n) {
          var i = Math.floor(t / n) / n,
            r = e.x + ((t % n) / n) * e.z,
            a = e.y + i * e.w;
          return Math.floor(a * n) * n + Math.floor(r * n);
        }
        var w = n(10);
        function M(t, e) {
          var n;
          if ('undefined' == typeof Symbol || null == t[Symbol.iterator]) {
            if (
              Array.isArray(t) ||
              (n = (function (t, e) {
                if (!t) return;
                if ('string' == typeof t) return q(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                'Object' === n && t.constructor && (n = t.constructor.name);
                if ('Map' === n || 'Set' === n) return Array.from(t);
                if (
                  'Arguments' === n ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                )
                  return q(t, e);
              })(t)) ||
              (e && t && 'number' == typeof t.length)
            ) {
              n && (t = n);
              var i = 0,
                r = function () {};
              return {
                s: r,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: r,
              };
            }
            throw new TypeError(
              'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          }
          var a,
            o = !0,
            s = !1;
          return {
            s: function () {
              n = t[Symbol.iterator]();
            },
            n: function () {
              var t = n.next();
              return (o = t.done), t;
            },
            e: function (t) {
              (s = !0), (a = t);
            },
            f: function () {
              try {
                o || null == n.return || n.return();
              } finally {
                if (s) throw a;
              }
            },
          };
        }
        function q(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
          return i;
        }
        function S(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = f()(t);
            if (e) {
              var r = f()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return d()(this, n);
          };
        }
        var T = -1,
          E = new m.Vector4(),
          A = (function (t) {
            u()(n, t);
            var e = S(n);
            function n(t, i) {
              var r;
              return (
                o()(this, n),
                ((r = e.call(this)).layer = i),
                (r.crs = i.parent.tileMatrixSets.indexOf(
                  w.a.formatToTms(i.crs),
                )),
                -1 == r.crs && console.error('Unknown crs:', i.crs),
                (r.textures = []),
                (r.offsetScales = []),
                (r.level = T),
                (r.material = t),
                (r._handlerCBEvent = function () {
                  r.material.layersNeedUpdate = !0;
                }),
                i.addEventListener(
                  'visible-property-changed',
                  r._handlerCBEvent,
                ),
                r
              );
            }
            return (
              l()(n, [
                {
                  key: 'id',
                  get: function () {
                    return this.layer.id;
                  },
                },
                {
                  key: 'opacity',
                  get: function () {
                    return this.layer.opacity;
                  },
                },
                {
                  key: 'visible',
                  get: function () {
                    return this.layer.visible;
                  },
                },
                {
                  key: 'initFromParent',
                  value: function (t, e) {
                    if (t && t.level > this.level) {
                      var n,
                        i = 0,
                        r = M(e);
                      try {
                        for (r.s(); !(n = r.n()).done; ) {
                          var a,
                            o = n.value,
                            s = M(t.textures);
                          try {
                            for (s.s(); !(a = s.n()).done; ) {
                              var l = a.value;
                              if (o.isInside(l.extent)) {
                                this.setTexture(
                                  i++,
                                  l,
                                  o.offsetToParent(l.extent),
                                );
                                break;
                              }
                            }
                          } catch (t) {
                            s.e(t);
                          } finally {
                            s.f();
                          }
                        }
                      } catch (t) {
                        r.e(t);
                      } finally {
                        r.f();
                      }
                    }
                  },
                },
                {
                  key: 'dispose',
                  value: function (t) {
                    t &&
                      (this.layer.removeEventListener(
                        'visible-property-changed',
                        this._handlerCBEvent,
                      ),
                      (this._listeners = {}));
                    var e,
                      n = M(this.textures);
                    try {
                      for (n.s(); !(e = n.n()).done; ) {
                        var i = e.value;
                        i.isTexture && i.dispose();
                      }
                    } catch (t) {
                      n.e(t);
                    } finally {
                      n.f();
                    }
                    (this.level = T),
                      (this.textures = []),
                      (this.offsetScales = []),
                      (this.material.layersNeedUpdate = !0);
                  },
                },
                {
                  key: 'setTexture',
                  value: function (t, e, n) {
                    (this.level = e && 0 == t ? e.extent.zoom : this.level),
                      (this.textures[t] = e || null),
                      (this.offsetScales[t] = n),
                      (this.material.layersNeedUpdate = !0);
                  },
                },
                {
                  key: 'setTextures',
                  value: function (t, e) {
                    this.dispose(!1);
                    for (var n = 0, i = t.length; n < i; ++n)
                      this.setTexture(n, t[n], e[n]);
                  },
                },
              ]),
              n
            );
          })(m.EventDispatcher),
          L = (function (t) {
            u()(n, t);
            var e = S(n);
            function n() {
              return o()(this, n), e.apply(this, arguments);
            }
            return (
              l()(n, [
                {
                  key: 'effect_type',
                  get: function () {
                    return this.layer.effect_type;
                  },
                },
                {
                  key: 'effect_parameter',
                  get: function () {
                    return this.layer.effect_parameter;
                  },
                },
              ]),
              n
            );
          })(A),
          R = (function (t) {
            u()(n, t);
            var e = S(n);
            function n(t, i) {
              var r;
              o()(this, n), (r = e.call(this, t, i));
              var a = {
                  bias: 0,
                  scale: 1,
                  mode: g.a.DATA,
                  zmin: 0,
                  zmax: 1 / 0,
                },
                s = 1;
              if (i.useRgbaTextureElevation)
                throw (
                  ((a.mode = g.a.RGBA),
                  (a.zmax = 5e3),
                  new Error('Restore this feature'))
                );
              return (
                i.useColorTextureElevation
                  ? ((s =
                      i.colorTextureElevationMaxZ -
                      i.colorTextureElevationMinZ),
                    (a.mode = g.a.COLOR),
                    (a.bias = i.colorTextureElevationMinZ),
                    (r.min = r.layer.colorTextureElevationMinZ),
                    (r.max = r.layer.colorTextureElevationMaxZ))
                  : ((r.min = 0), (r.max = 0)),
                (r.bias = i.bias || a.bias),
                (r.scale = (i.scale || a.scale) * s),
                (r.mode = i.mode || a.mode),
                (r.zmin = i.zmin || a.zmin),
                (r.zmax = i.zmax || a.zmax),
                r
              );
            }
            return (
              l()(n, [
                {
                  key: 'initFromParent',
                  value: function (t, e) {
                    r()(f()(n.prototype), 'initFromParent', this).call(
                      this,
                      t,
                      e,
                    ),
                      this.updateMinMaxElevation();
                  },
                },
                {
                  key: 'setTextures',
                  value: function (t, e) {
                    this.replaceNoDataValueFromTexture(t[0]),
                      r()(f()(n.prototype), 'setTextures', this).call(
                        this,
                        t,
                        e,
                      ),
                      this.updateMinMaxElevation();
                  },
                },
                {
                  key: 'updateMinMaxElevation',
                  value: function () {
                    if (
                      this.textures[0] &&
                      !this.layer.useColorTextureElevation
                    ) {
                      var t = b(
                          this.textures[0],
                          this.offsetScales[0],
                          this.layer.noDataValue,
                        ),
                        e = t.min,
                        n = t.max;
                      (this.min == e && this.max == n) ||
                        ((this.min = e),
                        (this.max = n),
                        this.dispatchEvent({
                          type: 'updatedElevation',
                          node: this,
                        }));
                    }
                  },
                },
                {
                  key: 'replaceNoDataValueFromTexture',
                  value: function (t) {
                    var e = this.layer.noDataValue;
                    if (null != e) {
                      var n,
                        i,
                        r,
                        a = this.textures[0],
                        o = a && a.image && a.image.data,
                        s = t.image && t.image.data;
                      !s ||
                        !o ||
                        ((i = e),
                        (r = (n = s).length),
                        n[0] > i &&
                          n[r - 1] > i &&
                          n[Math.sqrt(r) - 1] > i &&
                          n[r - Math.sqrt(r)] > i) ||
                        (t.extent.offsetToParent(a.extent, E),
                        (function (t, e, n, i) {
                          for (var r = 0, a = t.length; r < a; ++r)
                            t[r] === n && (t[r] = e[_(r, i, 256)]);
                        })(s, o, e, E));
                    }
                  },
                },
              ]),
              n
            );
          })(A);
      },
      88: function (t, e, n) {
        'use strict';
        (function (t) {
          n.d(e, 'a', function () {
            return Fn;
          }),
            n.d(e, 'b', function () {
              return en;
            });
          var i = {
            $version: 8,
            $root: {
              version: {
                required: !0,
                type: 'enum',
                values: [8],
                doc: 'Style specification version number. Must be 8.',
                example: 8,
              },
              name: {
                type: 'string',
                doc: 'A human-readable name for the style.',
                example: 'Bright',
              },
              metadata: {
                type: '*',
                doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'.",
              },
              center: {
                type: 'array',
                value: 'number',
                doc: 'Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
                example: [-73.9749, 40.7736],
              },
              zoom: {
                type: 'number',
                doc: 'Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
                example: 12.5,
              },
              bearing: {
                type: 'number',
                default: 0,
                period: 360,
                units: 'degrees',
                doc: 'Default bearing, in degrees. The bearing is the compass direction that is "up"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
                example: 29,
              },
              pitch: {
                type: 'number',
                default: 0,
                units: 'degrees',
                doc: 'Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).',
                example: 50,
              },
              light: {
                type: 'light',
                doc: 'The global light source.',
                example: { anchor: 'viewport', color: 'white', intensity: 0.4 },
              },
              terrain: {
                type: 'terrain',
                doc: 'A global modifier that elevates layers and markers based on a DEM data source.',
              },
              sources: {
                required: !0,
                type: 'sources',
                doc: 'Data source specifications.',
                example: {
                  'mapbox-streets': {
                    type: 'vector',
                    url: 'mapbox://mapbox.mapbox-streets-v6',
                  },
                },
              },
              sprite: {
                type: 'string',
                doc: 'A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).',
                example: 'mapbox://sprites/mapbox/bright-v8',
              },
              glyphs: {
                type: 'string',
                doc: 'A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).',
                example: 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf',
              },
              transition: {
                type: 'transition',
                doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's `transition` property.",
                example: { duration: 300, delay: 0 },
              },
              layers: {
                required: !0,
                type: 'array',
                value: 'layer',
                doc: 'Layers will be drawn in the order of this array.',
                example: [
                  {
                    id: 'water',
                    source: 'mapbox-streets',
                    'source-layer': 'water',
                    type: 'fill',
                    paint: { 'fill-color': '#00ffff' },
                  },
                ],
              },
            },
            sources: {
              '*': {
                type: 'source',
                doc: 'Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided.',
              },
            },
            source: [
              'source_vector',
              'source_raster',
              'source_raster_dem',
              'source_geojson',
              'source_video',
              'source_image',
            ],
            source_vector: {
              type: {
                required: !0,
                type: 'enum',
                values: { vector: { doc: 'A vector tile source.' } },
                doc: 'The type of the source.',
              },
              url: {
                type: 'string',
                doc: 'A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`.',
              },
              tiles: {
                type: 'array',
                value: 'string',
                doc: 'An array of one or more tile source URLs, as in the TileJSON spec.',
              },
              bounds: {
                type: 'array',
                value: 'number',
                length: 4,
                default: [-180, -85.051129, 180, 85.051129],
                doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL.",
              },
              scheme: {
                type: 'enum',
                values: {
                  xyz: { doc: 'Slippy map tilenames scheme.' },
                  tms: { doc: 'OSGeo spec scheme.' },
                },
                default: 'xyz',
                doc: 'Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed.',
              },
              minzoom: {
                type: 'number',
                default: 0,
                doc: 'Minimum zoom level for which tiles are available, as in the TileJSON spec.',
              },
              maxzoom: {
                type: 'number',
                default: 22,
                doc: 'Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.',
              },
              attribution: {
                type: 'string',
                doc: 'Contains an attribution to be displayed when the map is shown to a user.',
              },
              promoteId: {
                type: 'promoteId',
                doc: 'A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers.',
              },
              volatile: {
                type: 'boolean',
                default: !1,
                doc: "A setting to determine whether a source's tiles are cached locally.",
                'sdk-support': {
                  'basic functionality': { android: '9.3.0', ios: '5.10.0' },
                },
              },
              '*': {
                type: '*',
                doc: 'Other keys to configure the data source.',
              },
            },
            source_raster: {
              type: {
                required: !0,
                type: 'enum',
                values: { raster: { doc: 'A raster tile source.' } },
                doc: 'The type of the source.',
              },
              url: {
                type: 'string',
                doc: 'A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`.',
              },
              tiles: {
                type: 'array',
                value: 'string',
                doc: 'An array of one or more tile source URLs, as in the TileJSON spec.',
              },
              bounds: {
                type: 'array',
                value: 'number',
                length: 4,
                default: [-180, -85.051129, 180, 85.051129],
                doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL.",
              },
              minzoom: {
                type: 'number',
                default: 0,
                doc: 'Minimum zoom level for which tiles are available, as in the TileJSON spec.',
              },
              maxzoom: {
                type: 'number',
                default: 22,
                doc: 'Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.',
              },
              tileSize: {
                type: 'number',
                default: 512,
                units: 'pixels',
                doc: 'The minimum visual size to display tiles for this layer. Only configurable for raster layers.',
              },
              scheme: {
                type: 'enum',
                values: {
                  xyz: { doc: 'Slippy map tilenames scheme.' },
                  tms: { doc: 'OSGeo spec scheme.' },
                },
                default: 'xyz',
                doc: 'Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed.',
              },
              attribution: {
                type: 'string',
                doc: 'Contains an attribution to be displayed when the map is shown to a user.',
              },
              volatile: {
                type: 'boolean',
                default: !1,
                doc: "A setting to determine whether a source's tiles are cached locally.",
                'sdk-support': {
                  'basic functionality': { android: '9.3.0', ios: '5.10.0' },
                },
              },
              '*': {
                type: '*',
                doc: 'Other keys to configure the data source.',
              },
            },
            source_raster_dem: {
              type: {
                required: !0,
                type: 'enum',
                values: {
                  'raster-dem': { doc: 'A RGB-encoded raster DEM source' },
                },
                doc: 'The type of the source.',
              },
              url: {
                type: 'string',
                doc: 'A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`.',
              },
              tiles: {
                type: 'array',
                value: 'string',
                doc: 'An array of one or more tile source URLs, as in the TileJSON spec.',
              },
              bounds: {
                type: 'array',
                value: 'number',
                length: 4,
                default: [-180, -85.051129, 180, 85.051129],
                doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source's bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL.",
              },
              minzoom: {
                type: 'number',
                default: 0,
                doc: 'Minimum zoom level for which tiles are available, as in the TileJSON spec.',
              },
              maxzoom: {
                type: 'number',
                default: 22,
                doc: 'Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.',
              },
              tileSize: {
                type: 'number',
                default: 512,
                units: 'pixels',
                doc: 'The minimum visual size to display tiles for this layer. Only configurable for raster layers.',
              },
              attribution: {
                type: 'string',
                doc: 'Contains an attribution to be displayed when the map is shown to a user.',
              },
              encoding: {
                type: 'enum',
                values: {
                  terrarium: {
                    doc: 'Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info.',
                  },
                  mapbox: {
                    doc: 'Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info.',
                  },
                },
                default: 'mapbox',
                doc: 'The encoding used by this source. Mapbox Terrain RGB is used by default',
              },
              volatile: {
                type: 'boolean',
                default: !1,
                doc: "A setting to determine whether a source's tiles are cached locally.",
                'sdk-support': {
                  'basic functionality': { android: '9.3.0', ios: '5.10.0' },
                },
              },
              '*': {
                type: '*',
                doc: 'Other keys to configure the data source.',
              },
            },
            source_geojson: {
              type: {
                required: !0,
                type: 'enum',
                values: { geojson: { doc: 'A GeoJSON data source.' } },
                doc: 'The data type of the GeoJSON source.',
              },
              data: {
                type: '*',
                doc: 'A URL to a GeoJSON file, or inline GeoJSON.',
              },
              maxzoom: {
                type: 'number',
                default: 18,
                doc: 'Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels).',
              },
              attribution: {
                type: 'string',
                doc: 'Contains an attribution to be displayed when the map is shown to a user.',
              },
              buffer: {
                type: 'number',
                default: 128,
                maximum: 512,
                minimum: 0,
                doc: 'Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance.',
              },
              filter: {
                type: '*',
                doc: 'An expression for filtering features prior to processing them for rendering.',
              },
              tolerance: {
                type: 'number',
                default: 0.375,
                doc: 'Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance).',
              },
              cluster: {
                type: 'boolean',
                default: !1,
                doc: 'If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\n * `cluster` Is `true` if the point is a cluster \n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\n * `point_count` Number of original points grouped into this cluster\n * `point_count_abbreviated` An abbreviated point count',
              },
              clusterRadius: {
                type: 'number',
                default: 50,
                minimum: 0,
                doc: 'Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile.',
              },
              clusterMaxZoom: {
                type: 'number',
                doc: 'Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15.',
              },
              clusterMinPoints: {
                type: 'number',
                doc: 'Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`.',
              },
              clusterProperties: {
                type: '*',
                doc: 'An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{"property_name": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `"+"` or `"max"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\n\nExample: `{"sum": ["+", ["get", "scalerank"]]}`.\n\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `["accumulated"]` value, e.g.:\n`{"sum": [["+", ["accumulated"], ["get", "sum"]], ["get", "scalerank"]]}`',
              },
              lineMetrics: {
                type: 'boolean',
                default: !1,
                doc: 'Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values.',
              },
              generateId: {
                type: 'boolean',
                default: !1,
                doc: 'Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values.',
              },
              promoteId: {
                type: 'promoteId',
                doc: 'A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`.',
              },
            },
            source_video: {
              type: {
                required: !0,
                type: 'enum',
                values: { video: { doc: 'A video data source.' } },
                doc: 'The data type of the video source.',
              },
              urls: {
                required: !0,
                type: 'array',
                value: 'string',
                doc: 'URLs to video content in order of preferred format.',
              },
              coordinates: {
                required: !0,
                doc: 'Corners of video specified in longitude, latitude pairs.',
                type: 'array',
                length: 4,
                value: {
                  type: 'array',
                  length: 2,
                  value: 'number',
                  doc: 'A single longitude, latitude pair.',
                },
              },
            },
            source_image: {
              type: {
                required: !0,
                type: 'enum',
                values: { image: { doc: 'An image data source.' } },
                doc: 'The data type of the image source.',
              },
              url: {
                required: !0,
                type: 'string',
                doc: 'URL that points to an image.',
              },
              coordinates: {
                required: !0,
                doc: 'Corners of image specified in longitude, latitude pairs.',
                type: 'array',
                length: 4,
                value: {
                  type: 'array',
                  length: 2,
                  value: 'number',
                  doc: 'A single longitude, latitude pair.',
                },
              },
            },
            layer: {
              id: { type: 'string', doc: 'Unique layer name.', required: !0 },
              type: {
                type: 'enum',
                values: {
                  fill: {
                    doc: 'A filled polygon with an optional stroked border.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.10.0',
                        android: '2.0.1',
                        ios: '2.0.0',
                        macos: '0.1.0',
                      },
                    },
                  },
                  line: {
                    doc: 'A stroked line.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.10.0',
                        android: '2.0.1',
                        ios: '2.0.0',
                        macos: '0.1.0',
                      },
                    },
                  },
                  symbol: {
                    doc: 'An icon or a text label.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.10.0',
                        android: '2.0.1',
                        ios: '2.0.0',
                        macos: '0.1.0',
                      },
                    },
                  },
                  circle: {
                    doc: 'A filled circle.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.10.0',
                        android: '2.0.1',
                        ios: '2.0.0',
                        macos: '0.1.0',
                      },
                    },
                  },
                  heatmap: {
                    doc: 'A heatmap.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.41.0',
                        android: '6.0.0',
                        ios: '4.0.0',
                        macos: '0.7.0',
                      },
                    },
                  },
                  'fill-extrusion': {
                    doc: 'An extruded (3D) polygon.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.27.0',
                        android: '5.1.0',
                        ios: '3.6.0',
                        macos: '0.5.0',
                      },
                    },
                  },
                  raster: {
                    doc: 'Raster map textures such as satellite imagery.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.10.0',
                        android: '2.0.1',
                        ios: '2.0.0',
                        macos: '0.1.0',
                      },
                    },
                  },
                  hillshade: {
                    doc: 'Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.43.0',
                        android: '6.0.0',
                        ios: '4.0.0',
                        macos: '0.7.0',
                      },
                    },
                  },
                  background: {
                    doc: 'The background color or pattern of the map.',
                    'sdk-support': {
                      'basic functionality': {
                        js: '0.10.0',
                        android: '2.0.1',
                        ios: '2.0.0',
                        macos: '0.1.0',
                      },
                    },
                  },
                  sky: {
                    doc: 'A spherical dome around the map that is always rendered behind all other layers.',
                    'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                  },
                },
                doc: 'Rendering type of this layer.',
                required: !0,
              },
              metadata: {
                type: '*',
                doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'.",
              },
              source: {
                type: 'string',
                doc: 'Name of a source description to be used for this layer. Required for all layer types except `background`.',
              },
              'source-layer': {
                type: 'string',
                doc: 'Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources.',
              },
              minzoom: {
                type: 'number',
                minimum: 0,
                maximum: 24,
                doc: 'The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden.',
              },
              maxzoom: {
                type: 'number',
                minimum: 0,
                maximum: 24,
                doc: 'The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden.',
              },
              filter: {
                type: 'filter',
                doc: 'A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions.',
              },
              layout: {
                type: 'layout',
                doc: 'Layout properties for the layer.',
              },
              paint: {
                type: 'paint',
                doc: 'Default paint properties for this layer.',
              },
            },
            layout: [
              'layout_fill',
              'layout_line',
              'layout_circle',
              'layout_heatmap',
              'layout_fill-extrusion',
              'layout_symbol',
              'layout_raster',
              'layout_hillshade',
              'layout_background',
              'layout_sky',
            ],
            layout_background: {
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            layout_sky: {
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                'property-type': 'constant',
              },
            },
            layout_fill: {
              'fill-sort-key': {
                type: 'number',
                doc: 'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
                'sdk-support': {
                  'basic functionality': {
                    js: '1.2.0',
                    android: '9.1.0',
                    ios: '5.8.0',
                    macos: '0.15.0',
                  },
                  'data-driven styling': {
                    js: '1.2.0',
                    android: '9.1.0',
                    ios: '5.8.0',
                    macos: '0.15.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            layout_circle: {
              'circle-sort-key': {
                type: 'number',
                doc: 'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
                'sdk-support': {
                  'basic functionality': {
                    js: '1.2.0',
                    android: '9.2.0',
                    ios: '5.9.0',
                    macos: '0.16.0',
                  },
                  'data-driven styling': {
                    js: '1.2.0',
                    android: '9.2.0',
                    ios: '5.9.0',
                    macos: '0.16.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            layout_heatmap: {
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.41.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            'layout_fill-extrusion': {
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            layout_line: {
              'line-cap': {
                type: 'enum',
                values: {
                  butt: {
                    doc: 'A cap with a squared-off end which is drawn to the exact endpoint of the line.',
                  },
                  round: {
                    doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
                  },
                  square: {
                    doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
                  },
                },
                default: 'butt',
                doc: 'The display of line endings.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'line-join': {
                type: 'enum',
                values: {
                  bevel: {
                    doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line's width.",
                  },
                  round: {
                    doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line's width and centered on the endpoint of the line.",
                  },
                  miter: {
                    doc: 'A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet.',
                  },
                },
                default: 'miter',
                doc: 'The display of lines when joining.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.40.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'line-miter-limit': {
                type: 'number',
                default: 2,
                doc: 'Used to automatically convert miter joins to bevel joins for sharp angles.',
                requires: [{ 'line-join': 'miter' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'line-round-limit': {
                type: 'number',
                default: 1.05,
                doc: 'Used to automatically convert round joins to miter joins for shallow angles.',
                requires: [{ 'line-join': 'round' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'line-sort-key': {
                type: 'number',
                doc: 'Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.',
                'sdk-support': {
                  'basic functionality': {
                    js: '1.2.0',
                    android: '9.1.0',
                    ios: '5.8.0',
                    macos: '0.15.0',
                  },
                  'data-driven styling': {
                    js: '1.2.0',
                    android: '9.1.0',
                    ios: '5.8.0',
                    macos: '0.15.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            layout_symbol: {
              'symbol-placement': {
                type: 'enum',
                values: {
                  point: {
                    doc: 'The label is placed at the point where the geometry is located.',
                  },
                  line: {
                    doc: 'The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries.',
                  },
                  'line-center': {
                    doc: 'The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries.',
                  },
                },
                default: 'point',
                doc: 'Label placement relative to its geometry.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  '`line-center` value': {
                    js: '0.47.0',
                    android: '6.4.0',
                    ios: '4.3.0',
                    macos: '0.10.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'symbol-spacing': {
                type: 'number',
                default: 250,
                minimum: 1,
                units: 'pixels',
                doc: 'Distance between two symbol anchors.',
                requires: [{ 'symbol-placement': 'line' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'symbol-avoid-edges': {
                type: 'boolean',
                default: !1,
                doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'symbol-sort-key': {
                type: 'number',
                doc: 'Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.53.0',
                    android: '7.4.0',
                    ios: '4.11.0',
                    macos: '0.14.0',
                  },
                  'data-driven styling': {
                    js: '0.53.0',
                    android: '7.4.0',
                    ios: '4.11.0',
                    macos: '0.14.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'symbol-z-order': {
                type: 'enum',
                values: {
                  auto: {
                    doc: 'Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.',
                  },
                  'viewport-y': {
                    doc: 'Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.',
                  },
                  source: {
                    doc: 'Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data.',
                  },
                },
                default: 'auto',
                doc: 'Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.49.0',
                    android: '6.6.0',
                    ios: '4.5.0',
                    macos: '0.12.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-allow-overlap': {
                type: 'boolean',
                default: !1,
                doc: 'If true, the icon will be visible even if it collides with other previously drawn symbols.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-ignore-placement': {
                type: 'boolean',
                default: !1,
                doc: 'If true, other symbols can be visible even if they collide with the icon.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-optional': {
                type: 'boolean',
                default: !1,
                doc: 'If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.',
                requires: ['icon-image', 'text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-rotation-alignment': {
                type: 'enum',
                values: {
                  map: {
                    doc: 'When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line.',
                  },
                  viewport: {
                    doc: 'Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.',
                  },
                  auto: {
                    doc: 'When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.',
                  },
                },
                default: 'auto',
                doc: 'In combination with `symbol-placement`, determines the rotation behavior of icons.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  '`auto` value': {
                    js: '0.25.0',
                    android: '4.2.0',
                    ios: '3.4.0',
                    macos: '0.3.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-size': {
                type: 'number',
                default: 1,
                minimum: 0,
                units: 'factor of the original icon size',
                doc: 'Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.35.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'icon-text-fit': {
                type: 'enum',
                values: {
                  none: {
                    doc: 'The icon is displayed at its intrinsic aspect ratio.',
                  },
                  width: {
                    doc: 'The icon is scaled in the x-dimension to fit the width of the text.',
                  },
                  height: {
                    doc: 'The icon is scaled in the y-dimension to fit the height of the text.',
                  },
                  both: {
                    doc: 'The icon is scaled in both x- and y-dimensions.',
                  },
                },
                default: 'none',
                doc: 'Scales the icon to fit around the associated text.',
                requires: ['icon-image', 'text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.21.0',
                    android: '4.2.0',
                    ios: '3.4.0',
                    macos: '0.2.1',
                  },
                  'stretchable icons': {
                    js: '1.6.0',
                    android: '9.2.0',
                    ios: '5.8.0',
                    macos: '0.15.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-text-fit-padding': {
                type: 'array',
                value: 'number',
                length: 4,
                default: [0, 0, 0, 0],
                units: 'pixels',
                doc: 'Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.',
                requires: [
                  'icon-image',
                  'text-field',
                  { 'icon-text-fit': ['both', 'width', 'height'] },
                ],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.21.0',
                    android: '4.2.0',
                    ios: '3.4.0',
                    macos: '0.2.1',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-image': {
                type: 'resolvedImage',
                doc: 'Name of image in sprite to use for drawing an image background.',
                tokens: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.35.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'icon-rotate': {
                type: 'number',
                default: 0,
                period: 360,
                units: 'degrees',
                doc: 'Rotates the icon clockwise.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.21.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'icon-padding': {
                type: 'number',
                default: 2,
                minimum: 0,
                units: 'pixels',
                doc: 'Size of the additional area around the icon bounding box used for detecting symbol collisions.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-keep-upright': {
                type: 'boolean',
                default: !1,
                doc: 'If true, the icon may be flipped to prevent it from being rendered upside-down.',
                requires: [
                  'icon-image',
                  { 'icon-rotation-alignment': 'map' },
                  { 'symbol-placement': ['line', 'line-center'] },
                ],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-offset': {
                type: 'array',
                value: 'number',
                length: 2,
                default: [0, 0],
                doc: 'Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'icon-anchor': {
                type: 'enum',
                values: {
                  center: {
                    doc: 'The center of the icon is placed closest to the anchor.',
                  },
                  left: {
                    doc: 'The left side of the icon is placed closest to the anchor.',
                  },
                  right: {
                    doc: 'The right side of the icon is placed closest to the anchor.',
                  },
                  top: {
                    doc: 'The top of the icon is placed closest to the anchor.',
                  },
                  bottom: {
                    doc: 'The bottom of the icon is placed closest to the anchor.',
                  },
                  'top-left': {
                    doc: 'The top left corner of the icon is placed closest to the anchor.',
                  },
                  'top-right': {
                    doc: 'The top right corner of the icon is placed closest to the anchor.',
                  },
                  'bottom-left': {
                    doc: 'The bottom left corner of the icon is placed closest to the anchor.',
                  },
                  'bottom-right': {
                    doc: 'The bottom right corner of the icon is placed closest to the anchor.',
                  },
                },
                default: 'center',
                doc: 'Part of the icon placed closest to the anchor.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.40.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                  'data-driven styling': {
                    js: '0.40.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'icon-pitch-alignment': {
                type: 'enum',
                values: {
                  map: { doc: 'The icon is aligned to the plane of the map.' },
                  viewport: {
                    doc: 'The icon is aligned to the plane of the viewport.',
                  },
                  auto: {
                    doc: 'Automatically matches the value of `icon-rotation-alignment`.',
                  },
                },
                default: 'auto',
                doc: 'Orientation of icon when map is pitched.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.39.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-pitch-alignment': {
                type: 'enum',
                values: {
                  map: { doc: 'The text is aligned to the plane of the map.' },
                  viewport: {
                    doc: 'The text is aligned to the plane of the viewport.',
                  },
                  auto: {
                    doc: 'Automatically matches the value of `text-rotation-alignment`.',
                  },
                },
                default: 'auto',
                doc: 'Orientation of text when map is pitched.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.21.0',
                    android: '4.2.0',
                    ios: '3.4.0',
                    macos: '0.2.1',
                  },
                  '`auto` value': {
                    js: '0.25.0',
                    android: '4.2.0',
                    ios: '3.4.0',
                    macos: '0.3.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-rotation-alignment': {
                type: 'enum',
                values: {
                  map: {
                    doc: 'When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line.',
                  },
                  viewport: {
                    doc: 'Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.',
                  },
                  auto: {
                    doc: 'When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.',
                  },
                },
                default: 'auto',
                doc: 'In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  '`auto` value': {
                    js: '0.25.0',
                    android: '4.2.0',
                    ios: '3.4.0',
                    macos: '0.3.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-field': {
                type: 'formatted',
                default: '',
                tokens: !0,
                doc: 'Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-font': {
                type: 'array',
                value: 'string',
                default: ['Open Sans Regular', 'Arial Unicode MS Regular'],
                doc: 'Font stack to use for displaying text.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-size': {
                type: 'number',
                default: 16,
                minimum: 0,
                units: 'pixels',
                doc: 'Font size.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.35.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-max-width': {
                type: 'number',
                default: 10,
                minimum: 0,
                units: 'ems',
                doc: 'The maximum line width for text wrapping.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.40.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-line-height': {
                type: 'number',
                default: 1.2,
                units: 'ems',
                doc: 'Text leading value for multi-line text.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-letter-spacing': {
                type: 'number',
                default: 0,
                units: 'ems',
                doc: 'Text tracking amount.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.40.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-justify': {
                type: 'enum',
                values: {
                  auto: {
                    doc: 'The text is aligned towards the anchor position.',
                  },
                  left: { doc: 'The text is aligned to the left.' },
                  center: { doc: 'The text is centered.' },
                  right: { doc: 'The text is aligned to the right.' },
                },
                default: 'center',
                doc: 'Text justification options.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.39.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                  auto: {
                    js: '0.54.0',
                    android: '7.4.0',
                    ios: '4.10.0',
                    macos: '0.14.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-radial-offset': {
                type: 'number',
                units: 'ems',
                default: 0,
                doc: "Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",
                'sdk-support': {
                  'basic functionality': {
                    js: '0.54.0',
                    android: '7.4.0',
                    ios: '4.10.0',
                    macos: '0.14.0',
                  },
                  'data-driven styling': {
                    js: '0.54.0',
                    android: '7.4.0',
                    ios: '4.10.0',
                    macos: '0.14.0',
                  },
                },
                requires: ['text-field'],
                'property-type': 'data-driven',
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
              },
              'text-variable-anchor': {
                type: 'array',
                value: 'enum',
                values: {
                  center: {
                    doc: 'The center of the text is placed closest to the anchor.',
                  },
                  left: {
                    doc: 'The left side of the text is placed closest to the anchor.',
                  },
                  right: {
                    doc: 'The right side of the text is placed closest to the anchor.',
                  },
                  top: {
                    doc: 'The top of the text is placed closest to the anchor.',
                  },
                  bottom: {
                    doc: 'The bottom of the text is placed closest to the anchor.',
                  },
                  'top-left': {
                    doc: 'The top left corner of the text is placed closest to the anchor.',
                  },
                  'top-right': {
                    doc: 'The top right corner of the text is placed closest to the anchor.',
                  },
                  'bottom-left': {
                    doc: 'The bottom left corner of the text is placed closest to the anchor.',
                  },
                  'bottom-right': {
                    doc: 'The bottom right corner of the text is placed closest to the anchor.',
                  },
                },
                requires: ['text-field', { 'symbol-placement': ['point'] }],
                doc: 'To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.54.0',
                    android: '7.4.0',
                    ios: '4.10.0',
                    macos: '0.14.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-anchor': {
                type: 'enum',
                values: {
                  center: {
                    doc: 'The center of the text is placed closest to the anchor.',
                  },
                  left: {
                    doc: 'The left side of the text is placed closest to the anchor.',
                  },
                  right: {
                    doc: 'The right side of the text is placed closest to the anchor.',
                  },
                  top: {
                    doc: 'The top of the text is placed closest to the anchor.',
                  },
                  bottom: {
                    doc: 'The bottom of the text is placed closest to the anchor.',
                  },
                  'top-left': {
                    doc: 'The top left corner of the text is placed closest to the anchor.',
                  },
                  'top-right': {
                    doc: 'The top right corner of the text is placed closest to the anchor.',
                  },
                  'bottom-left': {
                    doc: 'The bottom left corner of the text is placed closest to the anchor.',
                  },
                  'bottom-right': {
                    doc: 'The bottom right corner of the text is placed closest to the anchor.',
                  },
                },
                default: 'center',
                doc: 'Part of the text placed closest to the anchor.',
                requires: ['text-field', { '!': 'text-variable-anchor' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.39.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-max-angle': {
                type: 'number',
                default: 45,
                units: 'degrees',
                doc: 'Maximum angle change between adjacent characters.',
                requires: [
                  'text-field',
                  { 'symbol-placement': ['line', 'line-center'] },
                ],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-writing-mode': {
                type: 'array',
                value: 'enum',
                values: {
                  horizontal: {
                    doc: "If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally.",
                  },
                  vertical: {
                    doc: "If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically.",
                  },
                },
                doc: "The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",
                requires: ['text-field', { 'symbol-placement': ['point'] }],
                'sdk-support': {
                  'basic functionality': {
                    js: '1.3.0',
                    android: '8.3.0',
                    ios: '5.3.0',
                    macos: '0.15.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-rotate': {
                type: 'number',
                default: 0,
                period: 360,
                units: 'degrees',
                doc: 'Rotates the text clockwise.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.35.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-padding': {
                type: 'number',
                default: 2,
                minimum: 0,
                units: 'pixels',
                doc: 'Size of the additional area around the text bounding box used for detecting symbol collisions.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-keep-upright': {
                type: 'boolean',
                default: !0,
                doc: 'If true, the text may be flipped vertically to prevent it from being rendered upside-down.',
                requires: [
                  'text-field',
                  { 'text-rotation-alignment': 'map' },
                  { 'symbol-placement': ['line', 'line-center'] },
                ],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-transform': {
                type: 'enum',
                values: {
                  none: { doc: 'The text is not altered.' },
                  uppercase: {
                    doc: 'Forces all letters to be displayed in uppercase.',
                  },
                  lowercase: {
                    doc: 'Forces all letters to be displayed in lowercase.',
                  },
                },
                default: 'none',
                doc: 'Specifies how to capitalize text, similar to the CSS `text-transform` property.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-offset': {
                type: 'array',
                doc: 'Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.',
                value: 'number',
                units: 'ems',
                length: 2,
                default: [0, 0],
                requires: ['text-field', { '!': 'text-radial-offset' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.35.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'data-driven',
              },
              'text-allow-overlap': {
                type: 'boolean',
                default: !1,
                doc: 'If true, the text will be visible even if it collides with other previously drawn symbols.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-ignore-placement': {
                type: 'boolean',
                default: !1,
                doc: 'If true, other symbols can be visible even if they collide with the text.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-optional': {
                type: 'boolean',
                default: !1,
                doc: 'If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.',
                requires: ['text-field', 'icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            layout_raster: {
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            layout_hillshade: {
              visibility: {
                type: 'enum',
                values: {
                  visible: { doc: 'The layer is shown.' },
                  none: { doc: 'The layer is not shown.' },
                },
                default: 'visible',
                doc: 'Whether this layer is displayed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                'property-type': 'constant',
              },
            },
            filter: {
              type: 'array',
              value: '*',
              doc: 'A filter selects specific features from a layer.',
            },
            filter_operator: {
              type: 'enum',
              values: {
                '==': {
                  doc: '`["==", key, value]` equality: `feature[key] = value`',
                },
                '!=': {
                  doc: '`["!=", key, value]` inequality: `feature[key] ≠ value`',
                },
                '>': {
                  doc: '`[">", key, value]` greater than: `feature[key] > value`',
                },
                '>=': {
                  doc: '`[">=", key, value]` greater than or equal: `feature[key] ≥ value`',
                },
                '<': {
                  doc: '`["<", key, value]` less than: `feature[key] < value`',
                },
                '<=': {
                  doc: '`["<=", key, value]` less than or equal: `feature[key] ≤ value`',
                },
                in: {
                  doc: '`["in", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`',
                },
                '!in': {
                  doc: '`["!in", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`',
                },
                all: {
                  doc: '`["all", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`',
                },
                any: {
                  doc: '`["any", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`',
                },
                none: {
                  doc: '`["none", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`',
                },
                has: { doc: '`["has", key]` `feature[key]` exists' },
                '!has': {
                  doc: '`["!has", key]` `feature[key]` does not exist',
                },
                within: {
                  doc: '`["within", object]` feature geometry is within object geometry',
                },
              },
              doc: 'The filter operator.',
            },
            geometry_type: {
              type: 'enum',
              values: {
                Point: { doc: 'Filter to point geometries.' },
                LineString: { doc: 'Filter to line geometries.' },
                Polygon: { doc: 'Filter to polygon geometries.' },
              },
              doc: 'The geometry type for the filter to select.',
            },
            function: {
              expression: { type: 'expression', doc: 'An expression.' },
              stops: {
                type: 'array',
                doc: 'An array of stops.',
                value: 'function_stop',
              },
              base: {
                type: 'number',
                default: 1,
                minimum: 0,
                doc: 'The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly.',
              },
              property: {
                type: 'string',
                doc: 'The name of a feature property to use as the function input.',
                default: '$zoom',
              },
              type: {
                type: 'enum',
                values: {
                  identity: {
                    doc: 'Return the input value as the output value.',
                  },
                  exponential: {
                    doc: 'Generate an output by interpolating between stops just less than and just greater than the function input.',
                  },
                  interval: {
                    doc: 'Return the output value of the stop just less than the function input.',
                  },
                  categorical: {
                    doc: 'Return the output value of the stop equal to the function input.',
                  },
                },
                doc: 'The interpolation strategy to use in function evaluation.',
                default: 'exponential',
              },
              colorSpace: {
                type: 'enum',
                values: {
                  rgb: {
                    doc: 'Use the RGB color space to interpolate color values',
                  },
                  lab: {
                    doc: 'Use the LAB color space to interpolate color values.',
                  },
                  hcl: {
                    doc: 'Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually.',
                  },
                },
                doc: 'The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.',
                default: 'rgb',
              },
              default: {
                type: '*',
                required: !1,
                doc: "A value to serve as a fallback function result when a value isn't otherwise available. It is used in the following circumstances:\n* In categorical functions, when the feature value does not match any of the stop domain values.\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\nIf no default is provided, the style property's default is used in these circumstances.",
              },
            },
            function_stop: {
              type: 'array',
              minimum: 0,
              maximum: 24,
              value: ['number', 'color'],
              length: 2,
              doc: 'Zoom level and value pair.',
            },
            expression: {
              type: 'array',
              value: '*',
              minimum: 1,
              doc: 'An expression defines a function that can be used for data-driven style properties or feature filters.',
            },
            expression_name: {
              doc: '',
              type: 'enum',
              values: {
                let: {
                  doc: 'Binds expressions to named variables, which can then be referenced in the result expression using ["var", "variable_name"].',
                  group: 'Variable binding',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                var: {
                  doc: 'References variable bound using "let".',
                  group: 'Variable binding',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                literal: {
                  doc: 'Provides a literal array or object value.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                array: {
                  doc: 'Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                at: {
                  doc: 'Retrieves an item from an array.',
                  group: 'Lookup',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                in: {
                  doc: 'Determines whether an item exists in an array or a substring exists in a string.',
                  group: 'Lookup',
                  'sdk-support': {
                    'basic functionality': {
                      js: '1.6.0',
                      android: '9.1.0',
                      ios: '5.8.0',
                      macos: '0.15.0',
                    },
                  },
                },
                'index-of': {
                  doc: 'Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.',
                  group: 'Lookup',
                  'sdk-support': { 'basic functionality': { js: '1.10.0' } },
                },
                slice: {
                  doc: 'Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.',
                  group: 'Lookup',
                  'sdk-support': { 'basic functionality': { js: '1.10.0' } },
                },
                case: {
                  doc: 'Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                match: {
                  doc: 'Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `["get", "building_type"]`). Each label must be either:\n - a single literal value; or\n - an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `["c", "b"]`). The input matches if any of the values in the array matches, similar to the `"in"` operator.\nEach label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                coalesce: {
                  doc: 'Evaluates each expression in turn until the first non-null value is obtained, and returns that value.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                step: {
                  doc: 'Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.',
                  group: 'Ramps, scales, curves',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.42.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                interpolate: {
                  doc: 'Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\n\nInterpolation types:\n- `["linear"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\n- `["exponential", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\n- `["cubic-bezier", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.',
                  group: 'Ramps, scales, curves',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.42.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'interpolate-hcl': {
                  doc: 'Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.',
                  group: 'Ramps, scales, curves',
                  'sdk-support': { 'basic functionality': { js: '0.49.0' } },
                },
                'interpolate-lab': {
                  doc: 'Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.',
                  group: 'Ramps, scales, curves',
                  'sdk-support': { 'basic functionality': { js: '0.49.0' } },
                },
                ln2: {
                  doc: 'Returns mathematical constant ln(2).',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                pi: {
                  doc: 'Returns the mathematical constant pi.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                e: {
                  doc: 'Returns the mathematical constant e.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                typeof: {
                  doc: 'Returns a string describing the type of the given value.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                string: {
                  doc: 'Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                number: {
                  doc: 'Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                boolean: {
                  doc: 'Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                object: {
                  doc: 'Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                collator: {
                  doc: 'Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
                format: {
                  doc: 'Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`\'image\'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\n- `"text-font"`: Overrides the font stack specified by the root layout property.\n- `"text-color"`: Overrides the color specified by the root paint property.\n- `"font-scale"`: Applies a scaling factor on `text-size` as specified by the root layout property.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.48.0',
                      android: '6.7.0',
                      ios: '4.6.0',
                      macos: '0.12.0',
                    },
                    'text-font': {
                      js: '0.48.0',
                      android: '6.7.0',
                      ios: '4.6.0',
                      macos: '0.12.0',
                    },
                    'font-scale': {
                      js: '0.48.0',
                      android: '6.7.0',
                      ios: '4.6.0',
                      macos: '0.12.0',
                    },
                    'text-color': {
                      js: '1.3.0',
                      android: '7.3.0',
                      ios: '4.10.0',
                      macos: '0.14.0',
                    },
                    image: {
                      js: '1.6.0',
                      android: '8.6.0',
                      ios: '5.7.0',
                      macos: '0.15.0',
                    },
                  },
                },
                image: {
                  doc: 'Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '1.4.0',
                      android: '8.6.0',
                      ios: '5.7.0',
                      macos: '0.15.0',
                    },
                  },
                },
                'number-format': {
                  doc: 'Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.',
                  group: 'Types',
                  'sdk-support': { 'basic functionality': { js: '0.54.0' } },
                },
                'to-string': {
                  doc: 'Converts the input value to a string. If the input is `null`, the result is `""`. If the input is a boolean, the result is `"true"` or `"false"`. If the input is a number, it is converted to a string as specified by the ["NumberToString" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `"rgba(r,g,b,a)"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'to-number': {
                  doc: 'Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the ["ToNumber Applied to the String Type" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'to-boolean': {
                  doc: 'Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'to-rgba': {
                  doc: "Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.",
                  group: 'Color',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'to-color': {
                  doc: 'Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.',
                  group: 'Types',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                rgb: {
                  doc: 'Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.',
                  group: 'Color',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                rgba: {
                  doc: 'Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.',
                  group: 'Color',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                get: {
                  doc: "Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",
                  group: 'Lookup',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                has: {
                  doc: "Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.",
                  group: 'Lookup',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                length: {
                  doc: 'Gets the length of an array or string.',
                  group: 'Lookup',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                properties: {
                  doc: 'Gets the feature properties object.  Note that in some cases, it may be more efficient to use ["get", "property_name"] directly.',
                  group: 'Feature data',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'feature-state': {
                  doc: "Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\"feature-state\"] can only be used with paint properties that support data-driven styling.",
                  group: 'Feature data',
                  'sdk-support': { 'basic functionality': { js: '0.46.0' } },
                },
                'geometry-type': {
                  doc: "Gets the feature's geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`.",
                  group: 'Feature data',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                id: {
                  doc: "Gets the feature's id, if it has one.",
                  group: 'Feature data',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                zoom: {
                  doc: 'Gets the current zoom level.  Note that in style layout and paint properties, ["zoom"] may only appear as the input to a top-level "step" or "interpolate" expression.',
                  group: 'Zoom',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'heatmap-density': {
                  doc: 'Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.',
                  group: 'Heatmap',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'line-progress': {
                  doc: 'Gets the progress along a gradient line. Can only be used in the `line-gradient` property.',
                  group: 'Feature data',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.6.0',
                      macos: '0.12.0',
                    },
                  },
                },
                'sky-radial-progress': {
                  doc: 'Gets the distance of a point on the sky from the sun position. Returns 0 at sun position and 1 when the distance reaches `sky-gradient-radius`. Can only be used in the `sky-gradient` property.',
                  group: 'sky',
                  'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                },
                accumulated: {
                  doc: 'Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.',
                  group: 'Feature data',
                  'sdk-support': { 'basic functionality': { js: '0.53.0' } },
                },
                '+': {
                  doc: 'Returns the sum of the inputs.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                '*': {
                  doc: 'Returns the product of the inputs.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                '-': {
                  doc: 'For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                '/': {
                  doc: 'Returns the result of floating point division of the first input by the second.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                '%': {
                  doc: 'Returns the remainder after integer division of the first input by the second.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                '^': {
                  doc: 'Returns the result of raising the first input to the power specified by the second.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                sqrt: {
                  doc: 'Returns the square root of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.42.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                log10: {
                  doc: 'Returns the base-ten logarithm of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                ln: {
                  doc: 'Returns the natural logarithm of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                log2: {
                  doc: 'Returns the base-two logarithm of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                sin: {
                  doc: 'Returns the sine of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                cos: {
                  doc: 'Returns the cosine of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                tan: {
                  doc: 'Returns the tangent of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                asin: {
                  doc: 'Returns the arcsine of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                acos: {
                  doc: 'Returns the arccosine of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                atan: {
                  doc: 'Returns the arctangent of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                min: {
                  doc: 'Returns the minimum value of the inputs.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                max: {
                  doc: 'Returns the maximum value of the inputs.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                round: {
                  doc: 'Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `["round", -1.5]` evaluates to -2.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.45.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                abs: {
                  doc: 'Returns the absolute value of the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.45.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                ceil: {
                  doc: 'Returns the smallest integer that is greater than or equal to the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.45.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                floor: {
                  doc: 'Returns the largest integer that is less than or equal to the input.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.45.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                distance: {
                  doc: 'Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.',
                  group: 'Math',
                  'sdk-support': {
                    'basic functionality': {
                      android: '9.2.0',
                      ios: '5.9.0',
                      macos: '0.16.0',
                    },
                  },
                },
                '==': {
                  doc: 'Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                    collator: {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
                '!=': {
                  doc: 'Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                    collator: {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
                '>': {
                  doc: 'Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                    collator: {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
                '<': {
                  doc: 'Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                    collator: {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
                '>=': {
                  doc: 'Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                    collator: {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
                '<=': {
                  doc: 'Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                    collator: {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
                all: {
                  doc: 'Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                any: {
                  doc: 'Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                '!': {
                  doc: 'Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.',
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                within: {
                  doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line's endpoint is on the boundary.",
                  group: 'Decision',
                  'sdk-support': {
                    'basic functionality': {
                      js: '1.9.0',
                      android: '9.1.0',
                      ios: '5.8.0',
                      macos: '0.15.0',
                    },
                  },
                },
                'is-supported-script': {
                  doc: 'Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).',
                  group: 'String',
                  'sdk-support': {
                    'basic functionality': { js: '0.45.0', android: '6.6.0' },
                  },
                },
                upcase: {
                  doc: 'Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.',
                  group: 'String',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                downcase: {
                  doc: 'Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.',
                  group: 'String',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                concat: {
                  doc: 'Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.',
                  group: 'String',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.41.0',
                      android: '6.0.0',
                      ios: '4.0.0',
                      macos: '0.7.0',
                    },
                  },
                },
                'resolved-locale': {
                  doc: 'Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.',
                  group: 'String',
                  'sdk-support': {
                    'basic functionality': {
                      js: '0.45.0',
                      android: '6.5.0',
                      ios: '4.2.0',
                      macos: '0.9.0',
                    },
                  },
                },
              },
            },
            light: {
              anchor: {
                type: 'enum',
                default: 'viewport',
                values: {
                  map: {
                    doc: 'The position of the light source is aligned to the rotation of the map.',
                  },
                  viewport: {
                    doc: 'The position of the light source is aligned to the rotation of the viewport.',
                  },
                },
                'property-type': 'data-constant',
                transition: !1,
                expression: { interpolated: !1, parameters: ['zoom'] },
                doc: 'Whether extruded geometries are lit relative to the map or viewport.',
                example: 'map',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
              },
              position: {
                type: 'array',
                default: [1.15, 210, 30],
                length: 3,
                value: 'number',
                'property-type': 'data-constant',
                transition: !0,
                expression: { interpolated: !0, parameters: ['zoom'] },
                doc: 'Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).',
                example: [1.5, 90, 80],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
              },
              color: {
                type: 'color',
                'property-type': 'data-constant',
                default: '#ffffff',
                expression: { interpolated: !0, parameters: ['zoom'] },
                transition: !0,
                doc: 'Color tint for lighting extruded geometries.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
              },
              intensity: {
                type: 'number',
                'property-type': 'data-constant',
                default: 0.5,
                minimum: 0,
                maximum: 1,
                expression: { interpolated: !0, parameters: ['zoom'] },
                transition: !0,
                doc: 'Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
              },
            },
            terrain: {
              source: {
                type: 'string',
                doc: 'Name of a source of `raster_dem` type to be used for terrain elevation.',
                required: !0,
              },
              exaggeration: {
                type: 'number',
                'property-type': 'data-constant',
                default: 1,
                minimum: 0,
                maximum: 1e3,
                expression: { interpolated: !0, parameters: ['zoom'] },
                transition: !0,
                doc: 'Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.',
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
              },
            },
            paint: [
              'paint_fill',
              'paint_line',
              'paint_circle',
              'paint_heatmap',
              'paint_fill-extrusion',
              'paint_symbol',
              'paint_raster',
              'paint_hillshade',
              'paint_background',
              'paint_sky',
            ],
            paint_fill: {
              'fill-antialias': {
                type: 'boolean',
                default: !0,
                doc: 'Whether or not the fill should be antialiased.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'fill-opacity': {
                type: 'number',
                default: 1,
                minimum: 0,
                maximum: 1,
                doc: 'The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.21.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'fill-color': {
                type: 'color',
                default: '#000000',
                doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.",
                transition: !0,
                requires: [{ '!': 'fill-pattern' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.19.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'fill-outline-color': {
                type: 'color',
                doc: 'The outline color of the fill. Matches the value of `fill-color` if unspecified.',
                transition: !0,
                requires: [{ '!': 'fill-pattern' }, { 'fill-antialias': !0 }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.19.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'fill-translate': {
                type: 'array',
                value: 'number',
                length: 2,
                default: [0, 0],
                transition: !0,
                units: 'pixels',
                doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'fill-translate-anchor': {
                type: 'enum',
                values: {
                  map: { doc: 'The fill is translated relative to the map.' },
                  viewport: {
                    doc: 'The fill is translated relative to the viewport.',
                  },
                },
                doc: 'Controls the frame of reference for `fill-translate`.',
                default: 'map',
                requires: ['fill-translate'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'fill-pattern': {
                type: 'resolvedImage',
                transition: !0,
                doc: 'Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.49.0',
                    android: '6.5.0',
                    macos: '0.11.0',
                    ios: '4.4.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'cross-faded-data-driven',
              },
            },
            'paint_fill-extrusion': {
              'fill-extrusion-opacity': {
                type: 'number',
                default: 1,
                minimum: 0,
                maximum: 1,
                doc: 'The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'fill-extrusion-color': {
                type: 'color',
                default: '#000000',
                doc: "The base color of the extruded fill. The extrusion's surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",
                transition: !0,
                requires: [{ '!': 'fill-extrusion-pattern' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                  'data-driven styling': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'fill-extrusion-translate': {
                type: 'array',
                value: 'number',
                length: 2,
                default: [0, 0],
                transition: !0,
                units: 'pixels',
                doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'fill-extrusion-translate-anchor': {
                type: 'enum',
                values: {
                  map: {
                    doc: 'The fill extrusion is translated relative to the map.',
                  },
                  viewport: {
                    doc: 'The fill extrusion is translated relative to the viewport.',
                  },
                },
                doc: 'Controls the frame of reference for `fill-extrusion-translate`.',
                default: 'map',
                requires: ['fill-extrusion-translate'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'fill-extrusion-pattern': {
                type: 'resolvedImage',
                transition: !0,
                doc: 'Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                  'data-driven styling': {
                    js: '0.49.0',
                    android: '6.5.0',
                    macos: '0.11.0',
                    ios: '4.4.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'cross-faded-data-driven',
              },
              'fill-extrusion-height': {
                type: 'number',
                default: 0,
                minimum: 0,
                units: 'meters',
                doc: 'The height with which to extrude this layer.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                  'data-driven styling': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'fill-extrusion-base': {
                type: 'number',
                default: 0,
                minimum: 0,
                units: 'meters',
                doc: 'The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.',
                transition: !0,
                requires: ['fill-extrusion-height'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                  'data-driven styling': {
                    js: '0.27.0',
                    android: '5.1.0',
                    ios: '3.6.0',
                    macos: '0.5.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'fill-extrusion-vertical-gradient': {
                type: 'boolean',
                default: !0,
                doc: 'Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.',
                transition: !1,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.50.0',
                    ios: '4.7.0',
                    macos: '0.13.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
            },
            paint_line: {
              'line-opacity': {
                type: 'number',
                doc: 'The opacity at which the line will be drawn.',
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'line-color': {
                type: 'color',
                doc: 'The color with which the line will be drawn.',
                default: '#000000',
                transition: !0,
                requires: [{ '!': 'line-pattern' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.23.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'line-translate': {
                type: 'array',
                value: 'number',
                length: 2,
                default: [0, 0],
                transition: !0,
                units: 'pixels',
                doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'line-translate-anchor': {
                type: 'enum',
                values: {
                  map: { doc: 'The line is translated relative to the map.' },
                  viewport: {
                    doc: 'The line is translated relative to the viewport.',
                  },
                },
                doc: 'Controls the frame of reference for `line-translate`.',
                default: 'map',
                requires: ['line-translate'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'line-width': {
                type: 'number',
                default: 1,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: 'Stroke thickness.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.39.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'line-gap-width': {
                type: 'number',
                default: 0,
                minimum: 0,
                doc: "Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.",
                transition: !0,
                units: 'pixels',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'line-offset': {
                type: 'number',
                default: 0,
                doc: "The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",
                transition: !0,
                units: 'pixels',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.12.1',
                    android: '3.0.0',
                    ios: '3.1.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'line-blur': {
                type: 'number',
                default: 0,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: 'Blur applied to the line, in pixels.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'line-dasharray': {
                type: 'array',
                value: 'number',
                doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",
                minimum: 0,
                transition: !0,
                units: 'line widths',
                requires: [{ '!': 'line-pattern' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {},
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'cross-faded',
              },
              'line-pattern': {
                type: 'resolvedImage',
                transition: !0,
                doc: 'Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.49.0',
                    android: '6.5.0',
                    macos: '0.11.0',
                    ios: '4.4.0',
                  },
                },
                expression: {
                  interpolated: !1,
                  parameters: ['zoom', 'feature'],
                },
                'property-type': 'cross-faded-data-driven',
              },
              'line-gradient': {
                type: 'color',
                doc: 'Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `"lineMetrics": true`.',
                transition: !1,
                requires: [
                  { '!': 'line-dasharray' },
                  { '!': 'line-pattern' },
                  { source: 'geojson', has: { lineMetrics: !0 } },
                ],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.45.0',
                    android: '6.5.0',
                    ios: '4.4.0',
                    macos: '0.11.0',
                  },
                  'data-driven styling': {},
                },
                expression: { interpolated: !0, parameters: ['line-progress'] },
                'property-type': 'color-ramp',
              },
            },
            paint_circle: {
              'circle-radius': {
                type: 'number',
                default: 5,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: 'Circle radius.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.18.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'circle-color': {
                type: 'color',
                default: '#000000',
                doc: 'The fill color of the circle.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.18.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'circle-blur': {
                type: 'number',
                default: 0,
                doc: 'Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.20.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'circle-opacity': {
                type: 'number',
                doc: 'The opacity at which the circle will be drawn.',
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.20.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'circle-translate': {
                type: 'array',
                value: 'number',
                length: 2,
                default: [0, 0],
                transition: !0,
                units: 'pixels',
                doc: "The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.",
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'circle-translate-anchor': {
                type: 'enum',
                values: {
                  map: { doc: 'The circle is translated relative to the map.' },
                  viewport: {
                    doc: 'The circle is translated relative to the viewport.',
                  },
                },
                doc: 'Controls the frame of reference for `circle-translate`.',
                default: 'map',
                requires: ['circle-translate'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'circle-pitch-scale': {
                type: 'enum',
                values: {
                  map: {
                    doc: 'Circles are scaled according to their apparent distance to the camera.',
                  },
                  viewport: { doc: 'Circles are not scaled.' },
                },
                default: 'map',
                doc: 'Controls the scaling behavior of the circle when the map is pitched.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.21.0',
                    android: '4.2.0',
                    ios: '3.4.0',
                    macos: '0.2.1',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'circle-pitch-alignment': {
                type: 'enum',
                values: {
                  map: {
                    doc: 'The circle is aligned to the plane of the map.',
                  },
                  viewport: {
                    doc: 'The circle is aligned to the plane of the viewport.',
                  },
                },
                default: 'viewport',
                doc: 'Orientation of circle when map is pitched.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.39.0',
                    android: '5.2.0',
                    ios: '3.7.0',
                    macos: '0.6.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'circle-stroke-width': {
                type: 'number',
                default: 0,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: "The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.",
                'sdk-support': {
                  'basic functionality': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'circle-stroke-color': {
                type: 'color',
                default: '#000000',
                doc: 'The stroke color of the circle.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'circle-stroke-opacity': {
                type: 'number',
                doc: "The opacity of the circle's stroke.",
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                  'data-driven styling': {
                    js: '0.29.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
            },
            paint_heatmap: {
              'heatmap-radius': {
                type: 'number',
                default: 30,
                minimum: 1,
                transition: !0,
                units: 'pixels',
                doc: 'Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.41.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                  'data-driven styling': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'heatmap-weight': {
                type: 'number',
                default: 1,
                minimum: 0,
                transition: !1,
                doc: 'A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.41.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                  'data-driven styling': {
                    js: '0.41.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'heatmap-intensity': {
                type: 'number',
                default: 1,
                minimum: 0,
                transition: !0,
                doc: 'Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.41.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'heatmap-color': {
                type: 'color',
                default: [
                  'interpolate',
                  ['linear'],
                  ['heatmap-density'],
                  0,
                  'rgba(0, 0, 255, 0)',
                  0.1,
                  'royalblue',
                  0.3,
                  'cyan',
                  0.5,
                  'lime',
                  0.7,
                  'yellow',
                  1,
                  'red',
                ],
                doc: 'Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `["heatmap-density"]` as input.',
                transition: !1,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.41.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                  'data-driven styling': {},
                },
                expression: {
                  interpolated: !0,
                  parameters: ['heatmap-density'],
                },
                'property-type': 'color-ramp',
              },
              'heatmap-opacity': {
                type: 'number',
                doc: 'The global opacity at which the heatmap layer will be drawn.',
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.41.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
            },
            paint_symbol: {
              'icon-opacity': {
                doc: 'The opacity at which the icon will be drawn.',
                type: 'number',
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'icon-color': {
                type: 'color',
                default: '#000000',
                transition: !0,
                doc: 'The color of the icon. This can only be used with sdf icons.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'icon-halo-color': {
                type: 'color',
                default: 'rgba(0, 0, 0, 0)',
                transition: !0,
                doc: "The color of the icon's halo. Icon halos can only be used with SDF icons.",
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'icon-halo-width': {
                type: 'number',
                default: 0,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: 'Distance of halo to the icon outline.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'icon-halo-blur': {
                type: 'number',
                default: 0,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: 'Fade out the halo towards the outside.',
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'icon-translate': {
                type: 'array',
                value: 'number',
                length: 2,
                default: [0, 0],
                transition: !0,
                units: 'pixels',
                doc: "Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
                requires: ['icon-image'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'icon-translate-anchor': {
                type: 'enum',
                values: {
                  map: { doc: 'Icons are translated relative to the map.' },
                  viewport: {
                    doc: 'Icons are translated relative to the viewport.',
                  },
                },
                doc: 'Controls the frame of reference for `icon-translate`.',
                default: 'map',
                requires: ['icon-image', 'icon-translate'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-opacity': {
                type: 'number',
                doc: 'The opacity at which the text will be drawn.',
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'text-color': {
                type: 'color',
                doc: 'The color with which the text will be drawn.',
                default: '#000000',
                transition: !0,
                overridable: !0,
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'text-halo-color': {
                type: 'color',
                default: 'rgba(0, 0, 0, 0)',
                transition: !0,
                doc: "The color of the text's halo, which helps it stand out from backgrounds.",
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'text-halo-width': {
                type: 'number',
                default: 0,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: 'Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.',
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'text-halo-blur': {
                type: 'number',
                default: 0,
                minimum: 0,
                transition: !0,
                units: 'pixels',
                doc: "The halo's fadeout distance towards the outside.",
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {
                    js: '0.33.0',
                    android: '5.0.0',
                    ios: '3.5.0',
                    macos: '0.4.0',
                  },
                },
                expression: {
                  interpolated: !0,
                  parameters: ['zoom', 'feature', 'feature-state'],
                },
                'property-type': 'data-driven',
              },
              'text-translate': {
                type: 'array',
                value: 'number',
                length: 2,
                default: [0, 0],
                transition: !0,
                units: 'pixels',
                doc: "Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",
                requires: ['text-field'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'text-translate-anchor': {
                type: 'enum',
                values: {
                  map: { doc: 'The text is translated relative to the map.' },
                  viewport: {
                    doc: 'The text is translated relative to the viewport.',
                  },
                },
                doc: 'Controls the frame of reference for `text-translate`.',
                default: 'map',
                requires: ['text-field', 'text-translate'],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
            },
            paint_raster: {
              'raster-opacity': {
                type: 'number',
                doc: 'The opacity at which the image will be drawn.',
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'raster-hue-rotate': {
                type: 'number',
                default: 0,
                period: 360,
                transition: !0,
                units: 'degrees',
                doc: 'Rotates hues around the color wheel.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'raster-brightness-min': {
                type: 'number',
                doc: 'Increase or reduce the brightness of the image. The value is the minimum brightness.',
                default: 0,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'raster-brightness-max': {
                type: 'number',
                doc: 'Increase or reduce the brightness of the image. The value is the maximum brightness.',
                default: 1,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'raster-saturation': {
                type: 'number',
                doc: 'Increase or reduce the saturation of the image.',
                default: 0,
                minimum: -1,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'raster-contrast': {
                type: 'number',
                doc: 'Increase or reduce the contrast of the image.',
                default: 0,
                minimum: -1,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'raster-resampling': {
                type: 'enum',
                doc: 'The resampling/interpolation method to use for overscaling, also known as texture magnification filter',
                values: {
                  linear: {
                    doc: '(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled',
                  },
                  nearest: {
                    doc: 'Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled',
                  },
                },
                default: 'linear',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.47.0',
                    android: '6.3.0',
                    ios: '4.2.0',
                    macos: '0.9.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'raster-fade-duration': {
                type: 'number',
                default: 300,
                minimum: 0,
                transition: !1,
                units: 'milliseconds',
                doc: 'Fade duration when a new tile is added.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
            },
            paint_hillshade: {
              'hillshade-illumination-direction': {
                type: 'number',
                default: 335,
                minimum: 0,
                maximum: 359,
                doc: 'The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.',
                transition: !1,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'hillshade-illumination-anchor': {
                type: 'enum',
                values: {
                  map: {
                    doc: 'The hillshade illumination is relative to the north direction.',
                  },
                  viewport: {
                    doc: 'The hillshade illumination is relative to the top of the viewport.',
                  },
                },
                default: 'viewport',
                doc: 'Direction of light source when map is rotated.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'hillshade-exaggeration': {
                type: 'number',
                doc: 'Intensity of the hillshade',
                default: 0.5,
                minimum: 0,
                maximum: 1,
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'hillshade-shadow-color': {
                type: 'color',
                default: '#000000',
                doc: 'The shading color of areas that face away from the light source.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'hillshade-highlight-color': {
                type: 'color',
                default: '#FFFFFF',
                doc: 'The shading color of areas that faces towards the light source.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'hillshade-accent-color': {
                type: 'color',
                default: '#000000',
                doc: 'The shading color used to accentuate rugged terrain like sharp cliffs and gorges.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.43.0',
                    android: '6.0.0',
                    ios: '4.0.0',
                    macos: '0.7.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
            },
            paint_background: {
              'background-color': {
                type: 'color',
                default: '#000000',
                doc: 'The color with which the background will be drawn.',
                transition: !0,
                requires: [{ '!': 'background-pattern' }],
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'background-pattern': {
                type: 'resolvedImage',
                transition: !0,
                doc: 'Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.',
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                  'data-driven styling': {},
                },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'cross-faded',
              },
              'background-opacity': {
                type: 'number',
                default: 1,
                minimum: 0,
                maximum: 1,
                doc: 'The opacity at which the background will be drawn.',
                transition: !0,
                'sdk-support': {
                  'basic functionality': {
                    js: '0.10.0',
                    android: '2.0.1',
                    ios: '2.0.0',
                    macos: '0.1.0',
                  },
                },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
            },
            paint_sky: {
              'sky-type': {
                type: 'enum',
                values: {
                  gradient: {
                    doc: 'Renders the sky with a gradient that can be configured with `sky-gradient-radius` and `sky-gradient`.',
                  },
                  atmosphere: {
                    doc: 'Renders the sky with a simulated atmospheric scattering algorithm, the sun direction can be attached to the light position or explicitly set through `sky-atmosphere-sun`.',
                  },
                },
                default: 'atmosphere',
                doc: 'The type of the sky',
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'sky-atmosphere-sun': {
                type: 'array',
                value: 'number',
                length: 2,
                units: 'degrees',
                minimum: [0, 0],
                maximum: [360, 180],
                transition: !1,
                doc: 'Position of the sun center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the sun relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the sun, where 0° is directly above, at zenith, and 90° at the horizon. When this property is ommitted, the sun center is directly inherited from the light position.',
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                requires: [{ 'sky-type': 'atmosphere' }],
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'sky-atmosphere-sun-intensity': {
                type: 'number',
                requires: [{ 'sky-type': 'atmosphere' }],
                default: 10,
                minimum: 0,
                maximum: 100,
                transition: !1,
                doc: 'Intensity of the sun as a light source in the atmosphere (on a scale from 0 to a 100). Setting higher values will brighten up the sky.',
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                'property-type': 'data-constant',
              },
              'sky-gradient-center': {
                type: 'array',
                requires: [{ 'sky-type': 'gradient' }],
                value: 'number',
                default: [0, 0],
                length: 2,
                units: 'degrees',
                minimum: [0, 0],
                maximum: [360, 180],
                transition: !1,
                doc: 'Position of the gradient center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the gradient center relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the gradient center, where 0° is directly above, at zenith, and 90° at the horizon.',
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'sky-gradient-radius': {
                type: 'number',
                requires: [{ 'sky-type': 'gradient' }],
                default: 90,
                minimum: 0,
                maximum: 180,
                transition: !1,
                doc: 'The angular distance (measured in degrees) from `sky-gradient-center` up to which the gradient extends. A value of 180 causes the gradient to wrap around to the opposite direction from `sky-gradient-center`.',
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                expression: { interpolated: !1, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
              'sky-gradient': {
                type: 'color',
                default: [
                  'interpolate',
                  ['linear'],
                  ['sky-radial-progress'],
                  0.8,
                  '#87ceeb',
                  1,
                  'white',
                ],
                doc: 'Defines a radial color gradient with which to color the sky. The color values can be interpolated with an expression using `sky-radial-progress`. The range [0, 1] for the interpolant covers a radial distance (in degrees) of [0, `sky-gradient-radius`] centered at the position specified by `sky-gradient-center`.',
                transition: !1,
                requires: [{ 'sky-type': 'gradient' }],
                'sdk-support': {
                  'basic functionality': { js: '2.0.0' },
                  'data-driven styling': {},
                },
                expression: {
                  interpolated: !0,
                  parameters: ['sky-radial-progress'],
                },
                'property-type': 'color-ramp',
              },
              'sky-atmosphere-halo-color': {
                type: 'color',
                default: 'white',
                doc: 'A color applied to the atmosphere sun halo. The alpha channel describes how strongly the sun halo is represented in an atmosphere sky layer.',
                transition: !1,
                requires: [{ 'sky-type': 'atmosphere' }],
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                'property-type': 'data-constant',
              },
              'sky-atmosphere-color': {
                type: 'color',
                default: 'white',
                doc: 'A color used to tweak the main atmospheric scattering coefficients. Using white applies the default coefficients giving the natural blue color to the atmosphere. This color affects how heavily the corresponding wavelength is represented during scattering. The alpha channel describes the density of the atmosphere, with 1 maximum density and 0 no density.',
                transition: !1,
                requires: [{ 'sky-type': 'atmosphere' }],
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                'property-type': 'data-constant',
              },
              'sky-opacity': {
                type: 'number',
                default: 1,
                minimum: 0,
                maximum: 1,
                doc: 'The opacity of the entire sky layer.',
                transition: !0,
                'sdk-support': { 'basic functionality': { js: '2.0.0' } },
                expression: { interpolated: !0, parameters: ['zoom'] },
                'property-type': 'data-constant',
              },
            },
            transition: {
              duration: {
                type: 'number',
                default: 300,
                minimum: 0,
                units: 'milliseconds',
                doc: 'Time allotted for transitions to complete.',
              },
              delay: {
                type: 'number',
                default: 0,
                minimum: 0,
                units: 'milliseconds',
                doc: 'Length of time before a transition begins.',
              },
            },
            'property-type': {
              'data-driven': {
                type: 'property-type',
                doc: 'Property is interpolable and can be represented using a property expression.',
              },
              'cross-faded': {
                type: 'property-type',
                doc: 'Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms.',
              },
              'cross-faded-data-driven': {
                type: 'property-type',
                doc: 'Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression.',
              },
              'color-ramp': {
                type: 'property-type',
                doc: 'Property should be specified using a color ramp from which the output color can be sampled based on a property calculation.',
              },
              'data-constant': {
                type: 'property-type',
                doc: 'Property is interpolable but cannot be represented using a property expression.',
              },
              constant: {
                type: 'property-type',
                doc: 'Property is constant across all zoom levels and property values.',
              },
            },
            promoteId: {
              '*': {
                type: 'string',
                doc: 'A name of a feature property to use as ID for feature state.',
              },
            },
          };
          var r =
            'undefined' != typeof globalThis
              ? globalThis
              : 'undefined' != typeof window
              ? window
              : void 0 !== t
              ? t
              : 'undefined' != typeof self
              ? self
              : {};
          function a() {
            throw new Error(
              'Dynamic requires are not currently supported by rollup-plugin-commonjs',
            );
          }
          function o(t, e) {
            return t((e = { exports: {} }), e.exports), e.exports;
          }
          var s = o(function (t, e) {
              !(function (n) {
                var i = e && !e.nodeType && e,
                  a = t && !t.nodeType && t,
                  o = 'object' == typeof r && r;
                (o.global !== o && o.window !== o && o.self !== o) || (n = o);
                var s,
                  l,
                  c = 2147483647,
                  u = /^xn--/,
                  h = /[^\x20-\x7E]/,
                  d = /[\x2E\u3002\uFF0E\uFF61]/g,
                  p = {
                    overflow: 'Overflow: input needs wider integers to process',
                    'not-basic':
                      'Illegal input >= 0x80 (not a basic code point)',
                    'invalid-input': 'Invalid input',
                  },
                  f = Math.floor,
                  m = String.fromCharCode;
                function g(t) {
                  throw RangeError(p[t]);
                }
                function y(t, e) {
                  for (var n = t.length, i = []; n--; ) i[n] = e(t[n]);
                  return i;
                }
                function v(t, e) {
                  var n = t.split('@'),
                    i = '';
                  return (
                    n.length > 1 && ((i = n[0] + '@'), (t = n[1])),
                    i + y((t = t.replace(d, '.')).split('.'), e).join('.')
                  );
                }
                function x(t) {
                  for (var e, n, i = [], r = 0, a = t.length; r < a; )
                    (e = t.charCodeAt(r++)) >= 55296 && e <= 56319 && r < a
                      ? 56320 == (64512 & (n = t.charCodeAt(r++)))
                        ? i.push(((1023 & e) << 10) + (1023 & n) + 65536)
                        : (i.push(e), r--)
                      : i.push(e);
                  return i;
                }
                function b(t) {
                  return y(t, function (t) {
                    var e = '';
                    return (
                      t > 65535 &&
                        ((e += m((((t -= 65536) >>> 10) & 1023) | 55296)),
                        (t = 56320 | (1023 & t))),
                      (e += m(t))
                    );
                  }).join('');
                }
                function _(t, e) {
                  return t + 22 + 75 * (t < 26) - ((0 != e) << 5);
                }
                function w(t, e, n) {
                  var i = 0;
                  for (
                    t = n ? f(t / 700) : t >> 1, t += f(t / e);
                    t > 455;
                    i += 36
                  )
                    t = f(t / 35);
                  return f(i + (36 * t) / (t + 38));
                }
                function M(t) {
                  var e,
                    n,
                    i,
                    r,
                    a,
                    o,
                    s,
                    l,
                    u,
                    h,
                    d,
                    p = [],
                    m = t.length,
                    y = 0,
                    v = 128,
                    x = 72;
                  for (
                    (n = t.lastIndexOf('-')) < 0 && (n = 0), i = 0;
                    i < n;
                    ++i
                  )
                    t.charCodeAt(i) >= 128 && g('not-basic'),
                      p.push(t.charCodeAt(i));
                  for (r = n > 0 ? n + 1 : 0; r < m; ) {
                    for (
                      a = y, o = 1, s = 36;
                      r >= m && g('invalid-input'),
                        ((l =
                          (d = t.charCodeAt(r++)) - 48 < 10
                            ? d - 22
                            : d - 65 < 26
                            ? d - 65
                            : d - 97 < 26
                            ? d - 97
                            : 36) >= 36 ||
                          l > f((c - y) / o)) &&
                          g('overflow'),
                        (y += l * o),
                        !(l < (u = s <= x ? 1 : s >= x + 26 ? 26 : s - x));
                      s += 36
                    )
                      o > f(c / (h = 36 - u)) && g('overflow'), (o *= h);
                    (x = w(y - a, (e = p.length + 1), 0 == a)),
                      f(y / e) > c - v && g('overflow'),
                      (v += f(y / e)),
                      (y %= e),
                      p.splice(y++, 0, v);
                  }
                  return b(p);
                }
                function q(t) {
                  var e,
                    n,
                    i,
                    r,
                    a,
                    o,
                    s,
                    l,
                    u,
                    h,
                    d,
                    p,
                    y,
                    v,
                    b,
                    M = [];
                  for (
                    p = (t = x(t)).length, e = 128, n = 0, a = 72, o = 0;
                    o < p;
                    ++o
                  )
                    (d = t[o]) < 128 && M.push(m(d));
                  for (i = r = M.length, r && M.push('-'); i < p; ) {
                    for (s = c, o = 0; o < p; ++o)
                      (d = t[o]) >= e && d < s && (s = d);
                    for (
                      s - e > f((c - n) / (y = i + 1)) && g('overflow'),
                        n += (s - e) * y,
                        e = s,
                        o = 0;
                      o < p;
                      ++o
                    )
                      if (
                        ((d = t[o]) < e && ++n > c && g('overflow'), d == e)
                      ) {
                        for (
                          l = n, u = 36;
                          !(l < (h = u <= a ? 1 : u >= a + 26 ? 26 : u - a));
                          u += 36
                        )
                          (b = l - h),
                            (v = 36 - h),
                            M.push(m(_(h + (b % v), 0))),
                            (l = f(b / v));
                        M.push(m(_(l, 0))), (a = w(n, y, i == r)), (n = 0), ++i;
                      }
                    ++n, ++e;
                  }
                  return M.join('');
                }
                if (
                  ((s = {
                    version: '1.3.2',
                    ucs2: { decode: x, encode: b },
                    decode: M,
                    encode: q,
                    toASCII: function (t) {
                      return v(t, function (t) {
                        return h.test(t) ? 'xn--' + q(t) : t;
                      });
                    },
                    toUnicode: function (t) {
                      return v(t, function (t) {
                        return u.test(t) ? M(t.slice(4).toLowerCase()) : t;
                      });
                    },
                  }),
                  i && a)
                )
                  if (t.exports == i) a.exports = s;
                  else for (l in s) s.hasOwnProperty(l) && (i[l] = s[l]);
                else n.punycode = s;
              })(r);
            }),
            l = function (t) {
              return 'string' == typeof t;
            },
            c = function (t) {
              return 'object' == typeof t && null !== t;
            },
            u = function (t) {
              return null === t;
            },
            h = function (t) {
              return null == t;
            };
          function d(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
          }
          var p = function (t, e, n, i) {
              (e = e || '&'), (n = n || '=');
              var r = {};
              if ('string' != typeof t || 0 === t.length) return r;
              var a = /\+/g;
              t = t.split(e);
              var o = 1e3;
              i && 'number' == typeof i.maxKeys && (o = i.maxKeys);
              var s = t.length;
              o > 0 && s > o && (s = o);
              for (var l = 0; l < s; ++l) {
                var c,
                  u,
                  h,
                  p,
                  f = t[l].replace(a, '%20'),
                  m = f.indexOf(n);
                m >= 0
                  ? ((c = f.substr(0, m)), (u = f.substr(m + 1)))
                  : ((c = f), (u = '')),
                  (h = decodeURIComponent(c)),
                  (p = decodeURIComponent(u)),
                  d(r, h)
                    ? Array.isArray(r[h])
                      ? r[h].push(p)
                      : (r[h] = [r[h], p])
                    : (r[h] = p);
              }
              return r;
            },
            f = function (t) {
              switch (typeof t) {
                case 'string':
                  return t;
                case 'boolean':
                  return t ? 'true' : 'false';
                case 'number':
                  return isFinite(t) ? t : '';
                default:
                  return '';
              }
            },
            m = function (t, e, n, i) {
              return (
                (e = e || '&'),
                (n = n || '='),
                null === t && (t = void 0),
                'object' == typeof t
                  ? Object.keys(t)
                      .map(function (i) {
                        var r = encodeURIComponent(f(i)) + n;
                        return Array.isArray(t[i])
                          ? t[i]
                              .map(function (t) {
                                return r + encodeURIComponent(f(t));
                              })
                              .join(e)
                          : r + encodeURIComponent(f(t[i]));
                      })
                      .join(e)
                  : i
                  ? encodeURIComponent(f(i)) + n + encodeURIComponent(f(t))
                  : ''
              );
            },
            g = o(function (t, e) {
              (e.decode = e.parse = p), (e.encode = e.stringify = m);
            });
          g.decode, g.parse, g.encode, g.stringify;
          function y() {
            (this.protocol = null),
              (this.slashes = null),
              (this.auth = null),
              (this.host = null),
              (this.port = null),
              (this.hostname = null),
              (this.hash = null),
              (this.search = null),
              (this.query = null),
              (this.pathname = null),
              (this.path = null),
              (this.href = null);
          }
          var v = /^([a-z0-9.+-]+:)/i,
            x = /:[0-9]*$/,
            b = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
            _ = ['{', '}', '|', '\\', '^', '`'].concat([
              '<',
              '>',
              '"',
              '`',
              ' ',
              '\r',
              '\n',
              '\t',
            ]),
            w = ["'"].concat(_),
            M = ['%', '/', '?', ';', '#'].concat(w),
            q = ['/', '?', '#'],
            S = /^[+a-z0-9A-Z_-]{0,63}$/,
            T = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
            E = { javascript: !0, 'javascript:': !0 },
            A = { javascript: !0, 'javascript:': !0 },
            L = {
              http: !0,
              https: !0,
              ftp: !0,
              gopher: !0,
              file: !0,
              'http:': !0,
              'https:': !0,
              'ftp:': !0,
              'gopher:': !0,
              'file:': !0,
            };
          function R(t, e, n) {
            if (t && c(t) && t instanceof y) return t;
            var i = new y();
            return i.parse(t, e, n), i;
          }
          (y.prototype.parse = function (t, e, n) {
            if (!l(t))
              throw new TypeError(
                "Parameter 'url' must be a string, not " + typeof t,
              );
            var i = t.indexOf('?'),
              r = -1 !== i && i < t.indexOf('#') ? '?' : '#',
              a = t.split(r);
            a[0] = a[0].replace(/\\/g, '/');
            var o = (t = a.join(r));
            if (((o = o.trim()), !n && 1 === t.split('#').length)) {
              var c = b.exec(o);
              if (c)
                return (
                  (this.path = o),
                  (this.href = o),
                  (this.pathname = c[1]),
                  c[2]
                    ? ((this.search = c[2]),
                      (this.query = e
                        ? g.parse(this.search.substr(1))
                        : this.search.substr(1)))
                    : e && ((this.search = ''), (this.query = {})),
                  this
                );
            }
            var u = v.exec(o);
            if (u) {
              var h = (u = u[0]).toLowerCase();
              (this.protocol = h), (o = o.substr(u.length));
            }
            if (n || u || o.match(/^\/\/[^@\/]+@[^@\/]+/)) {
              var d = '//' === o.substr(0, 2);
              !d || (u && A[u]) || ((o = o.substr(2)), (this.slashes = !0));
            }
            if (!A[u] && (d || (u && !L[u]))) {
              for (var p, f, m = -1, y = 0; y < q.length; y++) {
                -1 !== (x = o.indexOf(q[y])) && (-1 === m || x < m) && (m = x);
              }
              -1 !==
                (f = -1 === m ? o.lastIndexOf('@') : o.lastIndexOf('@', m)) &&
                ((p = o.slice(0, f)),
                (o = o.slice(f + 1)),
                (this.auth = decodeURIComponent(p))),
                (m = -1);
              for (y = 0; y < M.length; y++) {
                var x;
                -1 !== (x = o.indexOf(M[y])) && (-1 === m || x < m) && (m = x);
              }
              -1 === m && (m = o.length),
                (this.host = o.slice(0, m)),
                (o = o.slice(m)),
                this.parseHost(),
                (this.hostname = this.hostname || '');
              var _ =
                '[' === this.hostname[0] &&
                ']' === this.hostname[this.hostname.length - 1];
              if (!_)
                for (
                  var R = this.hostname.split(/\./), C = ((y = 0), R.length);
                  y < C;
                  y++
                ) {
                  var P = R[y];
                  if (P && !P.match(S)) {
                    for (var k = '', I = 0, D = P.length; I < D; I++)
                      P.charCodeAt(I) > 127 ? (k += 'x') : (k += P[I]);
                    if (!k.match(S)) {
                      var O = R.slice(0, y),
                        N = R.slice(y + 1),
                        z = P.match(T);
                      z && (O.push(z[1]), N.unshift(z[2])),
                        N.length && (o = '/' + N.join('.') + o),
                        (this.hostname = O.join('.'));
                      break;
                    }
                  }
                }
              this.hostname.length > 255
                ? (this.hostname = '')
                : (this.hostname = this.hostname.toLowerCase()),
                _ || (this.hostname = s.toASCII(this.hostname));
              var F = this.port ? ':' + this.port : '',
                B = this.hostname || '';
              (this.host = B + F),
                (this.href += this.host),
                _ &&
                  ((this.hostname = this.hostname.substr(
                    1,
                    this.hostname.length - 2,
                  )),
                  '/' !== o[0] && (o = '/' + o));
            }
            if (!E[h])
              for (y = 0, C = w.length; y < C; y++) {
                var U = w[y];
                if (-1 !== o.indexOf(U)) {
                  var j = encodeURIComponent(U);
                  j === U && (j = escape(U)), (o = o.split(U).join(j));
                }
              }
            var G = o.indexOf('#');
            -1 !== G && ((this.hash = o.substr(G)), (o = o.slice(0, G)));
            var H = o.indexOf('?');
            if (
              (-1 !== H
                ? ((this.search = o.substr(H)),
                  (this.query = o.substr(H + 1)),
                  e && (this.query = g.parse(this.query)),
                  (o = o.slice(0, H)))
                : e && ((this.search = ''), (this.query = {})),
              o && (this.pathname = o),
              L[h] && this.hostname && !this.pathname && (this.pathname = '/'),
              this.pathname || this.search)
            ) {
              F = this.pathname || '';
              var V = this.search || '';
              this.path = F + V;
            }
            return (this.href = this.format()), this;
          }),
            (y.prototype.format = function () {
              var t = this.auth || '';
              t &&
                ((t = (t = encodeURIComponent(t)).replace(/%3A/i, ':')),
                (t += '@'));
              var e = this.protocol || '',
                n = this.pathname || '',
                i = this.hash || '',
                r = !1,
                a = '';
              this.host
                ? (r = t + this.host)
                : this.hostname &&
                  ((r =
                    t +
                    (-1 === this.hostname.indexOf(':')
                      ? this.hostname
                      : '[' + this.hostname + ']')),
                  this.port && (r += ':' + this.port)),
                this.query &&
                  c(this.query) &&
                  Object.keys(this.query).length &&
                  (a = g.stringify(this.query));
              var o = this.search || (a && '?' + a) || '';
              return (
                e && ':' !== e.substr(-1) && (e += ':'),
                this.slashes || ((!e || L[e]) && !1 !== r)
                  ? ((r = '//' + (r || '')),
                    n && '/' !== n.charAt(0) && (n = '/' + n))
                  : r || (r = ''),
                i && '#' !== i.charAt(0) && (i = '#' + i),
                o && '?' !== o.charAt(0) && (o = '?' + o),
                e +
                  r +
                  (n = n.replace(/[?#]/g, function (t) {
                    return encodeURIComponent(t);
                  })) +
                  (o = o.replace('#', '%23')) +
                  i
              );
            }),
            (y.prototype.resolve = function (t) {
              return this.resolveObject(R(t, !1, !0)).format();
            }),
            (y.prototype.resolveObject = function (t) {
              if (l(t)) {
                var e = new y();
                e.parse(t, !1, !0), (t = e);
              }
              for (
                var n = new y(), i = Object.keys(this), r = 0;
                r < i.length;
                r++
              ) {
                var a = i[r];
                n[a] = this[a];
              }
              if (((n.hash = t.hash), '' === t.href))
                return (n.href = n.format()), n;
              if (t.slashes && !t.protocol) {
                for (var o = Object.keys(t), s = 0; s < o.length; s++) {
                  var c = o[s];
                  'protocol' !== c && (n[c] = t[c]);
                }
                return (
                  L[n.protocol] &&
                    n.hostname &&
                    !n.pathname &&
                    (n.path = n.pathname = '/'),
                  (n.href = n.format()),
                  n
                );
              }
              if (t.protocol && t.protocol !== n.protocol) {
                if (!L[t.protocol]) {
                  for (var d = Object.keys(t), p = 0; p < d.length; p++) {
                    var f = d[p];
                    n[f] = t[f];
                  }
                  return (n.href = n.format()), n;
                }
                if (((n.protocol = t.protocol), t.host || A[t.protocol]))
                  n.pathname = t.pathname;
                else {
                  for (
                    var m = (t.pathname || '').split('/');
                    m.length && !(t.host = m.shift());

                  );
                  t.host || (t.host = ''),
                    t.hostname || (t.hostname = ''),
                    '' !== m[0] && m.unshift(''),
                    m.length < 2 && m.unshift(''),
                    (n.pathname = m.join('/'));
                }
                if (
                  ((n.search = t.search),
                  (n.query = t.query),
                  (n.host = t.host || ''),
                  (n.auth = t.auth),
                  (n.hostname = t.hostname || t.host),
                  (n.port = t.port),
                  n.pathname || n.search)
                ) {
                  var g = n.pathname || '',
                    v = n.search || '';
                  n.path = g + v;
                }
                return (
                  (n.slashes = n.slashes || t.slashes), (n.href = n.format()), n
                );
              }
              var x = n.pathname && '/' === n.pathname.charAt(0),
                b = t.host || (t.pathname && '/' === t.pathname.charAt(0)),
                _ = b || x || (n.host && t.pathname),
                w = _,
                M = (n.pathname && n.pathname.split('/')) || [],
                q =
                  ((m = (t.pathname && t.pathname.split('/')) || []),
                  n.protocol && !L[n.protocol]);
              if (
                (q &&
                  ((n.hostname = ''),
                  (n.port = null),
                  n.host && ('' === M[0] ? (M[0] = n.host) : M.unshift(n.host)),
                  (n.host = ''),
                  t.protocol &&
                    ((t.hostname = null),
                    (t.port = null),
                    t.host &&
                      ('' === m[0] ? (m[0] = t.host) : m.unshift(t.host)),
                    (t.host = null)),
                  (_ = _ && ('' === m[0] || '' === M[0]))),
                b)
              )
                (n.host = t.host || '' === t.host ? t.host : n.host),
                  (n.hostname =
                    t.hostname || '' === t.hostname ? t.hostname : n.hostname),
                  (n.search = t.search),
                  (n.query = t.query),
                  (M = m);
              else if (m.length)
                M || (M = []),
                  M.pop(),
                  (M = M.concat(m)),
                  (n.search = t.search),
                  (n.query = t.query);
              else if (!h(t.search)) {
                if (q)
                  (n.hostname = n.host = M.shift()),
                    (C =
                      !!(n.host && n.host.indexOf('@') > 0) &&
                      n.host.split('@')) &&
                      ((n.auth = C.shift()), (n.host = n.hostname = C.shift()));
                return (
                  (n.search = t.search),
                  (n.query = t.query),
                  (u(n.pathname) && u(n.search)) ||
                    (n.path =
                      (n.pathname ? n.pathname : '') +
                      (n.search ? n.search : '')),
                  (n.href = n.format()),
                  n
                );
              }
              if (!M.length)
                return (
                  (n.pathname = null),
                  n.search ? (n.path = '/' + n.search) : (n.path = null),
                  (n.href = n.format()),
                  n
                );
              for (
                var S = M.slice(-1)[0],
                  T =
                    ((n.host || t.host || M.length > 1) &&
                      ('.' === S || '..' === S)) ||
                    '' === S,
                  E = 0,
                  R = M.length;
                R >= 0;
                R--
              )
                '.' === (S = M[R])
                  ? M.splice(R, 1)
                  : '..' === S
                  ? (M.splice(R, 1), E++)
                  : E && (M.splice(R, 1), E--);
              if (!_ && !w) for (; E--; E) M.unshift('..');
              !_ ||
                '' === M[0] ||
                (M[0] && '/' === M[0].charAt(0)) ||
                M.unshift(''),
                T && '/' !== M.join('/').substr(-1) && M.push('');
              var C,
                P = '' === M[0] || (M[0] && '/' === M[0].charAt(0));
              q &&
                ((n.hostname = n.host = P ? '' : M.length ? M.shift() : ''),
                (C =
                  !!(n.host && n.host.indexOf('@') > 0) && n.host.split('@')) &&
                  ((n.auth = C.shift()), (n.host = n.hostname = C.shift())));
              return (
                (_ = _ || (n.host && M.length)) && !P && M.unshift(''),
                M.length
                  ? (n.pathname = M.join('/'))
                  : ((n.pathname = null), (n.path = null)),
                (u(n.pathname) && u(n.search)) ||
                  (n.path =
                    (n.pathname ? n.pathname : '') +
                    (n.search ? n.search : '')),
                (n.auth = t.auth || n.auth),
                (n.slashes = n.slashes || t.slashes),
                (n.href = n.format()),
                n
              );
            }),
            (y.prototype.parseHost = function () {
              var t = this.host,
                e = x.exec(t);
              e &&
                (':' !== (e = e[0]) && (this.port = e.substr(1)),
                (t = t.substr(0, t.length - e.length))),
                t && (this.hostname = t);
            });
          function C(t, ...e) {
            for (const n of e) for (const e in n) t[e] = n[e];
            return t;
          }
          class P extends Error {
            constructor(t, e) {
              super(e), (this.message = e), (this.key = t);
            }
          }
          class k {
            constructor(t, e = []) {
              (this.parent = t), (this.bindings = {});
              for (const [t, n] of e) this.bindings[t] = n;
            }
            concat(t) {
              return new k(this, t);
            }
            get(t) {
              if (this.bindings[t]) return this.bindings[t];
              if (this.parent) return this.parent.get(t);
              throw new Error(t + ' not found in scope.');
            }
            has(t) {
              return (
                !!this.bindings[t] || (!!this.parent && this.parent.has(t))
              );
            }
          }
          const I = { kind: 'null' },
            D = { kind: 'number' },
            O = { kind: 'string' },
            N = { kind: 'boolean' },
            z = { kind: 'color' },
            F = { kind: 'object' },
            B = { kind: 'value' },
            U = { kind: 'collator' },
            j = { kind: 'formatted' },
            G = { kind: 'resolvedImage' };
          function H(t, e) {
            return { kind: 'array', itemType: t, N: e };
          }
          function V(t) {
            if ('array' === t.kind) {
              const e = V(t.itemType);
              return 'number' == typeof t.N
                ? `array<${e}, ${t.N}>`
                : 'value' === t.itemType.kind
                ? 'array'
                : `array<${e}>`;
            }
            return t.kind;
          }
          const W = [I, D, O, N, z, j, F, H(B), G];
          function X(t, e) {
            if ('error' === e.kind) return null;
            if ('array' === t.kind) {
              if (
                'array' === e.kind &&
                ((0 === e.N && 'value' === e.itemType.kind) ||
                  !X(t.itemType, e.itemType)) &&
                ('number' != typeof t.N || t.N === e.N)
              )
                return null;
            } else {
              if (t.kind === e.kind) return null;
              if ('value' === t.kind)
                for (const t of W) if (!X(t, e)) return null;
            }
            return `Expected ${V(t)} but found ${V(e)} instead.`;
          }
          function Y(t, e) {
            return e.some((e) => e.kind === t.kind);
          }
          function $(t, e) {
            return e.some((e) =>
              'null' === e
                ? null === t
                : 'array' === e
                ? Array.isArray(t)
                : 'object' === e
                ? t && !Array.isArray(t) && 'object' == typeof t
                : e === typeof t,
            );
          }
          var J = o(function (t, e) {
            var n = {
              transparent: [0, 0, 0, 0],
              aliceblue: [240, 248, 255, 1],
              antiquewhite: [250, 235, 215, 1],
              aqua: [0, 255, 255, 1],
              aquamarine: [127, 255, 212, 1],
              azure: [240, 255, 255, 1],
              beige: [245, 245, 220, 1],
              bisque: [255, 228, 196, 1],
              black: [0, 0, 0, 1],
              blanchedalmond: [255, 235, 205, 1],
              blue: [0, 0, 255, 1],
              blueviolet: [138, 43, 226, 1],
              brown: [165, 42, 42, 1],
              burlywood: [222, 184, 135, 1],
              cadetblue: [95, 158, 160, 1],
              chartreuse: [127, 255, 0, 1],
              chocolate: [210, 105, 30, 1],
              coral: [255, 127, 80, 1],
              cornflowerblue: [100, 149, 237, 1],
              cornsilk: [255, 248, 220, 1],
              crimson: [220, 20, 60, 1],
              cyan: [0, 255, 255, 1],
              darkblue: [0, 0, 139, 1],
              darkcyan: [0, 139, 139, 1],
              darkgoldenrod: [184, 134, 11, 1],
              darkgray: [169, 169, 169, 1],
              darkgreen: [0, 100, 0, 1],
              darkgrey: [169, 169, 169, 1],
              darkkhaki: [189, 183, 107, 1],
              darkmagenta: [139, 0, 139, 1],
              darkolivegreen: [85, 107, 47, 1],
              darkorange: [255, 140, 0, 1],
              darkorchid: [153, 50, 204, 1],
              darkred: [139, 0, 0, 1],
              darksalmon: [233, 150, 122, 1],
              darkseagreen: [143, 188, 143, 1],
              darkslateblue: [72, 61, 139, 1],
              darkslategray: [47, 79, 79, 1],
              darkslategrey: [47, 79, 79, 1],
              darkturquoise: [0, 206, 209, 1],
              darkviolet: [148, 0, 211, 1],
              deeppink: [255, 20, 147, 1],
              deepskyblue: [0, 191, 255, 1],
              dimgray: [105, 105, 105, 1],
              dimgrey: [105, 105, 105, 1],
              dodgerblue: [30, 144, 255, 1],
              firebrick: [178, 34, 34, 1],
              floralwhite: [255, 250, 240, 1],
              forestgreen: [34, 139, 34, 1],
              fuchsia: [255, 0, 255, 1],
              gainsboro: [220, 220, 220, 1],
              ghostwhite: [248, 248, 255, 1],
              gold: [255, 215, 0, 1],
              goldenrod: [218, 165, 32, 1],
              gray: [128, 128, 128, 1],
              green: [0, 128, 0, 1],
              greenyellow: [173, 255, 47, 1],
              grey: [128, 128, 128, 1],
              honeydew: [240, 255, 240, 1],
              hotpink: [255, 105, 180, 1],
              indianred: [205, 92, 92, 1],
              indigo: [75, 0, 130, 1],
              ivory: [255, 255, 240, 1],
              khaki: [240, 230, 140, 1],
              lavender: [230, 230, 250, 1],
              lavenderblush: [255, 240, 245, 1],
              lawngreen: [124, 252, 0, 1],
              lemonchiffon: [255, 250, 205, 1],
              lightblue: [173, 216, 230, 1],
              lightcoral: [240, 128, 128, 1],
              lightcyan: [224, 255, 255, 1],
              lightgoldenrodyellow: [250, 250, 210, 1],
              lightgray: [211, 211, 211, 1],
              lightgreen: [144, 238, 144, 1],
              lightgrey: [211, 211, 211, 1],
              lightpink: [255, 182, 193, 1],
              lightsalmon: [255, 160, 122, 1],
              lightseagreen: [32, 178, 170, 1],
              lightskyblue: [135, 206, 250, 1],
              lightslategray: [119, 136, 153, 1],
              lightslategrey: [119, 136, 153, 1],
              lightsteelblue: [176, 196, 222, 1],
              lightyellow: [255, 255, 224, 1],
              lime: [0, 255, 0, 1],
              limegreen: [50, 205, 50, 1],
              linen: [250, 240, 230, 1],
              magenta: [255, 0, 255, 1],
              maroon: [128, 0, 0, 1],
              mediumaquamarine: [102, 205, 170, 1],
              mediumblue: [0, 0, 205, 1],
              mediumorchid: [186, 85, 211, 1],
              mediumpurple: [147, 112, 219, 1],
              mediumseagreen: [60, 179, 113, 1],
              mediumslateblue: [123, 104, 238, 1],
              mediumspringgreen: [0, 250, 154, 1],
              mediumturquoise: [72, 209, 204, 1],
              mediumvioletred: [199, 21, 133, 1],
              midnightblue: [25, 25, 112, 1],
              mintcream: [245, 255, 250, 1],
              mistyrose: [255, 228, 225, 1],
              moccasin: [255, 228, 181, 1],
              navajowhite: [255, 222, 173, 1],
              navy: [0, 0, 128, 1],
              oldlace: [253, 245, 230, 1],
              olive: [128, 128, 0, 1],
              olivedrab: [107, 142, 35, 1],
              orange: [255, 165, 0, 1],
              orangered: [255, 69, 0, 1],
              orchid: [218, 112, 214, 1],
              palegoldenrod: [238, 232, 170, 1],
              palegreen: [152, 251, 152, 1],
              paleturquoise: [175, 238, 238, 1],
              palevioletred: [219, 112, 147, 1],
              papayawhip: [255, 239, 213, 1],
              peachpuff: [255, 218, 185, 1],
              peru: [205, 133, 63, 1],
              pink: [255, 192, 203, 1],
              plum: [221, 160, 221, 1],
              powderblue: [176, 224, 230, 1],
              purple: [128, 0, 128, 1],
              rebeccapurple: [102, 51, 153, 1],
              red: [255, 0, 0, 1],
              rosybrown: [188, 143, 143, 1],
              royalblue: [65, 105, 225, 1],
              saddlebrown: [139, 69, 19, 1],
              salmon: [250, 128, 114, 1],
              sandybrown: [244, 164, 96, 1],
              seagreen: [46, 139, 87, 1],
              seashell: [255, 245, 238, 1],
              sienna: [160, 82, 45, 1],
              silver: [192, 192, 192, 1],
              skyblue: [135, 206, 235, 1],
              slateblue: [106, 90, 205, 1],
              slategray: [112, 128, 144, 1],
              slategrey: [112, 128, 144, 1],
              snow: [255, 250, 250, 1],
              springgreen: [0, 255, 127, 1],
              steelblue: [70, 130, 180, 1],
              tan: [210, 180, 140, 1],
              teal: [0, 128, 128, 1],
              thistle: [216, 191, 216, 1],
              tomato: [255, 99, 71, 1],
              turquoise: [64, 224, 208, 1],
              violet: [238, 130, 238, 1],
              wheat: [245, 222, 179, 1],
              white: [255, 255, 255, 1],
              whitesmoke: [245, 245, 245, 1],
              yellow: [255, 255, 0, 1],
              yellowgreen: [154, 205, 50, 1],
            };
            function i(t) {
              return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;
            }
            function r(t) {
              return t < 0 ? 0 : t > 1 ? 1 : t;
            }
            function a(t) {
              return '%' === t[t.length - 1]
                ? i((parseFloat(t) / 100) * 255)
                : i(parseInt(t));
            }
            function o(t) {
              return '%' === t[t.length - 1]
                ? r(parseFloat(t) / 100)
                : r(parseFloat(t));
            }
            function s(t, e, n) {
              return (
                n < 0 ? (n += 1) : n > 1 && (n -= 1),
                6 * n < 1
                  ? t + (e - t) * n * 6
                  : 2 * n < 1
                  ? e
                  : 3 * n < 2
                  ? t + (e - t) * (2 / 3 - n) * 6
                  : t
              );
            }
            try {
              e.parseCSSColor = function (t) {
                var e,
                  r = t.replace(/ /g, '').toLowerCase();
                if (r in n) return n[r].slice();
                if ('#' === r[0])
                  return 4 === r.length
                    ? (e = parseInt(r.substr(1), 16)) >= 0 && e <= 4095
                      ? [
                          ((3840 & e) >> 4) | ((3840 & e) >> 8),
                          (240 & e) | ((240 & e) >> 4),
                          (15 & e) | ((15 & e) << 4),
                          1,
                        ]
                      : null
                    : 7 === r.length &&
                      (e = parseInt(r.substr(1), 16)) >= 0 &&
                      e <= 16777215
                    ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1]
                    : null;
                var l = r.indexOf('('),
                  c = r.indexOf(')');
                if (-1 !== l && c + 1 === r.length) {
                  var u = r.substr(0, l),
                    h = r.substr(l + 1, c - (l + 1)).split(','),
                    d = 1;
                  switch (u) {
                    case 'rgba':
                      if (4 !== h.length) return null;
                      d = o(h.pop());
                    case 'rgb':
                      return 3 !== h.length
                        ? null
                        : [a(h[0]), a(h[1]), a(h[2]), d];
                    case 'hsla':
                      if (4 !== h.length) return null;
                      d = o(h.pop());
                    case 'hsl':
                      if (3 !== h.length) return null;
                      var p = (((parseFloat(h[0]) % 360) + 360) % 360) / 360,
                        f = o(h[1]),
                        m = o(h[2]),
                        g = m <= 0.5 ? m * (f + 1) : m + f - m * f,
                        y = 2 * m - g;
                      return [
                        i(255 * s(y, g, p + 1 / 3)),
                        i(255 * s(y, g, p)),
                        i(255 * s(y, g, p - 1 / 3)),
                        d,
                      ];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch (t) {}
          }).parseCSSColor;
          class Z {
            constructor(t, e, n, i = 1) {
              (this.r = t), (this.g = e), (this.b = n), (this.a = i);
            }
            static parse(t) {
              if (!t) return;
              if (t instanceof Z) return t;
              if ('string' != typeof t) return;
              const e = J(t);
              return e
                ? new Z(
                    (e[0] / 255) * e[3],
                    (e[1] / 255) * e[3],
                    (e[2] / 255) * e[3],
                    e[3],
                  )
                : void 0;
            }
            toString() {
              const [t, e, n, i] = this.toArray();
              return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(
                n,
              )},${i})`;
            }
            toArray() {
              const { r: t, g: e, b: n, a: i } = this;
              return 0 === i
                ? [0, 0, 0, 0]
                : [(255 * t) / i, (255 * e) / i, (255 * n) / i, i];
            }
          }
          (Z.black = new Z(0, 0, 0, 1)),
            (Z.white = new Z(1, 1, 1, 1)),
            (Z.transparent = new Z(0, 0, 0, 0)),
            (Z.red = new Z(1, 0, 0, 1)),
            (Z.blue = new Z(0, 0, 1, 1));
          class K {
            constructor(t, e, n) {
              (this.sensitivity = t
                ? e
                  ? 'variant'
                  : 'case'
                : e
                ? 'accent'
                : 'base'),
                (this.locale = n),
                (this.collator = new Intl.Collator(
                  this.locale ? this.locale : [],
                  { sensitivity: this.sensitivity, usage: 'search' },
                ));
            }
            compare(t, e) {
              return this.collator.compare(t, e);
            }
            resolvedLocale() {
              return new Intl.Collator(
                this.locale ? this.locale : [],
              ).resolvedOptions().locale;
            }
          }
          class Q {
            constructor(t, e, n, i, r) {
              (this.text = t),
                (this.image = e),
                (this.scale = n),
                (this.fontStack = i),
                (this.textColor = r);
            }
          }
          class tt {
            constructor(t) {
              this.sections = t;
            }
            static fromString(t) {
              return new tt([new Q(t, null, null, null, null)]);
            }
            isEmpty() {
              return (
                0 === this.sections.length ||
                !this.sections.some(
                  (t) =>
                    0 !== t.text.length ||
                    (t.image && 0 !== t.image.name.length),
                )
              );
            }
            static factory(t) {
              return t instanceof tt ? t : tt.fromString(t);
            }
            toString() {
              return 0 === this.sections.length
                ? ''
                : this.sections.map((t) => t.text).join('');
            }
            serialize() {
              const t = ['format'];
              for (const e of this.sections) {
                if (e.image) {
                  t.push(['image', e.image.name]);
                  continue;
                }
                t.push(e.text);
                const n = {};
                e.fontStack &&
                  (n['text-font'] = ['literal', e.fontStack.split(',')]),
                  e.scale && (n['font-scale'] = e.scale),
                  e.textColor &&
                    (n['text-color'] = ['rgba'].concat(e.textColor.toArray())),
                  t.push(n);
              }
              return t;
            }
          }
          class et {
            constructor(t) {
              (this.name = t.name), (this.available = t.available);
            }
            toString() {
              return this.name;
            }
            static fromString(t) {
              return t ? new et({ name: t, available: !1 }) : null;
            }
            serialize() {
              return ['image', this.name];
            }
          }
          function nt(t, e, n, i) {
            if (
              !(
                'number' == typeof t &&
                t >= 0 &&
                t <= 255 &&
                'number' == typeof e &&
                e >= 0 &&
                e <= 255 &&
                'number' == typeof n &&
                n >= 0 &&
                n <= 255
              )
            ) {
              return `Invalid rgba value [${('number' == typeof i
                ? [t, e, n, i]
                : [t, e, n]
              ).join(', ')}]: 'r', 'g', and 'b' must be between 0 and 255.`;
            }
            return void 0 === i || ('number' == typeof i && i >= 0 && i <= 1)
              ? null
              : `Invalid rgba value [${[t, e, n, i].join(
                  ', ',
                )}]: 'a' must be between 0 and 1.`;
          }
          function it(t) {
            if (null === t) return !0;
            if ('string' == typeof t) return !0;
            if ('boolean' == typeof t) return !0;
            if ('number' == typeof t) return !0;
            if (t instanceof Z) return !0;
            if (t instanceof K) return !0;
            if (t instanceof tt) return !0;
            if (t instanceof et) return !0;
            if (Array.isArray(t)) {
              for (const e of t) if (!it(e)) return !1;
              return !0;
            }
            if ('object' == typeof t) {
              for (const e in t) if (!it(t[e])) return !1;
              return !0;
            }
            return !1;
          }
          function rt(t) {
            if (null === t) return I;
            if ('string' == typeof t) return O;
            if ('boolean' == typeof t) return N;
            if ('number' == typeof t) return D;
            if (t instanceof Z) return z;
            if (t instanceof K) return U;
            if (t instanceof tt) return j;
            if (t instanceof et) return G;
            if (Array.isArray(t)) {
              const e = t.length;
              let n;
              for (const e of t) {
                const t = rt(e);
                if (n) {
                  if (n === t) continue;
                  n = B;
                  break;
                }
                n = t;
              }
              return H(n || B, e);
            }
            return F;
          }
          function at(t) {
            const e = typeof t;
            return null === t
              ? ''
              : 'string' === e || 'number' === e || 'boolean' === e
              ? String(t)
              : t instanceof Z || t instanceof tt || t instanceof et
              ? t.toString()
              : JSON.stringify(t);
          }
          class ot {
            constructor(t, e) {
              (this.type = t), (this.value = e);
            }
            static parse(t, e) {
              if (2 !== t.length)
                return e.error(
                  `'literal' expression requires exactly one argument, but found ${
                    t.length - 1
                  } instead.`,
                );
              if (!it(t[1])) return e.error('invalid value');
              const n = t[1];
              let i = rt(n);
              const r = e.expectedType;
              return (
                'array' !== i.kind ||
                  0 !== i.N ||
                  !r ||
                  'array' !== r.kind ||
                  ('number' == typeof r.N && 0 !== r.N) ||
                  (i = r),
                new ot(i, n)
              );
            }
            evaluate() {
              return this.value;
            }
            eachChild() {}
            outputDefined() {
              return !0;
            }
            serialize() {
              return 'array' === this.type.kind || 'object' === this.type.kind
                ? ['literal', this.value]
                : this.value instanceof Z
                ? ['rgba'].concat(this.value.toArray())
                : this.value instanceof tt
                ? this.value.serialize()
                : this.value;
            }
          }
          class st {
            constructor(t) {
              (this.name = 'ExpressionEvaluationError'), (this.message = t);
            }
            toJSON() {
              return this.message;
            }
          }
          const lt = { string: O, number: D, boolean: N, object: F };
          class ct {
            constructor(t, e) {
              (this.type = t), (this.args = e);
            }
            static parse(t, e) {
              if (t.length < 2)
                return e.error('Expected at least one argument.');
              let n,
                i = 1;
              const r = t[0];
              if ('array' === r) {
                let r, a;
                if (t.length > 2) {
                  const n = t[1];
                  if ('string' != typeof n || !(n in lt) || 'object' === n)
                    return e.error(
                      'The item type argument of "array" must be one of string, number, boolean',
                      1,
                    );
                  (r = lt[n]), i++;
                } else r = B;
                if (t.length > 3) {
                  if (
                    null !== t[2] &&
                    ('number' != typeof t[2] ||
                      t[2] < 0 ||
                      t[2] !== Math.floor(t[2]))
                  )
                    return e.error(
                      'The length argument to "array" must be a positive integer literal',
                      2,
                    );
                  (a = t[2]), i++;
                }
                n = H(r, a);
              } else n = lt[r];
              const a = [];
              for (; i < t.length; i++) {
                const n = e.parse(t[i], i, B);
                if (!n) return null;
                a.push(n);
              }
              return new ct(n, a);
            }
            evaluate(t) {
              for (let e = 0; e < this.args.length; e++) {
                const n = this.args[e].evaluate(t);
                if (!X(this.type, rt(n))) return n;
                if (e === this.args.length - 1)
                  throw new st(
                    `Expected value to be of type ${V(
                      this.type,
                    )}, but found ${V(rt(n))} instead.`,
                  );
              }
              return null;
            }
            eachChild(t) {
              this.args.forEach(t);
            }
            outputDefined() {
              return this.args.every((t) => t.outputDefined());
            }
            serialize() {
              const t = this.type,
                e = [t.kind];
              if ('array' === t.kind) {
                const n = t.itemType;
                if (
                  'string' === n.kind ||
                  'number' === n.kind ||
                  'boolean' === n.kind
                ) {
                  e.push(n.kind);
                  const i = t.N;
                  ('number' == typeof i || this.args.length > 1) && e.push(i);
                }
              }
              return e.concat(this.args.map((t) => t.serialize()));
            }
          }
          class ut {
            constructor(t) {
              (this.type = j), (this.sections = t);
            }
            static parse(t, e) {
              if (t.length < 2)
                return e.error('Expected at least one argument.');
              const n = t[1];
              if (!Array.isArray(n) && 'object' == typeof n)
                return e.error(
                  'First argument must be an image or text section.',
                );
              const i = [];
              let r = !1;
              for (let n = 1; n <= t.length - 1; ++n) {
                const a = t[n];
                if (r && 'object' == typeof a && !Array.isArray(a)) {
                  r = !1;
                  let t = null;
                  if (
                    a['font-scale'] &&
                    ((t = e.parse(a['font-scale'], 1, D)), !t)
                  )
                    return null;
                  let n = null;
                  if (
                    a['text-font'] &&
                    ((n = e.parse(a['text-font'], 1, H(O))), !n)
                  )
                    return null;
                  let o = null;
                  if (
                    a['text-color'] &&
                    ((o = e.parse(a['text-color'], 1, z)), !o)
                  )
                    return null;
                  const s = i[i.length - 1];
                  (s.scale = t), (s.font = n), (s.textColor = o);
                } else {
                  const a = e.parse(t[n], 1, B);
                  if (!a) return null;
                  const o = a.type.kind;
                  if (
                    'string' !== o &&
                    'value' !== o &&
                    'null' !== o &&
                    'resolvedImage' !== o
                  )
                    return e.error(
                      "Formatted text type must be 'string', 'value', 'image' or 'null'.",
                    );
                  (r = !0),
                    i.push({
                      content: a,
                      scale: null,
                      font: null,
                      textColor: null,
                    });
                }
              }
              return new ut(i);
            }
            evaluate(t) {
              return new tt(
                this.sections.map((e) => {
                  const n = e.content.evaluate(t);
                  return rt(n) === G
                    ? new Q('', n, null, null, null)
                    : new Q(
                        at(n),
                        null,
                        e.scale ? e.scale.evaluate(t) : null,
                        e.font ? e.font.evaluate(t).join(',') : null,
                        e.textColor ? e.textColor.evaluate(t) : null,
                      );
                }),
              );
            }
            eachChild(t) {
              for (const e of this.sections)
                t(e.content),
                  e.scale && t(e.scale),
                  e.font && t(e.font),
                  e.textColor && t(e.textColor);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              const t = ['format'];
              for (const e of this.sections) {
                t.push(e.content.serialize());
                const n = {};
                e.scale && (n['font-scale'] = e.scale.serialize()),
                  e.font && (n['text-font'] = e.font.serialize()),
                  e.textColor && (n['text-color'] = e.textColor.serialize()),
                  t.push(n);
              }
              return t;
            }
          }
          class ht {
            constructor(t) {
              (this.type = G), (this.input = t);
            }
            static parse(t, e) {
              if (2 !== t.length) return e.error('Expected two arguments.');
              const n = e.parse(t[1], 1, O);
              return n ? new ht(n) : e.error('No image name provided.');
            }
            evaluate(t) {
              const e = this.input.evaluate(t),
                n = et.fromString(e);
              return (
                n &&
                  t.availableImages &&
                  (n.available = t.availableImages.indexOf(e) > -1),
                n
              );
            }
            eachChild(t) {
              t(this.input);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              return ['image', this.input.serialize()];
            }
          }
          const dt = {
            'to-boolean': N,
            'to-color': z,
            'to-number': D,
            'to-string': O,
          };
          class pt {
            constructor(t, e) {
              (this.type = t), (this.args = e);
            }
            static parse(t, e) {
              if (t.length < 2)
                return e.error('Expected at least one argument.');
              const n = t[0];
              if (('to-boolean' === n || 'to-string' === n) && 2 !== t.length)
                return e.error('Expected one argument.');
              const i = dt[n],
                r = [];
              for (let n = 1; n < t.length; n++) {
                const i = e.parse(t[n], n, B);
                if (!i) return null;
                r.push(i);
              }
              return new pt(i, r);
            }
            evaluate(t) {
              if ('boolean' === this.type.kind)
                return Boolean(this.args[0].evaluate(t));
              if ('color' === this.type.kind) {
                let e, n;
                for (const i of this.args) {
                  if (((e = i.evaluate(t)), (n = null), e instanceof Z))
                    return e;
                  if ('string' == typeof e) {
                    const n = t.parseColor(e);
                    if (n) return n;
                  } else if (
                    Array.isArray(e) &&
                    ((n =
                      e.length < 3 || e.length > 4
                        ? `Invalid rbga value ${JSON.stringify(
                            e,
                          )}: expected an array containing either three or four numeric values.`
                        : nt(e[0], e[1], e[2], e[3])),
                    !n)
                  )
                    return new Z(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                }
                throw new st(
                  n ||
                    `Could not parse color from value '${
                      'string' == typeof e ? e : String(JSON.stringify(e))
                    }'`,
                );
              }
              if ('number' === this.type.kind) {
                let e = null;
                for (const n of this.args) {
                  if (((e = n.evaluate(t)), null === e)) return 0;
                  const i = Number(e);
                  if (!isNaN(i)) return i;
                }
                throw new st(
                  `Could not convert ${JSON.stringify(e)} to number.`,
                );
              }
              return 'formatted' === this.type.kind
                ? tt.fromString(at(this.args[0].evaluate(t)))
                : 'resolvedImage' === this.type.kind
                ? et.fromString(at(this.args[0].evaluate(t)))
                : at(this.args[0].evaluate(t));
            }
            eachChild(t) {
              this.args.forEach(t);
            }
            outputDefined() {
              return this.args.every((t) => t.outputDefined());
            }
            serialize() {
              if ('formatted' === this.type.kind)
                return new ut([
                  {
                    content: this.args[0],
                    scale: null,
                    font: null,
                    textColor: null,
                  },
                ]).serialize();
              if ('resolvedImage' === this.type.kind)
                return new ht(this.args[0]).serialize();
              const t = ['to-' + this.type.kind];
              return (
                this.eachChild((e) => {
                  t.push(e.serialize());
                }),
                t
              );
            }
          }
          const ft = ['Unknown', 'Point', 'LineString', 'Polygon'];
          class mt {
            constructor() {
              (this.globals = null),
                (this.feature = null),
                (this.featureState = null),
                (this.formattedSection = null),
                (this._parseColorCache = {}),
                (this.availableImages = null),
                (this.canonical = null);
            }
            id() {
              return this.feature && 'id' in this.feature
                ? this.feature.id
                : null;
            }
            geometryType() {
              return this.feature
                ? 'number' == typeof this.feature.type
                  ? ft[this.feature.type]
                  : this.feature.type
                : null;
            }
            geometry() {
              return this.feature && 'geometry' in this.feature
                ? this.feature.geometry
                : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return (this.feature && this.feature.properties) || {};
            }
            parseColor(t) {
              let e = this._parseColorCache[t];
              return e || (e = this._parseColorCache[t] = Z.parse(t)), e;
            }
          }
          class gt {
            constructor(t, e, n, i) {
              (this.name = t),
                (this.type = e),
                (this._evaluate = n),
                (this.args = i);
            }
            evaluate(t) {
              return this._evaluate(t, this.args);
            }
            eachChild(t) {
              this.args.forEach(t);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              return [this.name].concat(this.args.map((t) => t.serialize()));
            }
            static parse(t, e) {
              const n = t[0],
                i = gt.definitions[n];
              if (!i)
                return e.error(
                  `Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`,
                  0,
                );
              const r = Array.isArray(i) ? i[0] : i.type,
                a = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads,
                o = a.filter(
                  ([e]) => !Array.isArray(e) || e.length === t.length - 1,
                );
              let s = null;
              for (const [i, a] of o) {
                s = new Ft(e.registry, e.path, null, e.scope);
                const o = [];
                let l = !1;
                for (let e = 1; e < t.length; e++) {
                  const n = t[e],
                    r = Array.isArray(i) ? i[e - 1] : i.type,
                    a = s.parse(n, 1 + o.length, r);
                  if (!a) {
                    l = !0;
                    break;
                  }
                  o.push(a);
                }
                if (!l)
                  if (Array.isArray(i) && i.length !== o.length)
                    s.error(
                      `Expected ${i.length} arguments, but found ${o.length} instead.`,
                    );
                  else {
                    for (let t = 0; t < o.length; t++) {
                      const e = Array.isArray(i) ? i[t] : i.type,
                        n = o[t];
                      s.concat(t + 1).checkSubtype(e, n.type);
                    }
                    if (0 === s.errors.length) return new gt(n, r, a, o);
                  }
              }
              if (1 === o.length) e.errors.push(...s.errors);
              else {
                const n = (o.length ? o : a)
                    .map(([t]) => {
                      return (
                        (e = t),
                        Array.isArray(e)
                          ? `(${e.map(V).join(', ')})`
                          : `(${V(e.type)}...)`
                      );
                      var e;
                    })
                    .join(' | '),
                  i = [];
                for (let n = 1; n < t.length; n++) {
                  const r = e.parse(t[n], 1 + i.length);
                  if (!r) return null;
                  i.push(V(r.type));
                }
                e.error(
                  `Expected arguments of type ${n}, but found (${i.join(
                    ', ',
                  )}) instead.`,
                );
              }
              return null;
            }
            static register(t, e) {
              gt.definitions = e;
              for (const n in e) t[n] = gt;
            }
          }
          class yt {
            constructor(t, e, n) {
              (this.type = U),
                (this.locale = n),
                (this.caseSensitive = t),
                (this.diacriticSensitive = e);
            }
            static parse(t, e) {
              if (2 !== t.length) return e.error('Expected one argument.');
              const n = t[1];
              if ('object' != typeof n || Array.isArray(n))
                return e.error('Collator options argument must be an object.');
              const i = e.parse(
                void 0 !== n['case-sensitive'] && n['case-sensitive'],
                1,
                N,
              );
              if (!i) return null;
              const r = e.parse(
                void 0 !== n['diacritic-sensitive'] && n['diacritic-sensitive'],
                1,
                N,
              );
              if (!r) return null;
              let a = null;
              return n.locale && ((a = e.parse(n.locale, 1, O)), !a)
                ? null
                : new yt(i, r, a);
            }
            evaluate(t) {
              return new K(
                this.caseSensitive.evaluate(t),
                this.diacriticSensitive.evaluate(t),
                this.locale ? this.locale.evaluate(t) : null,
              );
            }
            eachChild(t) {
              t(this.caseSensitive),
                t(this.diacriticSensitive),
                this.locale && t(this.locale);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              const t = {};
              return (
                (t['case-sensitive'] = this.caseSensitive.serialize()),
                (t['diacritic-sensitive'] =
                  this.diacriticSensitive.serialize()),
                this.locale && (t.locale = this.locale.serialize()),
                ['collator', t]
              );
            }
          }
          function vt(t, e) {
            (t[0] = Math.min(t[0], e[0])),
              (t[1] = Math.min(t[1], e[1])),
              (t[2] = Math.max(t[2], e[0])),
              (t[3] = Math.max(t[3], e[1]));
          }
          function xt(t, e) {
            return (
              !(t[0] <= e[0]) &&
              !(t[2] >= e[2]) &&
              !(t[1] <= e[1]) &&
              !(t[3] >= e[3])
            );
          }
          function bt(t, e) {
            const n = (180 + t[0]) / 360;
            const i =
              ((r = t[1]),
              (180 -
                (180 / Math.PI) *
                  Math.log(Math.tan(Math.PI / 4 + (r * Math.PI) / 360))) /
                360);
            var r;
            const a = Math.pow(2, e.z);
            return [Math.round(n * a * 8192), Math.round(i * a * 8192)];
          }
          function _t(t, e, n) {
            const i = t[0] - e[0],
              r = t[1] - e[1],
              a = t[0] - n[0],
              o = t[1] - n[1];
            return i * o - a * r == 0 && i * a <= 0 && r * o <= 0;
          }
          function wt(t, e) {
            let n = !1;
            for (let o = 0, s = e.length; o < s; o++) {
              const s = e[o];
              for (let e = 0, o = s.length; e < o - 1; e++) {
                if (_t(t, s[e], s[e + 1])) return !1;
                (i = t),
                  (r = s[e]),
                  (a = s[e + 1]),
                  r[1] > i[1] != a[1] > i[1] &&
                    i[0] <
                      ((a[0] - r[0]) * (i[1] - r[1])) / (a[1] - r[1]) + r[0] &&
                    (n = !n);
              }
            }
            var i, r, a;
            return n;
          }
          function Mt(t, e) {
            for (let n = 0; n < e.length; n++) if (wt(t, e[n])) return !0;
            return !1;
          }
          function qt(t, e, n, i) {
            const r = t[0] - n[0],
              a = t[1] - n[1],
              o = e[0] - n[0],
              s = e[1] - n[1],
              l = i[0] - n[0],
              c = i[1] - n[1],
              u = r * c - l * a,
              h = o * c - l * s;
            return (u > 0 && h < 0) || (u < 0 && h > 0);
          }
          function St(t, e, n, i) {
            const r = [e[0] - t[0], e[1] - t[1]],
              a = [i[0] - n[0], i[1] - n[1]];
            return (
              0 != (o = a)[0] * (s = r)[1] - o[1] * s[0] &&
              !(!qt(t, e, n, i) || !qt(n, i, t, e))
            );
            var o, s;
          }
          function Tt(t, e, n) {
            for (const i of n)
              for (let n = 0; n < i.length - 1; ++n)
                if (St(t, e, i[n], i[n + 1])) return !0;
            return !1;
          }
          function Et(t, e) {
            for (let n = 0; n < t.length; ++n) if (!wt(t[n], e)) return !1;
            for (let n = 0; n < t.length - 1; ++n)
              if (Tt(t[n], t[n + 1], e)) return !1;
            return !0;
          }
          function At(t, e) {
            for (let n = 0; n < e.length; n++) if (Et(t, e[n])) return !0;
            return !1;
          }
          function Lt(t, e, n) {
            const i = [];
            for (let r = 0; r < t.length; r++) {
              const a = [];
              for (let i = 0; i < t[r].length; i++) {
                const o = bt(t[r][i], n);
                vt(e, o), a.push(o);
              }
              i.push(a);
            }
            return i;
          }
          function Rt(t, e, n) {
            const i = [];
            for (let r = 0; r < t.length; r++) {
              const a = Lt(t[r], e, n);
              i.push(a);
            }
            return i;
          }
          function Ct(t, e, n, i) {
            if (t[0] < n[0] || t[0] > n[2]) {
              const e = 0.5 * i;
              let r = t[0] - n[0] > e ? -i : n[0] - t[0] > e ? i : 0;
              0 === r && (r = t[0] - n[2] > e ? -i : n[2] - t[0] > e ? i : 0),
                (t[0] += r);
            }
            vt(e, t);
          }
          function Pt(t, e, n, i) {
            const r = 8192 * Math.pow(2, i.z),
              a = [8192 * i.x, 8192 * i.y],
              o = [];
            for (const i of t)
              for (const t of i) {
                const i = [t.x + a[0], t.y + a[1]];
                Ct(i, e, n, r), o.push(i);
              }
            return o;
          }
          function kt(t, e, n, i) {
            const r = 8192 * Math.pow(2, i.z),
              a = [8192 * i.x, 8192 * i.y],
              o = [];
            for (const n of t) {
              const t = [];
              for (const i of n) {
                const n = [i.x + a[0], i.y + a[1]];
                vt(e, n), t.push(n);
              }
              o.push(t);
            }
            if (e[2] - e[0] <= r / 2) {
              ((s = e)[0] = s[1] = 1 / 0), (s[2] = s[3] = -1 / 0);
              for (const t of o) for (const i of t) Ct(i, e, n, r);
            }
            var s;
            return o;
          }
          class It {
            constructor(t, e) {
              (this.type = N), (this.geojson = t), (this.geometries = e);
            }
            static parse(t, e) {
              if (2 !== t.length)
                return e.error(
                  `'within' expression requires exactly one argument, but found ${
                    t.length - 1
                  } instead.`,
                );
              if (it(t[1])) {
                const e = t[1];
                if ('FeatureCollection' === e.type)
                  for (let t = 0; t < e.features.length; ++t) {
                    const n = e.features[t].geometry.type;
                    if ('Polygon' === n || 'MultiPolygon' === n)
                      return new It(e, e.features[t].geometry);
                  }
                else if ('Feature' === e.type) {
                  const t = e.geometry.type;
                  if ('Polygon' === t || 'MultiPolygon' === t)
                    return new It(e, e.geometry);
                } else if ('Polygon' === e.type || 'MultiPolygon' === e.type)
                  return new It(e, e);
              }
              return e.error(
                "'within' expression requires valid geojson object that contains polygon geometry type.",
              );
            }
            evaluate(t) {
              if (null != t.geometry() && null != t.canonicalID()) {
                if ('Point' === t.geometryType())
                  return (function (t, e) {
                    const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                      i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                      r = t.canonicalID();
                    if ('Polygon' === e.type) {
                      const a = Lt(e.coordinates, i, r),
                        o = Pt(t.geometry(), n, i, r);
                      if (!xt(n, i)) return !1;
                      for (const t of o) if (!wt(t, a)) return !1;
                    }
                    if ('MultiPolygon' === e.type) {
                      const a = Rt(e.coordinates, i, r),
                        o = Pt(t.geometry(), n, i, r);
                      if (!xt(n, i)) return !1;
                      for (const t of o) if (!Mt(t, a)) return !1;
                    }
                    return !0;
                  })(t, this.geometries);
                if ('LineString' === t.geometryType())
                  return (function (t, e) {
                    const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                      i = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                      r = t.canonicalID();
                    if ('Polygon' === e.type) {
                      const a = Lt(e.coordinates, i, r),
                        o = kt(t.geometry(), n, i, r);
                      if (!xt(n, i)) return !1;
                      for (const t of o) if (!Et(t, a)) return !1;
                    }
                    if ('MultiPolygon' === e.type) {
                      const a = Rt(e.coordinates, i, r),
                        o = kt(t.geometry(), n, i, r);
                      if (!xt(n, i)) return !1;
                      for (const t of o) if (!At(t, a)) return !1;
                    }
                    return !0;
                  })(t, this.geometries);
              }
              return !1;
            }
            eachChild() {}
            outputDefined() {
              return !0;
            }
            serialize() {
              return ['within', this.geojson];
            }
          }
          function Dt(t) {
            if (t instanceof gt) {
              if ('get' === t.name && 1 === t.args.length) return !1;
              if ('feature-state' === t.name) return !1;
              if ('has' === t.name && 1 === t.args.length) return !1;
              if (
                'properties' === t.name ||
                'geometry-type' === t.name ||
                'id' === t.name
              )
                return !1;
              if (/^filter-/.test(t.name)) return !1;
            }
            if (t instanceof It) return !1;
            let e = !0;
            return (
              t.eachChild((t) => {
                e && !Dt(t) && (e = !1);
              }),
              e
            );
          }
          function Ot(t) {
            if (t instanceof gt && 'feature-state' === t.name) return !1;
            let e = !0;
            return (
              t.eachChild((t) => {
                e && !Ot(t) && (e = !1);
              }),
              e
            );
          }
          function Nt(t, e) {
            if (t instanceof gt && e.indexOf(t.name) >= 0) return !1;
            let n = !0;
            return (
              t.eachChild((t) => {
                n && !Nt(t, e) && (n = !1);
              }),
              n
            );
          }
          class zt {
            constructor(t, e) {
              (this.type = e.type), (this.name = t), (this.boundExpression = e);
            }
            static parse(t, e) {
              if (2 !== t.length || 'string' != typeof t[1])
                return e.error(
                  "'var' expression requires exactly one string literal argument.",
                );
              const n = t[1];
              return e.scope.has(n)
                ? new zt(n, e.scope.get(n))
                : e.error(
                    `Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`,
                    1,
                  );
            }
            evaluate(t) {
              return this.boundExpression.evaluate(t);
            }
            eachChild() {}
            outputDefined() {
              return !1;
            }
            serialize() {
              return ['var', this.name];
            }
          }
          class Ft {
            constructor(t, e = [], n, i = new k(), r = []) {
              (this.registry = t),
                (this.path = e),
                (this.key = e.map((t) => `[${t}]`).join('')),
                (this.scope = i),
                (this.errors = r),
                (this.expectedType = n);
            }
            parse(t, e, n, i, r = {}) {
              return e ? this.concat(e, n, i)._parse(t, r) : this._parse(t, r);
            }
            _parse(t, e) {
              function n(t, e, n) {
                return 'assert' === n
                  ? new ct(e, [t])
                  : 'coerce' === n
                  ? new pt(e, [t])
                  : t;
              }
              if (
                ((null !== t &&
                  'string' != typeof t &&
                  'boolean' != typeof t &&
                  'number' != typeof t) ||
                  (t = ['literal', t]),
                Array.isArray(t))
              ) {
                if (0 === t.length)
                  return this.error(
                    'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].',
                  );
                const i = t[0];
                if ('string' != typeof i)
                  return (
                    this.error(
                      `Expression name must be a string, but found ${typeof i} instead. If you wanted a literal array, use ["literal", [...]].`,
                      0,
                    ),
                    null
                  );
                const r = this.registry[i];
                if (r) {
                  let i = r.parse(t, this);
                  if (!i) return null;
                  if (this.expectedType) {
                    const t = this.expectedType,
                      r = i.type;
                    if (
                      ('string' !== t.kind &&
                        'number' !== t.kind &&
                        'boolean' !== t.kind &&
                        'object' !== t.kind &&
                        'array' !== t.kind) ||
                      'value' !== r.kind
                    )
                      if (
                        ('color' !== t.kind &&
                          'formatted' !== t.kind &&
                          'resolvedImage' !== t.kind) ||
                        ('value' !== r.kind && 'string' !== r.kind)
                      ) {
                        if (this.checkSubtype(t, r)) return null;
                      } else i = n(i, t, e.typeAnnotation || 'coerce');
                    else i = n(i, t, e.typeAnnotation || 'assert');
                  }
                  if (
                    !(i instanceof ot) &&
                    'resolvedImage' !== i.type.kind &&
                    (function t(e) {
                      if (e instanceof zt) return t(e.boundExpression);
                      if (e instanceof gt && 'error' === e.name) return !1;
                      if (e instanceof yt) return !1;
                      if (e instanceof It) return !1;
                      const n = e instanceof pt || e instanceof ct;
                      let i = !0;
                      if (
                        (e.eachChild((e) => {
                          i = n ? i && t(e) : i && e instanceof ot;
                        }),
                        !i)
                      )
                        return !1;
                      return (
                        Dt(e) &&
                        Nt(e, [
                          'zoom',
                          'heatmap-density',
                          'line-progress',
                          'sky-radial-progress',
                          'accumulated',
                          'is-supported-script',
                        ])
                      );
                    })(i)
                  ) {
                    const t = new mt();
                    try {
                      i = new ot(i.type, i.evaluate(t));
                    } catch (t) {
                      return this.error(t.message), null;
                    }
                  }
                  return i;
                }
                return this.error(
                  `Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`,
                  0,
                );
              }
              return void 0 === t
                ? this.error("'undefined' value invalid. Use null instead.")
                : 'object' == typeof t
                ? this.error(
                    'Bare objects invalid. Use ["literal", {...}] instead.',
                  )
                : this.error(
                    `Expected an array, but found ${typeof t} instead.`,
                  );
            }
            concat(t, e, n) {
              const i = 'number' == typeof t ? this.path.concat(t) : this.path,
                r = n ? this.scope.concat(n) : this.scope;
              return new Ft(this.registry, i, e || null, r, this.errors);
            }
            error(t, ...e) {
              const n = `${this.key}${e.map((t) => `[${t}]`).join('')}`;
              this.errors.push(new P(n, t));
            }
            checkSubtype(t, e) {
              const n = X(t, e);
              return n && this.error(n), n;
            }
          }
          function Bt(t, e) {
            const n = t.length - 1;
            let i,
              r,
              a = 0,
              o = n,
              s = 0;
            for (; a <= o; )
              if (
                ((s = Math.floor((a + o) / 2)),
                (i = t[s]),
                (r = t[s + 1]),
                i <= e)
              ) {
                if (s === n || e < r) return s;
                a = s + 1;
              } else {
                if (!(i > e)) throw new st('Input is not a number.');
                o = s - 1;
              }
            return 0;
          }
          class Ut {
            constructor(t, e, n) {
              (this.type = t),
                (this.input = e),
                (this.labels = []),
                (this.outputs = []);
              for (const [t, e] of n) this.labels.push(t), this.outputs.push(e);
            }
            static parse(t, e) {
              if (t.length - 1 < 4)
                return e.error(
                  `Expected at least 4 arguments, but found only ${
                    t.length - 1
                  }.`,
                );
              if ((t.length - 1) % 2 != 0)
                return e.error('Expected an even number of arguments.');
              const n = e.parse(t[1], 1, D);
              if (!n) return null;
              const i = [];
              let r = null;
              e.expectedType &&
                'value' !== e.expectedType.kind &&
                (r = e.expectedType);
              for (let n = 1; n < t.length; n += 2) {
                const a = 1 === n ? -1 / 0 : t[n],
                  o = t[n + 1],
                  s = n,
                  l = n + 1;
                if ('number' != typeof a)
                  return e.error(
                    'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                    s,
                  );
                if (i.length && i[i.length - 1][0] >= a)
                  return e.error(
                    'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                    s,
                  );
                const c = e.parse(o, l, r);
                if (!c) return null;
                (r = r || c.type), i.push([a, c]);
              }
              return new Ut(r, n, i);
            }
            evaluate(t) {
              const e = this.labels,
                n = this.outputs;
              if (1 === e.length) return n[0].evaluate(t);
              const i = this.input.evaluate(t);
              if (i <= e[0]) return n[0].evaluate(t);
              const r = e.length;
              if (i >= e[r - 1]) return n[r - 1].evaluate(t);
              return n[Bt(e, i)].evaluate(t);
            }
            eachChild(t) {
              t(this.input);
              for (const e of this.outputs) t(e);
            }
            outputDefined() {
              return this.outputs.every((t) => t.outputDefined());
            }
            serialize() {
              const t = ['step', this.input.serialize()];
              for (let e = 0; e < this.labels.length; e++)
                e > 0 && t.push(this.labels[e]),
                  t.push(this.outputs[e].serialize());
              return t;
            }
          }
          var jt = Gt;
          function Gt(t, e, n, i) {
            (this.cx = 3 * t),
              (this.bx = 3 * (n - t) - this.cx),
              (this.ax = 1 - this.cx - this.bx),
              (this.cy = 3 * e),
              (this.by = 3 * (i - e) - this.cy),
              (this.ay = 1 - this.cy - this.by),
              (this.p1x = t),
              (this.p1y = i),
              (this.p2x = n),
              (this.p2y = i);
          }
          function Ht(t, e, n) {
            return t * (1 - n) + e * n;
          }
          (Gt.prototype.sampleCurveX = function (t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }),
            (Gt.prototype.sampleCurveY = function (t) {
              return ((this.ay * t + this.by) * t + this.cy) * t;
            }),
            (Gt.prototype.sampleCurveDerivativeX = function (t) {
              return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
            }),
            (Gt.prototype.solveCurveX = function (t, e) {
              var n, i, r, a, o;
              for (void 0 === e && (e = 1e-6), r = t, o = 0; o < 8; o++) {
                if (((a = this.sampleCurveX(r) - t), Math.abs(a) < e)) return r;
                var s = this.sampleCurveDerivativeX(r);
                if (Math.abs(s) < 1e-6) break;
                r -= a / s;
              }
              if ((r = t) < (n = 0)) return n;
              if (r > (i = 1)) return i;
              for (; n < i; ) {
                if (((a = this.sampleCurveX(r)), Math.abs(a - t) < e)) return r;
                t > a ? (n = r) : (i = r), (r = 0.5 * (i - n) + n);
              }
              return r;
            }),
            (Gt.prototype.solve = function (t, e) {
              return this.sampleCurveY(this.solveCurveX(t, e));
            });
          var Vt = Object.freeze({
            __proto__: null,
            number: Ht,
            color: function (t, e, n) {
              return new Z(
                Ht(t.r, e.r, n),
                Ht(t.g, e.g, n),
                Ht(t.b, e.b, n),
                Ht(t.a, e.a, n),
              );
            },
            array: function (t, e, n) {
              return t.map((t, i) => Ht(t, e[i], n));
            },
          });
          const Wt = 6 / 29,
            Xt = 3 * Wt * Wt,
            Yt = Math.PI / 180,
            $t = 180 / Math.PI;
          function Jt(t) {
            return t > 0.008856451679035631
              ? Math.pow(t, 1 / 3)
              : t / Xt + 4 / 29;
          }
          function Zt(t) {
            return t > Wt ? t * t * t : Xt * (t - 4 / 29);
          }
          function Kt(t) {
            return (
              255 *
              (t <= 0.0031308
                ? 12.92 * t
                : 1.055 * Math.pow(t, 1 / 2.4) - 0.055)
            );
          }
          function Qt(t) {
            return (t /= 255) <= 0.04045
              ? t / 12.92
              : Math.pow((t + 0.055) / 1.055, 2.4);
          }
          function te(t) {
            const e = Qt(t.r),
              n = Qt(t.g),
              i = Qt(t.b),
              r = Jt((0.4124564 * e + 0.3575761 * n + 0.1804375 * i) / 0.95047),
              a = Jt((0.2126729 * e + 0.7151522 * n + 0.072175 * i) / 1);
            return {
              l: 116 * a - 16,
              a: 500 * (r - a),
              b:
                200 *
                (a -
                  Jt((0.0193339 * e + 0.119192 * n + 0.9503041 * i) / 1.08883)),
              alpha: t.a,
            };
          }
          function ee(t) {
            let e = (t.l + 16) / 116,
              n = isNaN(t.a) ? e : e + t.a / 500,
              i = isNaN(t.b) ? e : e - t.b / 200;
            return (
              (e = 1 * Zt(e)),
              (n = 0.95047 * Zt(n)),
              (i = 1.08883 * Zt(i)),
              new Z(
                Kt(3.2404542 * n - 1.5371385 * e - 0.4985314 * i),
                Kt(-0.969266 * n + 1.8760108 * e + 0.041556 * i),
                Kt(0.0556434 * n - 0.2040259 * e + 1.0572252 * i),
                t.alpha,
              )
            );
          }
          function ne(t, e, n) {
            const i = e - t;
            return (
              t + n * (i > 180 || i < -180 ? i - 360 * Math.round(i / 360) : i)
            );
          }
          const ie = {
              forward: te,
              reverse: ee,
              interpolate: function (t, e, n) {
                return {
                  l: Ht(t.l, e.l, n),
                  a: Ht(t.a, e.a, n),
                  b: Ht(t.b, e.b, n),
                  alpha: Ht(t.alpha, e.alpha, n),
                };
              },
            },
            re = {
              forward: function (t) {
                const { l: e, a: n, b: i } = te(t),
                  r = Math.atan2(i, n) * $t;
                return {
                  h: r < 0 ? r + 360 : r,
                  c: Math.sqrt(n * n + i * i),
                  l: e,
                  alpha: t.a,
                };
              },
              reverse: function (t) {
                const e = t.h * Yt,
                  n = t.c;
                return ee({
                  l: t.l,
                  a: Math.cos(e) * n,
                  b: Math.sin(e) * n,
                  alpha: t.alpha,
                });
              },
              interpolate: function (t, e, n) {
                return {
                  h: ne(t.h, e.h, n),
                  c: Ht(t.c, e.c, n),
                  l: Ht(t.l, e.l, n),
                  alpha: Ht(t.alpha, e.alpha, n),
                };
              },
            };
          var ae = Object.freeze({ __proto__: null, lab: ie, hcl: re });
          class oe {
            constructor(t, e, n, i, r) {
              (this.type = t),
                (this.operator = e),
                (this.interpolation = n),
                (this.input = i),
                (this.labels = []),
                (this.outputs = []);
              for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);
            }
            static interpolationFactor(t, e, n, i) {
              let r = 0;
              if ('exponential' === t.name) r = se(e, t.base, n, i);
              else if ('linear' === t.name) r = se(e, 1, n, i);
              else if ('cubic-bezier' === t.name) {
                const a = t.controlPoints;
                r = new jt(a[0], a[1], a[2], a[3]).solve(se(e, 1, n, i));
              }
              return r;
            }
            static parse(t, e) {
              let [n, i, r, ...a] = t;
              if (!Array.isArray(i) || 0 === i.length)
                return e.error('Expected an interpolation type expression.', 1);
              if ('linear' === i[0]) i = { name: 'linear' };
              else if ('exponential' === i[0]) {
                const t = i[1];
                if ('number' != typeof t)
                  return e.error(
                    'Exponential interpolation requires a numeric base.',
                    1,
                    1,
                  );
                i = { name: 'exponential', base: t };
              } else {
                if ('cubic-bezier' !== i[0])
                  return e.error(
                    'Unknown interpolation type ' + String(i[0]),
                    1,
                    0,
                  );
                {
                  const t = i.slice(1);
                  if (
                    4 !== t.length ||
                    t.some((t) => 'number' != typeof t || t < 0 || t > 1)
                  )
                    return e.error(
                      'Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.',
                      1,
                    );
                  i = { name: 'cubic-bezier', controlPoints: t };
                }
              }
              if (t.length - 1 < 4)
                return e.error(
                  `Expected at least 4 arguments, but found only ${
                    t.length - 1
                  }.`,
                );
              if ((t.length - 1) % 2 != 0)
                return e.error('Expected an even number of arguments.');
              if (((r = e.parse(r, 2, D)), !r)) return null;
              const o = [];
              let s = null;
              'interpolate-hcl' === n || 'interpolate-lab' === n
                ? (s = z)
                : e.expectedType &&
                  'value' !== e.expectedType.kind &&
                  (s = e.expectedType);
              for (let t = 0; t < a.length; t += 2) {
                const n = a[t],
                  i = a[t + 1],
                  r = t + 3,
                  l = t + 4;
                if ('number' != typeof n)
                  return e.error(
                    'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                    r,
                  );
                if (o.length && o[o.length - 1][0] >= n)
                  return e.error(
                    'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                    r,
                  );
                const c = e.parse(i, l, s);
                if (!c) return null;
                (s = s || c.type), o.push([n, c]);
              }
              return 'number' === s.kind ||
                'color' === s.kind ||
                ('array' === s.kind &&
                  'number' === s.itemType.kind &&
                  'number' == typeof s.N)
                ? new oe(s, n, i, r, o)
                : e.error(`Type ${V(s)} is not interpolatable.`);
            }
            evaluate(t) {
              const e = this.labels,
                n = this.outputs;
              if (1 === e.length) return n[0].evaluate(t);
              const i = this.input.evaluate(t);
              if (i <= e[0]) return n[0].evaluate(t);
              const r = e.length;
              if (i >= e[r - 1]) return n[r - 1].evaluate(t);
              const a = Bt(e, i),
                o = e[a],
                s = e[a + 1],
                l = oe.interpolationFactor(this.interpolation, i, o, s),
                c = n[a].evaluate(t),
                u = n[a + 1].evaluate(t);
              return 'interpolate' === this.operator
                ? Vt[this.type.kind.toLowerCase()](c, u, l)
                : 'interpolate-hcl' === this.operator
                ? re.reverse(re.interpolate(re.forward(c), re.forward(u), l))
                : ie.reverse(ie.interpolate(ie.forward(c), ie.forward(u), l));
            }
            eachChild(t) {
              t(this.input);
              for (const e of this.outputs) t(e);
            }
            outputDefined() {
              return this.outputs.every((t) => t.outputDefined());
            }
            serialize() {
              let t;
              t =
                'linear' === this.interpolation.name
                  ? ['linear']
                  : 'exponential' === this.interpolation.name
                  ? 1 === this.interpolation.base
                    ? ['linear']
                    : ['exponential', this.interpolation.base]
                  : ['cubic-bezier'].concat(this.interpolation.controlPoints);
              const e = [this.operator, t, this.input.serialize()];
              for (let t = 0; t < this.labels.length; t++)
                e.push(this.labels[t], this.outputs[t].serialize());
              return e;
            }
          }
          function se(t, e, n, i) {
            const r = i - n,
              a = t - n;
            return 0 === r
              ? 0
              : 1 === e
              ? a / r
              : (Math.pow(e, a) - 1) / (Math.pow(e, r) - 1);
          }
          class le {
            constructor(t, e) {
              (this.type = t), (this.args = e);
            }
            static parse(t, e) {
              if (t.length < 2)
                return e.error('Expectected at least one argument.');
              let n = null;
              const i = e.expectedType;
              i && 'value' !== i.kind && (n = i);
              const r = [];
              for (const i of t.slice(1)) {
                const t = e.parse(i, 1 + r.length, n, void 0, {
                  typeAnnotation: 'omit',
                });
                if (!t) return null;
                (n = n || t.type), r.push(t);
              }
              const a = i && r.some((t) => X(i, t.type));
              return new le(a ? B : n, r);
            }
            evaluate(t) {
              let e,
                n = null,
                i = 0;
              for (const r of this.args)
                if (
                  (i++,
                  (n = r.evaluate(t)),
                  n &&
                    n instanceof et &&
                    !n.available &&
                    (e || (e = n.name),
                    (n = null),
                    i === this.args.length && (n = e)),
                  null !== n)
                )
                  break;
              return n;
            }
            eachChild(t) {
              this.args.forEach(t);
            }
            outputDefined() {
              return this.args.every((t) => t.outputDefined());
            }
            serialize() {
              const t = ['coalesce'];
              return (
                this.eachChild((e) => {
                  t.push(e.serialize());
                }),
                t
              );
            }
          }
          class ce {
            constructor(t, e) {
              (this.type = e.type),
                (this.bindings = [].concat(t)),
                (this.result = e);
            }
            evaluate(t) {
              return this.result.evaluate(t);
            }
            eachChild(t) {
              for (const e of this.bindings) t(e[1]);
              t(this.result);
            }
            static parse(t, e) {
              if (t.length < 4)
                return e.error(
                  `Expected at least 3 arguments, but found ${
                    t.length - 1
                  } instead.`,
                );
              const n = [];
              for (let i = 1; i < t.length - 1; i += 2) {
                const r = t[i];
                if ('string' != typeof r)
                  return e.error(
                    `Expected string, but found ${typeof r} instead.`,
                    i,
                  );
                if (/[^a-zA-Z0-9_]/.test(r))
                  return e.error(
                    "Variable names must contain only alphanumeric characters or '_'.",
                    i,
                  );
                const a = e.parse(t[i + 1], i + 1);
                if (!a) return null;
                n.push([r, a]);
              }
              const i = e.parse(
                t[t.length - 1],
                t.length - 1,
                e.expectedType,
                n,
              );
              return i ? new ce(n, i) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
            serialize() {
              const t = ['let'];
              for (const [e, n] of this.bindings) t.push(e, n.serialize());
              return t.push(this.result.serialize()), t;
            }
          }
          class ue {
            constructor(t, e, n) {
              (this.type = t), (this.index = e), (this.input = n);
            }
            static parse(t, e) {
              if (3 !== t.length)
                return e.error(
                  `Expected 2 arguments, but found ${t.length - 1} instead.`,
                );
              const n = e.parse(t[1], 1, D),
                i = e.parse(t[2], 2, H(e.expectedType || B));
              if (!n || !i) return null;
              const r = i.type;
              return new ue(r.itemType, n, i);
            }
            evaluate(t) {
              const e = this.index.evaluate(t),
                n = this.input.evaluate(t);
              if (e < 0) throw new st(`Array index out of bounds: ${e} < 0.`);
              if (e >= n.length)
                throw new st(
                  `Array index out of bounds: ${e} > ${n.length - 1}.`,
                );
              if (e !== Math.floor(e))
                throw new st(
                  `Array index must be an integer, but found ${e} instead.`,
                );
              return n[e];
            }
            eachChild(t) {
              t(this.index), t(this.input);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              return ['at', this.index.serialize(), this.input.serialize()];
            }
          }
          class he {
            constructor(t, e) {
              (this.type = N), (this.needle = t), (this.haystack = e);
            }
            static parse(t, e) {
              if (3 !== t.length)
                return e.error(
                  `Expected 2 arguments, but found ${t.length - 1} instead.`,
                );
              const n = e.parse(t[1], 1, B),
                i = e.parse(t[2], 2, B);
              return n && i
                ? Y(n.type, [N, O, D, I, B])
                  ? new he(n, i)
                  : e.error(
                      `Expected first argument to be of type boolean, string, number or null, but found ${V(
                        n.type,
                      )} instead`,
                    )
                : null;
            }
            evaluate(t) {
              const e = this.needle.evaluate(t),
                n = this.haystack.evaluate(t);
              if (!n) return !1;
              if (!$(e, ['boolean', 'string', 'number', 'null']))
                throw new st(
                  `Expected first argument to be of type boolean, string, number or null, but found ${V(
                    rt(e),
                  )} instead.`,
                );
              if (!$(n, ['string', 'array']))
                throw new st(
                  `Expected second argument to be of type array or string, but found ${V(
                    rt(n),
                  )} instead.`,
                );
              return n.indexOf(e) >= 0;
            }
            eachChild(t) {
              t(this.needle), t(this.haystack);
            }
            outputDefined() {
              return !0;
            }
            serialize() {
              return ['in', this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class de {
            constructor(t, e, n) {
              (this.type = D),
                (this.needle = t),
                (this.haystack = e),
                (this.fromIndex = n);
            }
            static parse(t, e) {
              if (t.length <= 2 || t.length >= 5)
                return e.error(
                  `Expected 3 or 4 arguments, but found ${
                    t.length - 1
                  } instead.`,
                );
              const n = e.parse(t[1], 1, B),
                i = e.parse(t[2], 2, B);
              if (!n || !i) return null;
              if (!Y(n.type, [N, O, D, I, B]))
                return e.error(
                  `Expected first argument to be of type boolean, string, number or null, but found ${V(
                    n.type,
                  )} instead`,
                );
              if (4 === t.length) {
                const r = e.parse(t[3], 3, D);
                return r ? new de(n, i, r) : null;
              }
              return new de(n, i);
            }
            evaluate(t) {
              const e = this.needle.evaluate(t),
                n = this.haystack.evaluate(t);
              if (!$(e, ['boolean', 'string', 'number', 'null']))
                throw new st(
                  `Expected first argument to be of type boolean, string, number or null, but found ${V(
                    rt(e),
                  )} instead.`,
                );
              if (!$(n, ['string', 'array']))
                throw new st(
                  `Expected second argument to be of type array or string, but found ${V(
                    rt(n),
                  )} instead.`,
                );
              if (this.fromIndex) {
                const i = this.fromIndex.evaluate(t);
                return n.indexOf(e, i);
              }
              return n.indexOf(e);
            }
            eachChild(t) {
              t(this.needle),
                t(this.haystack),
                this.fromIndex && t(this.fromIndex);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              if (null != this.fromIndex && void 0 !== this.fromIndex) {
                const t = this.fromIndex.serialize();
                return [
                  'index-of',
                  this.needle.serialize(),
                  this.haystack.serialize(),
                  t,
                ];
              }
              return [
                'index-of',
                this.needle.serialize(),
                this.haystack.serialize(),
              ];
            }
          }
          class pe {
            constructor(t, e, n, i, r, a) {
              (this.inputType = t),
                (this.type = e),
                (this.input = n),
                (this.cases = i),
                (this.outputs = r),
                (this.otherwise = a);
            }
            static parse(t, e) {
              if (t.length < 5)
                return e.error(
                  `Expected at least 4 arguments, but found only ${
                    t.length - 1
                  }.`,
                );
              if (t.length % 2 != 1)
                return e.error('Expected an even number of arguments.');
              let n, i;
              e.expectedType &&
                'value' !== e.expectedType.kind &&
                (i = e.expectedType);
              const r = {},
                a = [];
              for (let o = 2; o < t.length - 1; o += 2) {
                let s = t[o];
                const l = t[o + 1];
                Array.isArray(s) || (s = [s]);
                const c = e.concat(o);
                if (0 === s.length)
                  return c.error('Expected at least one branch label.');
                for (const t of s) {
                  if ('number' != typeof t && 'string' != typeof t)
                    return c.error('Branch labels must be numbers or strings.');
                  if (
                    'number' == typeof t &&
                    Math.abs(t) > Number.MAX_SAFE_INTEGER
                  )
                    return c.error(
                      `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`,
                    );
                  if ('number' == typeof t && Math.floor(t) !== t)
                    return c.error(
                      'Numeric branch labels must be integer values.',
                    );
                  if (n) {
                    if (c.checkSubtype(n, rt(t))) return null;
                  } else n = rt(t);
                  if (void 0 !== r[String(t)])
                    return c.error('Branch labels must be unique.');
                  r[String(t)] = a.length;
                }
                const u = e.parse(l, o, i);
                if (!u) return null;
                (i = i || u.type), a.push(u);
              }
              const o = e.parse(t[1], 1, B);
              if (!o) return null;
              const s = e.parse(t[t.length - 1], t.length - 1, i);
              return s
                ? 'value' !== o.type.kind && e.concat(1).checkSubtype(n, o.type)
                  ? null
                  : new pe(n, i, o, r, a, s)
                : null;
            }
            evaluate(t) {
              const e = this.input.evaluate(t);
              return (
                (rt(e) === this.inputType && this.outputs[this.cases[e]]) ||
                this.otherwise
              ).evaluate(t);
            }
            eachChild(t) {
              t(this.input), this.outputs.forEach(t), t(this.otherwise);
            }
            outputDefined() {
              return (
                this.outputs.every((t) => t.outputDefined()) &&
                this.otherwise.outputDefined()
              );
            }
            serialize() {
              const t = ['match', this.input.serialize()],
                e = Object.keys(this.cases).sort(),
                n = [],
                i = {};
              for (const t of e) {
                const e = i[this.cases[t]];
                void 0 === e
                  ? ((i[this.cases[t]] = n.length),
                    n.push([this.cases[t], [t]]))
                  : n[e][1].push(t);
              }
              const r = (t) =>
                'number' === this.inputType.kind ? Number(t) : t;
              for (const [e, i] of n)
                1 === i.length ? t.push(r(i[0])) : t.push(i.map(r)),
                  t.push(this.outputs[e].serialize());
              return t.push(this.otherwise.serialize()), t;
            }
          }
          class fe {
            constructor(t, e, n) {
              (this.type = t), (this.branches = e), (this.otherwise = n);
            }
            static parse(t, e) {
              if (t.length < 4)
                return e.error(
                  `Expected at least 3 arguments, but found only ${
                    t.length - 1
                  }.`,
                );
              if (t.length % 2 != 0)
                return e.error('Expected an odd number of arguments.');
              let n;
              e.expectedType &&
                'value' !== e.expectedType.kind &&
                (n = e.expectedType);
              const i = [];
              for (let r = 1; r < t.length - 1; r += 2) {
                const a = e.parse(t[r], r, N);
                if (!a) return null;
                const o = e.parse(t[r + 1], r + 1, n);
                if (!o) return null;
                i.push([a, o]), (n = n || o.type);
              }
              const r = e.parse(t[t.length - 1], t.length - 1, n);
              return r ? new fe(n, i, r) : null;
            }
            evaluate(t) {
              for (const [e, n] of this.branches)
                if (e.evaluate(t)) return n.evaluate(t);
              return this.otherwise.evaluate(t);
            }
            eachChild(t) {
              for (const [e, n] of this.branches) t(e), t(n);
              t(this.otherwise);
            }
            outputDefined() {
              return (
                this.branches.every(([t, e]) => e.outputDefined()) &&
                this.otherwise.outputDefined()
              );
            }
            serialize() {
              const t = ['case'];
              return (
                this.eachChild((e) => {
                  t.push(e.serialize());
                }),
                t
              );
            }
          }
          class me {
            constructor(t, e, n, i) {
              (this.type = t),
                (this.input = e),
                (this.beginIndex = n),
                (this.endIndex = i);
            }
            static parse(t, e) {
              if (t.length <= 2 || t.length >= 5)
                return e.error(
                  `Expected 3 or 4 arguments, but found ${
                    t.length - 1
                  } instead.`,
                );
              const n = e.parse(t[1], 1, B),
                i = e.parse(t[2], 2, D);
              if (!n || !i) return null;
              if (!Y(n.type, [H(B), O, B]))
                return e.error(
                  `Expected first argument to be of type array or string, but found ${V(
                    n.type,
                  )} instead`,
                );
              if (4 === t.length) {
                const r = e.parse(t[3], 3, D);
                return r ? new me(n.type, n, i, r) : null;
              }
              return new me(n.type, n, i);
            }
            evaluate(t) {
              const e = this.input.evaluate(t),
                n = this.beginIndex.evaluate(t);
              if (!$(e, ['string', 'array']))
                throw new st(
                  `Expected first argument to be of type array or string, but found ${V(
                    rt(e),
                  )} instead.`,
                );
              if (this.endIndex) {
                const i = this.endIndex.evaluate(t);
                return e.slice(n, i);
              }
              return e.slice(n);
            }
            eachChild(t) {
              t(this.input),
                t(this.beginIndex),
                this.endIndex && t(this.endIndex);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              if (null != this.endIndex && void 0 !== this.endIndex) {
                const t = this.endIndex.serialize();
                return [
                  'slice',
                  this.input.serialize(),
                  this.beginIndex.serialize(),
                  t,
                ];
              }
              return [
                'slice',
                this.input.serialize(),
                this.beginIndex.serialize(),
              ];
            }
          }
          function ge(t, e) {
            return '==' === t || '!=' === t
              ? 'boolean' === e.kind ||
                  'string' === e.kind ||
                  'number' === e.kind ||
                  'null' === e.kind ||
                  'value' === e.kind
              : 'string' === e.kind ||
                  'number' === e.kind ||
                  'value' === e.kind;
          }
          function ye(t, e, n, i) {
            return 0 === i.compare(e, n);
          }
          function ve(t, e, n) {
            const i = '==' !== t && '!=' !== t;
            return class r {
              constructor(t, e, n) {
                (this.type = N),
                  (this.lhs = t),
                  (this.rhs = e),
                  (this.collator = n),
                  (this.hasUntypedArgument =
                    'value' === t.type.kind || 'value' === e.type.kind);
              }
              static parse(t, e) {
                if (3 !== t.length && 4 !== t.length)
                  return e.error('Expected two or three arguments.');
                const n = t[0];
                let a = e.parse(t[1], 1, B);
                if (!a) return null;
                if (!ge(n, a.type))
                  return e
                    .concat(1)
                    .error(
                      `"${n}" comparisons are not supported for type '${V(
                        a.type,
                      )}'.`,
                    );
                let o = e.parse(t[2], 2, B);
                if (!o) return null;
                if (!ge(n, o.type))
                  return e
                    .concat(2)
                    .error(
                      `"${n}" comparisons are not supported for type '${V(
                        o.type,
                      )}'.`,
                    );
                if (
                  a.type.kind !== o.type.kind &&
                  'value' !== a.type.kind &&
                  'value' !== o.type.kind
                )
                  return e.error(
                    `Cannot compare types '${V(a.type)}' and '${V(o.type)}'.`,
                  );
                i &&
                  ('value' === a.type.kind && 'value' !== o.type.kind
                    ? (a = new ct(o.type, [a]))
                    : 'value' !== a.type.kind &&
                      'value' === o.type.kind &&
                      (o = new ct(a.type, [o])));
                let s = null;
                if (4 === t.length) {
                  if (
                    'string' !== a.type.kind &&
                    'string' !== o.type.kind &&
                    'value' !== a.type.kind &&
                    'value' !== o.type.kind
                  )
                    return e.error(
                      'Cannot use collator to compare non-string types.',
                    );
                  if (((s = e.parse(t[3], 3, U)), !s)) return null;
                }
                return new r(a, o, s);
              }
              evaluate(r) {
                const a = this.lhs.evaluate(r),
                  o = this.rhs.evaluate(r);
                if (i && this.hasUntypedArgument) {
                  const e = rt(a),
                    n = rt(o);
                  if (
                    e.kind !== n.kind ||
                    ('string' !== e.kind && 'number' !== e.kind)
                  )
                    throw new st(
                      `Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${n.kind}) instead.`,
                    );
                }
                if (this.collator && !i && this.hasUntypedArgument) {
                  const t = rt(a),
                    n = rt(o);
                  if ('string' !== t.kind || 'string' !== n.kind)
                    return e(r, a, o);
                }
                return this.collator
                  ? n(r, a, o, this.collator.evaluate(r))
                  : e(r, a, o);
              }
              eachChild(t) {
                t(this.lhs), t(this.rhs), this.collator && t(this.collator);
              }
              outputDefined() {
                return !0;
              }
              serialize() {
                const e = [t];
                return (
                  this.eachChild((t) => {
                    e.push(t.serialize());
                  }),
                  e
                );
              }
            };
          }
          const xe = ve(
              '==',
              function (t, e, n) {
                return e === n;
              },
              ye,
            ),
            be = ve(
              '!=',
              function (t, e, n) {
                return e !== n;
              },
              function (t, e, n, i) {
                return !ye(0, e, n, i);
              },
            ),
            _e = ve(
              '<',
              function (t, e, n) {
                return e < n;
              },
              function (t, e, n, i) {
                return i.compare(e, n) < 0;
              },
            ),
            we = ve(
              '>',
              function (t, e, n) {
                return e > n;
              },
              function (t, e, n, i) {
                return i.compare(e, n) > 0;
              },
            ),
            Me = ve(
              '<=',
              function (t, e, n) {
                return e <= n;
              },
              function (t, e, n, i) {
                return i.compare(e, n) <= 0;
              },
            ),
            qe = ve(
              '>=',
              function (t, e, n) {
                return e >= n;
              },
              function (t, e, n, i) {
                return i.compare(e, n) >= 0;
              },
            );
          class Se {
            constructor(t, e, n, i, r) {
              (this.type = O),
                (this.number = t),
                (this.locale = e),
                (this.currency = n),
                (this.minFractionDigits = i),
                (this.maxFractionDigits = r);
            }
            static parse(t, e) {
              if (3 !== t.length) return e.error('Expected two arguments.');
              const n = e.parse(t[1], 1, D);
              if (!n) return null;
              const i = t[2];
              if ('object' != typeof i || Array.isArray(i))
                return e.error(
                  'NumberFormat options argument must be an object.',
                );
              let r = null;
              if (i.locale && ((r = e.parse(i.locale, 1, O)), !r)) return null;
              let a = null;
              if (i.currency && ((a = e.parse(i.currency, 1, O)), !a))
                return null;
              let o = null;
              if (
                i['min-fraction-digits'] &&
                ((o = e.parse(i['min-fraction-digits'], 1, D)), !o)
              )
                return null;
              let s = null;
              return i['max-fraction-digits'] &&
                ((s = e.parse(i['max-fraction-digits'], 1, D)), !s)
                ? null
                : new Se(n, r, a, o, s);
            }
            evaluate(t) {
              return new Intl.NumberFormat(
                this.locale ? this.locale.evaluate(t) : [],
                {
                  style: this.currency ? 'currency' : 'decimal',
                  currency: this.currency ? this.currency.evaluate(t) : void 0,
                  minimumFractionDigits: this.minFractionDigits
                    ? this.minFractionDigits.evaluate(t)
                    : void 0,
                  maximumFractionDigits: this.maxFractionDigits
                    ? this.maxFractionDigits.evaluate(t)
                    : void 0,
                },
              ).format(this.number.evaluate(t));
            }
            eachChild(t) {
              t(this.number),
                this.locale && t(this.locale),
                this.currency && t(this.currency),
                this.minFractionDigits && t(this.minFractionDigits),
                this.maxFractionDigits && t(this.maxFractionDigits);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              const t = {};
              return (
                this.locale && (t.locale = this.locale.serialize()),
                this.currency && (t.currency = this.currency.serialize()),
                this.minFractionDigits &&
                  (t['min-fraction-digits'] =
                    this.minFractionDigits.serialize()),
                this.maxFractionDigits &&
                  (t['max-fraction-digits'] =
                    this.maxFractionDigits.serialize()),
                ['number-format', this.number.serialize(), t]
              );
            }
          }
          class Te {
            constructor(t) {
              (this.type = D), (this.input = t);
            }
            static parse(t, e) {
              if (2 !== t.length)
                return e.error(
                  `Expected 1 argument, but found ${t.length - 1} instead.`,
                );
              const n = e.parse(t[1], 1);
              return n
                ? 'array' !== n.type.kind &&
                  'string' !== n.type.kind &&
                  'value' !== n.type.kind
                  ? e.error(
                      `Expected argument of type string or array, but found ${V(
                        n.type,
                      )} instead.`,
                    )
                  : new Te(n)
                : null;
            }
            evaluate(t) {
              const e = this.input.evaluate(t);
              if ('string' == typeof e) return e.length;
              if (Array.isArray(e)) return e.length;
              throw new st(
                `Expected value to be of type string or array, but found ${V(
                  rt(e),
                )} instead.`,
              );
            }
            eachChild(t) {
              t(this.input);
            }
            outputDefined() {
              return !1;
            }
            serialize() {
              const t = ['length'];
              return (
                this.eachChild((e) => {
                  t.push(e.serialize());
                }),
                t
              );
            }
          }
          const Ee = {
            '==': xe,
            '!=': be,
            '>': we,
            '<': _e,
            '>=': qe,
            '<=': Me,
            array: ct,
            at: ue,
            boolean: ct,
            case: fe,
            coalesce: le,
            collator: yt,
            format: ut,
            image: ht,
            in: he,
            'index-of': de,
            interpolate: oe,
            'interpolate-hcl': oe,
            'interpolate-lab': oe,
            length: Te,
            let: ce,
            literal: ot,
            match: pe,
            number: ct,
            'number-format': Se,
            object: ct,
            slice: me,
            step: Ut,
            string: ct,
            'to-boolean': pt,
            'to-color': pt,
            'to-number': pt,
            'to-string': pt,
            var: zt,
            within: It,
          };
          function Ae(t, [e, n, i, r]) {
            (e = e.evaluate(t)), (n = n.evaluate(t)), (i = i.evaluate(t));
            const a = r ? r.evaluate(t) : 1,
              o = nt(e, n, i, a);
            if (o) throw new st(o);
            return new Z((e / 255) * a, (n / 255) * a, (i / 255) * a, a);
          }
          function Le(t, e) {
            return t in e;
          }
          function Re(t, e) {
            const n = e[t];
            return void 0 === n ? null : n;
          }
          function Ce(t) {
            return { type: t };
          }
          function Pe(t) {
            return { result: 'success', value: t };
          }
          function ke(t) {
            return { result: 'error', value: t };
          }
          function Ie(t) {
            return (
              'data-driven' === t['property-type'] ||
              'cross-faded-data-driven' === t['property-type']
            );
          }
          function De(t) {
            return (
              !!t.expression && t.expression.parameters.indexOf('zoom') > -1
            );
          }
          function Oe(t) {
            return !!t.expression && t.expression.interpolated;
          }
          function Ne(t) {
            return t instanceof Number
              ? 'number'
              : t instanceof String
              ? 'string'
              : t instanceof Boolean
              ? 'boolean'
              : Array.isArray(t)
              ? 'array'
              : null === t
              ? 'null'
              : typeof t;
          }
          function ze(t) {
            return 'object' == typeof t && null !== t && !Array.isArray(t);
          }
          function Fe(t) {
            return t;
          }
          function Be(t, e) {
            const n = 'color' === e.type,
              i = t.stops && 'object' == typeof t.stops[0][0],
              r = i || void 0 !== t.property,
              a = i || !r,
              o = t.type || (Oe(e) ? 'exponential' : 'interval');
            if (
              (n &&
                ((t = C({}, t)).stops &&
                  (t.stops = t.stops.map((t) => [t[0], Z.parse(t[1])])),
                t.default
                  ? (t.default = Z.parse(t.default))
                  : (t.default = Z.parse(e.default))),
              t.colorSpace && 'rgb' !== t.colorSpace && !ae[t.colorSpace])
            )
              throw new Error('Unknown color space: ' + t.colorSpace);
            let s, l, c;
            if ('exponential' === o) s = He;
            else if ('interval' === o) s = Ge;
            else if ('categorical' === o) {
              (s = je), (l = Object.create(null));
              for (const e of t.stops) l[e[0]] = e[1];
              c = typeof t.stops[0][0];
            } else {
              if ('identity' !== o)
                throw new Error(`Unknown function type "${o}"`);
              s = Ve;
            }
            if (i) {
              const n = {},
                i = [];
              for (let e = 0; e < t.stops.length; e++) {
                const r = t.stops[e],
                  a = r[0].zoom;
                void 0 === n[a] &&
                  ((n[a] = {
                    zoom: a,
                    type: t.type,
                    property: t.property,
                    default: t.default,
                    stops: [],
                  }),
                  i.push(a)),
                  n[a].stops.push([r[0].value, r[1]]);
              }
              const r = [];
              for (const t of i) r.push([n[t].zoom, Be(n[t], e)]);
              const a = { name: 'linear' };
              return {
                kind: 'composite',
                interpolationType: a,
                interpolationFactor: oe.interpolationFactor.bind(void 0, a),
                zoomStops: r.map((t) => t[0]),
                evaluate: ({ zoom: n }, i) =>
                  He({ stops: r, base: t.base }, e, n).evaluate(n, i),
              };
            }
            if (a) {
              const n =
                'exponential' === o
                  ? {
                      name: 'exponential',
                      base: void 0 !== t.base ? t.base : 1,
                    }
                  : null;
              return {
                kind: 'camera',
                interpolationType: n,
                interpolationFactor: oe.interpolationFactor.bind(void 0, n),
                zoomStops: t.stops.map((t) => t[0]),
                evaluate: ({ zoom: n }) => s(t, e, n, l, c),
              };
            }
            return {
              kind: 'source',
              evaluate(n, i) {
                const r = i && i.properties ? i.properties[t.property] : void 0;
                return void 0 === r
                  ? Ue(t.default, e.default)
                  : s(t, e, r, l, c);
              },
            };
          }
          function Ue(t, e, n) {
            return void 0 !== t
              ? t
              : void 0 !== e
              ? e
              : void 0 !== n
              ? n
              : void 0;
          }
          function je(t, e, n, i, r) {
            return Ue(typeof n === r ? i[n] : void 0, t.default, e.default);
          }
          function Ge(t, e, n) {
            if ('number' !== Ne(n)) return Ue(t.default, e.default);
            const i = t.stops.length;
            if (1 === i) return t.stops[0][1];
            if (n <= t.stops[0][0]) return t.stops[0][1];
            if (n >= t.stops[i - 1][0]) return t.stops[i - 1][1];
            const r = Bt(
              t.stops.map((t) => t[0]),
              n,
            );
            return t.stops[r][1];
          }
          function He(t, e, n) {
            const i = void 0 !== t.base ? t.base : 1;
            if ('number' !== Ne(n)) return Ue(t.default, e.default);
            const r = t.stops.length;
            if (1 === r) return t.stops[0][1];
            if (n <= t.stops[0][0]) return t.stops[0][1];
            if (n >= t.stops[r - 1][0]) return t.stops[r - 1][1];
            const a = Bt(
                t.stops.map((t) => t[0]),
                n,
              ),
              o = (function (t, e, n, i) {
                const r = i - n,
                  a = t - n;
                return 0 === r
                  ? 0
                  : 1 === e
                  ? a / r
                  : (Math.pow(e, a) - 1) / (Math.pow(e, r) - 1);
              })(n, i, t.stops[a][0], t.stops[a + 1][0]),
              s = t.stops[a][1],
              l = t.stops[a + 1][1];
            let c = Vt[e.type] || Fe;
            if (t.colorSpace && 'rgb' !== t.colorSpace) {
              const e = ae[t.colorSpace];
              c = (t, n) =>
                e.reverse(e.interpolate(e.forward(t), e.forward(n), o));
            }
            return 'function' == typeof s.evaluate
              ? {
                  evaluate(...t) {
                    const e = s.evaluate.apply(void 0, t),
                      n = l.evaluate.apply(void 0, t);
                    if (void 0 !== e && void 0 !== n) return c(e, n, o);
                  },
                }
              : c(s, l, o);
          }
          function Ve(t, e, n) {
            return (
              'color' === e.type
                ? (n = Z.parse(n))
                : 'formatted' === e.type
                ? (n = tt.fromString(n.toString()))
                : 'resolvedImage' === e.type
                ? (n = et.fromString(n.toString()))
                : Ne(n) === e.type ||
                  ('enum' === e.type && e.values[n]) ||
                  (n = void 0),
              Ue(n, t.default, e.default)
            );
          }
          gt.register(Ee, {
            error: [
              { kind: 'error' },
              [O],
              (t, [e]) => {
                throw new st(e.evaluate(t));
              },
            ],
            typeof: [O, [B], (t, [e]) => V(rt(e.evaluate(t)))],
            'to-rgba': [H(D, 4), [z], (t, [e]) => e.evaluate(t).toArray()],
            rgb: [z, [D, D, D], Ae],
            rgba: [z, [D, D, D, D], Ae],
            has: {
              type: N,
              overloads: [
                [[O], (t, [e]) => Le(e.evaluate(t), t.properties())],
                [[O, F], (t, [e, n]) => Le(e.evaluate(t), n.evaluate(t))],
              ],
            },
            get: {
              type: B,
              overloads: [
                [[O], (t, [e]) => Re(e.evaluate(t), t.properties())],
                [[O, F], (t, [e, n]) => Re(e.evaluate(t), n.evaluate(t))],
              ],
            },
            'feature-state': [
              B,
              [O],
              (t, [e]) => Re(e.evaluate(t), t.featureState || {}),
            ],
            properties: [F, [], (t) => t.properties()],
            'geometry-type': [O, [], (t) => t.geometryType()],
            id: [B, [], (t) => t.id()],
            zoom: [D, [], (t) => t.globals.zoom],
            'heatmap-density': [D, [], (t) => t.globals.heatmapDensity || 0],
            'line-progress': [D, [], (t) => t.globals.lineProgress || 0],
            'sky-radial-progress': [
              D,
              [],
              (t) => t.globals.skyRadialProgress || 0,
            ],
            accumulated: [
              B,
              [],
              (t) =>
                void 0 === t.globals.accumulated ? null : t.globals.accumulated,
            ],
            '+': [
              D,
              Ce(D),
              (t, e) => {
                let n = 0;
                for (const i of e) n += i.evaluate(t);
                return n;
              },
            ],
            '*': [
              D,
              Ce(D),
              (t, e) => {
                let n = 1;
                for (const i of e) n *= i.evaluate(t);
                return n;
              },
            ],
            '-': {
              type: D,
              overloads: [
                [[D, D], (t, [e, n]) => e.evaluate(t) - n.evaluate(t)],
                [[D], (t, [e]) => -e.evaluate(t)],
              ],
            },
            '/': [D, [D, D], (t, [e, n]) => e.evaluate(t) / n.evaluate(t)],
            '%': [D, [D, D], (t, [e, n]) => e.evaluate(t) % n.evaluate(t)],
            ln2: [D, [], () => Math.LN2],
            pi: [D, [], () => Math.PI],
            e: [D, [], () => Math.E],
            '^': [
              D,
              [D, D],
              (t, [e, n]) => Math.pow(e.evaluate(t), n.evaluate(t)),
            ],
            sqrt: [D, [D], (t, [e]) => Math.sqrt(e.evaluate(t))],
            log10: [D, [D], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],
            ln: [D, [D], (t, [e]) => Math.log(e.evaluate(t))],
            log2: [D, [D], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
            sin: [D, [D], (t, [e]) => Math.sin(e.evaluate(t))],
            cos: [D, [D], (t, [e]) => Math.cos(e.evaluate(t))],
            tan: [D, [D], (t, [e]) => Math.tan(e.evaluate(t))],
            asin: [D, [D], (t, [e]) => Math.asin(e.evaluate(t))],
            acos: [D, [D], (t, [e]) => Math.acos(e.evaluate(t))],
            atan: [D, [D], (t, [e]) => Math.atan(e.evaluate(t))],
            min: [D, Ce(D), (t, e) => Math.min(...e.map((e) => e.evaluate(t)))],
            max: [D, Ce(D), (t, e) => Math.max(...e.map((e) => e.evaluate(t)))],
            abs: [D, [D], (t, [e]) => Math.abs(e.evaluate(t))],
            round: [
              D,
              [D],
              (t, [e]) => {
                const n = e.evaluate(t);
                return n < 0 ? -Math.round(-n) : Math.round(n);
              },
            ],
            floor: [D, [D], (t, [e]) => Math.floor(e.evaluate(t))],
            ceil: [D, [D], (t, [e]) => Math.ceil(e.evaluate(t))],
            'filter-==': [
              N,
              [O, B],
              (t, [e, n]) => t.properties()[e.value] === n.value,
            ],
            'filter-id-==': [N, [B], (t, [e]) => t.id() === e.value],
            'filter-type-==': [
              N,
              [O],
              (t, [e]) => t.geometryType() === e.value,
            ],
            'filter-<': [
              N,
              [O, B],
              (t, [e, n]) => {
                const i = t.properties()[e.value],
                  r = n.value;
                return typeof i == typeof r && i < r;
              },
            ],
            'filter-id-<': [
              N,
              [B],
              (t, [e]) => {
                const n = t.id(),
                  i = e.value;
                return typeof n == typeof i && n < i;
              },
            ],
            'filter->': [
              N,
              [O, B],
              (t, [e, n]) => {
                const i = t.properties()[e.value],
                  r = n.value;
                return typeof i == typeof r && i > r;
              },
            ],
            'filter-id->': [
              N,
              [B],
              (t, [e]) => {
                const n = t.id(),
                  i = e.value;
                return typeof n == typeof i && n > i;
              },
            ],
            'filter-<=': [
              N,
              [O, B],
              (t, [e, n]) => {
                const i = t.properties()[e.value],
                  r = n.value;
                return typeof i == typeof r && i <= r;
              },
            ],
            'filter-id-<=': [
              N,
              [B],
              (t, [e]) => {
                const n = t.id(),
                  i = e.value;
                return typeof n == typeof i && n <= i;
              },
            ],
            'filter->=': [
              N,
              [O, B],
              (t, [e, n]) => {
                const i = t.properties()[e.value],
                  r = n.value;
                return typeof i == typeof r && i >= r;
              },
            ],
            'filter-id->=': [
              N,
              [B],
              (t, [e]) => {
                const n = t.id(),
                  i = e.value;
                return typeof n == typeof i && n >= i;
              },
            ],
            'filter-has': [N, [B], (t, [e]) => e.value in t.properties()],
            'filter-has-id': [
              N,
              [],
              (t) => null !== t.id() && void 0 !== t.id(),
            ],
            'filter-type-in': [
              N,
              [H(O)],
              (t, [e]) => e.value.indexOf(t.geometryType()) >= 0,
            ],
            'filter-id-in': [
              N,
              [H(B)],
              (t, [e]) => e.value.indexOf(t.id()) >= 0,
            ],
            'filter-in-small': [
              N,
              [O, H(B)],
              (t, [e, n]) => n.value.indexOf(t.properties()[e.value]) >= 0,
            ],
            'filter-in-large': [
              N,
              [O, H(B)],
              (t, [e, n]) =>
                (function (t, e, n, i) {
                  for (; n <= i; ) {
                    const r = (n + i) >> 1;
                    if (e[r] === t) return !0;
                    e[r] > t ? (i = r - 1) : (n = r + 1);
                  }
                  return !1;
                })(t.properties()[e.value], n.value, 0, n.value.length - 1),
            ],
            all: {
              type: N,
              overloads: [
                [[N, N], (t, [e, n]) => e.evaluate(t) && n.evaluate(t)],
                [
                  Ce(N),
                  (t, e) => {
                    for (const n of e) if (!n.evaluate(t)) return !1;
                    return !0;
                  },
                ],
              ],
            },
            any: {
              type: N,
              overloads: [
                [[N, N], (t, [e, n]) => e.evaluate(t) || n.evaluate(t)],
                [
                  Ce(N),
                  (t, e) => {
                    for (const n of e) if (n.evaluate(t)) return !0;
                    return !1;
                  },
                ],
              ],
            },
            '!': [N, [N], (t, [e]) => !e.evaluate(t)],
            'is-supported-script': [
              N,
              [O],
              (t, [e]) => {
                const n = t.globals && t.globals.isSupportedScript;
                return !n || n(e.evaluate(t));
              },
            ],
            upcase: [O, [O], (t, [e]) => e.evaluate(t).toUpperCase()],
            downcase: [O, [O], (t, [e]) => e.evaluate(t).toLowerCase()],
            concat: [
              O,
              Ce(B),
              (t, e) => e.map((e) => at(e.evaluate(t))).join(''),
            ],
            'resolved-locale': [
              O,
              [U],
              (t, [e]) => e.evaluate(t).resolvedLocale(),
            ],
          });
          class We {
            constructor(t, e) {
              var n;
              (this.expression = t),
                (this._warningHistory = {}),
                (this._evaluator = new mt()),
                (this._defaultValue = e
                  ? 'color' === (n = e).type && ze(n.default)
                    ? new Z(0, 0, 0, 0)
                    : 'color' === n.type
                    ? Z.parse(n.default) || null
                    : void 0 === n.default
                    ? null
                    : n.default
                  : null),
                (this._enumValues = e && 'enum' === e.type ? e.values : null);
            }
            evaluateWithoutErrorHandling(t, e, n, i, r, a) {
              return (
                (this._evaluator.globals = t),
                (this._evaluator.feature = e),
                (this._evaluator.featureState = n),
                (this._evaluator.canonical = i),
                (this._evaluator.availableImages = r || null),
                (this._evaluator.formattedSection = a),
                this.expression.evaluate(this._evaluator)
              );
            }
            evaluate(t, e, n, i, r, a) {
              (this._evaluator.globals = t),
                (this._evaluator.feature = e || null),
                (this._evaluator.featureState = n || null),
                (this._evaluator.canonical = i),
                (this._evaluator.availableImages = r || null),
                (this._evaluator.formattedSection = a || null);
              try {
                const t = this.expression.evaluate(this._evaluator);
                if (null == t || ('number' == typeof t && t != t))
                  return this._defaultValue;
                if (this._enumValues && !(t in this._enumValues))
                  throw new st(
                    `Expected value to be one of ${Object.keys(this._enumValues)
                      .map((t) => JSON.stringify(t))
                      .join(', ')}, but found ${JSON.stringify(t)} instead.`,
                  );
                return t;
              } catch (t) {
                return (
                  this._warningHistory[t.message] ||
                    ((this._warningHistory[t.message] = !0),
                    'undefined' != typeof console && console.warn(t.message)),
                  this._defaultValue
                );
              }
            }
          }
          function Xe(t) {
            return (
              Array.isArray(t) &&
              t.length > 0 &&
              'string' == typeof t[0] &&
              t[0] in Ee
            );
          }
          function Ye(t, e) {
            const n = new Ft(
                Ee,
                [],
                e
                  ? (function (t) {
                      const e = {
                        color: z,
                        string: O,
                        number: D,
                        enum: O,
                        boolean: N,
                        formatted: j,
                        resolvedImage: G,
                      };
                      if ('array' === t.type)
                        return H(e[t.value] || B, t.length);
                      return e[t.type];
                    })(e)
                  : void 0,
              ),
              i = n.parse(
                t,
                void 0,
                void 0,
                void 0,
                e && 'string' === e.type
                  ? { typeAnnotation: 'coerce' }
                  : void 0,
              );
            return i ? Pe(new We(i, e)) : ke(n.errors);
          }
          class $e {
            constructor(t, e) {
              (this.kind = t),
                (this._styleExpression = e),
                (this.isStateDependent = 'constant' !== t && !Ot(e.expression));
            }
            evaluateWithoutErrorHandling(t, e, n, i, r, a) {
              return this._styleExpression.evaluateWithoutErrorHandling(
                t,
                e,
                n,
                i,
                r,
                a,
              );
            }
            evaluate(t, e, n, i, r, a) {
              return this._styleExpression.evaluate(t, e, n, i, r, a);
            }
          }
          class Je {
            constructor(t, e, n, i) {
              (this.kind = t),
                (this.zoomStops = n),
                (this._styleExpression = e),
                (this.isStateDependent = 'camera' !== t && !Ot(e.expression)),
                (this.interpolationType = i);
            }
            evaluateWithoutErrorHandling(t, e, n, i, r, a) {
              return this._styleExpression.evaluateWithoutErrorHandling(
                t,
                e,
                n,
                i,
                r,
                a,
              );
            }
            evaluate(t, e, n, i, r, a) {
              return this._styleExpression.evaluate(t, e, n, i, r, a);
            }
            interpolationFactor(t, e, n) {
              return this.interpolationType
                ? oe.interpolationFactor(this.interpolationType, t, e, n)
                : 0;
            }
          }
          function Ze(t, e) {
            if ('error' === (t = Ye(t, e)).result) return t;
            const n = t.value.expression,
              i = Dt(n);
            if (!i && !Ie(e))
              return ke([new P('', 'data expressions not supported')]);
            const r = Nt(n, ['zoom']);
            if (!r && !De(e))
              return ke([new P('', 'zoom expressions not supported')]);
            const a = (function t(e) {
              let n = null;
              if (e instanceof ce) n = t(e.result);
              else if (e instanceof le) {
                for (const i of e.args) if (((n = t(i)), n)) break;
              } else
                (e instanceof Ut || e instanceof oe) &&
                  e.input instanceof gt &&
                  'zoom' === e.input.name &&
                  (n = e);
              if (n instanceof P) return n;
              return (
                e.eachChild((e) => {
                  const i = t(e);
                  i instanceof P
                    ? (n = i)
                    : !n && i
                    ? (n = new P(
                        '',
                        '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.',
                      ))
                    : n &&
                      i &&
                      n !== i &&
                      (n = new P(
                        '',
                        'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.',
                      ));
                }),
                n
              );
            })(n);
            if (!a && !r)
              return ke([
                new P(
                  '',
                  '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.',
                ),
              ]);
            if (a instanceof P) return ke([a]);
            if (a instanceof oe && !Oe(e))
              return ke([
                new P(
                  '',
                  '"interpolate" expressions cannot be used with this property',
                ),
              ]);
            if (!a) return Pe(new $e(i ? 'constant' : 'source', t.value));
            const o = a instanceof oe ? a.interpolation : void 0;
            return Pe(new Je(i ? 'camera' : 'composite', t.value, a.labels, o));
          }
          class Ke {
            constructor(t, e) {
              (this._parameters = t),
                (this._specification = e),
                C(this, Be(this._parameters, this._specification));
            }
            static deserialize(t) {
              return new Ke(t._parameters, t._specification);
            }
            static serialize(t) {
              return {
                _parameters: t._parameters,
                _specification: t._specification,
              };
            }
          }
          function Qe(t) {
            if (!0 === t || !1 === t) return !0;
            if (!Array.isArray(t) || 0 === t.length) return !1;
            switch (t[0]) {
              case 'has':
                return t.length >= 2 && '$id' !== t[1] && '$type' !== t[1];
              case 'in':
                return (
                  t.length >= 3 &&
                  ('string' != typeof t[1] || Array.isArray(t[2]))
                );
              case '!in':
              case '!has':
              case 'none':
                return !1;
              case '==':
              case '!=':
              case '>':
              case '>=':
              case '<':
              case '<=':
                return (
                  3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2])
                );
              case 'any':
              case 'all':
                for (const e of t.slice(1))
                  if (!Qe(e) && 'boolean' != typeof e) return !1;
                return !0;
              default:
                return !0;
            }
          }
          const tn = {
            type: 'boolean',
            default: !1,
            transition: !1,
            'property-type': 'data-driven',
            expression: { interpolated: !1, parameters: ['zoom', 'feature'] },
          };
          function en(t) {
            if (null == t) return { filter: () => !0, needGeometry: !1 };
            Qe(t) || (t = rn(t));
            const e = Ye(t, tn);
            if ('error' === e.result)
              throw new Error(
                e.value.map((t) => `${t.key}: ${t.message}`).join(', '),
              );
            return {
              filter: (t, n, i) => e.value.evaluate(t, n, {}, i),
              needGeometry: (function t(e) {
                if (!Array.isArray(e)) return !1;
                if ('within' === e[0]) return !0;
                for (let n = 1; n < e.length; n++) if (t(e[n])) return !0;
                return !1;
              })(t),
            };
          }
          function nn(t, e) {
            return t < e ? -1 : t > e ? 1 : 0;
          }
          function rn(t) {
            if (!t) return !0;
            const e = t[0];
            if (t.length <= 1) return 'any' !== e;
            var n;
            return '==' === e
              ? an(t[1], t[2], '==')
              : '!=' === e
              ? ln(an(t[1], t[2], '=='))
              : '<' === e || '>' === e || '<=' === e || '>=' === e
              ? an(t[1], t[2], e)
              : 'any' === e
              ? ((n = t.slice(1)), ['any'].concat(n.map(rn)))
              : 'all' === e
              ? ['all'].concat(t.slice(1).map(rn))
              : 'none' === e
              ? ['all'].concat(t.slice(1).map(rn).map(ln))
              : 'in' === e
              ? on(t[1], t.slice(2))
              : '!in' === e
              ? ln(on(t[1], t.slice(2)))
              : 'has' === e
              ? sn(t[1])
              : '!has' === e
              ? ln(sn(t[1]))
              : 'within' !== e || t;
          }
          function an(t, e, n) {
            switch (t) {
              case '$type':
                return ['filter-type-' + n, e];
              case '$id':
                return ['filter-id-' + n, e];
              default:
                return ['filter-' + n, t, e];
            }
          }
          function on(t, e) {
            if (0 === e.length) return !1;
            switch (t) {
              case '$type':
                return ['filter-type-in', ['literal', e]];
              case '$id':
                return ['filter-id-in', ['literal', e]];
              default:
                return e.length > 200 && !e.some((t) => typeof t != typeof e[0])
                  ? ['filter-in-large', t, ['literal', e.sort(nn)]]
                  : ['filter-in-small', t, ['literal', e]];
            }
          }
          function sn(t) {
            switch (t) {
              case '$type':
                return !0;
              case '$id':
                return ['filter-has-id'];
              default:
                return ['filter-has', t];
            }
          }
          function ln(t) {
            return ['!', t];
          }
          class cn {
            constructor(t, e, n, i) {
              (this.message = (t ? t + ': ' : '') + n),
                i && (this.identifier = i),
                null != e && e.__line__ && (this.line = e.__line__);
            }
          }
          class un {
            constructor(t) {
              (this.error = t), (this.message = t.message);
              const e = t.message.match(/line (\d+)/);
              this.line = e ? parseInt(e[1], 10) : 0;
            }
          }
          function hn(t) {
            const e = t.key,
              n = t.value;
            return n
              ? [new cn(e, n, 'constants have been deprecated as of v8')]
              : [];
          }
          function dn(t) {
            return t instanceof Number ||
              t instanceof String ||
              t instanceof Boolean
              ? t.valueOf()
              : t;
          }
          function pn(t) {
            if (Array.isArray(t)) return t.map(pn);
            if (
              t instanceof Object &&
              !(
                t instanceof Number ||
                t instanceof String ||
                t instanceof Boolean
              )
            ) {
              const e = {};
              for (const n in t) e[n] = pn(t[n]);
              return e;
            }
            return dn(t);
          }
          function fn(t) {
            const e = t.key,
              n = t.value,
              i = t.valueSpec || {},
              r = t.objectElementValidators || {},
              a = t.style,
              o = t.styleSpec;
            let s = [];
            const l = Ne(n);
            if ('object' !== l)
              return [new cn(e, n, `object expected, ${l} found`)];
            for (const t in n) {
              const l = t.split('.')[0],
                c = i[l] || i['*'];
              let u;
              if (r[l]) u = r[l];
              else if (i[l]) u = Cn;
              else if (r['*']) u = r['*'];
              else {
                if (!i['*']) {
                  s.push(new cn(e, n[t], `unknown property "${t}"`));
                  continue;
                }
                u = Cn;
              }
              s = s.concat(
                u(
                  {
                    key: (e ? e + '.' : e) + t,
                    value: n[t],
                    valueSpec: c,
                    style: a,
                    styleSpec: o,
                    object: n,
                    objectKey: t,
                  },
                  n,
                ),
              );
            }
            for (const t in i)
              r[t] ||
                (i[t].required &&
                  void 0 === i[t].default &&
                  void 0 === n[t] &&
                  s.push(new cn(e, n, `missing required property "${t}"`)));
            return s;
          }
          function mn(t) {
            const e = t.value,
              n = t.valueSpec,
              i = t.style,
              r = t.styleSpec,
              a = t.key,
              o = t.arrayElementValidator || Cn;
            if ('array' !== Ne(e))
              return [new cn(a, e, `array expected, ${Ne(e)} found`)];
            if (n.length && e.length !== n.length)
              return [
                new cn(
                  a,
                  e,
                  `array length ${n.length} expected, length ${e.length} found`,
                ),
              ];
            if (n['min-length'] && e.length < n['min-length'])
              return [
                new cn(
                  a,
                  e,
                  `array length at least ${n['min-length']} expected, length ${e.length} found`,
                ),
              ];
            let s = {
              type: n.value,
              values: n.values,
              minimum: n.minimum,
              maximum: n.maximum,
            };
            r.$version < 7 && (s.function = n.function),
              'object' === Ne(n.value) && (s = n.value);
            let l = [];
            for (let t = 0; t < e.length; t++)
              l = l.concat(
                o({
                  array: e,
                  arrayIndex: t,
                  value: e[t],
                  valueSpec: s,
                  style: i,
                  styleSpec: r,
                  key: `${a}[${t}]`,
                }),
              );
            return l;
          }
          function gn(t) {
            const e = t.key,
              n = t.value,
              i = t.valueSpec;
            let r = Ne(n);
            if (('number' === r && n != n && (r = 'NaN'), 'number' !== r))
              return [new cn(e, n, `number expected, ${r} found`)];
            if ('minimum' in i) {
              let r = i.minimum;
              if ('array' === Ne(i.minimum)) {
                const e = t.arrayIndex;
                r = i.minimum[e];
              }
              if (n < r)
                return [
                  new cn(e, n, `${n} is less than the minimum value ${r}`),
                ];
            }
            if ('maximum' in i) {
              let r = i.maximum;
              if ('array' === Ne(i.maximum)) {
                const e = t.arrayIndex;
                r = i.maximum[e];
              }
              if (n > r)
                return [
                  new cn(e, n, `${n} is greater than the maximum value ${r}`),
                ];
            }
            return [];
          }
          function yn(t) {
            const e = t.valueSpec,
              n = dn(t.value.type);
            let i,
              r,
              a,
              o = {};
            const s = 'categorical' !== n && void 0 === t.value.property,
              l = !s,
              c =
                'array' === Ne(t.value.stops) &&
                'array' === Ne(t.value.stops[0]) &&
                'object' === Ne(t.value.stops[0][0]),
              u = fn({
                key: t.key,
                value: t.value,
                valueSpec: t.styleSpec.function,
                style: t.style,
                styleSpec: t.styleSpec,
                objectElementValidators: {
                  stops: function (t) {
                    if ('identity' === n)
                      return [
                        new cn(
                          t.key,
                          t.value,
                          'identity function may not have a "stops" property',
                        ),
                      ];
                    let e = [];
                    const i = t.value;
                    (e = e.concat(
                      mn({
                        key: t.key,
                        value: i,
                        valueSpec: t.valueSpec,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        arrayElementValidator: h,
                      }),
                    )),
                      'array' === Ne(i) &&
                        0 === i.length &&
                        e.push(
                          new cn(t.key, i, 'array must have at least one stop'),
                        );
                    return e;
                  },
                  default: function (t) {
                    return Cn({
                      key: t.key,
                      value: t.value,
                      valueSpec: e,
                      style: t.style,
                      styleSpec: t.styleSpec,
                    });
                  },
                },
              });
            return (
              'identity' === n &&
                s &&
                u.push(
                  new cn(
                    t.key,
                    t.value,
                    'missing required property "property"',
                  ),
                ),
              'identity' === n ||
                t.value.stops ||
                u.push(
                  new cn(t.key, t.value, 'missing required property "stops"'),
                ),
              'exponential' === n &&
                t.valueSpec.expression &&
                !Oe(t.valueSpec) &&
                u.push(
                  new cn(t.key, t.value, 'exponential functions not supported'),
                ),
              t.styleSpec.$version >= 8 &&
                (l && !Ie(t.valueSpec)
                  ? u.push(
                      new cn(
                        t.key,
                        t.value,
                        'property functions not supported',
                      ),
                    )
                  : s &&
                    !De(t.valueSpec) &&
                    u.push(
                      new cn(t.key, t.value, 'zoom functions not supported'),
                    )),
              ('categorical' !== n && !c) ||
                void 0 !== t.value.property ||
                u.push(
                  new cn(t.key, t.value, '"property" property is required'),
                ),
              u
            );
            function h(t) {
              let n = [];
              const i = t.value,
                s = t.key;
              if ('array' !== Ne(i))
                return [new cn(s, i, `array expected, ${Ne(i)} found`)];
              if (2 !== i.length)
                return [
                  new cn(
                    s,
                    i,
                    `array length 2 expected, length ${i.length} found`,
                  ),
                ];
              if (c) {
                if ('object' !== Ne(i[0]))
                  return [new cn(s, i, `object expected, ${Ne(i[0])} found`)];
                if (void 0 === i[0].zoom)
                  return [new cn(s, i, 'object stop key must have zoom')];
                if (void 0 === i[0].value)
                  return [new cn(s, i, 'object stop key must have value')];
                if (a && a > dn(i[0].zoom))
                  return [
                    new cn(
                      s,
                      i[0].zoom,
                      'stop zoom values must appear in ascending order',
                    ),
                  ];
                dn(i[0].zoom) !== a &&
                  ((a = dn(i[0].zoom)), (r = void 0), (o = {})),
                  (n = n.concat(
                    fn({
                      key: s + '[0]',
                      value: i[0],
                      valueSpec: { zoom: {} },
                      style: t.style,
                      styleSpec: t.styleSpec,
                      objectElementValidators: { zoom: gn, value: d },
                    }),
                  ));
              } else
                n = n.concat(
                  d(
                    {
                      key: s + '[0]',
                      value: i[0],
                      valueSpec: {},
                      style: t.style,
                      styleSpec: t.styleSpec,
                    },
                    i,
                  ),
                );
              return Xe(pn(i[1]))
                ? n.concat([
                    new cn(
                      s + '[1]',
                      i[1],
                      'expressions are not allowed in function stops.',
                    ),
                  ])
                : n.concat(
                    Cn({
                      key: s + '[1]',
                      value: i[1],
                      valueSpec: e,
                      style: t.style,
                      styleSpec: t.styleSpec,
                    }),
                  );
            }
            function d(t, a) {
              const s = Ne(t.value),
                l = dn(t.value),
                c = null !== t.value ? t.value : a;
              if (i) {
                if (s !== i)
                  return [
                    new cn(
                      t.key,
                      c,
                      `${s} stop domain type must match previous stop domain type ${i}`,
                    ),
                  ];
              } else i = s;
              if ('number' !== s && 'string' !== s && 'boolean' !== s)
                return [
                  new cn(
                    t.key,
                    c,
                    'stop domain value must be a number, string, or boolean',
                  ),
                ];
              if ('number' !== s && 'categorical' !== n) {
                let i = `number expected, ${s} found`;
                return (
                  Ie(e) &&
                    void 0 === n &&
                    (i +=
                      '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                  [new cn(t.key, c, i)]
                );
              }
              return 'categorical' !== n ||
                'number' !== s ||
                (isFinite(l) && Math.floor(l) === l)
                ? 'categorical' !== n && 'number' === s && void 0 !== r && l < r
                  ? [
                      new cn(
                        t.key,
                        c,
                        'stop domain values must appear in ascending order',
                      ),
                    ]
                  : ((r = l),
                    'categorical' === n && l in o
                      ? [new cn(t.key, c, 'stop domain values must be unique')]
                      : ((o[l] = !0), []))
                : [new cn(t.key, c, 'integer expected, found ' + l)];
            }
          }
          function vn(t) {
            const e = ('property' === t.expressionContext ? Ze : Ye)(
              pn(t.value),
              t.valueSpec,
            );
            if ('error' === e.result)
              return e.value.map(
                (e) => new cn(`${t.key}${e.key}`, t.value, e.message),
              );
            const n = e.value.expression || e.value._styleExpression.expression;
            if (
              'property' === t.expressionContext &&
              'text-font' === t.propertyKey &&
              !n.outputDefined()
            )
              return [
                new cn(
                  t.key,
                  t.value,
                  `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`,
                ),
              ];
            if (
              'property' === t.expressionContext &&
              'layout' === t.propertyType &&
              !Ot(n)
            )
              return [
                new cn(
                  t.key,
                  t.value,
                  '"feature-state" data expressions are not supported with layout properties.',
                ),
              ];
            if ('filter' === t.expressionContext && !Ot(n))
              return [
                new cn(
                  t.key,
                  t.value,
                  '"feature-state" data expressions are not supported with filters.',
                ),
              ];
            if (
              t.expressionContext &&
              0 === t.expressionContext.indexOf('cluster')
            ) {
              if (!Nt(n, ['zoom', 'feature-state']))
                return [
                  new cn(
                    t.key,
                    t.value,
                    '"zoom" and "feature-state" expressions are not supported with cluster properties.',
                  ),
                ];
              if ('cluster-initial' === t.expressionContext && !Dt(n))
                return [
                  new cn(
                    t.key,
                    t.value,
                    'Feature data expressions are not supported with initial expression part of cluster properties.',
                  ),
                ];
            }
            return [];
          }
          function xn(t) {
            const e = t.key,
              n = t.value,
              i = t.valueSpec,
              r = [];
            return (
              Array.isArray(i.values)
                ? -1 === i.values.indexOf(dn(n)) &&
                  r.push(
                    new cn(
                      e,
                      n,
                      `expected one of [${i.values.join(
                        ', ',
                      )}], ${JSON.stringify(n)} found`,
                    ),
                  )
                : -1 === Object.keys(i.values).indexOf(dn(n)) &&
                  r.push(
                    new cn(
                      e,
                      n,
                      `expected one of [${Object.keys(i.values).join(
                        ', ',
                      )}], ${JSON.stringify(n)} found`,
                    ),
                  ),
              r
            );
          }
          function bn(t) {
            return Qe(pn(t.value))
              ? vn(
                  C({}, t, {
                    expressionContext: 'filter',
                    valueSpec: { value: 'boolean' },
                  }),
                )
              : (function t(e) {
                  const n = e.value,
                    i = e.key;
                  if ('array' !== Ne(n))
                    return [new cn(i, n, `array expected, ${Ne(n)} found`)];
                  const r = e.styleSpec;
                  let a,
                    o = [];
                  if (n.length < 1)
                    return [
                      new cn(i, n, 'filter array must have at least 1 element'),
                    ];
                  switch (
                    ((o = o.concat(
                      xn({
                        key: i + '[0]',
                        value: n[0],
                        valueSpec: r.filter_operator,
                        style: e.style,
                        styleSpec: e.styleSpec,
                      }),
                    )),
                    dn(n[0]))
                  ) {
                    case '<':
                    case '<=':
                    case '>':
                    case '>=':
                      n.length >= 2 &&
                        '$type' === dn(n[1]) &&
                        o.push(
                          new cn(
                            i,
                            n,
                            `"$type" cannot be use with operator "${n[0]}"`,
                          ),
                        );
                    case '==':
                    case '!=':
                      3 !== n.length &&
                        o.push(
                          new cn(
                            i,
                            n,
                            `filter array for operator "${n[0]}" must have 3 elements`,
                          ),
                        );
                    case 'in':
                    case '!in':
                      n.length >= 2 &&
                        ((a = Ne(n[1])),
                        'string' !== a &&
                          o.push(
                            new cn(
                              i + '[1]',
                              n[1],
                              `string expected, ${a} found`,
                            ),
                          ));
                      for (let t = 2; t < n.length; t++)
                        (a = Ne(n[t])),
                          '$type' === dn(n[1])
                            ? (o = o.concat(
                                xn({
                                  key: `${i}[${t}]`,
                                  value: n[t],
                                  valueSpec: r.geometry_type,
                                  style: e.style,
                                  styleSpec: e.styleSpec,
                                }),
                              ))
                            : 'string' !== a &&
                              'number' !== a &&
                              'boolean' !== a &&
                              o.push(
                                new cn(
                                  `${i}[${t}]`,
                                  n[t],
                                  `string, number, or boolean expected, ${a} found`,
                                ),
                              );
                      break;
                    case 'any':
                    case 'all':
                    case 'none':
                      for (let r = 1; r < n.length; r++)
                        o = o.concat(
                          t({
                            key: `${i}[${r}]`,
                            value: n[r],
                            style: e.style,
                            styleSpec: e.styleSpec,
                          }),
                        );
                      break;
                    case 'has':
                    case '!has':
                      (a = Ne(n[1])),
                        2 !== n.length
                          ? o.push(
                              new cn(
                                i,
                                n,
                                `filter array for "${n[0]}" operator must have 2 elements`,
                              ),
                            )
                          : 'string' !== a &&
                            o.push(
                              new cn(
                                i + '[1]',
                                n[1],
                                `string expected, ${a} found`,
                              ),
                            );
                      break;
                    case 'within':
                      (a = Ne(n[1])),
                        2 !== n.length
                          ? o.push(
                              new cn(
                                i,
                                n,
                                `filter array for "${n[0]}" operator must have 2 elements`,
                              ),
                            )
                          : 'object' !== a &&
                            o.push(
                              new cn(
                                i + '[1]',
                                n[1],
                                `object expected, ${a} found`,
                              ),
                            );
                  }
                  return o;
                })(t);
          }
          function _n(t, e) {
            const n = t.key,
              i = t.style,
              r = t.styleSpec,
              a = t.value,
              o = t.objectKey,
              s = r[`${e}_${t.layerType}`];
            if (!s) return [];
            const l = o.match(/^(.*)-transition$/);
            if ('paint' === e && l && s[l[1]] && s[l[1]].transition)
              return Cn({
                key: n,
                value: a,
                valueSpec: r.transition,
                style: i,
                styleSpec: r,
              });
            const c = t.valueSpec || s[o];
            if (!c) return [new cn(n, a, `unknown property "${o}"`)];
            let u;
            if (
              'string' === Ne(a) &&
              Ie(c) &&
              !c.tokens &&
              (u = /^{([^}]+)}$/.exec(a))
            )
              return [
                new cn(
                  n,
                  a,
                  `"${o}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(
                    u[1],
                  )} }\`.`,
                ),
              ];
            const h = [];
            return (
              'symbol' === t.layerType &&
                ('text-field' === o &&
                  i &&
                  !i.glyphs &&
                  h.push(
                    new cn(
                      n,
                      a,
                      'use of "text-field" requires a style "glyphs" property',
                    ),
                  ),
                'text-font' === o &&
                  ze(pn(a)) &&
                  'identity' === dn(a.type) &&
                  h.push(
                    new cn(
                      n,
                      a,
                      '"text-font" does not support identity functions',
                    ),
                  )),
              h.concat(
                Cn({
                  key: t.key,
                  value: a,
                  valueSpec: c,
                  style: i,
                  styleSpec: r,
                  expressionContext: 'property',
                  propertyType: e,
                  propertyKey: o,
                }),
              )
            );
          }
          function wn(t) {
            return _n(t, 'paint');
          }
          function Mn(t) {
            return _n(t, 'layout');
          }
          function qn(t) {
            let e = [];
            const n = t.value,
              i = t.key,
              r = t.style,
              a = t.styleSpec;
            n.type ||
              n.ref ||
              e.push(new cn(i, n, 'either "type" or "ref" is required'));
            let o = dn(n.type);
            const s = dn(n.ref);
            if (n.id) {
              const a = dn(n.id);
              for (let o = 0; o < t.arrayIndex; o++) {
                const t = r.layers[o];
                dn(t.id) === a &&
                  e.push(
                    new cn(
                      i,
                      n.id,
                      `duplicate layer id "${n.id}", previously used at line ${t.id.__line__}`,
                    ),
                  );
              }
            }
            if ('ref' in n) {
              let t;
              ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(
                (t) => {
                  t in n &&
                    e.push(
                      new cn(i, n[t], `"${t}" is prohibited for ref layers`),
                    );
                },
              ),
                r.layers.forEach((e) => {
                  dn(e.id) === s && (t = e);
                }),
                t
                  ? t.ref
                    ? e.push(
                        new cn(
                          i,
                          n.ref,
                          'ref cannot reference another ref layer',
                        ),
                      )
                    : (o = dn(t.type))
                  : e.push(new cn(i, n.ref, `ref layer "${s}" not found`));
            } else if ('background' !== o && 'sky' !== o)
              if (n.source) {
                const t = r.sources && r.sources[n.source],
                  a = t && dn(t.type);
                t
                  ? 'vector' === a && 'raster' === o
                    ? e.push(
                        new cn(
                          i,
                          n.source,
                          `layer "${n.id}" requires a raster source`,
                        ),
                      )
                    : 'raster' === a && 'raster' !== o
                    ? e.push(
                        new cn(
                          i,
                          n.source,
                          `layer "${n.id}" requires a vector source`,
                        ),
                      )
                    : 'vector' !== a || n['source-layer']
                    ? 'raster-dem' === a && 'hillshade' !== o
                      ? e.push(
                          new cn(
                            i,
                            n.source,
                            "raster-dem source can only be used with layer type 'hillshade'.",
                          ),
                        )
                      : 'line' !== o ||
                        !n.paint ||
                        !n.paint['line-gradient'] ||
                        ('geojson' === a && t.lineMetrics) ||
                        e.push(
                          new cn(
                            i,
                            n,
                            `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`,
                          ),
                        )
                    : e.push(
                        new cn(
                          i,
                          n,
                          `layer "${n.id}" must specify a "source-layer"`,
                        ),
                      )
                  : e.push(
                      new cn(i, n.source, `source "${n.source}" not found`),
                    );
              } else e.push(new cn(i, n, 'missing required property "source"'));
            return (
              (e = e.concat(
                fn({
                  key: i,
                  value: n,
                  valueSpec: a.layer,
                  style: t.style,
                  styleSpec: t.styleSpec,
                  objectElementValidators: {
                    '*': () => [],
                    type: () =>
                      Cn({
                        key: i + '.type',
                        value: n.type,
                        valueSpec: a.layer.type,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        object: n,
                        objectKey: 'type',
                      }),
                    filter: bn,
                    layout: (t) =>
                      fn({
                        layer: n,
                        key: t.key,
                        value: t.value,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                          '*': (t) => Mn(C({ layerType: o }, t)),
                        },
                      }),
                    paint: (t) =>
                      fn({
                        layer: n,
                        key: t.key,
                        value: t.value,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                          '*': (t) => wn(C({ layerType: o }, t)),
                        },
                      }),
                  },
                }),
              )),
              e
            );
          }
          function Sn(t) {
            const e = t.value,
              n = t.key,
              i = Ne(e);
            return 'string' !== i
              ? [new cn(n, e, `string expected, ${i} found`)]
              : [];
          }
          const Tn = {
            promoteId: function ({ key: t, value: e }) {
              if ('string' === Ne(e)) return Sn({ key: t, value: e });
              {
                const n = [];
                for (const i in e)
                  n.push(...Sn({ key: `${t}.${i}`, value: e[i] }));
                return n;
              }
            },
          };
          function En(t) {
            const e = t.value,
              n = t.key,
              i = t.styleSpec,
              r = t.style;
            if (!e.type) return [new cn(n, e, '"type" is required')];
            const a = dn(e.type);
            let o;
            switch (a) {
              case 'vector':
              case 'raster':
              case 'raster-dem':
                return (
                  (o = fn({
                    key: n,
                    value: e,
                    valueSpec: i['source_' + a.replace('-', '_')],
                    style: t.style,
                    styleSpec: i,
                    objectElementValidators: Tn,
                  })),
                  o
                );
              case 'geojson':
                if (
                  ((o = fn({
                    key: n,
                    value: e,
                    valueSpec: i.source_geojson,
                    style: r,
                    styleSpec: i,
                    objectElementValidators: Tn,
                  })),
                  e.cluster)
                )
                  for (const t in e.clusterProperties) {
                    const [i, r] = e.clusterProperties[t],
                      a =
                        'string' == typeof i
                          ? [i, ['accumulated'], ['get', t]]
                          : i;
                    o.push(
                      ...vn({
                        key: `${n}.${t}.map`,
                        value: r,
                        expressionContext: 'cluster-map',
                      }),
                    ),
                      o.push(
                        ...vn({
                          key: `${n}.${t}.reduce`,
                          value: a,
                          expressionContext: 'cluster-reduce',
                        }),
                      );
                  }
                return o;
              case 'video':
                return fn({
                  key: n,
                  value: e,
                  valueSpec: i.source_video,
                  style: r,
                  styleSpec: i,
                });
              case 'image':
                return fn({
                  key: n,
                  value: e,
                  valueSpec: i.source_image,
                  style: r,
                  styleSpec: i,
                });
              case 'canvas':
                return [
                  new cn(
                    n,
                    null,
                    'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.',
                    'source.canvas',
                  ),
                ];
              default:
                return xn({
                  key: n + '.type',
                  value: e.type,
                  valueSpec: {
                    values: [
                      'vector',
                      'raster',
                      'raster-dem',
                      'geojson',
                      'video',
                      'image',
                    ],
                  },
                  style: r,
                  styleSpec: i,
                });
            }
          }
          function An(t) {
            const e = t.value,
              n = t.styleSpec,
              i = n.light,
              r = t.style;
            let a = [];
            const o = Ne(e);
            if (void 0 === e) return a;
            if ('object' !== o)
              return (
                (a = a.concat([
                  new cn('light', e, `object expected, ${o} found`),
                ])),
                a
              );
            for (const t in e) {
              const o = t.match(/^(.*)-transition$/);
              a =
                o && i[o[1]] && i[o[1]].transition
                  ? a.concat(
                      Cn({
                        key: t,
                        value: e[t],
                        valueSpec: n.transition,
                        style: r,
                        styleSpec: n,
                      }),
                    )
                  : i[t]
                  ? a.concat(
                      Cn({
                        key: t,
                        value: e[t],
                        valueSpec: i[t],
                        style: r,
                        styleSpec: n,
                      }),
                    )
                  : a.concat([new cn(t, e[t], `unknown property "${t}"`)]);
            }
            return a;
          }
          function Ln(t) {
            const e = t.value,
              n = t.key,
              i = t.style,
              r = t.styleSpec,
              a = r.terrain;
            let o = [];
            const s = Ne(e);
            if (void 0 === e) return o;
            if ('object' !== s)
              return (
                (o = o.concat([
                  new cn('terrain', e, `object expected, ${s} found`),
                ])),
                o
              );
            for (const t in e) {
              const n = t.match(/^(.*)-transition$/);
              o =
                n && a[n[1]] && a[n[1]].transition
                  ? o.concat(
                      Cn({
                        key: t,
                        value: e[t],
                        valueSpec: r.transition,
                        style: i,
                        styleSpec: r,
                      }),
                    )
                  : a[t]
                  ? o.concat(
                      Cn({
                        key: t,
                        value: e[t],
                        valueSpec: a[t],
                        style: i,
                        styleSpec: r,
                      }),
                    )
                  : o.concat([new cn(t, e[t], `unknown property "${t}"`)]);
            }
            if (e.source) {
              const t = i.sources && i.sources[e.source],
                r = t && dn(t.type);
              t
                ? 'raster-dem' !== r &&
                  o.push(
                    new cn(
                      n,
                      e.source,
                      `terrain cannot be used with a source of type ${r}, it only be used with a "raster-dem" source type`,
                    ),
                  )
                : o.push(new cn(n, e.source, `source "${e.source}" not found`));
            } else
              o.push(
                new cn(n, e, 'terrain is missing required property "source"'),
              );
            return o;
          }
          const Rn = {
            '*': () => [],
            array: mn,
            boolean: function (t) {
              const e = t.value,
                n = t.key,
                i = Ne(e);
              return 'boolean' !== i
                ? [new cn(n, e, `boolean expected, ${i} found`)]
                : [];
            },
            number: gn,
            color: function (t) {
              const e = t.key,
                n = t.value,
                i = Ne(n);
              return 'string' !== i
                ? [new cn(e, n, `color expected, ${i} found`)]
                : null === J(n)
                ? [new cn(e, n, `color expected, "${n}" found`)]
                : [];
            },
            constants: hn,
            enum: xn,
            filter: bn,
            function: yn,
            layer: qn,
            object: fn,
            source: En,
            light: An,
            terrain: Ln,
            string: Sn,
            formatted: function (t) {
              return 0 === Sn(t).length ? [] : vn(t);
            },
            resolvedImage: function (t) {
              return 0 === Sn(t).length ? [] : vn(t);
            },
          };
          function Cn(t) {
            const e = t.value,
              n = t.valueSpec,
              i = t.styleSpec;
            if (n.expression && ze(dn(e))) return yn(t);
            if (n.expression && Xe(pn(e))) return vn(t);
            if (n.type && Rn[n.type]) return Rn[n.type](t);
            return fn(C({}, t, { valueSpec: n.type ? i[n.type] : n }));
          }
          function Pn(t) {
            const e = t.value,
              n = t.key,
              i = Sn(t);
            return (
              i.length ||
                (-1 === e.indexOf('{fontstack}') &&
                  i.push(
                    new cn(
                      n,
                      e,
                      '"glyphs" url must include a "{fontstack}" token',
                    ),
                  ),
                -1 === e.indexOf('{range}') &&
                  i.push(
                    new cn(n, e, '"glyphs" url must include a "{range}" token'),
                  )),
              i
            );
          }
          function kn(t, e = i) {
            let n = [];
            return (
              (n = n.concat(
                Cn({
                  key: '',
                  value: t,
                  valueSpec: e.$root,
                  styleSpec: e,
                  style: t,
                  objectElementValidators: { glyphs: Pn, '*': () => [] },
                }),
              )),
              t.constants &&
                (n = n.concat(
                  hn({
                    key: 'constants',
                    value: t.constants,
                    style: t,
                    styleSpec: e,
                  }),
                )),
              In(n)
            );
          }
          function In(t) {
            return [].concat(t).sort((t, e) => t.line - e.line);
          }
          function Dn(t) {
            return function (...e) {
              return In(t.apply(this, e));
            };
          }
          (kn.source = Dn(En)),
            (kn.light = Dn(An)),
            (kn.terrain = Dn(Ln)),
            (kn.layer = Dn(qn)),
            (kn.filter = Dn(bn)),
            (kn.paintProperty = Dn(wn)),
            (kn.layoutProperty = Dn(Mn));
          var On = o(function (t, e) {
            var n = (function () {
              var t = function (t, e, n, i) {
                  for (n = n || {}, i = t.length; i--; n[t[i]] = e);
                  return n;
                },
                e = [1, 12],
                n = [1, 13],
                i = [1, 9],
                r = [1, 10],
                a = [1, 11],
                o = [1, 14],
                s = [1, 15],
                l = [14, 18, 22, 24],
                c = [18, 22],
                u = [22, 24],
                h = {
                  trace: function () {},
                  yy: {},
                  symbols_: {
                    error: 2,
                    JSONString: 3,
                    STRING: 4,
                    JSONNumber: 5,
                    NUMBER: 6,
                    JSONNullLiteral: 7,
                    NULL: 8,
                    JSONBooleanLiteral: 9,
                    TRUE: 10,
                    FALSE: 11,
                    JSONText: 12,
                    JSONValue: 13,
                    EOF: 14,
                    JSONObject: 15,
                    JSONArray: 16,
                    '{': 17,
                    '}': 18,
                    JSONMemberList: 19,
                    JSONMember: 20,
                    ':': 21,
                    ',': 22,
                    '[': 23,
                    ']': 24,
                    JSONElementList: 25,
                    $accept: 0,
                    $end: 1,
                  },
                  terminals_: {
                    2: 'error',
                    4: 'STRING',
                    6: 'NUMBER',
                    8: 'NULL',
                    10: 'TRUE',
                    11: 'FALSE',
                    14: 'EOF',
                    17: '{',
                    18: '}',
                    21: ':',
                    22: ',',
                    23: '[',
                    24: ']',
                  },
                  productions_: [
                    0,
                    [3, 1],
                    [5, 1],
                    [7, 1],
                    [9, 1],
                    [9, 1],
                    [12, 2],
                    [13, 1],
                    [13, 1],
                    [13, 1],
                    [13, 1],
                    [13, 1],
                    [13, 1],
                    [15, 2],
                    [15, 3],
                    [20, 3],
                    [19, 1],
                    [19, 3],
                    [16, 2],
                    [16, 3],
                    [25, 1],
                    [25, 3],
                  ],
                  performAction: function (t, e, n, i, r, a, o) {
                    var s = a.length - 1;
                    switch (r) {
                      case 1:
                        (this.$ = new String(
                          t
                            .replace(/\\(\\|")/g, '$1')
                            .replace(/\\n/g, '\n')
                            .replace(/\\r/g, '\r')
                            .replace(/\\t/g, '\t')
                            .replace(/\\v/g, '\v')
                            .replace(/\\f/g, '\f')
                            .replace(/\\b/g, '\b'),
                        )),
                          (this.$.__line__ = this._$.first_line);
                        break;
                      case 2:
                        (this.$ = new Number(t)),
                          (this.$.__line__ = this._$.first_line);
                        break;
                      case 3:
                        this.$ = null;
                        break;
                      case 4:
                        (this.$ = new Boolean(!0)),
                          (this.$.__line__ = this._$.first_line);
                        break;
                      case 5:
                        (this.$ = new Boolean(!1)),
                          (this.$.__line__ = this._$.first_line);
                        break;
                      case 6:
                        return (this.$ = a[s - 1]);
                      case 13:
                        (this.$ = {}),
                          Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: !1,
                          });
                        break;
                      case 14:
                      case 19:
                        (this.$ = a[s - 1]),
                          Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: !1,
                          });
                        break;
                      case 15:
                        this.$ = [a[s - 2], a[s]];
                        break;
                      case 16:
                        (this.$ = {}), (this.$[a[s][0]] = a[s][1]);
                        break;
                      case 17:
                        (this.$ = a[s - 2]), (a[s - 2][a[s][0]] = a[s][1]);
                        break;
                      case 18:
                        (this.$ = []),
                          Object.defineProperty(this.$, '__line__', {
                            value: this._$.first_line,
                            enumerable: !1,
                          });
                        break;
                      case 20:
                        this.$ = [a[s]];
                        break;
                      case 21:
                        (this.$ = a[s - 2]), a[s - 2].push(a[s]);
                    }
                  },
                  table: [
                    {
                      3: 5,
                      4: e,
                      5: 6,
                      6: n,
                      7: 3,
                      8: i,
                      9: 4,
                      10: r,
                      11: a,
                      12: 1,
                      13: 2,
                      15: 7,
                      16: 8,
                      17: o,
                      23: s,
                    },
                    { 1: [3] },
                    { 14: [1, 16] },
                    t(l, [2, 7]),
                    t(l, [2, 8]),
                    t(l, [2, 9]),
                    t(l, [2, 10]),
                    t(l, [2, 11]),
                    t(l, [2, 12]),
                    t(l, [2, 3]),
                    t(l, [2, 4]),
                    t(l, [2, 5]),
                    t([14, 18, 21, 22, 24], [2, 1]),
                    t(l, [2, 2]),
                    { 3: 20, 4: e, 18: [1, 17], 19: 18, 20: 19 },
                    {
                      3: 5,
                      4: e,
                      5: 6,
                      6: n,
                      7: 3,
                      8: i,
                      9: 4,
                      10: r,
                      11: a,
                      13: 23,
                      15: 7,
                      16: 8,
                      17: o,
                      23: s,
                      24: [1, 21],
                      25: 22,
                    },
                    { 1: [2, 6] },
                    t(l, [2, 13]),
                    { 18: [1, 24], 22: [1, 25] },
                    t(c, [2, 16]),
                    { 21: [1, 26] },
                    t(l, [2, 18]),
                    { 22: [1, 28], 24: [1, 27] },
                    t(u, [2, 20]),
                    t(l, [2, 14]),
                    { 3: 20, 4: e, 20: 29 },
                    {
                      3: 5,
                      4: e,
                      5: 6,
                      6: n,
                      7: 3,
                      8: i,
                      9: 4,
                      10: r,
                      11: a,
                      13: 30,
                      15: 7,
                      16: 8,
                      17: o,
                      23: s,
                    },
                    t(l, [2, 19]),
                    {
                      3: 5,
                      4: e,
                      5: 6,
                      6: n,
                      7: 3,
                      8: i,
                      9: 4,
                      10: r,
                      11: a,
                      13: 31,
                      15: 7,
                      16: 8,
                      17: o,
                      23: s,
                    },
                    t(c, [2, 17]),
                    t(c, [2, 15]),
                    t(u, [2, 21]),
                  ],
                  defaultActions: { 16: [2, 6] },
                  parseError: function (t, e) {
                    if (!e.recoverable) throw new Error(t);
                    this.trace(t);
                  },
                  parse: function (t) {
                    var e = this,
                      n = [0],
                      i = [null],
                      r = [],
                      a = this.table,
                      o = '',
                      s = 0,
                      l = 0,
                      c = 2,
                      u = 1,
                      h = r.slice.call(arguments, 1),
                      d = Object.create(this.lexer),
                      p = { yy: {} };
                    for (var f in this.yy)
                      Object.prototype.hasOwnProperty.call(this.yy, f) &&
                        (p.yy[f] = this.yy[f]);
                    d.setInput(t, p.yy),
                      (p.yy.lexer = d),
                      (p.yy.parser = this),
                      void 0 === d.yylloc && (d.yylloc = {});
                    var m = d.yylloc;
                    r.push(m);
                    var g = d.options && d.options.ranges;
                    function y() {
                      var t;
                      return (
                        'number' != typeof (t = d.lex() || u) &&
                          (t = e.symbols_[t] || t),
                        t
                      );
                    }
                    'function' == typeof p.yy.parseError
                      ? (this.parseError = p.yy.parseError)
                      : (this.parseError =
                          Object.getPrototypeOf(this).parseError);
                    for (var v, x, b, _, w, M, q, S, T = {}; ; ) {
                      if (
                        ((x = n[n.length - 1]),
                        this.defaultActions[x]
                          ? (b = this.defaultActions[x])
                          : (null == v && (v = y()), (b = a[x] && a[x][v])),
                        void 0 === b || !b.length || !b[0])
                      ) {
                        var E = '';
                        for (w in ((S = []), a[x]))
                          this.terminals_[w] &&
                            w > c &&
                            S.push("'" + this.terminals_[w] + "'");
                        (E = d.showPosition
                          ? 'Parse error on line ' +
                            (s + 1) +
                            ':\n' +
                            d.showPosition() +
                            '\nExpecting ' +
                            S.join(', ') +
                            ", got '" +
                            (this.terminals_[v] || v) +
                            "'"
                          : 'Parse error on line ' +
                            (s + 1) +
                            ': Unexpected ' +
                            (v == u
                              ? 'end of input'
                              : "'" + (this.terminals_[v] || v) + "'")),
                          this.parseError(E, {
                            text: d.match,
                            token: this.terminals_[v] || v,
                            line: d.yylineno,
                            loc: m,
                            expected: S,
                          });
                      }
                      if (b[0] instanceof Array && b.length > 1)
                        throw new Error(
                          'Parse Error: multiple actions possible at state: ' +
                            x +
                            ', token: ' +
                            v,
                        );
                      switch (b[0]) {
                        case 1:
                          n.push(v),
                            i.push(d.yytext),
                            r.push(d.yylloc),
                            n.push(b[1]),
                            (v = null),
                            (l = d.yyleng),
                            (o = d.yytext),
                            (s = d.yylineno),
                            (m = d.yylloc);
                          break;
                        case 2:
                          if (
                            ((M = this.productions_[b[1]][1]),
                            (T.$ = i[i.length - M]),
                            (T._$ = {
                              first_line: r[r.length - (M || 1)].first_line,
                              last_line: r[r.length - 1].last_line,
                              first_column: r[r.length - (M || 1)].first_column,
                              last_column: r[r.length - 1].last_column,
                            }),
                            g &&
                              (T._$.range = [
                                r[r.length - (M || 1)].range[0],
                                r[r.length - 1].range[1],
                              ]),
                            void 0 !==
                              (_ = this.performAction.apply(
                                T,
                                [o, l, s, p.yy, b[1], i, r].concat(h),
                              )))
                          )
                            return _;
                          M &&
                            ((n = n.slice(0, -1 * M * 2)),
                            (i = i.slice(0, -1 * M)),
                            (r = r.slice(0, -1 * M))),
                            n.push(this.productions_[b[1]][0]),
                            i.push(T.$),
                            r.push(T._$),
                            (q = a[n[n.length - 2]][n[n.length - 1]]),
                            n.push(q);
                          break;
                        case 3:
                          return !0;
                      }
                    }
                    return !0;
                  },
                },
                d = {
                  EOF: 1,
                  parseError: function (t, e) {
                    if (!this.yy.parser) throw new Error(t);
                    this.yy.parser.parseError(t, e);
                  },
                  setInput: function (t, e) {
                    return (
                      (this.yy = e || this.yy || {}),
                      (this._input = t),
                      (this._more = this._backtrack = this.done = !1),
                      (this.yylineno = this.yyleng = 0),
                      (this.yytext = this.matched = this.match = ''),
                      (this.conditionStack = ['INITIAL']),
                      (this.yylloc = {
                        first_line: 1,
                        first_column: 0,
                        last_line: 1,
                        last_column: 0,
                      }),
                      this.options.ranges && (this.yylloc.range = [0, 0]),
                      (this.offset = 0),
                      this
                    );
                  },
                  input: function () {
                    var t = this._input[0];
                    return (
                      (this.yytext += t),
                      this.yyleng++,
                      this.offset++,
                      (this.match += t),
                      (this.matched += t),
                      t.match(/(?:\r\n?|\n).*/g)
                        ? (this.yylineno++, this.yylloc.last_line++)
                        : this.yylloc.last_column++,
                      this.options.ranges && this.yylloc.range[1]++,
                      (this._input = this._input.slice(1)),
                      t
                    );
                  },
                  unput: function (t) {
                    var e = t.length,
                      n = t.split(/(?:\r\n?|\n)/g);
                    (this._input = t + this._input),
                      (this.yytext = this.yytext.substr(
                        0,
                        this.yytext.length - e,
                      )),
                      (this.offset -= e);
                    var i = this.match.split(/(?:\r\n?|\n)/g);
                    (this.match = this.match.substr(0, this.match.length - 1)),
                      (this.matched = this.matched.substr(
                        0,
                        this.matched.length - 1,
                      )),
                      n.length - 1 && (this.yylineno -= n.length - 1);
                    var r = this.yylloc.range;
                    return (
                      (this.yylloc = {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: n
                          ? (n.length === i.length
                              ? this.yylloc.first_column
                              : 0) +
                            i[i.length - n.length].length -
                            n[0].length
                          : this.yylloc.first_column - e,
                      }),
                      this.options.ranges &&
                        (this.yylloc.range = [r[0], r[0] + this.yyleng - e]),
                      (this.yyleng = this.yytext.length),
                      this
                    );
                  },
                  more: function () {
                    return (this._more = !0), this;
                  },
                  reject: function () {
                    return this.options.backtrack_lexer
                      ? ((this._backtrack = !0), this)
                      : this.parseError(
                          'Lexical error on line ' +
                            (this.yylineno + 1) +
                            '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' +
                            this.showPosition(),
                          { text: '', token: null, line: this.yylineno },
                        );
                  },
                  less: function (t) {
                    this.unput(this.match.slice(t));
                  },
                  pastInput: function () {
                    var t = this.matched.substr(
                      0,
                      this.matched.length - this.match.length,
                    );
                    return (
                      (t.length > 20 ? '...' : '') +
                      t.substr(-20).replace(/\n/g, '')
                    );
                  },
                  upcomingInput: function () {
                    var t = this.match;
                    return (
                      t.length < 20 &&
                        (t += this._input.substr(0, 20 - t.length)),
                      (t.substr(0, 20) + (t.length > 20 ? '...' : '')).replace(
                        /\n/g,
                        '',
                      )
                    );
                  },
                  showPosition: function () {
                    var t = this.pastInput(),
                      e = new Array(t.length + 1).join('-');
                    return t + this.upcomingInput() + '\n' + e + '^';
                  },
                  test_match: function (t, e) {
                    var n, i, r;
                    if (
                      (this.options.backtrack_lexer &&
                        ((r = {
                          yylineno: this.yylineno,
                          yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column,
                          },
                          yytext: this.yytext,
                          match: this.match,
                          matches: this.matches,
                          matched: this.matched,
                          yyleng: this.yyleng,
                          offset: this.offset,
                          _more: this._more,
                          _input: this._input,
                          yy: this.yy,
                          conditionStack: this.conditionStack.slice(0),
                          done: this.done,
                        }),
                        this.options.ranges &&
                          (r.yylloc.range = this.yylloc.range.slice(0))),
                      (i = t[0].match(/(?:\r\n?|\n).*/g)) &&
                        (this.yylineno += i.length),
                      (this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: i
                          ? i[i.length - 1].length -
                            i[i.length - 1].match(/\r?\n?/)[0].length
                          : this.yylloc.last_column + t[0].length,
                      }),
                      (this.yytext += t[0]),
                      (this.match += t[0]),
                      (this.matches = t),
                      (this.yyleng = this.yytext.length),
                      this.options.ranges &&
                        (this.yylloc.range = [
                          this.offset,
                          (this.offset += this.yyleng),
                        ]),
                      (this._more = !1),
                      (this._backtrack = !1),
                      (this._input = this._input.slice(t[0].length)),
                      (this.matched += t[0]),
                      (n = this.performAction.call(
                        this,
                        this.yy,
                        this,
                        e,
                        this.conditionStack[this.conditionStack.length - 1],
                      )),
                      this.done && this._input && (this.done = !1),
                      n)
                    )
                      return n;
                    if (this._backtrack) {
                      for (var a in r) this[a] = r[a];
                      return !1;
                    }
                    return !1;
                  },
                  next: function () {
                    if (this.done) return this.EOF;
                    var t, e, n, i;
                    this._input || (this.done = !0),
                      this._more || ((this.yytext = ''), (this.match = ''));
                    for (var r = this._currentRules(), a = 0; a < r.length; a++)
                      if (
                        (n = this._input.match(this.rules[r[a]])) &&
                        (!e || n[0].length > e[0].length)
                      ) {
                        if (((e = n), (i = a), this.options.backtrack_lexer)) {
                          if (!1 !== (t = this.test_match(n, r[a]))) return t;
                          if (this._backtrack) {
                            e = !1;
                            continue;
                          }
                          return !1;
                        }
                        if (!this.options.flex) break;
                      }
                    return e
                      ? !1 !== (t = this.test_match(e, r[i])) && t
                      : '' === this._input
                      ? this.EOF
                      : this.parseError(
                          'Lexical error on line ' +
                            (this.yylineno + 1) +
                            '. Unrecognized text.\n' +
                            this.showPosition(),
                          { text: '', token: null, line: this.yylineno },
                        );
                  },
                  lex: function () {
                    var t = this.next();
                    return t || this.lex();
                  },
                  begin: function (t) {
                    this.conditionStack.push(t);
                  },
                  popState: function () {
                    return this.conditionStack.length - 1 > 0
                      ? this.conditionStack.pop()
                      : this.conditionStack[0];
                  },
                  _currentRules: function () {
                    return this.conditionStack.length &&
                      this.conditionStack[this.conditionStack.length - 1]
                      ? this.conditions[
                          this.conditionStack[this.conditionStack.length - 1]
                        ].rules
                      : this.conditions.INITIAL.rules;
                  },
                  topState: function (t) {
                    return (t =
                      this.conditionStack.length - 1 - Math.abs(t || 0)) >= 0
                      ? this.conditionStack[t]
                      : 'INITIAL';
                  },
                  pushState: function (t) {
                    this.begin(t);
                  },
                  stateStackSize: function () {
                    return this.conditionStack.length;
                  },
                  options: {},
                  performAction: function (t, e, n, i) {
                    switch (n) {
                      case 0:
                        break;
                      case 1:
                        return 6;
                      case 2:
                        return (e.yytext = e.yytext.substr(1, e.yyleng - 2)), 4;
                      case 3:
                        return 17;
                      case 4:
                        return 18;
                      case 5:
                        return 23;
                      case 6:
                        return 24;
                      case 7:
                        return 22;
                      case 8:
                        return 21;
                      case 9:
                        return 10;
                      case 10:
                        return 11;
                      case 11:
                        return 8;
                      case 12:
                        return 14;
                      case 13:
                        return 'INVALID';
                    }
                  },
                  rules: [
                    /^(?:\s+)/,
                    /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,
                    /^(?:"(?:\\[\\"bfnrt/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,
                    /^(?:\{)/,
                    /^(?:\})/,
                    /^(?:\[)/,
                    /^(?:\])/,
                    /^(?:,)/,
                    /^(?::)/,
                    /^(?:true\b)/,
                    /^(?:false\b)/,
                    /^(?:null\b)/,
                    /^(?:$)/,
                    /^(?:.)/,
                  ],
                  conditions: {
                    INITIAL: {
                      rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                      inclusive: !0,
                    },
                  },
                };
              function p() {
                this.yy = {};
              }
              return (h.lexer = d), (p.prototype = h), (h.Parser = p), new p();
            })();
            void 0 !== a &&
              ((e.parser = n),
              (e.Parser = n.Parser),
              (e.parse = function () {
                return n.parse.apply(n, arguments);
              }));
          });
          On.parser, On.Parser, On.parse;
          function Nn(t) {
            if (
              t instanceof String ||
              'string' == typeof t ||
              t instanceof Buffer
            )
              try {
                return On.parse(t.toString());
              } catch (t) {
                throw new un(t);
              }
            return t;
          }
          function zn(t, e = i) {
            let n = t;
            try {
              n = Nn(n);
            } catch (t) {
              return [t];
            }
            return kn(n, e);
          }
          const Fn = {
            StyleExpression: We,
            isExpression: Xe,
            isExpressionFilter: Qe,
            createExpression: Ye,
            createPropertyExpression: Ze,
            normalizePropertyExpression: function (t, e) {
              if (ze(t)) return new Ke(t, e);
              if (Xe(t)) {
                const n = Ze(t, e);
                if ('error' === n.result)
                  throw new Error(
                    n.value.map((t) => `${t.key}: ${t.message}`).join(', '),
                  );
                return n.value;
              }
              {
                let n = t;
                return (
                  'string' == typeof t &&
                    'color' === e.type &&
                    (n = Z.parse(t)),
                  { kind: 'constant', evaluate: () => n }
                );
              }
            },
            ZoomConstantExpression: $e,
            ZoomDependentExpression: Je,
            StylePropertyFunction: Ke,
          };
          (zn.parsed = zn), (zn.latest = zn);
        }.call(this, n(69)));
      },
      94: function (t, e, n) {
        'use strict';
        n.d(e, 'a', function () {
          return q;
        });
        var i = n(4),
          r = n.n(i),
          a = n(5),
          o = n.n(a),
          s = n(18),
          l = n.n(s),
          c = n(6),
          u = n.n(c),
          h = n(7),
          d = n.n(h),
          p = n(2),
          f = n.n(p),
          m = n(3),
          g = n.n(m),
          y = n(0),
          v = n(31),
          x = n(62),
          b = n(15);
        function _(t) {
          var e = (function () {
            if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ('function' == typeof Proxy) return !0;
            try {
              return (
                Boolean.prototype.valueOf.call(
                  Reflect.construct(Boolean, [], function () {}),
                ),
                !0
              );
            } catch (t) {
              return !1;
            }
          })();
          return function () {
            var n,
              i = f()(t);
            if (e) {
              var r = f()(this).constructor;
              n = Reflect.construct(i, arguments, r);
            } else n = i.apply(this, arguments);
            return d()(this, n);
          };
        }
        var w =
            "#include <itowns/WebGL2_pars_vertex>\n#include <itowns/precision_qualifier>\n#include <itowns/project_pars_vertex>\n#if defined(USE_TEXTURES_PROJECTIVE)\n#include <itowns/projective_texturing_pars_vertex>\n#endif\n#include <common>\n#include <logdepthbuf_pars_vertex>\n\nuniform float size;\n\nuniform bool picking;\nuniform int mode;\nuniform float opacity;\nuniform vec4 overlayColor;\nuniform vec2 intensityRange;\nuniform bool applyOpacityClassication;\nattribute vec3 color;\nattribute vec4 unique_id;\nattribute float intensity;\nattribute float classification;\nuniform sampler2D classificationLUT;\n\n#if defined(NORMAL_OCT16)\nattribute vec2 oct16Normal;\n#elif defined(NORMAL_SPHEREMAPPED)\nattribute vec2 sphereMappedNormal;\n#else\nattribute vec3 normal;\n#endif\n\nvarying vec4 vColor;\n\n// see https://web.archive.org/web/20150303053317/http://lgdv.cs.fau.de/get/1602\n// and implementation in PotreeConverter (BINPointReader.cpp) and potree (BinaryDecoderWorker.js)\n#if defined(NORMAL_OCT16)\nvec3 decodeOct16Normal(vec2 encodedNormal) {\n    vec2 nNorm = 2. * (encodedNormal / 255.) - 1.;\n    vec3 n;\n    n.z = 1. - abs(nNorm.x) - abs(nNorm.y);\n    if (n.z >= 0.) {\n        n.x = nNorm.x;\n        n.y = nNorm.y;\n    } else {\n        n.x = sign(nNorm.x) - sign(nNorm.x) * sign(nNorm.y) * nNorm.y;\n        n.y = sign(nNorm.y) - sign(nNorm.y) * sign(nNorm.x) * nNorm.x;\n    }\n    return normalize(n);\n}\n#elif defined(NORMAL_SPHEREMAPPED)\n// see http://aras-p.info/texts/CompactNormalStorage.html method #4\n// or see potree's implementation in BINPointReader.cpp\nvec3 decodeSphereMappedNormal(vec2 encodedNormal) {\n    vec2 fenc = 2. * encodedNormal / 255. - 1.;\n    float f = dot(fenc,fenc);\n    float g = 2. * sqrt(1. - f);\n    vec3 n;\n    n.xy = fenc * g;\n    n.z = 1. - 2. * f;\n    return n;\n}\n#endif\n\nvoid main() {\n\n#if defined(NORMAL_OCT16)\n    vec3  normal = decodeOct16Normal(oct16Normal);\n#elif defined(NORMAL_SPHEREMAPPED)\n    vec3 normal = decodeSphereMappedNormal(sphereMappedNormal);\n#elif defined(NORMAL)\n    // nothing to do\n#else\n    // default to color\n    vec3 normal = color;\n#endif\n\n    if (picking) {\n        vColor = unique_id;\n    } else {\n        vColor.a = opacity;\n        if (applyOpacityClassication || mode == MODE_CLASSIFICATION) {\n            vec2 uv = vec2(classification, 0.5);\n            vColor = texture2D(classificationLUT, uv);\n            vColor.a *= opacity;\n        }\n\n        if (mode == MODE_INTENSITY) {\n            // adapt the grayscale knowing the range\n            float i = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\n            vColor.rgb = vec3(i, i, i);\n        } else if (mode == MODE_NORMAL) {\n            vColor.rgb = abs(normal);\n        } else if (mode == MODE_COLOR) {\n            // default to color mode\n            vColor.rgb = mix(color, overlayColor.rgb, overlayColor.a);\n        }\n    }\n\n    #include <begin_vertex>\n    #include <project_vertex>\n\n    if (size > 0.) {\n        gl_PointSize = size;\n    } else {\n        gl_PointSize = clamp(-size / gl_Position.w, 3.0, 10.0);\n    }\n\n#if defined(USE_TEXTURES_PROJECTIVE)\n    #include <itowns/projective_texturing_vertex>\n#endif\n    #include <logdepthbuf_vertex>\n}\n",
          M =
            '#include <itowns/WebGL2_pars_fragment>\n#include <itowns/precision_qualifier>\n#include <logdepthbuf_pars_fragment>\n#if defined(USE_TEXTURES_PROJECTIVE)\n#include <itowns/projective_texturing_pars_fragment>\n#endif\n\nvarying vec4 vColor;\nuniform bool picking;\nvoid main() {\n    #include <logdepthbuf_fragment>\n    // circular point rendering\n    if((length(gl_PointCoord - 0.5) > 0.5) || (vColor.a == 0.0)) {\n        discard;\n    }\n#if defined(USE_TEXTURES_PROJECTIVE)\n    vec4 color = vColor;\n    if (!picking) {\n        #pragma unroll_loop\n        for (int i = 0; i < ORIENTED_IMAGES_COUNT; i++) {\n            color = projectiveTextureColor(projectiveTextureCoords[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTextureDistortion[ ORIENTED_IMAGES_COUNT - 1 - i ], projectiveTexture[ ORIENTED_IMAGES_COUNT - 1 - i ], mask[ORIENTED_IMAGES_COUNT - 1 - i], color);\n        }\n        gl_FragColor = vec4(color.rgb, color.a * opacity);\n    } else {\n        gl_FragColor = color;\n    }\n#else\n    gl_FragColor = vColor;\n#endif\n}\n',
          q = { COLOR: 0, INTENSITY: 1, CLASSIFICATION: 2, NORMAL: 3 },
          S = new y.Color(1, 1, 1),
          T = {
            DEFAULT: {
              0: {
                visible: !0,
                name: 'never classified',
                color: new y.Color(0.5, 0.5, 0.5),
                opacity: 1,
              },
              1: {
                visible: !0,
                name: 'unclassified',
                color: new y.Color(0.5, 0.5, 0.5),
                opacity: 1,
              },
              2: {
                visible: !0,
                name: 'ground',
                color: new y.Color(0.63, 0.32, 0.18),
                opacity: 1,
              },
              3: {
                visible: !0,
                name: 'low vegetation',
                color: new y.Color(0, 1, 0),
                opacity: 1,
              },
              4: {
                visible: !0,
                name: 'medium vegetation',
                color: new y.Color(0, 0.8, 0),
                opacity: 1,
              },
              5: {
                visible: !0,
                name: 'high vegetation',
                color: new y.Color(0, 0.6, 0),
                opacity: 1,
              },
              6: {
                visible: !0,
                name: 'building',
                color: new y.Color(1, 0.66, 0),
                opacity: 1,
              },
              7: {
                visible: !0,
                name: 'low point(noise)',
                color: new y.Color(1, 0, 1),
                opacity: 1,
              },
              8: {
                visible: !0,
                name: 'key-point',
                color: new y.Color(1, 0, 0),
                opacity: 1,
              },
              9: {
                visible: !0,
                name: 'water',
                color: new y.Color(0, 0, 1),
                opacity: 1,
              },
              10: {
                visible: !0,
                name: 'rail',
                color: new y.Color(0.8, 0.8, 1),
                opacity: 1,
              },
              11: {
                visible: !0,
                name: 'road Surface',
                color: new y.Color(0.4, 0.4, 0.7),
                opacity: 1,
              },
              12: {
                visible: !0,
                name: 'overlap',
                color: new y.Color(1, 1, 0),
                opacity: 1,
              },
              DEFAULT: {
                visible: !0,
                name: 'default',
                color: new y.Color(0.3, 0.6, 0.6),
                opacity: 0.5,
              },
            },
          },
          E = (function (t) {
            u()(n, t);
            var e = _(n);
            function n() {
              var t,
                i =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : {};
              g()(this, n);
              var r = i.intensityRange || new y.Vector2(0, 1),
                a = i.orientedImageMaterial,
                s = i.classification || T.DEFAULT,
                l =
                  null != i.applyOpacityClassication &&
                  i.applyOpacityClassication;
              delete i.orientedImageMaterial,
                delete i.intensityRange,
                delete i.classification,
                delete i.applyOpacityClassication,
                ((t = e.call(this, i)).vertexShader = w),
                (t.scale = i.scale || 0.025 / Math.tan(0.5)),
                b.a.setDefineMapping(o()(t), 'MODE', q),
                b.a.setUniformProperty(o()(t), 'size', i.size || 0),
                b.a.setUniformProperty(o()(t), 'mode', i.mode || q.COLOR),
                b.a.setUniformProperty(o()(t), 'picking', !1),
                b.a.setUniformProperty(o()(t), 'opacity', t.opacity),
                b.a.setUniformProperty(
                  o()(t),
                  'overlayColor',
                  i.overlayColor || new y.Vector4(0, 0, 0, 0),
                ),
                b.a.setUniformProperty(o()(t), 'intensityRange', r),
                b.a.setUniformProperty(o()(t), 'applyOpacityClassication', l);
              var c = new Uint8Array(1024),
                u = new y.DataTexture(c, 256, 1, y.RGBAFormat);
              return (
                (u.magFilter = y.NearestFilter),
                b.a.setUniformProperty(o()(t), 'classificationLUT', u),
                (t.classification = s),
                t.recomputeClassification(),
                a
                  ? ((t.uniforms.projectiveTextureAlphaBorder =
                      a.uniforms.projectiveTextureAlphaBorder),
                    (t.uniforms.projectiveTextureDistortion =
                      a.uniforms.projectiveTextureDistortion),
                    (t.uniforms.projectiveTextureMatrix =
                      a.uniforms.projectiveTextureMatrix),
                    (t.uniforms.projectiveTexture =
                      a.uniforms.projectiveTexture),
                    (t.uniforms.mask = a.uniforms.mask),
                    (t.uniforms.boostLight = a.uniforms.boostLight),
                    (t.defines.ORIENTED_IMAGES_COUNT =
                      a.defines.ORIENTED_IMAGES_COUNT),
                    (t.defines.USE_DISTORTION = a.defines.USE_DISTORTION),
                    (t.defines.DEBUG_ALPHA_BORDER =
                      a.defines.DEBUG_ALPHA_BORDER),
                    (t.defines.USE_TEXTURES_PROJECTIVE = !0),
                    (t.defines.USE_BASE_MATERIAL = !0),
                    (t.fragmentShader = x.a.unrollLoops(M, t.defines)))
                  : (t.fragmentShader = M),
                v.a.isLogDepthBufferSupported() &&
                  ((t.defines.USE_LOGDEPTHBUF = 1),
                  (t.defines.USE_LOGDEPTHBUF_EXT = 1)),
                t
              );
            }
            return (
              r()(n, [
                {
                  key: 'recomputeClassification',
                  value: function () {
                    for (
                      var t = this.classification,
                        e = this.classificationLUT.image.data,
                        n = this.classificationLUT.image.width,
                        i = 0;
                      i < n;
                      i++
                    ) {
                      var r = void 0,
                        a = void 0,
                        o = !0;
                      t[i]
                        ? ((r = t[i].color),
                          (o = t[i].visible),
                          (a = t[i].opacity))
                        : t[i % 32]
                        ? ((r = t[i % 32].color),
                          (o = t[i % 32].visible),
                          (a = t[i % 32].opacity))
                        : t.DEFAULT
                        ? ((r = t.DEFAULT.color),
                          (o = t.DEFAULT.visible),
                          (a = t.DEFAULT.opacity))
                        : ((r = S), (a = 1));
                      var s = 4 * i;
                      (e[s + 0] = parseInt(255 * r.r, 10)),
                        (e[s + 1] = parseInt(255 * r.g, 10)),
                        (e[s + 2] = parseInt(255 * r.b, 10)),
                        (e[s + 3] = o ? parseInt(255 * a, 10) : 0);
                    }
                    (this.classificationLUT.needsUpdate = !0),
                      this.dispatchEvent({
                        type: 'material_property_changed',
                        target: this,
                      });
                  },
                },
                {
                  key: 'onBeforeCompile',
                  value: function (t, e) {
                    e.capabilities.isWebGL2 &&
                      ((this.defines.WEBGL2 = !0), (t.glslVersion = '300 es'));
                  },
                },
                {
                  key: 'copy',
                  value: function (t) {
                    return (
                      l()(f()(n.prototype), 'copy', this).call(this, t),
                      t.uniforms.projectiveTextureAlphaBorder &&
                        ((this.uniforms.projectiveTextureAlphaBorder =
                          t.uniforms.projectiveTextureAlphaBorder),
                        (this.uniforms.projectiveTextureDistortion =
                          t.uniforms.projectiveTextureDistortion),
                        (this.uniforms.projectiveTextureMatrix =
                          t.uniforms.projectiveTextureMatrix),
                        (this.uniforms.projectiveTexture =
                          t.uniforms.projectiveTexture),
                        (this.uniforms.mask = t.uniforms.mask),
                        (this.uniforms.boostLight = t.uniforms.boostLight)),
                      this
                    );
                  },
                },
                {
                  key: 'enablePicking',
                  value: function (t) {
                    (this.picking = t),
                      (this.blending = t ? y.NoBlending : y.NormalBlending);
                  },
                },
                {
                  key: 'update',
                  value: function (t) {
                    return (
                      (this.visible = t.visible),
                      (this.opacity = t.opacity),
                      (this.transparent = t.transparent),
                      (this.size = t.size),
                      (this.mode = t.mode),
                      (this.picking = t.picking),
                      (this.scale = t.scale),
                      this.overlayColor.copy(t.overlayColor),
                      this.intensityRange.copy(t.intensityRange),
                      Object.assign(this.defines, t.defines),
                      this
                    );
                  },
                },
              ]),
              n
            );
          })(y.RawShaderMaterial);
        e.b = E;
      },
    },
    [[684, 0]],
  ]);
});
//# sourceMappingURL=debug.js.map
